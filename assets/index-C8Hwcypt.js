var Ej=(n,t)=>()=>(t||n((t={exports:{}}).exports,t),t.exports);var E_t=Ej((O_t,pH)=>{function Ij(n,t){for(var e=0;e<t.length;e++){const r=t[e];if(typeof r!="string"&&!Array.isArray(r)){for(const a in r)if(a!=="default"&&!(a in n)){const s=Object.getOwnPropertyDescriptor(r,a);s&&Object.defineProperty(n,a,s.get?s:{enumerable:!0,get:()=>r[a]})}}}return Object.freeze(Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}))}(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const a of document.querySelectorAll('link[rel="modulepreload"]'))r(a);new MutationObserver(a=>{for(const s of a)if(s.type==="childList")for(const o of s.addedNodes)o.tagName==="LINK"&&o.rel==="modulepreload"&&r(o)}).observe(document,{childList:!0,subtree:!0});function e(a){const s={};return a.integrity&&(s.integrity=a.integrity),a.referrerPolicy&&(s.referrerPolicy=a.referrerPolicy),a.crossOrigin==="use-credentials"?s.credentials="include":a.crossOrigin==="anonymous"?s.credentials="omit":s.credentials="same-origin",s}function r(a){if(a.ep)return;a.ep=!0;const s=e(a);fetch(a.href,s)}})();function bm(n){return n&&n.__esModule&&Object.prototype.hasOwnProperty.call(n,"default")?n.default:n}function Ck(n){if(Object.prototype.hasOwnProperty.call(n,"__esModule"))return n;var t=n.default;if(typeof t=="function"){var e=function r(){var a=!1;try{a=this instanceof r}catch{}return a?Reflect.construct(t,arguments,this.constructor):t.apply(this,arguments)};e.prototype=t.prototype}else e={};return Object.defineProperty(e,"__esModule",{value:!0}),Object.keys(n).forEach(function(r){var a=Object.getOwnPropertyDescriptor(n,r);Object.defineProperty(e,r,a.get?a:{enumerable:!0,get:function(){return n[r]}})}),e}var SS={exports:{}},bf={};var w$;function _j(){if(w$)return bf;w$=1;var n=Symbol.for("react.transitional.element"),t=Symbol.for("react.fragment");function e(r,a,s){var o=null;if(s!==void 0&&(o=""+s),a.key!==void 0&&(o=""+a.key),"key"in a){s={};for(var i in a)i!=="key"&&(s[i]=a[i])}else s=a;return a=s.ref,{$$typeof:n,type:r,key:o,ref:a!==void 0?a:null,props:s}}return bf.Fragment=t,bf.jsx=e,bf.jsxs=e,bf}var S$;function Rj(){return S$||(S$=1,SS.exports=_j()),SS.exports}var ce=Rj(),CS={exports:{}},ye={};var C$;function Aj(){if(C$)return ye;C$=1;var n=Symbol.for("react.transitional.element"),t=Symbol.for("react.portal"),e=Symbol.for("react.fragment"),r=Symbol.for("react.strict_mode"),a=Symbol.for("react.profiler"),s=Symbol.for("react.consumer"),o=Symbol.for("react.context"),i=Symbol.for("react.forward_ref"),u=Symbol.for("react.suspense"),l=Symbol.for("react.memo"),h=Symbol.for("react.lazy"),d=Symbol.for("react.activity"),f=Symbol.iterator;function m(M){return M===null||typeof M!="object"?null:(M=f&&M[f]||M["@@iterator"],typeof M=="function"?M:null)}var v={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},y=Object.assign,b={};function w(M,X,Q){this.props=M,this.context=X,this.refs=b,this.updater=Q||v}w.prototype.isReactComponent={},w.prototype.setState=function(M,X){if(typeof M!="object"&&typeof M!="function"&&M!=null)throw Error("takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,M,X,"setState")},w.prototype.forceUpdate=function(M){this.updater.enqueueForceUpdate(this,M,"forceUpdate")};function S(){}S.prototype=w.prototype;function N(M,X,Q){this.props=M,this.context=X,this.refs=b,this.updater=Q||v}var C=N.prototype=new S;C.constructor=N,y(C,w.prototype),C.isPureReactComponent=!0;var T=Array.isArray;function I(){}var _={H:null,A:null,T:null,S:null},$=Object.prototype.hasOwnProperty;function R(M,X,Q){var rt=Q.ref;return{$$typeof:n,type:M,key:X,ref:rt!==void 0?rt:null,props:Q}}function D(M,X){return R(M.type,X,M.props)}function A(M){return typeof M=="object"&&M!==null&&M.$$typeof===n}function L(M){var X={"=":"=0",":":"=2"};return"$"+M.replace(/[=:]/g,function(Q){return X[Q]})}var H=/\/+/g;function G(M,X){return typeof M=="object"&&M!==null&&M.key!=null?L(""+M.key):X.toString(36)}function q(M){switch(M.status){case"fulfilled":return M.value;case"rejected":throw M.reason;default:switch(typeof M.status=="string"?M.then(I,I):(M.status="pending",M.then(function(X){M.status==="pending"&&(M.status="fulfilled",M.value=X)},function(X){M.status==="pending"&&(M.status="rejected",M.reason=X)})),M.status){case"fulfilled":return M.value;case"rejected":throw M.reason}}throw M}function B(M,X,Q,rt,ct){var pt=typeof M;(pt==="undefined"||pt==="boolean")&&(M=null);var yt=!1;if(M===null)yt=!0;else switch(pt){case"bigint":case"string":case"number":yt=!0;break;case"object":switch(M.$$typeof){case n:case t:yt=!0;break;case h:return yt=M._init,B(yt(M._payload),X,Q,rt,ct)}}if(yt)return ct=ct(M),yt=rt===""?"."+G(M,0):rt,T(ct)?(Q="",yt!=null&&(Q=yt.replace(H,"$&/")+"/"),B(ct,X,Q,"",function(Rt){return Rt})):ct!=null&&(A(ct)&&(ct=D(ct,Q+(ct.key==null||M&&M.key===ct.key?"":(""+ct.key).replace(H,"$&/")+"/")+yt)),X.push(ct)),1;yt=0;var Tt=rt===""?".":rt+":";if(T(M))for(var gt=0;gt<M.length;gt++)rt=M[gt],pt=Tt+G(rt,gt),yt+=B(rt,X,Q,pt,ct);else if(gt=m(M),typeof gt=="function")for(M=gt.call(M),gt=0;!(rt=M.next()).done;)rt=rt.value,pt=Tt+G(rt,gt++),yt+=B(rt,X,Q,pt,ct);else if(pt==="object"){if(typeof M.then=="function")return B(q(M),X,Q,rt,ct);throw X=String(M),Error("Objects are not valid as a React child (found: "+(X==="[object Object]"?"object with keys {"+Object.keys(M).join(", ")+"}":X)+"). If you meant to render a collection of children, use an array instead.")}return yt}function j(M,X,Q){if(M==null)return M;var rt=[],ct=0;return B(M,rt,"","",function(pt){return X.call(Q,pt,ct++)}),rt}function K(M){if(M._status===-1){var X=M._result;X=X(),X.then(function(Q){(M._status===0||M._status===-1)&&(M._status=1,M._result=Q)},function(Q){(M._status===0||M._status===-1)&&(M._status=2,M._result=Q)}),M._status===-1&&(M._status=0,M._result=X)}if(M._status===1)return M._result.default;throw M._result}var z=typeof reportError=="function"?reportError:function(M){if(typeof window=="object"&&typeof window.ErrorEvent=="function"){var X=new window.ErrorEvent("error",{bubbles:!0,cancelable:!0,message:typeof M=="object"&&M!==null&&typeof M.message=="string"?String(M.message):String(M),error:M});if(!window.dispatchEvent(X))return}else if(typeof process=="object"&&typeof process.emit=="function"){process.emit("uncaughtException",M);return}console.error(M)},U={map:j,forEach:function(M,X,Q){j(M,function(){X.apply(this,arguments)},Q)},count:function(M){var X=0;return j(M,function(){X++}),X},toArray:function(M){return j(M,function(X){return X})||[]},only:function(M){if(!A(M))throw Error("React.Children.only expected to receive a single React element child.");return M}};return ye.Activity=d,ye.Children=U,ye.Component=w,ye.Fragment=e,ye.Profiler=a,ye.PureComponent=N,ye.StrictMode=r,ye.Suspense=u,ye.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE=_,ye.__COMPILER_RUNTIME={__proto__:null,c:function(M){return _.H.useMemoCache(M)}},ye.cache=function(M){return function(){return M.apply(null,arguments)}},ye.cacheSignal=function(){return null},ye.cloneElement=function(M,X,Q){if(M==null)throw Error("The argument must be a React element, but you passed "+M+".");var rt=y({},M.props),ct=M.key;if(X!=null)for(pt in X.key!==void 0&&(ct=""+X.key),X)!$.call(X,pt)||pt==="key"||pt==="__self"||pt==="__source"||pt==="ref"&&X.ref===void 0||(rt[pt]=X[pt]);var pt=arguments.length-2;if(pt===1)rt.children=Q;else if(1<pt){for(var yt=Array(pt),Tt=0;Tt<pt;Tt++)yt[Tt]=arguments[Tt+2];rt.children=yt}return R(M.type,ct,rt)},ye.createContext=function(M){return M={$$typeof:o,_currentValue:M,_currentValue2:M,_threadCount:0,Provider:null,Consumer:null},M.Provider=M,M.Consumer={$$typeof:s,_context:M},M},ye.createElement=function(M,X,Q){var rt,ct={},pt=null;if(X!=null)for(rt in X.key!==void 0&&(pt=""+X.key),X)$.call(X,rt)&&rt!=="key"&&rt!=="__self"&&rt!=="__source"&&(ct[rt]=X[rt]);var yt=arguments.length-2;if(yt===1)ct.children=Q;else if(1<yt){for(var Tt=Array(yt),gt=0;gt<yt;gt++)Tt[gt]=arguments[gt+2];ct.children=Tt}if(M&&M.defaultProps)for(rt in yt=M.defaultProps,yt)ct[rt]===void 0&&(ct[rt]=yt[rt]);return R(M,pt,ct)},ye.createRef=function(){return{current:null}},ye.forwardRef=function(M){return{$$typeof:i,render:M}},ye.isValidElement=A,ye.lazy=function(M){return{$$typeof:h,_payload:{_status:-1,_result:M},_init:K}},ye.memo=function(M,X){return{$$typeof:l,type:M,compare:X===void 0?null:X}},ye.startTransition=function(M){var X=_.T,Q={};_.T=Q;try{var rt=M(),ct=_.S;ct!==null&&ct(Q,rt),typeof rt=="object"&&rt!==null&&typeof rt.then=="function"&&rt.then(I,z)}catch(pt){z(pt)}finally{X!==null&&Q.types!==null&&(X.types=Q.types),_.T=X}},ye.unstable_useCacheRefresh=function(){return _.H.useCacheRefresh()},ye.use=function(M){return _.H.use(M)},ye.useActionState=function(M,X,Q){return _.H.useActionState(M,X,Q)},ye.useCallback=function(M,X){return _.H.useCallback(M,X)},ye.useContext=function(M){return _.H.useContext(M)},ye.useDebugValue=function(){},ye.useDeferredValue=function(M,X){return _.H.useDeferredValue(M,X)},ye.useEffect=function(M,X){return _.H.useEffect(M,X)},ye.useEffectEvent=function(M){return _.H.useEffectEvent(M)},ye.useId=function(){return _.H.useId()},ye.useImperativeHandle=function(M,X,Q){return _.H.useImperativeHandle(M,X,Q)},ye.useInsertionEffect=function(M,X){return _.H.useInsertionEffect(M,X)},ye.useLayoutEffect=function(M,X){return _.H.useLayoutEffect(M,X)},ye.useMemo=function(M,X){return _.H.useMemo(M,X)},ye.useOptimistic=function(M,X){return _.H.useOptimistic(M,X)},ye.useReducer=function(M,X,Q){return _.H.useReducer(M,X,Q)},ye.useRef=function(M){return _.H.useRef(M)},ye.useState=function(M){return _.H.useState(M)},ye.useSyncExternalStore=function(M,X,Q){return _.H.useSyncExternalStore(M,X,Q)},ye.useTransition=function(){return _.H.useTransition()},ye.version="19.2.4",ye}var N$;function Nk(){return N$||(N$=1,CS.exports=Aj()),CS.exports}var fe=Nk();const Dj=bm(fe);var NS={exports:{}},xf={},kS={exports:{}},TS={};var k$;function $j(){return k$||(k$=1,(function(n){function t(B,j){var K=B.length;B.push(j);t:for(;0<K;){var z=K-1>>>1,U=B[z];if(0<a(U,j))B[z]=j,B[K]=U,K=z;else break t}}function e(B){return B.length===0?null:B[0]}function r(B){if(B.length===0)return null;var j=B[0],K=B.pop();if(K!==j){B[0]=K;t:for(var z=0,U=B.length,M=U>>>1;z<M;){var X=2*(z+1)-1,Q=B[X],rt=X+1,ct=B[rt];if(0>a(Q,K))rt<U&&0>a(ct,Q)?(B[z]=ct,B[rt]=K,z=rt):(B[z]=Q,B[X]=K,z=X);else if(rt<U&&0>a(ct,K))B[z]=ct,B[rt]=K,z=rt;else break t}}return j}function a(B,j){var K=B.sortIndex-j.sortIndex;return K!==0?K:B.id-j.id}if(n.unstable_now=void 0,typeof performance=="object"&&typeof performance.now=="function"){var s=performance;n.unstable_now=function(){return s.now()}}else{var o=Date,i=o.now();n.unstable_now=function(){return o.now()-i}}var u=[],l=[],h=1,d=null,f=3,m=!1,v=!1,y=!1,b=!1,w=typeof setTimeout=="function"?setTimeout:null,S=typeof clearTimeout=="function"?clearTimeout:null,N=typeof setImmediate<"u"?setImmediate:null;function C(B){for(var j=e(l);j!==null;){if(j.callback===null)r(l);else if(j.startTime<=B)r(l),j.sortIndex=j.expirationTime,t(u,j);else break;j=e(l)}}function T(B){if(y=!1,C(B),!v)if(e(u)!==null)v=!0,I||(I=!0,L());else{var j=e(l);j!==null&&q(T,j.startTime-B)}}var I=!1,_=-1,$=5,R=-1;function D(){return b?!0:!(n.unstable_now()-R<$)}function A(){if(b=!1,I){var B=n.unstable_now();R=B;var j=!0;try{t:{v=!1,y&&(y=!1,S(_),_=-1),m=!0;var K=f;try{e:{for(C(B),d=e(u);d!==null&&!(d.expirationTime>B&&D());){var z=d.callback;if(typeof z=="function"){d.callback=null,f=d.priorityLevel;var U=z(d.expirationTime<=B);if(B=n.unstable_now(),typeof U=="function"){d.callback=U,C(B),j=!0;break e}d===e(u)&&r(u),C(B)}else r(u);d=e(u)}if(d!==null)j=!0;else{var M=e(l);M!==null&&q(T,M.startTime-B),j=!1}}break t}finally{d=null,f=K,m=!1}j=void 0}}finally{j?L():I=!1}}}var L;if(typeof N=="function")L=function(){N(A)};else if(typeof MessageChannel<"u"){var H=new MessageChannel,G=H.port2;H.port1.onmessage=A,L=function(){G.postMessage(null)}}else L=function(){w(A,0)};function q(B,j){_=w(function(){B(n.unstable_now())},j)}n.unstable_IdlePriority=5,n.unstable_ImmediatePriority=1,n.unstable_LowPriority=4,n.unstable_NormalPriority=3,n.unstable_Profiling=null,n.unstable_UserBlockingPriority=2,n.unstable_cancelCallback=function(B){B.callback=null},n.unstable_forceFrameRate=function(B){0>B||125<B?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):$=0<B?Math.floor(1e3/B):5},n.unstable_getCurrentPriorityLevel=function(){return f},n.unstable_next=function(B){switch(f){case 1:case 2:case 3:var j=3;break;default:j=f}var K=f;f=j;try{return B()}finally{f=K}},n.unstable_requestPaint=function(){b=!0},n.unstable_runWithPriority=function(B,j){switch(B){case 1:case 2:case 3:case 4:case 5:break;default:B=3}var K=f;f=B;try{return j()}finally{f=K}},n.unstable_scheduleCallback=function(B,j,K){var z=n.unstable_now();switch(typeof K=="object"&&K!==null?(K=K.delay,K=typeof K=="number"&&0<K?z+K:z):K=z,B){case 1:var U=-1;break;case 2:U=250;break;case 5:U=1073741823;break;case 4:U=1e4;break;default:U=5e3}return U=K+U,B={id:h++,callback:j,priorityLevel:B,startTime:K,expirationTime:U,sortIndex:-1},K>z?(B.sortIndex=K,t(l,B),e(u)===null&&B===e(l)&&(y?(S(_),_=-1):y=!0,q(T,K-z))):(B.sortIndex=U,t(u,B),v||m||(v=!0,I||(I=!0,L()))),B},n.unstable_shouldYield=D,n.unstable_wrapCallback=function(B){var j=f;return function(){var K=f;f=j;try{return B.apply(this,arguments)}finally{f=K}}}})(TS)),TS}var T$;function Oj(){return T$||(T$=1,kS.exports=$j()),kS.exports}var ES={exports:{}},ea={};var E$;function Fj(){if(E$)return ea;E$=1;var n=Nk();function t(u){var l="https://react.dev/errors/"+u;if(1<arguments.length){l+="?args[]="+encodeURIComponent(arguments[1]);for(var h=2;h<arguments.length;h++)l+="&args[]="+encodeURIComponent(arguments[h])}return"Minified React error #"+u+"; visit "+l+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}function e(){}var r={d:{f:e,r:function(){throw Error(t(522))},D:e,C:e,L:e,m:e,X:e,S:e,M:e},p:0,findDOMNode:null},a=Symbol.for("react.portal");function s(u,l,h){var d=3<arguments.length&&arguments[3]!==void 0?arguments[3]:null;return{$$typeof:a,key:d==null?null:""+d,children:u,containerInfo:l,implementation:h}}var o=n.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;function i(u,l){if(u==="font")return"";if(typeof l=="string")return l==="use-credentials"?l:""}return ea.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE=r,ea.createPortal=function(u,l){var h=2<arguments.length&&arguments[2]!==void 0?arguments[2]:null;if(!l||l.nodeType!==1&&l.nodeType!==9&&l.nodeType!==11)throw Error(t(299));return s(u,l,null,h)},ea.flushSync=function(u){var l=o.T,h=r.p;try{if(o.T=null,r.p=2,u)return u()}finally{o.T=l,r.p=h,r.d.f()}},ea.preconnect=function(u,l){typeof u=="string"&&(l?(l=l.crossOrigin,l=typeof l=="string"?l==="use-credentials"?l:"":void 0):l=null,r.d.C(u,l))},ea.prefetchDNS=function(u){typeof u=="string"&&r.d.D(u)},ea.preinit=function(u,l){if(typeof u=="string"&&l&&typeof l.as=="string"){var h=l.as,d=i(h,l.crossOrigin),f=typeof l.integrity=="string"?l.integrity:void 0,m=typeof l.fetchPriority=="string"?l.fetchPriority:void 0;h==="style"?r.d.S(u,typeof l.precedence=="string"?l.precedence:void 0,{crossOrigin:d,integrity:f,fetchPriority:m}):h==="script"&&r.d.X(u,{crossOrigin:d,integrity:f,fetchPriority:m,nonce:typeof l.nonce=="string"?l.nonce:void 0})}},ea.preinitModule=function(u,l){if(typeof u=="string")if(typeof l=="object"&&l!==null){if(l.as==null||l.as==="script"){var h=i(l.as,l.crossOrigin);r.d.M(u,{crossOrigin:h,integrity:typeof l.integrity=="string"?l.integrity:void 0,nonce:typeof l.nonce=="string"?l.nonce:void 0})}}else l==null&&r.d.M(u)},ea.preload=function(u,l){if(typeof u=="string"&&typeof l=="object"&&l!==null&&typeof l.as=="string"){var h=l.as,d=i(h,l.crossOrigin);r.d.L(u,h,{crossOrigin:d,integrity:typeof l.integrity=="string"?l.integrity:void 0,nonce:typeof l.nonce=="string"?l.nonce:void 0,type:typeof l.type=="string"?l.type:void 0,fetchPriority:typeof l.fetchPriority=="string"?l.fetchPriority:void 0,referrerPolicy:typeof l.referrerPolicy=="string"?l.referrerPolicy:void 0,imageSrcSet:typeof l.imageSrcSet=="string"?l.imageSrcSet:void 0,imageSizes:typeof l.imageSizes=="string"?l.imageSizes:void 0,media:typeof l.media=="string"?l.media:void 0})}},ea.preloadModule=function(u,l){if(typeof u=="string")if(l){var h=i(l.as,l.crossOrigin);r.d.m(u,{as:typeof l.as=="string"&&l.as!=="script"?l.as:void 0,crossOrigin:h,integrity:typeof l.integrity=="string"?l.integrity:void 0})}else r.d.m(u)},ea.requestFormReset=function(u){r.d.r(u)},ea.unstable_batchedUpdates=function(u,l){return u(l)},ea.useFormState=function(u,l,h){return o.H.useFormState(u,l,h)},ea.useFormStatus=function(){return o.H.useHostTransitionStatus()},ea.version="19.2.4",ea}var I$;function Mj(){if(I$)return ES.exports;I$=1;function n(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(n)}catch(t){console.error(t)}}return n(),ES.exports=Fj(),ES.exports}var _$;function Lj(){if(_$)return xf;_$=1;var n=Oj(),t=Nk(),e=Mj();function r(c){var p="https://react.dev/errors/"+c;if(1<arguments.length){p+="?args[]="+encodeURIComponent(arguments[1]);for(var g=2;g<arguments.length;g++)p+="&args[]="+encodeURIComponent(arguments[g])}return"Minified React error #"+c+"; visit "+p+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}function a(c){return!(!c||c.nodeType!==1&&c.nodeType!==9&&c.nodeType!==11)}function s(c){var p=c,g=c;if(c.alternate)for(;p.return;)p=p.return;else{c=p;do p=c,(p.flags&4098)!==0&&(g=p.return),c=p.return;while(c)}return p.tag===3?g:null}function o(c){if(c.tag===13){var p=c.memoizedState;if(p===null&&(c=c.alternate,c!==null&&(p=c.memoizedState)),p!==null)return p.dehydrated}return null}function i(c){if(c.tag===31){var p=c.memoizedState;if(p===null&&(c=c.alternate,c!==null&&(p=c.memoizedState)),p!==null)return p.dehydrated}return null}function u(c){if(s(c)!==c)throw Error(r(188))}function l(c){var p=c.alternate;if(!p){if(p=s(c),p===null)throw Error(r(188));return p!==c?null:c}for(var g=c,x=p;;){var k=g.return;if(k===null)break;var E=k.alternate;if(E===null){if(x=k.return,x!==null){g=x;continue}break}if(k.child===E.child){for(E=k.child;E;){if(E===g)return u(k),c;if(E===x)return u(k),p;E=E.sibling}throw Error(r(188))}if(g.return!==x.return)g=k,x=E;else{for(var F=!1,W=k.child;W;){if(W===g){F=!0,g=k,x=E;break}if(W===x){F=!0,x=k,g=E;break}W=W.sibling}if(!F){for(W=E.child;W;){if(W===g){F=!0,g=E,x=k;break}if(W===x){F=!0,x=E,g=k;break}W=W.sibling}if(!F)throw Error(r(189))}}if(g.alternate!==x)throw Error(r(190))}if(g.tag!==3)throw Error(r(188));return g.stateNode.current===g?c:p}function h(c){var p=c.tag;if(p===5||p===26||p===27||p===6)return c;for(c=c.child;c!==null;){if(p=h(c),p!==null)return p;c=c.sibling}return null}var d=Object.assign,f=Symbol.for("react.element"),m=Symbol.for("react.transitional.element"),v=Symbol.for("react.portal"),y=Symbol.for("react.fragment"),b=Symbol.for("react.strict_mode"),w=Symbol.for("react.profiler"),S=Symbol.for("react.consumer"),N=Symbol.for("react.context"),C=Symbol.for("react.forward_ref"),T=Symbol.for("react.suspense"),I=Symbol.for("react.suspense_list"),_=Symbol.for("react.memo"),$=Symbol.for("react.lazy"),R=Symbol.for("react.activity"),D=Symbol.for("react.memo_cache_sentinel"),A=Symbol.iterator;function L(c){return c===null||typeof c!="object"?null:(c=A&&c[A]||c["@@iterator"],typeof c=="function"?c:null)}var H=Symbol.for("react.client.reference");function G(c){if(c==null)return null;if(typeof c=="function")return c.$$typeof===H?null:c.displayName||c.name||null;if(typeof c=="string")return c;switch(c){case y:return"Fragment";case w:return"Profiler";case b:return"StrictMode";case T:return"Suspense";case I:return"SuspenseList";case R:return"Activity"}if(typeof c=="object")switch(c.$$typeof){case v:return"Portal";case N:return c.displayName||"Context";case S:return(c._context.displayName||"Context")+".Consumer";case C:var p=c.render;return c=c.displayName,c||(c=p.displayName||p.name||"",c=c!==""?"ForwardRef("+c+")":"ForwardRef"),c;case _:return p=c.displayName||null,p!==null?p:G(c.type)||"Memo";case $:p=c._payload,c=c._init;try{return G(c(p))}catch{}}return null}var q=Array.isArray,B=t.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,j=e.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,K={pending:!1,data:null,method:null,action:null},z=[],U=-1;function M(c){return{current:c}}function X(c){0>U||(c.current=z[U],z[U]=null,U--)}function Q(c,p){U++,z[U]=c.current,c.current=p}var rt=M(null),ct=M(null),pt=M(null),yt=M(null);function Tt(c,p){switch(Q(pt,p),Q(ct,c),Q(rt,null),p.nodeType){case 9:case 11:c=(c=p.documentElement)&&(c=c.namespaceURI)?GD(c):0;break;default:if(c=p.tagName,p=p.namespaceURI)p=GD(p),c=HD(p,c);else switch(c){case"svg":c=1;break;case"math":c=2;break;default:c=0}}X(rt),Q(rt,c)}function gt(){X(rt),X(ct),X(pt)}function Rt(c){c.memoizedState!==null&&Q(yt,c);var p=rt.current,g=HD(p,c.type);p!==g&&(Q(ct,c),Q(rt,g))}function At(c){ct.current===c&&(X(rt),X(ct)),yt.current===c&&(X(yt),mf._currentValue=K)}var Lt,Mt;function Wt(c){if(Lt===void 0)try{throw Error()}catch(g){var p=g.stack.trim().match(/\n( *(at )?)/);Lt=p&&p[1]||"",Mt=-1<g.stack.indexOf(`
    at`)?" (<anonymous>)":-1<g.stack.indexOf("@")?"@unknown:0:0":""}return`
`+Lt+c+Mt}var se=!1;function Xt(c,p){if(!c||se)return"";se=!0;var g=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{var x={DetermineComponentFrameRoot:function(){try{if(p){var _t=function(){throw Error()};if(Object.defineProperty(_t.prototype,"props",{set:function(){throw Error()}}),typeof Reflect=="object"&&Reflect.construct){try{Reflect.construct(_t,[])}catch(wt){var vt=wt}Reflect.construct(c,[],_t)}else{try{_t.call()}catch(wt){vt=wt}c.call(_t.prototype)}}else{try{throw Error()}catch(wt){vt=wt}(_t=c())&&typeof _t.catch=="function"&&_t.catch(function(){})}}catch(wt){if(wt&&vt&&typeof wt.stack=="string")return[wt.stack,vt.stack]}return[null,null]}};x.DetermineComponentFrameRoot.displayName="DetermineComponentFrameRoot";var k=Object.getOwnPropertyDescriptor(x.DetermineComponentFrameRoot,"name");k&&k.configurable&&Object.defineProperty(x.DetermineComponentFrameRoot,"name",{value:"DetermineComponentFrameRoot"});var E=x.DetermineComponentFrameRoot(),F=E[0],W=E[1];if(F&&W){var nt=F.split(`
`),mt=W.split(`
`);for(k=x=0;x<nt.length&&!nt[x].includes("DetermineComponentFrameRoot");)x++;for(;k<mt.length&&!mt[k].includes("DetermineComponentFrameRoot");)k++;if(x===nt.length||k===mt.length)for(x=nt.length-1,k=mt.length-1;1<=x&&0<=k&&nt[x]!==mt[k];)k--;for(;1<=x&&0<=k;x--,k--)if(nt[x]!==mt[k]){if(x!==1||k!==1)do if(x--,k--,0>k||nt[x]!==mt[k]){var Nt=`
`+nt[x].replace(" at new "," at ");return c.displayName&&Nt.includes("<anonymous>")&&(Nt=Nt.replace("<anonymous>",c.displayName)),Nt}while(1<=x&&0<=k);break}}}finally{se=!1,Error.prepareStackTrace=g}return(g=c?c.displayName||c.name:"")?Wt(g):""}function Se(c,p){switch(c.tag){case 26:case 27:case 5:return Wt(c.type);case 16:return Wt("Lazy");case 13:return c.child!==p&&p!==null?Wt("Suspense Fallback"):Wt("Suspense");case 19:return Wt("SuspenseList");case 0:case 15:return Xt(c.type,!1);case 11:return Xt(c.type.render,!1);case 1:return Xt(c.type,!0);case 31:return Wt("Activity");default:return""}}function pe(c){try{var p="",g=null;do p+=Se(c,g),g=c,c=c.return;while(c);return p}catch(x){return`
Error generating stack: `+x.message+`
`+x.stack}}var Xe=Object.prototype.hasOwnProperty,We=n.unstable_scheduleCallback,hn=n.unstable_cancelCallback,vn=n.unstable_shouldYield,Hn=n.unstable_requestPaint,Ge=n.unstable_now,Ot=n.unstable_getCurrentPriorityLevel,Ht=n.unstable_ImmediatePriority,Ce=n.unstable_UserBlockingPriority,ge=n.unstable_NormalPriority,en=n.unstable_LowPriority,hr=n.unstable_IdlePriority,Wr=n.log,ti=n.unstable_setDisableYieldValue,Er=null,Dn=null;function dr(c){if(typeof Wr=="function"&&ti(c),Dn&&typeof Dn.setStrictMode=="function")try{Dn.setStrictMode(Er,c)}catch{}}var Gr=Math.clz32?Math.clz32:Tp,Np=Math.log,kp=Math.LN2;function Tp(c){return c>>>=0,c===0?32:31-(Np(c)/kp|0)|0}var Oc=256,yv=262144,bv=4194304;function ll(c){var p=c&42;if(p!==0)return p;switch(c&-c){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:return 64;case 128:return 128;case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:return c&261888;case 262144:case 524288:case 1048576:case 2097152:return c&3932160;case 4194304:case 8388608:case 16777216:case 33554432:return c&62914560;case 67108864:return 67108864;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 0;default:return c}}function xv(c,p,g){var x=c.pendingLanes;if(x===0)return 0;var k=0,E=c.suspendedLanes,F=c.pingedLanes;c=c.warmLanes;var W=x&134217727;return W!==0?(x=W&~E,x!==0?k=ll(x):(F&=W,F!==0?k=ll(F):g||(g=W&~c,g!==0&&(k=ll(g))))):(W=x&~E,W!==0?k=ll(W):F!==0?k=ll(F):g||(g=x&~c,g!==0&&(k=ll(g)))),k===0?0:p!==0&&p!==k&&(p&E)===0&&(E=k&-k,g=p&-p,E>=g||E===32&&(g&4194048)!==0)?p:k}function Ep(c,p){return(c.pendingLanes&~(c.suspendedLanes&~c.pingedLanes)&p)===0}function fH(c,p){switch(c){case 1:case 2:case 4:case 8:case 64:return p+250;case 16:case 32:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return p+5e3;case 4194304:case 8388608:case 16777216:case 33554432:return-1;case 67108864:case 134217728:case 268435456:case 536870912:case 1073741824:return-1;default:return-1}}function k_(){var c=bv;return bv<<=1,(bv&62914560)===0&&(bv=4194304),c}function cw(c){for(var p=[],g=0;31>g;g++)p.push(c);return p}function Ip(c,p){c.pendingLanes|=p,p!==268435456&&(c.suspendedLanes=0,c.pingedLanes=0,c.warmLanes=0)}function mH(c,p,g,x,k,E){var F=c.pendingLanes;c.pendingLanes=g,c.suspendedLanes=0,c.pingedLanes=0,c.warmLanes=0,c.expiredLanes&=g,c.entangledLanes&=g,c.errorRecoveryDisabledLanes&=g,c.shellSuspendCounter=0;var W=c.entanglements,nt=c.expirationTimes,mt=c.hiddenUpdates;for(g=F&~g;0<g;){var Nt=31-Gr(g),_t=1<<Nt;W[Nt]=0,nt[Nt]=-1;var vt=mt[Nt];if(vt!==null)for(mt[Nt]=null,Nt=0;Nt<vt.length;Nt++){var wt=vt[Nt];wt!==null&&(wt.lane&=-536870913)}g&=~_t}x!==0&&T_(c,x,0),E!==0&&k===0&&c.tag!==0&&(c.suspendedLanes|=E&~(F&~p))}function T_(c,p,g){c.pendingLanes|=p,c.suspendedLanes&=~p;var x=31-Gr(p);c.entangledLanes|=p,c.entanglements[x]=c.entanglements[x]|1073741824|g&261930}function E_(c,p){var g=c.entangledLanes|=p;for(c=c.entanglements;g;){var x=31-Gr(g),k=1<<x;k&p|c[x]&p&&(c[x]|=p),g&=~k}}function I_(c,p){var g=p&-p;return g=(g&42)!==0?1:hw(g),(g&(c.suspendedLanes|p))!==0?0:g}function hw(c){switch(c){case 2:c=1;break;case 8:c=4;break;case 32:c=16;break;case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:c=128;break;case 268435456:c=134217728;break;default:c=0}return c}function dw(c){return c&=-c,2<c?8<c?(c&134217727)!==0?32:268435456:8:2}function __(){var c=j.p;return c!==0?c:(c=window.event,c===void 0?32:f$(c.type))}function R_(c,p){var g=j.p;try{return j.p=c,p()}finally{j.p=g}}var Xi=Math.random().toString(36).slice(2),Hr="__reactFiber$"+Xi,Ia="__reactProps$"+Xi,Fc="__reactContainer$"+Xi,pw="__reactEvents$"+Xi,gH="__reactListeners$"+Xi,vH="__reactHandles$"+Xi,A_="__reactResources$"+Xi,_p="__reactMarker$"+Xi;function fw(c){delete c[Hr],delete c[Ia],delete c[pw],delete c[gH],delete c[vH]}function Mc(c){var p=c[Hr];if(p)return p;for(var g=c.parentNode;g;){if(p=g[Fc]||g[Hr]){if(g=p.alternate,p.child!==null||g!==null&&g.child!==null)for(c=ZD(c);c!==null;){if(g=c[Hr])return g;c=ZD(c)}return p}c=g,g=c.parentNode}return null}function Lc(c){if(c=c[Hr]||c[Fc]){var p=c.tag;if(p===5||p===6||p===13||p===31||p===26||p===27||p===3)return c}return null}function Rp(c){var p=c.tag;if(p===5||p===26||p===27||p===6)return c.stateNode;throw Error(r(33))}function Bc(c){var p=c[A_];return p||(p=c[A_]={hoistableStyles:new Map,hoistableScripts:new Map}),p}function Ir(c){c[_p]=!0}var D_=new Set,$_={};function cl(c,p){zc(c,p),zc(c+"Capture",p)}function zc(c,p){for($_[c]=p,c=0;c<p.length;c++)D_.add(p[c])}var yH=RegExp("^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"),O_={},F_={};function bH(c){return Xe.call(F_,c)?!0:Xe.call(O_,c)?!1:yH.test(c)?F_[c]=!0:(O_[c]=!0,!1)}function wv(c,p,g){if(bH(p))if(g===null)c.removeAttribute(p);else{switch(typeof g){case"undefined":case"function":case"symbol":c.removeAttribute(p);return;case"boolean":var x=p.toLowerCase().slice(0,5);if(x!=="data-"&&x!=="aria-"){c.removeAttribute(p);return}}c.setAttribute(p,""+g)}}function Sv(c,p,g){if(g===null)c.removeAttribute(p);else{switch(typeof g){case"undefined":case"function":case"symbol":case"boolean":c.removeAttribute(p);return}c.setAttribute(p,""+g)}}function ei(c,p,g,x){if(x===null)c.removeAttribute(g);else{switch(typeof x){case"undefined":case"function":case"symbol":case"boolean":c.removeAttribute(g);return}c.setAttributeNS(p,g,""+x)}}function Ss(c){switch(typeof c){case"bigint":case"boolean":case"number":case"string":case"undefined":return c;case"object":return c;default:return""}}function M_(c){var p=c.type;return(c=c.nodeName)&&c.toLowerCase()==="input"&&(p==="checkbox"||p==="radio")}function xH(c,p,g){var x=Object.getOwnPropertyDescriptor(c.constructor.prototype,p);if(!c.hasOwnProperty(p)&&typeof x<"u"&&typeof x.get=="function"&&typeof x.set=="function"){var k=x.get,E=x.set;return Object.defineProperty(c,p,{configurable:!0,get:function(){return k.call(this)},set:function(F){g=""+F,E.call(this,F)}}),Object.defineProperty(c,p,{enumerable:x.enumerable}),{getValue:function(){return g},setValue:function(F){g=""+F},stopTracking:function(){c._valueTracker=null,delete c[p]}}}}function mw(c){if(!c._valueTracker){var p=M_(c)?"checked":"value";c._valueTracker=xH(c,p,""+c[p])}}function L_(c){if(!c)return!1;var p=c._valueTracker;if(!p)return!0;var g=p.getValue(),x="";return c&&(x=M_(c)?c.checked?"true":"false":c.value),c=x,c!==g?(p.setValue(c),!0):!1}function Cv(c){if(c=c||(typeof document<"u"?document:void 0),typeof c>"u")return null;try{return c.activeElement||c.body}catch{return c.body}}var wH=/[\n"\\]/g;function Cs(c){return c.replace(wH,function(p){return"\\"+p.charCodeAt(0).toString(16)+" "})}function gw(c,p,g,x,k,E,F,W){c.name="",F!=null&&typeof F!="function"&&typeof F!="symbol"&&typeof F!="boolean"?c.type=F:c.removeAttribute("type"),p!=null?F==="number"?(p===0&&c.value===""||c.value!=p)&&(c.value=""+Ss(p)):c.value!==""+Ss(p)&&(c.value=""+Ss(p)):F!=="submit"&&F!=="reset"||c.removeAttribute("value"),p!=null?vw(c,F,Ss(p)):g!=null?vw(c,F,Ss(g)):x!=null&&c.removeAttribute("value"),k==null&&E!=null&&(c.defaultChecked=!!E),k!=null&&(c.checked=k&&typeof k!="function"&&typeof k!="symbol"),W!=null&&typeof W!="function"&&typeof W!="symbol"&&typeof W!="boolean"?c.name=""+Ss(W):c.removeAttribute("name")}function B_(c,p,g,x,k,E,F,W){if(E!=null&&typeof E!="function"&&typeof E!="symbol"&&typeof E!="boolean"&&(c.type=E),p!=null||g!=null){if(!(E!=="submit"&&E!=="reset"||p!=null)){mw(c);return}g=g!=null?""+Ss(g):"",p=p!=null?""+Ss(p):g,W||p===c.value||(c.value=p),c.defaultValue=p}x=x??k,x=typeof x!="function"&&typeof x!="symbol"&&!!x,c.checked=W?c.checked:!!x,c.defaultChecked=!!x,F!=null&&typeof F!="function"&&typeof F!="symbol"&&typeof F!="boolean"&&(c.name=F),mw(c)}function vw(c,p,g){p==="number"&&Cv(c.ownerDocument)===c||c.defaultValue===""+g||(c.defaultValue=""+g)}function Pc(c,p,g,x){if(c=c.options,p){p={};for(var k=0;k<g.length;k++)p["$"+g[k]]=!0;for(g=0;g<c.length;g++)k=p.hasOwnProperty("$"+c[g].value),c[g].selected!==k&&(c[g].selected=k),k&&x&&(c[g].defaultSelected=!0)}else{for(g=""+Ss(g),p=null,k=0;k<c.length;k++){if(c[k].value===g){c[k].selected=!0,x&&(c[k].defaultSelected=!0);return}p!==null||c[k].disabled||(p=c[k])}p!==null&&(p.selected=!0)}}function z_(c,p,g){if(p!=null&&(p=""+Ss(p),p!==c.value&&(c.value=p),g==null)){c.defaultValue!==p&&(c.defaultValue=p);return}c.defaultValue=g!=null?""+Ss(g):""}function P_(c,p,g,x){if(p==null){if(x!=null){if(g!=null)throw Error(r(92));if(q(x)){if(1<x.length)throw Error(r(93));x=x[0]}g=x}g==null&&(g=""),p=g}g=Ss(p),c.defaultValue=g,x=c.textContent,x===g&&x!==""&&x!==null&&(c.value=x),mw(c)}function Vc(c,p){if(p){var g=c.firstChild;if(g&&g===c.lastChild&&g.nodeType===3){g.nodeValue=p;return}}c.textContent=p}var SH=new Set("animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(" "));function V_(c,p,g){var x=p.indexOf("--")===0;g==null||typeof g=="boolean"||g===""?x?c.setProperty(p,""):p==="float"?c.cssFloat="":c[p]="":x?c.setProperty(p,g):typeof g!="number"||g===0||SH.has(p)?p==="float"?c.cssFloat=g:c[p]=(""+g).trim():c[p]=g+"px"}function U_(c,p,g){if(p!=null&&typeof p!="object")throw Error(r(62));if(c=c.style,g!=null){for(var x in g)!g.hasOwnProperty(x)||p!=null&&p.hasOwnProperty(x)||(x.indexOf("--")===0?c.setProperty(x,""):x==="float"?c.cssFloat="":c[x]="");for(var k in p)x=p[k],p.hasOwnProperty(k)&&g[k]!==x&&V_(c,k,x)}else for(var E in p)p.hasOwnProperty(E)&&V_(c,E,p[E])}function yw(c){if(c.indexOf("-")===-1)return!1;switch(c){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var CH=new Map([["acceptCharset","accept-charset"],["htmlFor","for"],["httpEquiv","http-equiv"],["crossOrigin","crossorigin"],["accentHeight","accent-height"],["alignmentBaseline","alignment-baseline"],["arabicForm","arabic-form"],["baselineShift","baseline-shift"],["capHeight","cap-height"],["clipPath","clip-path"],["clipRule","clip-rule"],["colorInterpolation","color-interpolation"],["colorInterpolationFilters","color-interpolation-filters"],["colorProfile","color-profile"],["colorRendering","color-rendering"],["dominantBaseline","dominant-baseline"],["enableBackground","enable-background"],["fillOpacity","fill-opacity"],["fillRule","fill-rule"],["floodColor","flood-color"],["floodOpacity","flood-opacity"],["fontFamily","font-family"],["fontSize","font-size"],["fontSizeAdjust","font-size-adjust"],["fontStretch","font-stretch"],["fontStyle","font-style"],["fontVariant","font-variant"],["fontWeight","font-weight"],["glyphName","glyph-name"],["glyphOrientationHorizontal","glyph-orientation-horizontal"],["glyphOrientationVertical","glyph-orientation-vertical"],["horizAdvX","horiz-adv-x"],["horizOriginX","horiz-origin-x"],["imageRendering","image-rendering"],["letterSpacing","letter-spacing"],["lightingColor","lighting-color"],["markerEnd","marker-end"],["markerMid","marker-mid"],["markerStart","marker-start"],["overlinePosition","overline-position"],["overlineThickness","overline-thickness"],["paintOrder","paint-order"],["panose-1","panose-1"],["pointerEvents","pointer-events"],["renderingIntent","rendering-intent"],["shapeRendering","shape-rendering"],["stopColor","stop-color"],["stopOpacity","stop-opacity"],["strikethroughPosition","strikethrough-position"],["strikethroughThickness","strikethrough-thickness"],["strokeDasharray","stroke-dasharray"],["strokeDashoffset","stroke-dashoffset"],["strokeLinecap","stroke-linecap"],["strokeLinejoin","stroke-linejoin"],["strokeMiterlimit","stroke-miterlimit"],["strokeOpacity","stroke-opacity"],["strokeWidth","stroke-width"],["textAnchor","text-anchor"],["textDecoration","text-decoration"],["textRendering","text-rendering"],["transformOrigin","transform-origin"],["underlinePosition","underline-position"],["underlineThickness","underline-thickness"],["unicodeBidi","unicode-bidi"],["unicodeRange","unicode-range"],["unitsPerEm","units-per-em"],["vAlphabetic","v-alphabetic"],["vHanging","v-hanging"],["vIdeographic","v-ideographic"],["vMathematical","v-mathematical"],["vectorEffect","vector-effect"],["vertAdvY","vert-adv-y"],["vertOriginX","vert-origin-x"],["vertOriginY","vert-origin-y"],["wordSpacing","word-spacing"],["writingMode","writing-mode"],["xmlnsXlink","xmlns:xlink"],["xHeight","x-height"]]),NH=/^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;function Nv(c){return NH.test(""+c)?"javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')":c}function ni(){}var bw=null;function xw(c){return c=c.target||c.srcElement||window,c.correspondingUseElement&&(c=c.correspondingUseElement),c.nodeType===3?c.parentNode:c}var Uc=null,Wc=null;function W_(c){var p=Lc(c);if(p&&(c=p.stateNode)){var g=c[Ia]||null;t:switch(c=p.stateNode,p.type){case"input":if(gw(c,g.value,g.defaultValue,g.defaultValue,g.checked,g.defaultChecked,g.type,g.name),p=g.name,g.type==="radio"&&p!=null){for(g=c;g.parentNode;)g=g.parentNode;for(g=g.querySelectorAll('input[name="'+Cs(""+p)+'"][type="radio"]'),p=0;p<g.length;p++){var x=g[p];if(x!==c&&x.form===c.form){var k=x[Ia]||null;if(!k)throw Error(r(90));gw(x,k.value,k.defaultValue,k.defaultValue,k.checked,k.defaultChecked,k.type,k.name)}}for(p=0;p<g.length;p++)x=g[p],x.form===c.form&&L_(x)}break t;case"textarea":z_(c,g.value,g.defaultValue);break t;case"select":p=g.value,p!=null&&Pc(c,!!g.multiple,p,!1)}}}var ww=!1;function G_(c,p,g){if(ww)return c(p,g);ww=!0;try{var x=c(p);return x}finally{if(ww=!1,(Uc!==null||Wc!==null)&&(hy(),Uc&&(p=Uc,c=Wc,Wc=Uc=null,W_(p),c)))for(p=0;p<c.length;p++)W_(c[p])}}function Ap(c,p){var g=c.stateNode;if(g===null)return null;var x=g[Ia]||null;if(x===null)return null;g=x[p];t:switch(p){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(x=!x.disabled)||(c=c.type,x=!(c==="button"||c==="input"||c==="select"||c==="textarea")),c=!x;break t;default:c=!1}if(c)return null;if(g&&typeof g!="function")throw Error(r(231,p,typeof g));return g}var ri=!(typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"),Sw=!1;if(ri)try{var Dp={};Object.defineProperty(Dp,"passive",{get:function(){Sw=!0}}),window.addEventListener("test",Dp,Dp),window.removeEventListener("test",Dp,Dp)}catch{Sw=!1}var Yi=null,Cw=null,kv=null;function H_(){if(kv)return kv;var c,p=Cw,g=p.length,x,k="value"in Yi?Yi.value:Yi.textContent,E=k.length;for(c=0;c<g&&p[c]===k[c];c++);var F=g-c;for(x=1;x<=F&&p[g-x]===k[E-x];x++);return kv=k.slice(c,1<x?1-x:void 0)}function Tv(c){var p=c.keyCode;return"charCode"in c?(c=c.charCode,c===0&&p===13&&(c=13)):c=p,c===10&&(c=13),32<=c||c===13?c:0}function Ev(){return!0}function j_(){return!1}function _a(c){function p(g,x,k,E,F){this._reactName=g,this._targetInst=k,this.type=x,this.nativeEvent=E,this.target=F,this.currentTarget=null;for(var W in c)c.hasOwnProperty(W)&&(g=c[W],this[W]=g?g(E):E[W]);return this.isDefaultPrevented=(E.defaultPrevented!=null?E.defaultPrevented:E.returnValue===!1)?Ev:j_,this.isPropagationStopped=j_,this}return d(p.prototype,{preventDefault:function(){this.defaultPrevented=!0;var g=this.nativeEvent;g&&(g.preventDefault?g.preventDefault():typeof g.returnValue!="unknown"&&(g.returnValue=!1),this.isDefaultPrevented=Ev)},stopPropagation:function(){var g=this.nativeEvent;g&&(g.stopPropagation?g.stopPropagation():typeof g.cancelBubble!="unknown"&&(g.cancelBubble=!0),this.isPropagationStopped=Ev)},persist:function(){},isPersistent:Ev}),p}var hl={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(c){return c.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},Iv=_a(hl),$p=d({},hl,{view:0,detail:0}),kH=_a($p),Nw,kw,Op,_v=d({},$p,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:Ew,button:0,buttons:0,relatedTarget:function(c){return c.relatedTarget===void 0?c.fromElement===c.srcElement?c.toElement:c.fromElement:c.relatedTarget},movementX:function(c){return"movementX"in c?c.movementX:(c!==Op&&(Op&&c.type==="mousemove"?(Nw=c.screenX-Op.screenX,kw=c.screenY-Op.screenY):kw=Nw=0,Op=c),Nw)},movementY:function(c){return"movementY"in c?c.movementY:kw}}),q_=_a(_v),TH=d({},_v,{dataTransfer:0}),EH=_a(TH),IH=d({},$p,{relatedTarget:0}),Tw=_a(IH),_H=d({},hl,{animationName:0,elapsedTime:0,pseudoElement:0}),RH=_a(_H),AH=d({},hl,{clipboardData:function(c){return"clipboardData"in c?c.clipboardData:window.clipboardData}}),DH=_a(AH),$H=d({},hl,{data:0}),K_=_a($H),OH={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},FH={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},MH={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function LH(c){var p=this.nativeEvent;return p.getModifierState?p.getModifierState(c):(c=MH[c])?!!p[c]:!1}function Ew(){return LH}var BH=d({},$p,{key:function(c){if(c.key){var p=OH[c.key]||c.key;if(p!=="Unidentified")return p}return c.type==="keypress"?(c=Tv(c),c===13?"Enter":String.fromCharCode(c)):c.type==="keydown"||c.type==="keyup"?FH[c.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:Ew,charCode:function(c){return c.type==="keypress"?Tv(c):0},keyCode:function(c){return c.type==="keydown"||c.type==="keyup"?c.keyCode:0},which:function(c){return c.type==="keypress"?Tv(c):c.type==="keydown"||c.type==="keyup"?c.keyCode:0}}),zH=_a(BH),PH=d({},_v,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0}),X_=_a(PH),VH=d({},$p,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:Ew}),UH=_a(VH),WH=d({},hl,{propertyName:0,elapsedTime:0,pseudoElement:0}),GH=_a(WH),HH=d({},_v,{deltaX:function(c){return"deltaX"in c?c.deltaX:"wheelDeltaX"in c?-c.wheelDeltaX:0},deltaY:function(c){return"deltaY"in c?c.deltaY:"wheelDeltaY"in c?-c.wheelDeltaY:"wheelDelta"in c?-c.wheelDelta:0},deltaZ:0,deltaMode:0}),jH=_a(HH),qH=d({},hl,{newState:0,oldState:0}),KH=_a(qH),XH=[9,13,27,32],Iw=ri&&"CompositionEvent"in window,Fp=null;ri&&"documentMode"in document&&(Fp=document.documentMode);var YH=ri&&"TextEvent"in window&&!Fp,Y_=ri&&(!Iw||Fp&&8<Fp&&11>=Fp),Q_=" ",Z_=!1;function J_(c,p){switch(c){case"keyup":return XH.indexOf(p.keyCode)!==-1;case"keydown":return p.keyCode!==229;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function tR(c){return c=c.detail,typeof c=="object"&&"data"in c?c.data:null}var Gc=!1;function QH(c,p){switch(c){case"compositionend":return tR(p);case"keypress":return p.which!==32?null:(Z_=!0,Q_);case"textInput":return c=p.data,c===Q_&&Z_?null:c;default:return null}}function ZH(c,p){if(Gc)return c==="compositionend"||!Iw&&J_(c,p)?(c=H_(),kv=Cw=Yi=null,Gc=!1,c):null;switch(c){case"paste":return null;case"keypress":if(!(p.ctrlKey||p.altKey||p.metaKey)||p.ctrlKey&&p.altKey){if(p.char&&1<p.char.length)return p.char;if(p.which)return String.fromCharCode(p.which)}return null;case"compositionend":return Y_&&p.locale!=="ko"?null:p.data;default:return null}}var JH={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function eR(c){var p=c&&c.nodeName&&c.nodeName.toLowerCase();return p==="input"?!!JH[c.type]:p==="textarea"}function nR(c,p,g,x){Uc?Wc?Wc.push(x):Wc=[x]:Uc=x,p=yy(p,"onChange"),0<p.length&&(g=new Iv("onChange","change",null,g,x),c.push({event:g,listeners:p}))}var Mp=null,Lp=null;function t6(c){BD(c,0)}function Rv(c){var p=Rp(c);if(L_(p))return c}function rR(c,p){if(c==="change")return p}var aR=!1;if(ri){var _w;if(ri){var Rw="oninput"in document;if(!Rw){var sR=document.createElement("div");sR.setAttribute("oninput","return;"),Rw=typeof sR.oninput=="function"}_w=Rw}else _w=!1;aR=_w&&(!document.documentMode||9<document.documentMode)}function oR(){Mp&&(Mp.detachEvent("onpropertychange",iR),Lp=Mp=null)}function iR(c){if(c.propertyName==="value"&&Rv(Lp)){var p=[];nR(p,Lp,c,xw(c)),G_(t6,p)}}function e6(c,p,g){c==="focusin"?(oR(),Mp=p,Lp=g,Mp.attachEvent("onpropertychange",iR)):c==="focusout"&&oR()}function n6(c){if(c==="selectionchange"||c==="keyup"||c==="keydown")return Rv(Lp)}function r6(c,p){if(c==="click")return Rv(p)}function a6(c,p){if(c==="input"||c==="change")return Rv(p)}function s6(c,p){return c===p&&(c!==0||1/c===1/p)||c!==c&&p!==p}var Qa=typeof Object.is=="function"?Object.is:s6;function Bp(c,p){if(Qa(c,p))return!0;if(typeof c!="object"||c===null||typeof p!="object"||p===null)return!1;var g=Object.keys(c),x=Object.keys(p);if(g.length!==x.length)return!1;for(x=0;x<g.length;x++){var k=g[x];if(!Xe.call(p,k)||!Qa(c[k],p[k]))return!1}return!0}function uR(c){for(;c&&c.firstChild;)c=c.firstChild;return c}function lR(c,p){var g=uR(c);c=0;for(var x;g;){if(g.nodeType===3){if(x=c+g.textContent.length,c<=p&&x>=p)return{node:g,offset:p-c};c=x}t:{for(;g;){if(g.nextSibling){g=g.nextSibling;break t}g=g.parentNode}g=void 0}g=uR(g)}}function cR(c,p){return c&&p?c===p?!0:c&&c.nodeType===3?!1:p&&p.nodeType===3?cR(c,p.parentNode):"contains"in c?c.contains(p):c.compareDocumentPosition?!!(c.compareDocumentPosition(p)&16):!1:!1}function hR(c){c=c!=null&&c.ownerDocument!=null&&c.ownerDocument.defaultView!=null?c.ownerDocument.defaultView:window;for(var p=Cv(c.document);p instanceof c.HTMLIFrameElement;){try{var g=typeof p.contentWindow.location.href=="string"}catch{g=!1}if(g)c=p.contentWindow;else break;p=Cv(c.document)}return p}function Aw(c){var p=c&&c.nodeName&&c.nodeName.toLowerCase();return p&&(p==="input"&&(c.type==="text"||c.type==="search"||c.type==="tel"||c.type==="url"||c.type==="password")||p==="textarea"||c.contentEditable==="true")}var o6=ri&&"documentMode"in document&&11>=document.documentMode,Hc=null,Dw=null,zp=null,$w=!1;function dR(c,p,g){var x=g.window===g?g.document:g.nodeType===9?g:g.ownerDocument;$w||Hc==null||Hc!==Cv(x)||(x=Hc,"selectionStart"in x&&Aw(x)?x={start:x.selectionStart,end:x.selectionEnd}:(x=(x.ownerDocument&&x.ownerDocument.defaultView||window).getSelection(),x={anchorNode:x.anchorNode,anchorOffset:x.anchorOffset,focusNode:x.focusNode,focusOffset:x.focusOffset}),zp&&Bp(zp,x)||(zp=x,x=yy(Dw,"onSelect"),0<x.length&&(p=new Iv("onSelect","select",null,p,g),c.push({event:p,listeners:x}),p.target=Hc)))}function dl(c,p){var g={};return g[c.toLowerCase()]=p.toLowerCase(),g["Webkit"+c]="webkit"+p,g["Moz"+c]="moz"+p,g}var jc={animationend:dl("Animation","AnimationEnd"),animationiteration:dl("Animation","AnimationIteration"),animationstart:dl("Animation","AnimationStart"),transitionrun:dl("Transition","TransitionRun"),transitionstart:dl("Transition","TransitionStart"),transitioncancel:dl("Transition","TransitionCancel"),transitionend:dl("Transition","TransitionEnd")},Ow={},pR={};ri&&(pR=document.createElement("div").style,"AnimationEvent"in window||(delete jc.animationend.animation,delete jc.animationiteration.animation,delete jc.animationstart.animation),"TransitionEvent"in window||delete jc.transitionend.transition);function pl(c){if(Ow[c])return Ow[c];if(!jc[c])return c;var p=jc[c],g;for(g in p)if(p.hasOwnProperty(g)&&g in pR)return Ow[c]=p[g];return c}var fR=pl("animationend"),mR=pl("animationiteration"),gR=pl("animationstart"),i6=pl("transitionrun"),u6=pl("transitionstart"),l6=pl("transitioncancel"),vR=pl("transitionend"),yR=new Map,Fw="abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");Fw.push("scrollEnd");function Hs(c,p){yR.set(c,p),cl(p,[c])}var Av=typeof reportError=="function"?reportError:function(c){if(typeof window=="object"&&typeof window.ErrorEvent=="function"){var p=new window.ErrorEvent("error",{bubbles:!0,cancelable:!0,message:typeof c=="object"&&c!==null&&typeof c.message=="string"?String(c.message):String(c),error:c});if(!window.dispatchEvent(p))return}else if(typeof process=="object"&&typeof process.emit=="function"){process.emit("uncaughtException",c);return}console.error(c)},Ns=[],qc=0,Mw=0;function Dv(){for(var c=qc,p=Mw=qc=0;p<c;){var g=Ns[p];Ns[p++]=null;var x=Ns[p];Ns[p++]=null;var k=Ns[p];Ns[p++]=null;var E=Ns[p];if(Ns[p++]=null,x!==null&&k!==null){var F=x.pending;F===null?k.next=k:(k.next=F.next,F.next=k),x.pending=k}E!==0&&bR(g,k,E)}}function $v(c,p,g,x){Ns[qc++]=c,Ns[qc++]=p,Ns[qc++]=g,Ns[qc++]=x,Mw|=x,c.lanes|=x,c=c.alternate,c!==null&&(c.lanes|=x)}function Lw(c,p,g,x){return $v(c,p,g,x),Ov(c)}function fl(c,p){return $v(c,null,null,p),Ov(c)}function bR(c,p,g){c.lanes|=g;var x=c.alternate;x!==null&&(x.lanes|=g);for(var k=!1,E=c.return;E!==null;)E.childLanes|=g,x=E.alternate,x!==null&&(x.childLanes|=g),E.tag===22&&(c=E.stateNode,c===null||c._visibility&1||(k=!0)),c=E,E=E.return;return c.tag===3?(E=c.stateNode,k&&p!==null&&(k=31-Gr(g),c=E.hiddenUpdates,x=c[k],x===null?c[k]=[p]:x.push(p),p.lane=g|536870912),E):null}function Ov(c){if(50<uf)throw uf=0,j2=null,Error(r(185));for(var p=c.return;p!==null;)c=p,p=c.return;return c.tag===3?c.stateNode:null}var Kc={};function c6(c,p,g,x){this.tag=c,this.key=g,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.refCleanup=this.ref=null,this.pendingProps=p,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=x,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function Za(c,p,g,x){return new c6(c,p,g,x)}function Bw(c){return c=c.prototype,!(!c||!c.isReactComponent)}function ai(c,p){var g=c.alternate;return g===null?(g=Za(c.tag,p,c.key,c.mode),g.elementType=c.elementType,g.type=c.type,g.stateNode=c.stateNode,g.alternate=c,c.alternate=g):(g.pendingProps=p,g.type=c.type,g.flags=0,g.subtreeFlags=0,g.deletions=null),g.flags=c.flags&65011712,g.childLanes=c.childLanes,g.lanes=c.lanes,g.child=c.child,g.memoizedProps=c.memoizedProps,g.memoizedState=c.memoizedState,g.updateQueue=c.updateQueue,p=c.dependencies,g.dependencies=p===null?null:{lanes:p.lanes,firstContext:p.firstContext},g.sibling=c.sibling,g.index=c.index,g.ref=c.ref,g.refCleanup=c.refCleanup,g}function xR(c,p){c.flags&=65011714;var g=c.alternate;return g===null?(c.childLanes=0,c.lanes=p,c.child=null,c.subtreeFlags=0,c.memoizedProps=null,c.memoizedState=null,c.updateQueue=null,c.dependencies=null,c.stateNode=null):(c.childLanes=g.childLanes,c.lanes=g.lanes,c.child=g.child,c.subtreeFlags=0,c.deletions=null,c.memoizedProps=g.memoizedProps,c.memoizedState=g.memoizedState,c.updateQueue=g.updateQueue,c.type=g.type,p=g.dependencies,c.dependencies=p===null?null:{lanes:p.lanes,firstContext:p.firstContext}),c}function Fv(c,p,g,x,k,E){var F=0;if(x=c,typeof c=="function")Bw(c)&&(F=1);else if(typeof c=="string")F=mj(c,g,rt.current)?26:c==="html"||c==="head"||c==="body"?27:5;else t:switch(c){case R:return c=Za(31,g,p,k),c.elementType=R,c.lanes=E,c;case y:return ml(g.children,k,E,p);case b:F=8,k|=24;break;case w:return c=Za(12,g,p,k|2),c.elementType=w,c.lanes=E,c;case T:return c=Za(13,g,p,k),c.elementType=T,c.lanes=E,c;case I:return c=Za(19,g,p,k),c.elementType=I,c.lanes=E,c;default:if(typeof c=="object"&&c!==null)switch(c.$$typeof){case N:F=10;break t;case S:F=9;break t;case C:F=11;break t;case _:F=14;break t;case $:F=16,x=null;break t}F=29,g=Error(r(130,c===null?"null":typeof c,"")),x=null}return p=Za(F,g,p,k),p.elementType=c,p.type=x,p.lanes=E,p}function ml(c,p,g,x){return c=Za(7,c,x,p),c.lanes=g,c}function zw(c,p,g){return c=Za(6,c,null,p),c.lanes=g,c}function wR(c){var p=Za(18,null,null,0);return p.stateNode=c,p}function Pw(c,p,g){return p=Za(4,c.children!==null?c.children:[],c.key,p),p.lanes=g,p.stateNode={containerInfo:c.containerInfo,pendingChildren:null,implementation:c.implementation},p}var SR=new WeakMap;function ks(c,p){if(typeof c=="object"&&c!==null){var g=SR.get(c);return g!==void 0?g:(p={value:c,source:p,stack:pe(p)},SR.set(c,p),p)}return{value:c,source:p,stack:pe(p)}}var Xc=[],Yc=0,Mv=null,Pp=0,Ts=[],Es=0,Qi=null,fo=1,mo="";function si(c,p){Xc[Yc++]=Pp,Xc[Yc++]=Mv,Mv=c,Pp=p}function CR(c,p,g){Ts[Es++]=fo,Ts[Es++]=mo,Ts[Es++]=Qi,Qi=c;var x=fo;c=mo;var k=32-Gr(x)-1;x&=~(1<<k),g+=1;var E=32-Gr(p)+k;if(30<E){var F=k-k%5;E=(x&(1<<F)-1).toString(32),x>>=F,k-=F,fo=1<<32-Gr(p)+k|g<<k|x,mo=E+c}else fo=1<<E|g<<k|x,mo=c}function Vw(c){c.return!==null&&(si(c,1),CR(c,1,0))}function Uw(c){for(;c===Mv;)Mv=Xc[--Yc],Xc[Yc]=null,Pp=Xc[--Yc],Xc[Yc]=null;for(;c===Qi;)Qi=Ts[--Es],Ts[Es]=null,mo=Ts[--Es],Ts[Es]=null,fo=Ts[--Es],Ts[Es]=null}function NR(c,p){Ts[Es++]=fo,Ts[Es++]=mo,Ts[Es++]=Qi,fo=p.id,mo=p.overflow,Qi=c}var jr=null,bn=null,Ve=!1,Zi=null,Is=!1,Ww=Error(r(519));function Ji(c){var p=Error(r(418,1<arguments.length&&arguments[1]!==void 0&&arguments[1]?"text":"HTML",""));throw Vp(ks(p,c)),Ww}function kR(c){var p=c.stateNode,g=c.type,x=c.memoizedProps;switch(p[Hr]=c,p[Ia]=x,g){case"dialog":Me("cancel",p),Me("close",p);break;case"iframe":case"object":case"embed":Me("load",p);break;case"video":case"audio":for(g=0;g<cf.length;g++)Me(cf[g],p);break;case"source":Me("error",p);break;case"img":case"image":case"link":Me("error",p),Me("load",p);break;case"details":Me("toggle",p);break;case"input":Me("invalid",p),B_(p,x.value,x.defaultValue,x.checked,x.defaultChecked,x.type,x.name,!0);break;case"select":Me("invalid",p);break;case"textarea":Me("invalid",p),P_(p,x.value,x.defaultValue,x.children)}g=x.children,typeof g!="string"&&typeof g!="number"&&typeof g!="bigint"||p.textContent===""+g||x.suppressHydrationWarning===!0||UD(p.textContent,g)?(x.popover!=null&&(Me("beforetoggle",p),Me("toggle",p)),x.onScroll!=null&&Me("scroll",p),x.onScrollEnd!=null&&Me("scrollend",p),x.onClick!=null&&(p.onclick=ni),p=!0):p=!1,p||Ji(c,!0)}function TR(c){for(jr=c.return;jr;)switch(jr.tag){case 5:case 31:case 13:Is=!1;return;case 27:case 3:Is=!0;return;default:jr=jr.return}}function Qc(c){if(c!==jr)return!1;if(!Ve)return TR(c),Ve=!0,!1;var p=c.tag,g;if((g=p!==3&&p!==27)&&((g=p===5)&&(g=c.type,g=!(g!=="form"&&g!=="button")||iS(c.type,c.memoizedProps)),g=!g),g&&bn&&Ji(c),TR(c),p===13){if(c=c.memoizedState,c=c!==null?c.dehydrated:null,!c)throw Error(r(317));bn=QD(c)}else if(p===31){if(c=c.memoizedState,c=c!==null?c.dehydrated:null,!c)throw Error(r(317));bn=QD(c)}else p===27?(p=bn,pu(c.type)?(c=dS,dS=null,bn=c):bn=p):bn=jr?Rs(c.stateNode.nextSibling):null;return!0}function gl(){bn=jr=null,Ve=!1}function Gw(){var c=Zi;return c!==null&&($a===null?$a=c:$a.push.apply($a,c),Zi=null),c}function Vp(c){Zi===null?Zi=[c]:Zi.push(c)}var Hw=M(null),vl=null,oi=null;function tu(c,p,g){Q(Hw,p._currentValue),p._currentValue=g}function ii(c){c._currentValue=Hw.current,X(Hw)}function jw(c,p,g){for(;c!==null;){var x=c.alternate;if((c.childLanes&p)!==p?(c.childLanes|=p,x!==null&&(x.childLanes|=p)):x!==null&&(x.childLanes&p)!==p&&(x.childLanes|=p),c===g)break;c=c.return}}function qw(c,p,g,x){var k=c.child;for(k!==null&&(k.return=c);k!==null;){var E=k.dependencies;if(E!==null){var F=k.child;E=E.firstContext;t:for(;E!==null;){var W=E;E=k;for(var nt=0;nt<p.length;nt++)if(W.context===p[nt]){E.lanes|=g,W=E.alternate,W!==null&&(W.lanes|=g),jw(E.return,g,c),x||(F=null);break t}E=W.next}}else if(k.tag===18){if(F=k.return,F===null)throw Error(r(341));F.lanes|=g,E=F.alternate,E!==null&&(E.lanes|=g),jw(F,g,c),F=null}else F=k.child;if(F!==null)F.return=k;else for(F=k;F!==null;){if(F===c){F=null;break}if(k=F.sibling,k!==null){k.return=F.return,F=k;break}F=F.return}k=F}}function Zc(c,p,g,x){c=null;for(var k=p,E=!1;k!==null;){if(!E){if((k.flags&524288)!==0)E=!0;else if((k.flags&262144)!==0)break}if(k.tag===10){var F=k.alternate;if(F===null)throw Error(r(387));if(F=F.memoizedProps,F!==null){var W=k.type;Qa(k.pendingProps.value,F.value)||(c!==null?c.push(W):c=[W])}}else if(k===yt.current){if(F=k.alternate,F===null)throw Error(r(387));F.memoizedState.memoizedState!==k.memoizedState.memoizedState&&(c!==null?c.push(mf):c=[mf])}k=k.return}c!==null&&qw(p,c,g,x),p.flags|=262144}function Lv(c){for(c=c.firstContext;c!==null;){if(!Qa(c.context._currentValue,c.memoizedValue))return!0;c=c.next}return!1}function yl(c){vl=c,oi=null,c=c.dependencies,c!==null&&(c.firstContext=null)}function qr(c){return ER(vl,c)}function Bv(c,p){return vl===null&&yl(c),ER(c,p)}function ER(c,p){var g=p._currentValue;if(p={context:p,memoizedValue:g,next:null},oi===null){if(c===null)throw Error(r(308));oi=p,c.dependencies={lanes:0,firstContext:p},c.flags|=524288}else oi=oi.next=p;return g}var h6=typeof AbortController<"u"?AbortController:function(){var c=[],p=this.signal={aborted:!1,addEventListener:function(g,x){c.push(x)}};this.abort=function(){p.aborted=!0,c.forEach(function(g){return g()})}},d6=n.unstable_scheduleCallback,p6=n.unstable_NormalPriority,Jn={$$typeof:N,Consumer:null,Provider:null,_currentValue:null,_currentValue2:null,_threadCount:0};function Kw(){return{controller:new h6,data:new Map,refCount:0}}function Up(c){c.refCount--,c.refCount===0&&d6(p6,function(){c.controller.abort()})}var Wp=null,Xw=0,Jc=0,th=null;function f6(c,p){if(Wp===null){var g=Wp=[];Xw=0,Jc=Z2(),th={status:"pending",value:void 0,then:function(x){g.push(x)}}}return Xw++,p.then(IR,IR),p}function IR(){if(--Xw===0&&Wp!==null){th!==null&&(th.status="fulfilled");var c=Wp;Wp=null,Jc=0,th=null;for(var p=0;p<c.length;p++)(0,c[p])()}}function m6(c,p){var g=[],x={status:"pending",value:null,reason:null,then:function(k){g.push(k)}};return c.then(function(){x.status="fulfilled",x.value=p;for(var k=0;k<g.length;k++)(0,g[k])(p)},function(k){for(x.status="rejected",x.reason=k,k=0;k<g.length;k++)(0,g[k])(void 0)}),x}var _R=B.S;B.S=function(c,p){dD=Ge(),typeof p=="object"&&p!==null&&typeof p.then=="function"&&f6(c,p),_R!==null&&_R(c,p)};var bl=M(null);function Yw(){var c=bl.current;return c!==null?c:dn.pooledCache}function zv(c,p){p===null?Q(bl,bl.current):Q(bl,p.pool)}function RR(){var c=Yw();return c===null?null:{parent:Jn._currentValue,pool:c}}var eh=Error(r(460)),Qw=Error(r(474)),Pv=Error(r(542)),Vv={then:function(){}};function AR(c){return c=c.status,c==="fulfilled"||c==="rejected"}function DR(c,p,g){switch(g=c[g],g===void 0?c.push(p):g!==p&&(p.then(ni,ni),p=g),p.status){case"fulfilled":return p.value;case"rejected":throw c=p.reason,OR(c),c;default:if(typeof p.status=="string")p.then(ni,ni);else{if(c=dn,c!==null&&100<c.shellSuspendCounter)throw Error(r(482));c=p,c.status="pending",c.then(function(x){if(p.status==="pending"){var k=p;k.status="fulfilled",k.value=x}},function(x){if(p.status==="pending"){var k=p;k.status="rejected",k.reason=x}})}switch(p.status){case"fulfilled":return p.value;case"rejected":throw c=p.reason,OR(c),c}throw wl=p,eh}}function xl(c){try{var p=c._init;return p(c._payload)}catch(g){throw g!==null&&typeof g=="object"&&typeof g.then=="function"?(wl=g,eh):g}}var wl=null;function $R(){if(wl===null)throw Error(r(459));var c=wl;return wl=null,c}function OR(c){if(c===eh||c===Pv)throw Error(r(483))}var nh=null,Gp=0;function Uv(c){var p=Gp;return Gp+=1,nh===null&&(nh=[]),DR(nh,c,p)}function Hp(c,p){p=p.props.ref,c.ref=p!==void 0?p:null}function Wv(c,p){throw p.$$typeof===f?Error(r(525)):(c=Object.prototype.toString.call(p),Error(r(31,c==="[object Object]"?"object with keys {"+Object.keys(p).join(", ")+"}":c)))}function FR(c){function p(ht,it){if(c){var ft=ht.deletions;ft===null?(ht.deletions=[it],ht.flags|=16):ft.push(it)}}function g(ht,it){if(!c)return null;for(;it!==null;)p(ht,it),it=it.sibling;return null}function x(ht){for(var it=new Map;ht!==null;)ht.key!==null?it.set(ht.key,ht):it.set(ht.index,ht),ht=ht.sibling;return it}function k(ht,it){return ht=ai(ht,it),ht.index=0,ht.sibling=null,ht}function E(ht,it,ft){return ht.index=ft,c?(ft=ht.alternate,ft!==null?(ft=ft.index,ft<it?(ht.flags|=67108866,it):ft):(ht.flags|=67108866,it)):(ht.flags|=1048576,it)}function F(ht){return c&&ht.alternate===null&&(ht.flags|=67108866),ht}function W(ht,it,ft,Et){return it===null||it.tag!==6?(it=zw(ft,ht.mode,Et),it.return=ht,it):(it=k(it,ft),it.return=ht,it)}function nt(ht,it,ft,Et){var ie=ft.type;return ie===y?Nt(ht,it,ft.props.children,Et,ft.key):it!==null&&(it.elementType===ie||typeof ie=="object"&&ie!==null&&ie.$$typeof===$&&xl(ie)===it.type)?(it=k(it,ft.props),Hp(it,ft),it.return=ht,it):(it=Fv(ft.type,ft.key,ft.props,null,ht.mode,Et),Hp(it,ft),it.return=ht,it)}function mt(ht,it,ft,Et){return it===null||it.tag!==4||it.stateNode.containerInfo!==ft.containerInfo||it.stateNode.implementation!==ft.implementation?(it=Pw(ft,ht.mode,Et),it.return=ht,it):(it=k(it,ft.children||[]),it.return=ht,it)}function Nt(ht,it,ft,Et,ie){return it===null||it.tag!==7?(it=ml(ft,ht.mode,Et,ie),it.return=ht,it):(it=k(it,ft),it.return=ht,it)}function _t(ht,it,ft){if(typeof it=="string"&&it!==""||typeof it=="number"||typeof it=="bigint")return it=zw(""+it,ht.mode,ft),it.return=ht,it;if(typeof it=="object"&&it!==null){switch(it.$$typeof){case m:return ft=Fv(it.type,it.key,it.props,null,ht.mode,ft),Hp(ft,it),ft.return=ht,ft;case v:return it=Pw(it,ht.mode,ft),it.return=ht,it;case $:return it=xl(it),_t(ht,it,ft)}if(q(it)||L(it))return it=ml(it,ht.mode,ft,null),it.return=ht,it;if(typeof it.then=="function")return _t(ht,Uv(it),ft);if(it.$$typeof===N)return _t(ht,Bv(ht,it),ft);Wv(ht,it)}return null}function vt(ht,it,ft,Et){var ie=it!==null?it.key:null;if(typeof ft=="string"&&ft!==""||typeof ft=="number"||typeof ft=="bigint")return ie!==null?null:W(ht,it,""+ft,Et);if(typeof ft=="object"&&ft!==null){switch(ft.$$typeof){case m:return ft.key===ie?nt(ht,it,ft,Et):null;case v:return ft.key===ie?mt(ht,it,ft,Et):null;case $:return ft=xl(ft),vt(ht,it,ft,Et)}if(q(ft)||L(ft))return ie!==null?null:Nt(ht,it,ft,Et,null);if(typeof ft.then=="function")return vt(ht,it,Uv(ft),Et);if(ft.$$typeof===N)return vt(ht,it,Bv(ht,ft),Et);Wv(ht,ft)}return null}function wt(ht,it,ft,Et,ie){if(typeof Et=="string"&&Et!==""||typeof Et=="number"||typeof Et=="bigint")return ht=ht.get(ft)||null,W(it,ht,""+Et,ie);if(typeof Et=="object"&&Et!==null){switch(Et.$$typeof){case m:return ht=ht.get(Et.key===null?ft:Et.key)||null,nt(it,ht,Et,ie);case v:return ht=ht.get(Et.key===null?ft:Et.key)||null,mt(it,ht,Et,ie);case $:return Et=xl(Et),wt(ht,it,ft,Et,ie)}if(q(Et)||L(Et))return ht=ht.get(ft)||null,Nt(it,ht,Et,ie,null);if(typeof Et.then=="function")return wt(ht,it,ft,Uv(Et),ie);if(Et.$$typeof===N)return wt(ht,it,ft,Bv(it,Et),ie);Wv(it,Et)}return null}function qt(ht,it,ft,Et){for(var ie=null,qe=null,te=it,Te=it=0,Pe=null;te!==null&&Te<ft.length;Te++){te.index>Te?(Pe=te,te=null):Pe=te.sibling;var Ke=vt(ht,te,ft[Te],Et);if(Ke===null){te===null&&(te=Pe);break}c&&te&&Ke.alternate===null&&p(ht,te),it=E(Ke,it,Te),qe===null?ie=Ke:qe.sibling=Ke,qe=Ke,te=Pe}if(Te===ft.length)return g(ht,te),Ve&&si(ht,Te),ie;if(te===null){for(;Te<ft.length;Te++)te=_t(ht,ft[Te],Et),te!==null&&(it=E(te,it,Te),qe===null?ie=te:qe.sibling=te,qe=te);return Ve&&si(ht,Te),ie}for(te=x(te);Te<ft.length;Te++)Pe=wt(te,ht,Te,ft[Te],Et),Pe!==null&&(c&&Pe.alternate!==null&&te.delete(Pe.key===null?Te:Pe.key),it=E(Pe,it,Te),qe===null?ie=Pe:qe.sibling=Pe,qe=Pe);return c&&te.forEach(function(yu){return p(ht,yu)}),Ve&&si(ht,Te),ie}function le(ht,it,ft,Et){if(ft==null)throw Error(r(151));for(var ie=null,qe=null,te=it,Te=it=0,Pe=null,Ke=ft.next();te!==null&&!Ke.done;Te++,Ke=ft.next()){te.index>Te?(Pe=te,te=null):Pe=te.sibling;var yu=vt(ht,te,Ke.value,Et);if(yu===null){te===null&&(te=Pe);break}c&&te&&yu.alternate===null&&p(ht,te),it=E(yu,it,Te),qe===null?ie=yu:qe.sibling=yu,qe=yu,te=Pe}if(Ke.done)return g(ht,te),Ve&&si(ht,Te),ie;if(te===null){for(;!Ke.done;Te++,Ke=ft.next())Ke=_t(ht,Ke.value,Et),Ke!==null&&(it=E(Ke,it,Te),qe===null?ie=Ke:qe.sibling=Ke,qe=Ke);return Ve&&si(ht,Te),ie}for(te=x(te);!Ke.done;Te++,Ke=ft.next())Ke=wt(te,ht,Te,Ke.value,Et),Ke!==null&&(c&&Ke.alternate!==null&&te.delete(Ke.key===null?Te:Ke.key),it=E(Ke,it,Te),qe===null?ie=Ke:qe.sibling=Ke,qe=Ke);return c&&te.forEach(function(Tj){return p(ht,Tj)}),Ve&&si(ht,Te),ie}function ln(ht,it,ft,Et){if(typeof ft=="object"&&ft!==null&&ft.type===y&&ft.key===null&&(ft=ft.props.children),typeof ft=="object"&&ft!==null){switch(ft.$$typeof){case m:t:{for(var ie=ft.key;it!==null;){if(it.key===ie){if(ie=ft.type,ie===y){if(it.tag===7){g(ht,it.sibling),Et=k(it,ft.props.children),Et.return=ht,ht=Et;break t}}else if(it.elementType===ie||typeof ie=="object"&&ie!==null&&ie.$$typeof===$&&xl(ie)===it.type){g(ht,it.sibling),Et=k(it,ft.props),Hp(Et,ft),Et.return=ht,ht=Et;break t}g(ht,it);break}else p(ht,it);it=it.sibling}ft.type===y?(Et=ml(ft.props.children,ht.mode,Et,ft.key),Et.return=ht,ht=Et):(Et=Fv(ft.type,ft.key,ft.props,null,ht.mode,Et),Hp(Et,ft),Et.return=ht,ht=Et)}return F(ht);case v:t:{for(ie=ft.key;it!==null;){if(it.key===ie)if(it.tag===4&&it.stateNode.containerInfo===ft.containerInfo&&it.stateNode.implementation===ft.implementation){g(ht,it.sibling),Et=k(it,ft.children||[]),Et.return=ht,ht=Et;break t}else{g(ht,it);break}else p(ht,it);it=it.sibling}Et=Pw(ft,ht.mode,Et),Et.return=ht,ht=Et}return F(ht);case $:return ft=xl(ft),ln(ht,it,ft,Et)}if(q(ft))return qt(ht,it,ft,Et);if(L(ft)){if(ie=L(ft),typeof ie!="function")throw Error(r(150));return ft=ie.call(ft),le(ht,it,ft,Et)}if(typeof ft.then=="function")return ln(ht,it,Uv(ft),Et);if(ft.$$typeof===N)return ln(ht,it,Bv(ht,ft),Et);Wv(ht,ft)}return typeof ft=="string"&&ft!==""||typeof ft=="number"||typeof ft=="bigint"?(ft=""+ft,it!==null&&it.tag===6?(g(ht,it.sibling),Et=k(it,ft),Et.return=ht,ht=Et):(g(ht,it),Et=zw(ft,ht.mode,Et),Et.return=ht,ht=Et),F(ht)):g(ht,it)}return function(ht,it,ft,Et){try{Gp=0;var ie=ln(ht,it,ft,Et);return nh=null,ie}catch(te){if(te===eh||te===Pv)throw te;var qe=Za(29,te,null,ht.mode);return qe.lanes=Et,qe.return=ht,qe}}}var Sl=FR(!0),MR=FR(!1),eu=!1;function Zw(c){c.updateQueue={baseState:c.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,lanes:0,hiddenCallbacks:null},callbacks:null}}function Jw(c,p){c=c.updateQueue,p.updateQueue===c&&(p.updateQueue={baseState:c.baseState,firstBaseUpdate:c.firstBaseUpdate,lastBaseUpdate:c.lastBaseUpdate,shared:c.shared,callbacks:null})}function nu(c){return{lane:c,tag:0,payload:null,callback:null,next:null}}function ru(c,p,g){var x=c.updateQueue;if(x===null)return null;if(x=x.shared,(Ye&2)!==0){var k=x.pending;return k===null?p.next=p:(p.next=k.next,k.next=p),x.pending=p,p=Ov(c),bR(c,null,g),p}return $v(c,x,p,g),Ov(c)}function jp(c,p,g){if(p=p.updateQueue,p!==null&&(p=p.shared,(g&4194048)!==0)){var x=p.lanes;x&=c.pendingLanes,g|=x,p.lanes=g,E_(c,g)}}function t2(c,p){var g=c.updateQueue,x=c.alternate;if(x!==null&&(x=x.updateQueue,g===x)){var k=null,E=null;if(g=g.firstBaseUpdate,g!==null){do{var F={lane:g.lane,tag:g.tag,payload:g.payload,callback:null,next:null};E===null?k=E=F:E=E.next=F,g=g.next}while(g!==null);E===null?k=E=p:E=E.next=p}else k=E=p;g={baseState:x.baseState,firstBaseUpdate:k,lastBaseUpdate:E,shared:x.shared,callbacks:x.callbacks},c.updateQueue=g;return}c=g.lastBaseUpdate,c===null?g.firstBaseUpdate=p:c.next=p,g.lastBaseUpdate=p}var e2=!1;function qp(){if(e2){var c=th;if(c!==null)throw c}}function Kp(c,p,g,x){e2=!1;var k=c.updateQueue;eu=!1;var E=k.firstBaseUpdate,F=k.lastBaseUpdate,W=k.shared.pending;if(W!==null){k.shared.pending=null;var nt=W,mt=nt.next;nt.next=null,F===null?E=mt:F.next=mt,F=nt;var Nt=c.alternate;Nt!==null&&(Nt=Nt.updateQueue,W=Nt.lastBaseUpdate,W!==F&&(W===null?Nt.firstBaseUpdate=mt:W.next=mt,Nt.lastBaseUpdate=nt))}if(E!==null){var _t=k.baseState;F=0,Nt=mt=nt=null,W=E;do{var vt=W.lane&-536870913,wt=vt!==W.lane;if(wt?(ze&vt)===vt:(x&vt)===vt){vt!==0&&vt===Jc&&(e2=!0),Nt!==null&&(Nt=Nt.next={lane:0,tag:W.tag,payload:W.payload,callback:null,next:null});t:{var qt=c,le=W;vt=p;var ln=g;switch(le.tag){case 1:if(qt=le.payload,typeof qt=="function"){_t=qt.call(ln,_t,vt);break t}_t=qt;break t;case 3:qt.flags=qt.flags&-65537|128;case 0:if(qt=le.payload,vt=typeof qt=="function"?qt.call(ln,_t,vt):qt,vt==null)break t;_t=d({},_t,vt);break t;case 2:eu=!0}}vt=W.callback,vt!==null&&(c.flags|=64,wt&&(c.flags|=8192),wt=k.callbacks,wt===null?k.callbacks=[vt]:wt.push(vt))}else wt={lane:vt,tag:W.tag,payload:W.payload,callback:W.callback,next:null},Nt===null?(mt=Nt=wt,nt=_t):Nt=Nt.next=wt,F|=vt;if(W=W.next,W===null){if(W=k.shared.pending,W===null)break;wt=W,W=wt.next,wt.next=null,k.lastBaseUpdate=wt,k.shared.pending=null}}while(!0);Nt===null&&(nt=_t),k.baseState=nt,k.firstBaseUpdate=mt,k.lastBaseUpdate=Nt,E===null&&(k.shared.lanes=0),uu|=F,c.lanes=F,c.memoizedState=_t}}function LR(c,p){if(typeof c!="function")throw Error(r(191,c));c.call(p)}function BR(c,p){var g=c.callbacks;if(g!==null)for(c.callbacks=null,c=0;c<g.length;c++)LR(g[c],p)}var rh=M(null),Gv=M(0);function zR(c,p){c=gi,Q(Gv,c),Q(rh,p),gi=c|p.baseLanes}function n2(){Q(Gv,gi),Q(rh,rh.current)}function r2(){gi=Gv.current,X(rh),X(Gv)}var Ja=M(null),_s=null;function au(c){var p=c.alternate;Q(jn,jn.current&1),Q(Ja,c),_s===null&&(p===null||rh.current!==null||p.memoizedState!==null)&&(_s=c)}function a2(c){Q(jn,jn.current),Q(Ja,c),_s===null&&(_s=c)}function PR(c){c.tag===22?(Q(jn,jn.current),Q(Ja,c),_s===null&&(_s=c)):su()}function su(){Q(jn,jn.current),Q(Ja,Ja.current)}function ts(c){X(Ja),_s===c&&(_s=null),X(jn)}var jn=M(0);function Hv(c){for(var p=c;p!==null;){if(p.tag===13){var g=p.memoizedState;if(g!==null&&(g=g.dehydrated,g===null||cS(g)||hS(g)))return p}else if(p.tag===19&&(p.memoizedProps.revealOrder==="forwards"||p.memoizedProps.revealOrder==="backwards"||p.memoizedProps.revealOrder==="unstable_legacy-backwards"||p.memoizedProps.revealOrder==="together")){if((p.flags&128)!==0)return p}else if(p.child!==null){p.child.return=p,p=p.child;continue}if(p===c)break;for(;p.sibling===null;){if(p.return===null||p.return===c)return null;p=p.return}p.sibling.return=p.return,p=p.sibling}return null}var ui=0,Ne=null,on=null,tr=null,jv=!1,ah=!1,Cl=!1,qv=0,Xp=0,sh=null,g6=0;function Ln(){throw Error(r(321))}function s2(c,p){if(p===null)return!1;for(var g=0;g<p.length&&g<c.length;g++)if(!Qa(c[g],p[g]))return!1;return!0}function o2(c,p,g,x,k,E){return ui=E,Ne=p,p.memoizedState=null,p.updateQueue=null,p.lanes=0,B.H=c===null||c.memoizedState===null?CA:w2,Cl=!1,E=g(x,k),Cl=!1,ah&&(E=UR(p,g,x,k)),VR(c),E}function VR(c){B.H=Zp;var p=on!==null&&on.next!==null;if(ui=0,tr=on=Ne=null,jv=!1,Xp=0,sh=null,p)throw Error(r(300));c===null||er||(c=c.dependencies,c!==null&&Lv(c)&&(er=!0))}function UR(c,p,g,x){Ne=c;var k=0;do{if(ah&&(sh=null),Xp=0,ah=!1,25<=k)throw Error(r(301));if(k+=1,tr=on=null,c.updateQueue!=null){var E=c.updateQueue;E.lastEffect=null,E.events=null,E.stores=null,E.memoCache!=null&&(E.memoCache.index=0)}B.H=NA,E=p(g,x)}while(ah);return E}function v6(){var c=B.H,p=c.useState()[0];return p=typeof p.then=="function"?Yp(p):p,c=c.useState()[0],(on!==null?on.memoizedState:null)!==c&&(Ne.flags|=1024),p}function i2(){var c=qv!==0;return qv=0,c}function u2(c,p,g){p.updateQueue=c.updateQueue,p.flags&=-2053,c.lanes&=~g}function l2(c){if(jv){for(c=c.memoizedState;c!==null;){var p=c.queue;p!==null&&(p.pending=null),c=c.next}jv=!1}ui=0,tr=on=Ne=null,ah=!1,Xp=qv=0,sh=null}function ya(){var c={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return tr===null?Ne.memoizedState=tr=c:tr=tr.next=c,tr}function qn(){if(on===null){var c=Ne.alternate;c=c!==null?c.memoizedState:null}else c=on.next;var p=tr===null?Ne.memoizedState:tr.next;if(p!==null)tr=p,on=c;else{if(c===null)throw Ne.alternate===null?Error(r(467)):Error(r(310));on=c,c={memoizedState:on.memoizedState,baseState:on.baseState,baseQueue:on.baseQueue,queue:on.queue,next:null},tr===null?Ne.memoizedState=tr=c:tr=tr.next=c}return tr}function Kv(){return{lastEffect:null,events:null,stores:null,memoCache:null}}function Yp(c){var p=Xp;return Xp+=1,sh===null&&(sh=[]),c=DR(sh,c,p),p=Ne,(tr===null?p.memoizedState:tr.next)===null&&(p=p.alternate,B.H=p===null||p.memoizedState===null?CA:w2),c}function Xv(c){if(c!==null&&typeof c=="object"){if(typeof c.then=="function")return Yp(c);if(c.$$typeof===N)return qr(c)}throw Error(r(438,String(c)))}function c2(c){var p=null,g=Ne.updateQueue;if(g!==null&&(p=g.memoCache),p==null){var x=Ne.alternate;x!==null&&(x=x.updateQueue,x!==null&&(x=x.memoCache,x!=null&&(p={data:x.data.map(function(k){return k.slice()}),index:0})))}if(p==null&&(p={data:[],index:0}),g===null&&(g=Kv(),Ne.updateQueue=g),g.memoCache=p,g=p.data[p.index],g===void 0)for(g=p.data[p.index]=Array(c),x=0;x<c;x++)g[x]=D;return p.index++,g}function li(c,p){return typeof p=="function"?p(c):p}function Yv(c){var p=qn();return h2(p,on,c)}function h2(c,p,g){var x=c.queue;if(x===null)throw Error(r(311));x.lastRenderedReducer=g;var k=c.baseQueue,E=x.pending;if(E!==null){if(k!==null){var F=k.next;k.next=E.next,E.next=F}p.baseQueue=k=E,x.pending=null}if(E=c.baseState,k===null)c.memoizedState=E;else{p=k.next;var W=F=null,nt=null,mt=p,Nt=!1;do{var _t=mt.lane&-536870913;if(_t!==mt.lane?(ze&_t)===_t:(ui&_t)===_t){var vt=mt.revertLane;if(vt===0)nt!==null&&(nt=nt.next={lane:0,revertLane:0,gesture:null,action:mt.action,hasEagerState:mt.hasEagerState,eagerState:mt.eagerState,next:null}),_t===Jc&&(Nt=!0);else if((ui&vt)===vt){mt=mt.next,vt===Jc&&(Nt=!0);continue}else _t={lane:0,revertLane:mt.revertLane,gesture:null,action:mt.action,hasEagerState:mt.hasEagerState,eagerState:mt.eagerState,next:null},nt===null?(W=nt=_t,F=E):nt=nt.next=_t,Ne.lanes|=vt,uu|=vt;_t=mt.action,Cl&&g(E,_t),E=mt.hasEagerState?mt.eagerState:g(E,_t)}else vt={lane:_t,revertLane:mt.revertLane,gesture:mt.gesture,action:mt.action,hasEagerState:mt.hasEagerState,eagerState:mt.eagerState,next:null},nt===null?(W=nt=vt,F=E):nt=nt.next=vt,Ne.lanes|=_t,uu|=_t;mt=mt.next}while(mt!==null&&mt!==p);if(nt===null?F=E:nt.next=W,!Qa(E,c.memoizedState)&&(er=!0,Nt&&(g=th,g!==null)))throw g;c.memoizedState=E,c.baseState=F,c.baseQueue=nt,x.lastRenderedState=E}return k===null&&(x.lanes=0),[c.memoizedState,x.dispatch]}function d2(c){var p=qn(),g=p.queue;if(g===null)throw Error(r(311));g.lastRenderedReducer=c;var x=g.dispatch,k=g.pending,E=p.memoizedState;if(k!==null){g.pending=null;var F=k=k.next;do E=c(E,F.action),F=F.next;while(F!==k);Qa(E,p.memoizedState)||(er=!0),p.memoizedState=E,p.baseQueue===null&&(p.baseState=E),g.lastRenderedState=E}return[E,x]}function WR(c,p,g){var x=Ne,k=qn(),E=Ve;if(E){if(g===void 0)throw Error(r(407));g=g()}else g=p();var F=!Qa((on||k).memoizedState,g);if(F&&(k.memoizedState=g,er=!0),k=k.queue,m2(jR.bind(null,x,k,c),[c]),k.getSnapshot!==p||F||tr!==null&&tr.memoizedState.tag&1){if(x.flags|=2048,oh(9,{destroy:void 0},HR.bind(null,x,k,g,p),null),dn===null)throw Error(r(349));E||(ui&127)!==0||GR(x,p,g)}return g}function GR(c,p,g){c.flags|=16384,c={getSnapshot:p,value:g},p=Ne.updateQueue,p===null?(p=Kv(),Ne.updateQueue=p,p.stores=[c]):(g=p.stores,g===null?p.stores=[c]:g.push(c))}function HR(c,p,g,x){p.value=g,p.getSnapshot=x,qR(p)&&KR(c)}function jR(c,p,g){return g(function(){qR(p)&&KR(c)})}function qR(c){var p=c.getSnapshot;c=c.value;try{var g=p();return!Qa(c,g)}catch{return!0}}function KR(c){var p=fl(c,2);p!==null&&Oa(p,c,2)}function p2(c){var p=ya();if(typeof c=="function"){var g=c;if(c=g(),Cl){dr(!0);try{g()}finally{dr(!1)}}}return p.memoizedState=p.baseState=c,p.queue={pending:null,lanes:0,dispatch:null,lastRenderedReducer:li,lastRenderedState:c},p}function XR(c,p,g,x){return c.baseState=g,h2(c,on,typeof x=="function"?x:li)}function y6(c,p,g,x,k){if(Jv(c))throw Error(r(485));if(c=p.action,c!==null){var E={payload:k,action:c,next:null,isTransition:!0,status:"pending",value:null,reason:null,listeners:[],then:function(F){E.listeners.push(F)}};B.T!==null?g(!0):E.isTransition=!1,x(E),g=p.pending,g===null?(E.next=p.pending=E,YR(p,E)):(E.next=g.next,p.pending=g.next=E)}}function YR(c,p){var g=p.action,x=p.payload,k=c.state;if(p.isTransition){var E=B.T,F={};B.T=F;try{var W=g(k,x),nt=B.S;nt!==null&&nt(F,W),QR(c,p,W)}catch(mt){f2(c,p,mt)}finally{E!==null&&F.types!==null&&(E.types=F.types),B.T=E}}else try{E=g(k,x),QR(c,p,E)}catch(mt){f2(c,p,mt)}}function QR(c,p,g){g!==null&&typeof g=="object"&&typeof g.then=="function"?g.then(function(x){ZR(c,p,x)},function(x){return f2(c,p,x)}):ZR(c,p,g)}function ZR(c,p,g){p.status="fulfilled",p.value=g,JR(p),c.state=g,p=c.pending,p!==null&&(g=p.next,g===p?c.pending=null:(g=g.next,p.next=g,YR(c,g)))}function f2(c,p,g){var x=c.pending;if(c.pending=null,x!==null){x=x.next;do p.status="rejected",p.reason=g,JR(p),p=p.next;while(p!==x)}c.action=null}function JR(c){c=c.listeners;for(var p=0;p<c.length;p++)(0,c[p])()}function tA(c,p){return p}function eA(c,p){if(Ve){var g=dn.formState;if(g!==null){t:{var x=Ne;if(Ve){if(bn){e:{for(var k=bn,E=Is;k.nodeType!==8;){if(!E){k=null;break e}if(k=Rs(k.nextSibling),k===null){k=null;break e}}E=k.data,k=E==="F!"||E==="F"?k:null}if(k){bn=Rs(k.nextSibling),x=k.data==="F!";break t}}Ji(x)}x=!1}x&&(p=g[0])}}return g=ya(),g.memoizedState=g.baseState=p,x={pending:null,lanes:0,dispatch:null,lastRenderedReducer:tA,lastRenderedState:p},g.queue=x,g=xA.bind(null,Ne,x),x.dispatch=g,x=p2(!1),E=x2.bind(null,Ne,!1,x.queue),x=ya(),k={state:p,dispatch:null,action:c,pending:null},x.queue=k,g=y6.bind(null,Ne,k,E,g),k.dispatch=g,x.memoizedState=c,[p,g,!1]}function nA(c){var p=qn();return rA(p,on,c)}function rA(c,p,g){if(p=h2(c,p,tA)[0],c=Yv(li)[0],typeof p=="object"&&p!==null&&typeof p.then=="function")try{var x=Yp(p)}catch(F){throw F===eh?Pv:F}else x=p;p=qn();var k=p.queue,E=k.dispatch;return g!==p.memoizedState&&(Ne.flags|=2048,oh(9,{destroy:void 0},b6.bind(null,k,g),null)),[x,E,c]}function b6(c,p){c.action=p}function aA(c){var p=qn(),g=on;if(g!==null)return rA(p,g,c);qn(),p=p.memoizedState,g=qn();var x=g.queue.dispatch;return g.memoizedState=c,[p,x,!1]}function oh(c,p,g,x){return c={tag:c,create:g,deps:x,inst:p,next:null},p=Ne.updateQueue,p===null&&(p=Kv(),Ne.updateQueue=p),g=p.lastEffect,g===null?p.lastEffect=c.next=c:(x=g.next,g.next=c,c.next=x,p.lastEffect=c),c}function sA(){return qn().memoizedState}function Qv(c,p,g,x){var k=ya();Ne.flags|=c,k.memoizedState=oh(1|p,{destroy:void 0},g,x===void 0?null:x)}function Zv(c,p,g,x){var k=qn();x=x===void 0?null:x;var E=k.memoizedState.inst;on!==null&&x!==null&&s2(x,on.memoizedState.deps)?k.memoizedState=oh(p,E,g,x):(Ne.flags|=c,k.memoizedState=oh(1|p,E,g,x))}function oA(c,p){Qv(8390656,8,c,p)}function m2(c,p){Zv(2048,8,c,p)}function x6(c){Ne.flags|=4;var p=Ne.updateQueue;if(p===null)p=Kv(),Ne.updateQueue=p,p.events=[c];else{var g=p.events;g===null?p.events=[c]:g.push(c)}}function iA(c){var p=qn().memoizedState;return x6({ref:p,nextImpl:c}),function(){if((Ye&2)!==0)throw Error(r(440));return p.impl.apply(void 0,arguments)}}function uA(c,p){return Zv(4,2,c,p)}function lA(c,p){return Zv(4,4,c,p)}function cA(c,p){if(typeof p=="function"){c=c();var g=p(c);return function(){typeof g=="function"?g():p(null)}}if(p!=null)return c=c(),p.current=c,function(){p.current=null}}function hA(c,p,g){g=g!=null?g.concat([c]):null,Zv(4,4,cA.bind(null,p,c),g)}function g2(){}function dA(c,p){var g=qn();p=p===void 0?null:p;var x=g.memoizedState;return p!==null&&s2(p,x[1])?x[0]:(g.memoizedState=[c,p],c)}function pA(c,p){var g=qn();p=p===void 0?null:p;var x=g.memoizedState;if(p!==null&&s2(p,x[1]))return x[0];if(x=c(),Cl){dr(!0);try{c()}finally{dr(!1)}}return g.memoizedState=[x,p],x}function v2(c,p,g){return g===void 0||(ui&1073741824)!==0&&(ze&261930)===0?c.memoizedState=p:(c.memoizedState=g,c=fD(),Ne.lanes|=c,uu|=c,g)}function fA(c,p,g,x){return Qa(g,p)?g:rh.current!==null?(c=v2(c,g,x),Qa(c,p)||(er=!0),c):(ui&42)===0||(ui&1073741824)!==0&&(ze&261930)===0?(er=!0,c.memoizedState=g):(c=fD(),Ne.lanes|=c,uu|=c,p)}function mA(c,p,g,x,k){var E=j.p;j.p=E!==0&&8>E?E:8;var F=B.T,W={};B.T=W,x2(c,!1,p,g);try{var nt=k(),mt=B.S;if(mt!==null&&mt(W,nt),nt!==null&&typeof nt=="object"&&typeof nt.then=="function"){var Nt=m6(nt,x);Qp(c,p,Nt,rs(c))}else Qp(c,p,x,rs(c))}catch(_t){Qp(c,p,{then:function(){},status:"rejected",reason:_t},rs())}finally{j.p=E,F!==null&&W.types!==null&&(F.types=W.types),B.T=F}}function w6(){}function y2(c,p,g,x){if(c.tag!==5)throw Error(r(476));var k=gA(c).queue;mA(c,k,p,K,g===null?w6:function(){return vA(c),g(x)})}function gA(c){var p=c.memoizedState;if(p!==null)return p;p={memoizedState:K,baseState:K,baseQueue:null,queue:{pending:null,lanes:0,dispatch:null,lastRenderedReducer:li,lastRenderedState:K},next:null};var g={};return p.next={memoizedState:g,baseState:g,baseQueue:null,queue:{pending:null,lanes:0,dispatch:null,lastRenderedReducer:li,lastRenderedState:g},next:null},c.memoizedState=p,c=c.alternate,c!==null&&(c.memoizedState=p),p}function vA(c){var p=gA(c);p.next===null&&(p=c.alternate.memoizedState),Qp(c,p.next.queue,{},rs())}function b2(){return qr(mf)}function yA(){return qn().memoizedState}function bA(){return qn().memoizedState}function S6(c){for(var p=c.return;p!==null;){switch(p.tag){case 24:case 3:var g=rs();c=nu(g);var x=ru(p,c,g);x!==null&&(Oa(x,p,g),jp(x,p,g)),p={cache:Kw()},c.payload=p;return}p=p.return}}function C6(c,p,g){var x=rs();g={lane:x,revertLane:0,gesture:null,action:g,hasEagerState:!1,eagerState:null,next:null},Jv(c)?wA(p,g):(g=Lw(c,p,g,x),g!==null&&(Oa(g,c,x),SA(g,p,x)))}function xA(c,p,g){var x=rs();Qp(c,p,g,x)}function Qp(c,p,g,x){var k={lane:x,revertLane:0,gesture:null,action:g,hasEagerState:!1,eagerState:null,next:null};if(Jv(c))wA(p,k);else{var E=c.alternate;if(c.lanes===0&&(E===null||E.lanes===0)&&(E=p.lastRenderedReducer,E!==null))try{var F=p.lastRenderedState,W=E(F,g);if(k.hasEagerState=!0,k.eagerState=W,Qa(W,F))return $v(c,p,k,0),dn===null&&Dv(),!1}catch{}if(g=Lw(c,p,k,x),g!==null)return Oa(g,c,x),SA(g,p,x),!0}return!1}function x2(c,p,g,x){if(x={lane:2,revertLane:Z2(),gesture:null,action:x,hasEagerState:!1,eagerState:null,next:null},Jv(c)){if(p)throw Error(r(479))}else p=Lw(c,g,x,2),p!==null&&Oa(p,c,2)}function Jv(c){var p=c.alternate;return c===Ne||p!==null&&p===Ne}function wA(c,p){ah=jv=!0;var g=c.pending;g===null?p.next=p:(p.next=g.next,g.next=p),c.pending=p}function SA(c,p,g){if((g&4194048)!==0){var x=p.lanes;x&=c.pendingLanes,g|=x,p.lanes=g,E_(c,g)}}var Zp={readContext:qr,use:Xv,useCallback:Ln,useContext:Ln,useEffect:Ln,useImperativeHandle:Ln,useLayoutEffect:Ln,useInsertionEffect:Ln,useMemo:Ln,useReducer:Ln,useRef:Ln,useState:Ln,useDebugValue:Ln,useDeferredValue:Ln,useTransition:Ln,useSyncExternalStore:Ln,useId:Ln,useHostTransitionStatus:Ln,useFormState:Ln,useActionState:Ln,useOptimistic:Ln,useMemoCache:Ln,useCacheRefresh:Ln};Zp.useEffectEvent=Ln;var CA={readContext:qr,use:Xv,useCallback:function(c,p){return ya().memoizedState=[c,p===void 0?null:p],c},useContext:qr,useEffect:oA,useImperativeHandle:function(c,p,g){g=g!=null?g.concat([c]):null,Qv(4194308,4,cA.bind(null,p,c),g)},useLayoutEffect:function(c,p){return Qv(4194308,4,c,p)},useInsertionEffect:function(c,p){Qv(4,2,c,p)},useMemo:function(c,p){var g=ya();p=p===void 0?null:p;var x=c();if(Cl){dr(!0);try{c()}finally{dr(!1)}}return g.memoizedState=[x,p],x},useReducer:function(c,p,g){var x=ya();if(g!==void 0){var k=g(p);if(Cl){dr(!0);try{g(p)}finally{dr(!1)}}}else k=p;return x.memoizedState=x.baseState=k,c={pending:null,lanes:0,dispatch:null,lastRenderedReducer:c,lastRenderedState:k},x.queue=c,c=c.dispatch=C6.bind(null,Ne,c),[x.memoizedState,c]},useRef:function(c){var p=ya();return c={current:c},p.memoizedState=c},useState:function(c){c=p2(c);var p=c.queue,g=xA.bind(null,Ne,p);return p.dispatch=g,[c.memoizedState,g]},useDebugValue:g2,useDeferredValue:function(c,p){var g=ya();return v2(g,c,p)},useTransition:function(){var c=p2(!1);return c=mA.bind(null,Ne,c.queue,!0,!1),ya().memoizedState=c,[!1,c]},useSyncExternalStore:function(c,p,g){var x=Ne,k=ya();if(Ve){if(g===void 0)throw Error(r(407));g=g()}else{if(g=p(),dn===null)throw Error(r(349));(ze&127)!==0||GR(x,p,g)}k.memoizedState=g;var E={value:g,getSnapshot:p};return k.queue=E,oA(jR.bind(null,x,E,c),[c]),x.flags|=2048,oh(9,{destroy:void 0},HR.bind(null,x,E,g,p),null),g},useId:function(){var c=ya(),p=dn.identifierPrefix;if(Ve){var g=mo,x=fo;g=(x&~(1<<32-Gr(x)-1)).toString(32)+g,p="_"+p+"R_"+g,g=qv++,0<g&&(p+="H"+g.toString(32)),p+="_"}else g=g6++,p="_"+p+"r_"+g.toString(32)+"_";return c.memoizedState=p},useHostTransitionStatus:b2,useFormState:eA,useActionState:eA,useOptimistic:function(c){var p=ya();p.memoizedState=p.baseState=c;var g={pending:null,lanes:0,dispatch:null,lastRenderedReducer:null,lastRenderedState:null};return p.queue=g,p=x2.bind(null,Ne,!0,g),g.dispatch=p,[c,p]},useMemoCache:c2,useCacheRefresh:function(){return ya().memoizedState=S6.bind(null,Ne)},useEffectEvent:function(c){var p=ya(),g={impl:c};return p.memoizedState=g,function(){if((Ye&2)!==0)throw Error(r(440));return g.impl.apply(void 0,arguments)}}},w2={readContext:qr,use:Xv,useCallback:dA,useContext:qr,useEffect:m2,useImperativeHandle:hA,useInsertionEffect:uA,useLayoutEffect:lA,useMemo:pA,useReducer:Yv,useRef:sA,useState:function(){return Yv(li)},useDebugValue:g2,useDeferredValue:function(c,p){var g=qn();return fA(g,on.memoizedState,c,p)},useTransition:function(){var c=Yv(li)[0],p=qn().memoizedState;return[typeof c=="boolean"?c:Yp(c),p]},useSyncExternalStore:WR,useId:yA,useHostTransitionStatus:b2,useFormState:nA,useActionState:nA,useOptimistic:function(c,p){var g=qn();return XR(g,on,c,p)},useMemoCache:c2,useCacheRefresh:bA};w2.useEffectEvent=iA;var NA={readContext:qr,use:Xv,useCallback:dA,useContext:qr,useEffect:m2,useImperativeHandle:hA,useInsertionEffect:uA,useLayoutEffect:lA,useMemo:pA,useReducer:d2,useRef:sA,useState:function(){return d2(li)},useDebugValue:g2,useDeferredValue:function(c,p){var g=qn();return on===null?v2(g,c,p):fA(g,on.memoizedState,c,p)},useTransition:function(){var c=d2(li)[0],p=qn().memoizedState;return[typeof c=="boolean"?c:Yp(c),p]},useSyncExternalStore:WR,useId:yA,useHostTransitionStatus:b2,useFormState:aA,useActionState:aA,useOptimistic:function(c,p){var g=qn();return on!==null?XR(g,on,c,p):(g.baseState=c,[c,g.queue.dispatch])},useMemoCache:c2,useCacheRefresh:bA};NA.useEffectEvent=iA;function S2(c,p,g,x){p=c.memoizedState,g=g(x,p),g=g==null?p:d({},p,g),c.memoizedState=g,c.lanes===0&&(c.updateQueue.baseState=g)}var C2={enqueueSetState:function(c,p,g){c=c._reactInternals;var x=rs(),k=nu(x);k.payload=p,g!=null&&(k.callback=g),p=ru(c,k,x),p!==null&&(Oa(p,c,x),jp(p,c,x))},enqueueReplaceState:function(c,p,g){c=c._reactInternals;var x=rs(),k=nu(x);k.tag=1,k.payload=p,g!=null&&(k.callback=g),p=ru(c,k,x),p!==null&&(Oa(p,c,x),jp(p,c,x))},enqueueForceUpdate:function(c,p){c=c._reactInternals;var g=rs(),x=nu(g);x.tag=2,p!=null&&(x.callback=p),p=ru(c,x,g),p!==null&&(Oa(p,c,g),jp(p,c,g))}};function kA(c,p,g,x,k,E,F){return c=c.stateNode,typeof c.shouldComponentUpdate=="function"?c.shouldComponentUpdate(x,E,F):p.prototype&&p.prototype.isPureReactComponent?!Bp(g,x)||!Bp(k,E):!0}function TA(c,p,g,x){c=p.state,typeof p.componentWillReceiveProps=="function"&&p.componentWillReceiveProps(g,x),typeof p.UNSAFE_componentWillReceiveProps=="function"&&p.UNSAFE_componentWillReceiveProps(g,x),p.state!==c&&C2.enqueueReplaceState(p,p.state,null)}function Nl(c,p){var g=p;if("ref"in p){g={};for(var x in p)x!=="ref"&&(g[x]=p[x])}if(c=c.defaultProps){g===p&&(g=d({},g));for(var k in c)g[k]===void 0&&(g[k]=c[k])}return g}function EA(c){Av(c)}function IA(c){console.error(c)}function _A(c){Av(c)}function ty(c,p){try{var g=c.onUncaughtError;g(p.value,{componentStack:p.stack})}catch(x){setTimeout(function(){throw x})}}function RA(c,p,g){try{var x=c.onCaughtError;x(g.value,{componentStack:g.stack,errorBoundary:p.tag===1?p.stateNode:null})}catch(k){setTimeout(function(){throw k})}}function N2(c,p,g){return g=nu(g),g.tag=3,g.payload={element:null},g.callback=function(){ty(c,p)},g}function AA(c){return c=nu(c),c.tag=3,c}function DA(c,p,g,x){var k=g.type.getDerivedStateFromError;if(typeof k=="function"){var E=x.value;c.payload=function(){return k(E)},c.callback=function(){RA(p,g,x)}}var F=g.stateNode;F!==null&&typeof F.componentDidCatch=="function"&&(c.callback=function(){RA(p,g,x),typeof k!="function"&&(lu===null?lu=new Set([this]):lu.add(this));var W=x.stack;this.componentDidCatch(x.value,{componentStack:W!==null?W:""})})}function N6(c,p,g,x,k){if(g.flags|=32768,x!==null&&typeof x=="object"&&typeof x.then=="function"){if(p=g.alternate,p!==null&&Zc(p,g,k,!0),g=Ja.current,g!==null){switch(g.tag){case 31:case 13:return _s===null?dy():g.alternate===null&&Bn===0&&(Bn=3),g.flags&=-257,g.flags|=65536,g.lanes=k,x===Vv?g.flags|=16384:(p=g.updateQueue,p===null?g.updateQueue=new Set([x]):p.add(x),X2(c,x,k)),!1;case 22:return g.flags|=65536,x===Vv?g.flags|=16384:(p=g.updateQueue,p===null?(p={transitions:null,markerInstances:null,retryQueue:new Set([x])},g.updateQueue=p):(g=p.retryQueue,g===null?p.retryQueue=new Set([x]):g.add(x)),X2(c,x,k)),!1}throw Error(r(435,g.tag))}return X2(c,x,k),dy(),!1}if(Ve)return p=Ja.current,p!==null?((p.flags&65536)===0&&(p.flags|=256),p.flags|=65536,p.lanes=k,x!==Ww&&(c=Error(r(422),{cause:x}),Vp(ks(c,g)))):(x!==Ww&&(p=Error(r(423),{cause:x}),Vp(ks(p,g))),c=c.current.alternate,c.flags|=65536,k&=-k,c.lanes|=k,x=ks(x,g),k=N2(c.stateNode,x,k),t2(c,k),Bn!==4&&(Bn=2)),!1;var E=Error(r(520),{cause:x});if(E=ks(E,g),of===null?of=[E]:of.push(E),Bn!==4&&(Bn=2),p===null)return!0;x=ks(x,g),g=p;do{switch(g.tag){case 3:return g.flags|=65536,c=k&-k,g.lanes|=c,c=N2(g.stateNode,x,c),t2(g,c),!1;case 1:if(p=g.type,E=g.stateNode,(g.flags&128)===0&&(typeof p.getDerivedStateFromError=="function"||E!==null&&typeof E.componentDidCatch=="function"&&(lu===null||!lu.has(E))))return g.flags|=65536,k&=-k,g.lanes|=k,k=AA(k),DA(k,c,g,x),t2(g,k),!1}g=g.return}while(g!==null);return!1}var k2=Error(r(461)),er=!1;function Kr(c,p,g,x){p.child=c===null?MR(p,null,g,x):Sl(p,c.child,g,x)}function $A(c,p,g,x,k){g=g.render;var E=p.ref;if("ref"in x){var F={};for(var W in x)W!=="ref"&&(F[W]=x[W])}else F=x;return yl(p),x=o2(c,p,g,F,E,k),W=i2(),c!==null&&!er?(u2(c,p,k),ci(c,p,k)):(Ve&&W&&Vw(p),p.flags|=1,Kr(c,p,x,k),p.child)}function OA(c,p,g,x,k){if(c===null){var E=g.type;return typeof E=="function"&&!Bw(E)&&E.defaultProps===void 0&&g.compare===null?(p.tag=15,p.type=E,FA(c,p,E,x,k)):(c=Fv(g.type,null,x,p,p.mode,k),c.ref=p.ref,c.return=p,p.child=c)}if(E=c.child,!$2(c,k)){var F=E.memoizedProps;if(g=g.compare,g=g!==null?g:Bp,g(F,x)&&c.ref===p.ref)return ci(c,p,k)}return p.flags|=1,c=ai(E,x),c.ref=p.ref,c.return=p,p.child=c}function FA(c,p,g,x,k){if(c!==null){var E=c.memoizedProps;if(Bp(E,x)&&c.ref===p.ref)if(er=!1,p.pendingProps=x=E,$2(c,k))(c.flags&131072)!==0&&(er=!0);else return p.lanes=c.lanes,ci(c,p,k)}return T2(c,p,g,x,k)}function MA(c,p,g,x){var k=x.children,E=c!==null?c.memoizedState:null;if(c===null&&p.stateNode===null&&(p.stateNode={_visibility:1,_pendingMarkers:null,_retryCache:null,_transitions:null}),x.mode==="hidden"){if((p.flags&128)!==0){if(E=E!==null?E.baseLanes|g:g,c!==null){for(x=p.child=c.child,k=0;x!==null;)k=k|x.lanes|x.childLanes,x=x.sibling;x=k&~E}else x=0,p.child=null;return LA(c,p,E,g,x)}if((g&536870912)!==0)p.memoizedState={baseLanes:0,cachePool:null},c!==null&&zv(p,E!==null?E.cachePool:null),E!==null?zR(p,E):n2(),PR(p);else return x=p.lanes=536870912,LA(c,p,E!==null?E.baseLanes|g:g,g,x)}else E!==null?(zv(p,E.cachePool),zR(p,E),su(),p.memoizedState=null):(c!==null&&zv(p,null),n2(),su());return Kr(c,p,k,g),p.child}function Jp(c,p){return c!==null&&c.tag===22||p.stateNode!==null||(p.stateNode={_visibility:1,_pendingMarkers:null,_retryCache:null,_transitions:null}),p.sibling}function LA(c,p,g,x,k){var E=Yw();return E=E===null?null:{parent:Jn._currentValue,pool:E},p.memoizedState={baseLanes:g,cachePool:E},c!==null&&zv(p,null),n2(),PR(p),c!==null&&Zc(c,p,x,!0),p.childLanes=k,null}function ey(c,p){return p=ry({mode:p.mode,children:p.children},c.mode),p.ref=c.ref,c.child=p,p.return=c,p}function BA(c,p,g){return Sl(p,c.child,null,g),c=ey(p,p.pendingProps),c.flags|=2,ts(p),p.memoizedState=null,c}function k6(c,p,g){var x=p.pendingProps,k=(p.flags&128)!==0;if(p.flags&=-129,c===null){if(Ve){if(x.mode==="hidden")return c=ey(p,x),p.lanes=536870912,Jp(null,c);if(a2(p),(c=bn)?(c=YD(c,Is),c=c!==null&&c.data==="&"?c:null,c!==null&&(p.memoizedState={dehydrated:c,treeContext:Qi!==null?{id:fo,overflow:mo}:null,retryLane:536870912,hydrationErrors:null},g=wR(c),g.return=p,p.child=g,jr=p,bn=null)):c=null,c===null)throw Ji(p);return p.lanes=536870912,null}return ey(p,x)}var E=c.memoizedState;if(E!==null){var F=E.dehydrated;if(a2(p),k)if(p.flags&256)p.flags&=-257,p=BA(c,p,g);else if(p.memoizedState!==null)p.child=c.child,p.flags|=128,p=null;else throw Error(r(558));else if(er||Zc(c,p,g,!1),k=(g&c.childLanes)!==0,er||k){if(x=dn,x!==null&&(F=I_(x,g),F!==0&&F!==E.retryLane))throw E.retryLane=F,fl(c,F),Oa(x,c,F),k2;dy(),p=BA(c,p,g)}else c=E.treeContext,bn=Rs(F.nextSibling),jr=p,Ve=!0,Zi=null,Is=!1,c!==null&&NR(p,c),p=ey(p,x),p.flags|=4096;return p}return c=ai(c.child,{mode:x.mode,children:x.children}),c.ref=p.ref,p.child=c,c.return=p,c}function ny(c,p){var g=p.ref;if(g===null)c!==null&&c.ref!==null&&(p.flags|=4194816);else{if(typeof g!="function"&&typeof g!="object")throw Error(r(284));(c===null||c.ref!==g)&&(p.flags|=4194816)}}function T2(c,p,g,x,k){return yl(p),g=o2(c,p,g,x,void 0,k),x=i2(),c!==null&&!er?(u2(c,p,k),ci(c,p,k)):(Ve&&x&&Vw(p),p.flags|=1,Kr(c,p,g,k),p.child)}function zA(c,p,g,x,k,E){return yl(p),p.updateQueue=null,g=UR(p,x,g,k),VR(c),x=i2(),c!==null&&!er?(u2(c,p,E),ci(c,p,E)):(Ve&&x&&Vw(p),p.flags|=1,Kr(c,p,g,E),p.child)}function PA(c,p,g,x,k){if(yl(p),p.stateNode===null){var E=Kc,F=g.contextType;typeof F=="object"&&F!==null&&(E=qr(F)),E=new g(x,E),p.memoizedState=E.state!==null&&E.state!==void 0?E.state:null,E.updater=C2,p.stateNode=E,E._reactInternals=p,E=p.stateNode,E.props=x,E.state=p.memoizedState,E.refs={},Zw(p),F=g.contextType,E.context=typeof F=="object"&&F!==null?qr(F):Kc,E.state=p.memoizedState,F=g.getDerivedStateFromProps,typeof F=="function"&&(S2(p,g,F,x),E.state=p.memoizedState),typeof g.getDerivedStateFromProps=="function"||typeof E.getSnapshotBeforeUpdate=="function"||typeof E.UNSAFE_componentWillMount!="function"&&typeof E.componentWillMount!="function"||(F=E.state,typeof E.componentWillMount=="function"&&E.componentWillMount(),typeof E.UNSAFE_componentWillMount=="function"&&E.UNSAFE_componentWillMount(),F!==E.state&&C2.enqueueReplaceState(E,E.state,null),Kp(p,x,E,k),qp(),E.state=p.memoizedState),typeof E.componentDidMount=="function"&&(p.flags|=4194308),x=!0}else if(c===null){E=p.stateNode;var W=p.memoizedProps,nt=Nl(g,W);E.props=nt;var mt=E.context,Nt=g.contextType;F=Kc,typeof Nt=="object"&&Nt!==null&&(F=qr(Nt));var _t=g.getDerivedStateFromProps;Nt=typeof _t=="function"||typeof E.getSnapshotBeforeUpdate=="function",W=p.pendingProps!==W,Nt||typeof E.UNSAFE_componentWillReceiveProps!="function"&&typeof E.componentWillReceiveProps!="function"||(W||mt!==F)&&TA(p,E,x,F),eu=!1;var vt=p.memoizedState;E.state=vt,Kp(p,x,E,k),qp(),mt=p.memoizedState,W||vt!==mt||eu?(typeof _t=="function"&&(S2(p,g,_t,x),mt=p.memoizedState),(nt=eu||kA(p,g,nt,x,vt,mt,F))?(Nt||typeof E.UNSAFE_componentWillMount!="function"&&typeof E.componentWillMount!="function"||(typeof E.componentWillMount=="function"&&E.componentWillMount(),typeof E.UNSAFE_componentWillMount=="function"&&E.UNSAFE_componentWillMount()),typeof E.componentDidMount=="function"&&(p.flags|=4194308)):(typeof E.componentDidMount=="function"&&(p.flags|=4194308),p.memoizedProps=x,p.memoizedState=mt),E.props=x,E.state=mt,E.context=F,x=nt):(typeof E.componentDidMount=="function"&&(p.flags|=4194308),x=!1)}else{E=p.stateNode,Jw(c,p),F=p.memoizedProps,Nt=Nl(g,F),E.props=Nt,_t=p.pendingProps,vt=E.context,mt=g.contextType,nt=Kc,typeof mt=="object"&&mt!==null&&(nt=qr(mt)),W=g.getDerivedStateFromProps,(mt=typeof W=="function"||typeof E.getSnapshotBeforeUpdate=="function")||typeof E.UNSAFE_componentWillReceiveProps!="function"&&typeof E.componentWillReceiveProps!="function"||(F!==_t||vt!==nt)&&TA(p,E,x,nt),eu=!1,vt=p.memoizedState,E.state=vt,Kp(p,x,E,k),qp();var wt=p.memoizedState;F!==_t||vt!==wt||eu||c!==null&&c.dependencies!==null&&Lv(c.dependencies)?(typeof W=="function"&&(S2(p,g,W,x),wt=p.memoizedState),(Nt=eu||kA(p,g,Nt,x,vt,wt,nt)||c!==null&&c.dependencies!==null&&Lv(c.dependencies))?(mt||typeof E.UNSAFE_componentWillUpdate!="function"&&typeof E.componentWillUpdate!="function"||(typeof E.componentWillUpdate=="function"&&E.componentWillUpdate(x,wt,nt),typeof E.UNSAFE_componentWillUpdate=="function"&&E.UNSAFE_componentWillUpdate(x,wt,nt)),typeof E.componentDidUpdate=="function"&&(p.flags|=4),typeof E.getSnapshotBeforeUpdate=="function"&&(p.flags|=1024)):(typeof E.componentDidUpdate!="function"||F===c.memoizedProps&&vt===c.memoizedState||(p.flags|=4),typeof E.getSnapshotBeforeUpdate!="function"||F===c.memoizedProps&&vt===c.memoizedState||(p.flags|=1024),p.memoizedProps=x,p.memoizedState=wt),E.props=x,E.state=wt,E.context=nt,x=Nt):(typeof E.componentDidUpdate!="function"||F===c.memoizedProps&&vt===c.memoizedState||(p.flags|=4),typeof E.getSnapshotBeforeUpdate!="function"||F===c.memoizedProps&&vt===c.memoizedState||(p.flags|=1024),x=!1)}return E=x,ny(c,p),x=(p.flags&128)!==0,E||x?(E=p.stateNode,g=x&&typeof g.getDerivedStateFromError!="function"?null:E.render(),p.flags|=1,c!==null&&x?(p.child=Sl(p,c.child,null,k),p.child=Sl(p,null,g,k)):Kr(c,p,g,k),p.memoizedState=E.state,c=p.child):c=ci(c,p,k),c}function VA(c,p,g,x){return gl(),p.flags|=256,Kr(c,p,g,x),p.child}var E2={dehydrated:null,treeContext:null,retryLane:0,hydrationErrors:null};function I2(c){return{baseLanes:c,cachePool:RR()}}function _2(c,p,g){return c=c!==null?c.childLanes&~g:0,p&&(c|=ns),c}function UA(c,p,g){var x=p.pendingProps,k=!1,E=(p.flags&128)!==0,F;if((F=E)||(F=c!==null&&c.memoizedState===null?!1:(jn.current&2)!==0),F&&(k=!0,p.flags&=-129),F=(p.flags&32)!==0,p.flags&=-33,c===null){if(Ve){if(k?au(p):su(),(c=bn)?(c=YD(c,Is),c=c!==null&&c.data!=="&"?c:null,c!==null&&(p.memoizedState={dehydrated:c,treeContext:Qi!==null?{id:fo,overflow:mo}:null,retryLane:536870912,hydrationErrors:null},g=wR(c),g.return=p,p.child=g,jr=p,bn=null)):c=null,c===null)throw Ji(p);return hS(c)?p.lanes=32:p.lanes=536870912,null}var W=x.children;return x=x.fallback,k?(su(),k=p.mode,W=ry({mode:"hidden",children:W},k),x=ml(x,k,g,null),W.return=p,x.return=p,W.sibling=x,p.child=W,x=p.child,x.memoizedState=I2(g),x.childLanes=_2(c,F,g),p.memoizedState=E2,Jp(null,x)):(au(p),R2(p,W))}var nt=c.memoizedState;if(nt!==null&&(W=nt.dehydrated,W!==null)){if(E)p.flags&256?(au(p),p.flags&=-257,p=A2(c,p,g)):p.memoizedState!==null?(su(),p.child=c.child,p.flags|=128,p=null):(su(),W=x.fallback,k=p.mode,x=ry({mode:"visible",children:x.children},k),W=ml(W,k,g,null),W.flags|=2,x.return=p,W.return=p,x.sibling=W,p.child=x,Sl(p,c.child,null,g),x=p.child,x.memoizedState=I2(g),x.childLanes=_2(c,F,g),p.memoizedState=E2,p=Jp(null,x));else if(au(p),hS(W)){if(F=W.nextSibling&&W.nextSibling.dataset,F)var mt=F.dgst;F=mt,x=Error(r(419)),x.stack="",x.digest=F,Vp({value:x,source:null,stack:null}),p=A2(c,p,g)}else if(er||Zc(c,p,g,!1),F=(g&c.childLanes)!==0,er||F){if(F=dn,F!==null&&(x=I_(F,g),x!==0&&x!==nt.retryLane))throw nt.retryLane=x,fl(c,x),Oa(F,c,x),k2;cS(W)||dy(),p=A2(c,p,g)}else cS(W)?(p.flags|=192,p.child=c.child,p=null):(c=nt.treeContext,bn=Rs(W.nextSibling),jr=p,Ve=!0,Zi=null,Is=!1,c!==null&&NR(p,c),p=R2(p,x.children),p.flags|=4096);return p}return k?(su(),W=x.fallback,k=p.mode,nt=c.child,mt=nt.sibling,x=ai(nt,{mode:"hidden",children:x.children}),x.subtreeFlags=nt.subtreeFlags&65011712,mt!==null?W=ai(mt,W):(W=ml(W,k,g,null),W.flags|=2),W.return=p,x.return=p,x.sibling=W,p.child=x,Jp(null,x),x=p.child,W=c.child.memoizedState,W===null?W=I2(g):(k=W.cachePool,k!==null?(nt=Jn._currentValue,k=k.parent!==nt?{parent:nt,pool:nt}:k):k=RR(),W={baseLanes:W.baseLanes|g,cachePool:k}),x.memoizedState=W,x.childLanes=_2(c,F,g),p.memoizedState=E2,Jp(c.child,x)):(au(p),g=c.child,c=g.sibling,g=ai(g,{mode:"visible",children:x.children}),g.return=p,g.sibling=null,c!==null&&(F=p.deletions,F===null?(p.deletions=[c],p.flags|=16):F.push(c)),p.child=g,p.memoizedState=null,g)}function R2(c,p){return p=ry({mode:"visible",children:p},c.mode),p.return=c,c.child=p}function ry(c,p){return c=Za(22,c,null,p),c.lanes=0,c}function A2(c,p,g){return Sl(p,c.child,null,g),c=R2(p,p.pendingProps.children),c.flags|=2,p.memoizedState=null,c}function WA(c,p,g){c.lanes|=p;var x=c.alternate;x!==null&&(x.lanes|=p),jw(c.return,p,g)}function D2(c,p,g,x,k,E){var F=c.memoizedState;F===null?c.memoizedState={isBackwards:p,rendering:null,renderingStartTime:0,last:x,tail:g,tailMode:k,treeForkCount:E}:(F.isBackwards=p,F.rendering=null,F.renderingStartTime=0,F.last=x,F.tail=g,F.tailMode=k,F.treeForkCount=E)}function GA(c,p,g){var x=p.pendingProps,k=x.revealOrder,E=x.tail;x=x.children;var F=jn.current,W=(F&2)!==0;if(W?(F=F&1|2,p.flags|=128):F&=1,Q(jn,F),Kr(c,p,x,g),x=Ve?Pp:0,!W&&c!==null&&(c.flags&128)!==0)t:for(c=p.child;c!==null;){if(c.tag===13)c.memoizedState!==null&&WA(c,g,p);else if(c.tag===19)WA(c,g,p);else if(c.child!==null){c.child.return=c,c=c.child;continue}if(c===p)break t;for(;c.sibling===null;){if(c.return===null||c.return===p)break t;c=c.return}c.sibling.return=c.return,c=c.sibling}switch(k){case"forwards":for(g=p.child,k=null;g!==null;)c=g.alternate,c!==null&&Hv(c)===null&&(k=g),g=g.sibling;g=k,g===null?(k=p.child,p.child=null):(k=g.sibling,g.sibling=null),D2(p,!1,k,g,E,x);break;case"backwards":case"unstable_legacy-backwards":for(g=null,k=p.child,p.child=null;k!==null;){if(c=k.alternate,c!==null&&Hv(c)===null){p.child=k;break}c=k.sibling,k.sibling=g,g=k,k=c}D2(p,!0,g,null,E,x);break;case"together":D2(p,!1,null,null,void 0,x);break;default:p.memoizedState=null}return p.child}function ci(c,p,g){if(c!==null&&(p.dependencies=c.dependencies),uu|=p.lanes,(g&p.childLanes)===0)if(c!==null){if(Zc(c,p,g,!1),(g&p.childLanes)===0)return null}else return null;if(c!==null&&p.child!==c.child)throw Error(r(153));if(p.child!==null){for(c=p.child,g=ai(c,c.pendingProps),p.child=g,g.return=p;c.sibling!==null;)c=c.sibling,g=g.sibling=ai(c,c.pendingProps),g.return=p;g.sibling=null}return p.child}function $2(c,p){return(c.lanes&p)!==0?!0:(c=c.dependencies,!!(c!==null&&Lv(c)))}function T6(c,p,g){switch(p.tag){case 3:Tt(p,p.stateNode.containerInfo),tu(p,Jn,c.memoizedState.cache),gl();break;case 27:case 5:Rt(p);break;case 4:Tt(p,p.stateNode.containerInfo);break;case 10:tu(p,p.type,p.memoizedProps.value);break;case 31:if(p.memoizedState!==null)return p.flags|=128,a2(p),null;break;case 13:var x=p.memoizedState;if(x!==null)return x.dehydrated!==null?(au(p),p.flags|=128,null):(g&p.child.childLanes)!==0?UA(c,p,g):(au(p),c=ci(c,p,g),c!==null?c.sibling:null);au(p);break;case 19:var k=(c.flags&128)!==0;if(x=(g&p.childLanes)!==0,x||(Zc(c,p,g,!1),x=(g&p.childLanes)!==0),k){if(x)return GA(c,p,g);p.flags|=128}if(k=p.memoizedState,k!==null&&(k.rendering=null,k.tail=null,k.lastEffect=null),Q(jn,jn.current),x)break;return null;case 22:return p.lanes=0,MA(c,p,g,p.pendingProps);case 24:tu(p,Jn,c.memoizedState.cache)}return ci(c,p,g)}function HA(c,p,g){if(c!==null)if(c.memoizedProps!==p.pendingProps)er=!0;else{if(!$2(c,g)&&(p.flags&128)===0)return er=!1,T6(c,p,g);er=(c.flags&131072)!==0}else er=!1,Ve&&(p.flags&1048576)!==0&&CR(p,Pp,p.index);switch(p.lanes=0,p.tag){case 16:t:{var x=p.pendingProps;if(c=xl(p.elementType),p.type=c,typeof c=="function")Bw(c)?(x=Nl(c,x),p.tag=1,p=PA(null,p,c,x,g)):(p.tag=0,p=T2(null,p,c,x,g));else{if(c!=null){var k=c.$$typeof;if(k===C){p.tag=11,p=$A(null,p,c,x,g);break t}else if(k===_){p.tag=14,p=OA(null,p,c,x,g);break t}}throw p=G(c)||c,Error(r(306,p,""))}}return p;case 0:return T2(c,p,p.type,p.pendingProps,g);case 1:return x=p.type,k=Nl(x,p.pendingProps),PA(c,p,x,k,g);case 3:t:{if(Tt(p,p.stateNode.containerInfo),c===null)throw Error(r(387));x=p.pendingProps;var E=p.memoizedState;k=E.element,Jw(c,p),Kp(p,x,null,g);var F=p.memoizedState;if(x=F.cache,tu(p,Jn,x),x!==E.cache&&qw(p,[Jn],g,!0),qp(),x=F.element,E.isDehydrated)if(E={element:x,isDehydrated:!1,cache:F.cache},p.updateQueue.baseState=E,p.memoizedState=E,p.flags&256){p=VA(c,p,x,g);break t}else if(x!==k){k=ks(Error(r(424)),p),Vp(k),p=VA(c,p,x,g);break t}else for(c=p.stateNode.containerInfo,c.nodeType===9?c=c.body:c=c.nodeName==="HTML"?c.ownerDocument.body:c,bn=Rs(c.firstChild),jr=p,Ve=!0,Zi=null,Is=!0,g=MR(p,null,x,g),p.child=g;g;)g.flags=g.flags&-3|4096,g=g.sibling;else{if(gl(),x===k){p=ci(c,p,g);break t}Kr(c,p,x,g)}p=p.child}return p;case 26:return ny(c,p),c===null?(g=n$(p.type,null,p.pendingProps,null))?p.memoizedState=g:Ve||(g=p.type,c=p.pendingProps,x=by(pt.current).createElement(g),x[Hr]=p,x[Ia]=c,Xr(x,g,c),Ir(x),p.stateNode=x):p.memoizedState=n$(p.type,c.memoizedProps,p.pendingProps,c.memoizedState),null;case 27:return Rt(p),c===null&&Ve&&(x=p.stateNode=JD(p.type,p.pendingProps,pt.current),jr=p,Is=!0,k=bn,pu(p.type)?(dS=k,bn=Rs(x.firstChild)):bn=k),Kr(c,p,p.pendingProps.children,g),ny(c,p),c===null&&(p.flags|=4194304),p.child;case 5:return c===null&&Ve&&((k=x=bn)&&(x=nj(x,p.type,p.pendingProps,Is),x!==null?(p.stateNode=x,jr=p,bn=Rs(x.firstChild),Is=!1,k=!0):k=!1),k||Ji(p)),Rt(p),k=p.type,E=p.pendingProps,F=c!==null?c.memoizedProps:null,x=E.children,iS(k,E)?x=null:F!==null&&iS(k,F)&&(p.flags|=32),p.memoizedState!==null&&(k=o2(c,p,v6,null,null,g),mf._currentValue=k),ny(c,p),Kr(c,p,x,g),p.child;case 6:return c===null&&Ve&&((c=g=bn)&&(g=rj(g,p.pendingProps,Is),g!==null?(p.stateNode=g,jr=p,bn=null,c=!0):c=!1),c||Ji(p)),null;case 13:return UA(c,p,g);case 4:return Tt(p,p.stateNode.containerInfo),x=p.pendingProps,c===null?p.child=Sl(p,null,x,g):Kr(c,p,x,g),p.child;case 11:return $A(c,p,p.type,p.pendingProps,g);case 7:return Kr(c,p,p.pendingProps,g),p.child;case 8:return Kr(c,p,p.pendingProps.children,g),p.child;case 12:return Kr(c,p,p.pendingProps.children,g),p.child;case 10:return x=p.pendingProps,tu(p,p.type,x.value),Kr(c,p,x.children,g),p.child;case 9:return k=p.type._context,x=p.pendingProps.children,yl(p),k=qr(k),x=x(k),p.flags|=1,Kr(c,p,x,g),p.child;case 14:return OA(c,p,p.type,p.pendingProps,g);case 15:return FA(c,p,p.type,p.pendingProps,g);case 19:return GA(c,p,g);case 31:return k6(c,p,g);case 22:return MA(c,p,g,p.pendingProps);case 24:return yl(p),x=qr(Jn),c===null?(k=Yw(),k===null&&(k=dn,E=Kw(),k.pooledCache=E,E.refCount++,E!==null&&(k.pooledCacheLanes|=g),k=E),p.memoizedState={parent:x,cache:k},Zw(p),tu(p,Jn,k)):((c.lanes&g)!==0&&(Jw(c,p),Kp(p,null,null,g),qp()),k=c.memoizedState,E=p.memoizedState,k.parent!==x?(k={parent:x,cache:x},p.memoizedState=k,p.lanes===0&&(p.memoizedState=p.updateQueue.baseState=k),tu(p,Jn,x)):(x=E.cache,tu(p,Jn,x),x!==k.cache&&qw(p,[Jn],g,!0))),Kr(c,p,p.pendingProps.children,g),p.child;case 29:throw p.pendingProps}throw Error(r(156,p.tag))}function hi(c){c.flags|=4}function O2(c,p,g,x,k){if((p=(c.mode&32)!==0)&&(p=!1),p){if(c.flags|=16777216,(k&335544128)===k)if(c.stateNode.complete)c.flags|=8192;else if(yD())c.flags|=8192;else throw wl=Vv,Qw}else c.flags&=-16777217}function jA(c,p){if(p.type!=="stylesheet"||(p.state.loading&4)!==0)c.flags&=-16777217;else if(c.flags|=16777216,!i$(p))if(yD())c.flags|=8192;else throw wl=Vv,Qw}function ay(c,p){p!==null&&(c.flags|=4),c.flags&16384&&(p=c.tag!==22?k_():536870912,c.lanes|=p,ch|=p)}function tf(c,p){if(!Ve)switch(c.tailMode){case"hidden":p=c.tail;for(var g=null;p!==null;)p.alternate!==null&&(g=p),p=p.sibling;g===null?c.tail=null:g.sibling=null;break;case"collapsed":g=c.tail;for(var x=null;g!==null;)g.alternate!==null&&(x=g),g=g.sibling;x===null?p||c.tail===null?c.tail=null:c.tail.sibling=null:x.sibling=null}}function xn(c){var p=c.alternate!==null&&c.alternate.child===c.child,g=0,x=0;if(p)for(var k=c.child;k!==null;)g|=k.lanes|k.childLanes,x|=k.subtreeFlags&65011712,x|=k.flags&65011712,k.return=c,k=k.sibling;else for(k=c.child;k!==null;)g|=k.lanes|k.childLanes,x|=k.subtreeFlags,x|=k.flags,k.return=c,k=k.sibling;return c.subtreeFlags|=x,c.childLanes=g,p}function E6(c,p,g){var x=p.pendingProps;switch(Uw(p),p.tag){case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return xn(p),null;case 1:return xn(p),null;case 3:return g=p.stateNode,x=null,c!==null&&(x=c.memoizedState.cache),p.memoizedState.cache!==x&&(p.flags|=2048),ii(Jn),gt(),g.pendingContext&&(g.context=g.pendingContext,g.pendingContext=null),(c===null||c.child===null)&&(Qc(p)?hi(p):c===null||c.memoizedState.isDehydrated&&(p.flags&256)===0||(p.flags|=1024,Gw())),xn(p),null;case 26:var k=p.type,E=p.memoizedState;return c===null?(hi(p),E!==null?(xn(p),jA(p,E)):(xn(p),O2(p,k,null,x,g))):E?E!==c.memoizedState?(hi(p),xn(p),jA(p,E)):(xn(p),p.flags&=-16777217):(c=c.memoizedProps,c!==x&&hi(p),xn(p),O2(p,k,c,x,g)),null;case 27:if(At(p),g=pt.current,k=p.type,c!==null&&p.stateNode!=null)c.memoizedProps!==x&&hi(p);else{if(!x){if(p.stateNode===null)throw Error(r(166));return xn(p),null}c=rt.current,Qc(p)?kR(p):(c=JD(k,x,g),p.stateNode=c,hi(p))}return xn(p),null;case 5:if(At(p),k=p.type,c!==null&&p.stateNode!=null)c.memoizedProps!==x&&hi(p);else{if(!x){if(p.stateNode===null)throw Error(r(166));return xn(p),null}if(E=rt.current,Qc(p))kR(p);else{var F=by(pt.current);switch(E){case 1:E=F.createElementNS("http://www.w3.org/2000/svg",k);break;case 2:E=F.createElementNS("http://www.w3.org/1998/Math/MathML",k);break;default:switch(k){case"svg":E=F.createElementNS("http://www.w3.org/2000/svg",k);break;case"math":E=F.createElementNS("http://www.w3.org/1998/Math/MathML",k);break;case"script":E=F.createElement("div"),E.innerHTML="<script><\/script>",E=E.removeChild(E.firstChild);break;case"select":E=typeof x.is=="string"?F.createElement("select",{is:x.is}):F.createElement("select"),x.multiple?E.multiple=!0:x.size&&(E.size=x.size);break;default:E=typeof x.is=="string"?F.createElement(k,{is:x.is}):F.createElement(k)}}E[Hr]=p,E[Ia]=x;t:for(F=p.child;F!==null;){if(F.tag===5||F.tag===6)E.appendChild(F.stateNode);else if(F.tag!==4&&F.tag!==27&&F.child!==null){F.child.return=F,F=F.child;continue}if(F===p)break t;for(;F.sibling===null;){if(F.return===null||F.return===p)break t;F=F.return}F.sibling.return=F.return,F=F.sibling}p.stateNode=E;t:switch(Xr(E,k,x),k){case"button":case"input":case"select":case"textarea":x=!!x.autoFocus;break t;case"img":x=!0;break t;default:x=!1}x&&hi(p)}}return xn(p),O2(p,p.type,c===null?null:c.memoizedProps,p.pendingProps,g),null;case 6:if(c&&p.stateNode!=null)c.memoizedProps!==x&&hi(p);else{if(typeof x!="string"&&p.stateNode===null)throw Error(r(166));if(c=pt.current,Qc(p)){if(c=p.stateNode,g=p.memoizedProps,x=null,k=jr,k!==null)switch(k.tag){case 27:case 5:x=k.memoizedProps}c[Hr]=p,c=!!(c.nodeValue===g||x!==null&&x.suppressHydrationWarning===!0||UD(c.nodeValue,g)),c||Ji(p,!0)}else c=by(c).createTextNode(x),c[Hr]=p,p.stateNode=c}return xn(p),null;case 31:if(g=p.memoizedState,c===null||c.memoizedState!==null){if(x=Qc(p),g!==null){if(c===null){if(!x)throw Error(r(318));if(c=p.memoizedState,c=c!==null?c.dehydrated:null,!c)throw Error(r(557));c[Hr]=p}else gl(),(p.flags&128)===0&&(p.memoizedState=null),p.flags|=4;xn(p),c=!1}else g=Gw(),c!==null&&c.memoizedState!==null&&(c.memoizedState.hydrationErrors=g),c=!0;if(!c)return p.flags&256?(ts(p),p):(ts(p),null);if((p.flags&128)!==0)throw Error(r(558))}return xn(p),null;case 13:if(x=p.memoizedState,c===null||c.memoizedState!==null&&c.memoizedState.dehydrated!==null){if(k=Qc(p),x!==null&&x.dehydrated!==null){if(c===null){if(!k)throw Error(r(318));if(k=p.memoizedState,k=k!==null?k.dehydrated:null,!k)throw Error(r(317));k[Hr]=p}else gl(),(p.flags&128)===0&&(p.memoizedState=null),p.flags|=4;xn(p),k=!1}else k=Gw(),c!==null&&c.memoizedState!==null&&(c.memoizedState.hydrationErrors=k),k=!0;if(!k)return p.flags&256?(ts(p),p):(ts(p),null)}return ts(p),(p.flags&128)!==0?(p.lanes=g,p):(g=x!==null,c=c!==null&&c.memoizedState!==null,g&&(x=p.child,k=null,x.alternate!==null&&x.alternate.memoizedState!==null&&x.alternate.memoizedState.cachePool!==null&&(k=x.alternate.memoizedState.cachePool.pool),E=null,x.memoizedState!==null&&x.memoizedState.cachePool!==null&&(E=x.memoizedState.cachePool.pool),E!==k&&(x.flags|=2048)),g!==c&&g&&(p.child.flags|=8192),ay(p,p.updateQueue),xn(p),null);case 4:return gt(),c===null&&nS(p.stateNode.containerInfo),xn(p),null;case 10:return ii(p.type),xn(p),null;case 19:if(X(jn),x=p.memoizedState,x===null)return xn(p),null;if(k=(p.flags&128)!==0,E=x.rendering,E===null)if(k)tf(x,!1);else{if(Bn!==0||c!==null&&(c.flags&128)!==0)for(c=p.child;c!==null;){if(E=Hv(c),E!==null){for(p.flags|=128,tf(x,!1),c=E.updateQueue,p.updateQueue=c,ay(p,c),p.subtreeFlags=0,c=g,g=p.child;g!==null;)xR(g,c),g=g.sibling;return Q(jn,jn.current&1|2),Ve&&si(p,x.treeForkCount),p.child}c=c.sibling}x.tail!==null&&Ge()>ly&&(p.flags|=128,k=!0,tf(x,!1),p.lanes=4194304)}else{if(!k)if(c=Hv(E),c!==null){if(p.flags|=128,k=!0,c=c.updateQueue,p.updateQueue=c,ay(p,c),tf(x,!0),x.tail===null&&x.tailMode==="hidden"&&!E.alternate&&!Ve)return xn(p),null}else 2*Ge()-x.renderingStartTime>ly&&g!==536870912&&(p.flags|=128,k=!0,tf(x,!1),p.lanes=4194304);x.isBackwards?(E.sibling=p.child,p.child=E):(c=x.last,c!==null?c.sibling=E:p.child=E,x.last=E)}return x.tail!==null?(c=x.tail,x.rendering=c,x.tail=c.sibling,x.renderingStartTime=Ge(),c.sibling=null,g=jn.current,Q(jn,k?g&1|2:g&1),Ve&&si(p,x.treeForkCount),c):(xn(p),null);case 22:case 23:return ts(p),r2(),x=p.memoizedState!==null,c!==null?c.memoizedState!==null!==x&&(p.flags|=8192):x&&(p.flags|=8192),x?(g&536870912)!==0&&(p.flags&128)===0&&(xn(p),p.subtreeFlags&6&&(p.flags|=8192)):xn(p),g=p.updateQueue,g!==null&&ay(p,g.retryQueue),g=null,c!==null&&c.memoizedState!==null&&c.memoizedState.cachePool!==null&&(g=c.memoizedState.cachePool.pool),x=null,p.memoizedState!==null&&p.memoizedState.cachePool!==null&&(x=p.memoizedState.cachePool.pool),x!==g&&(p.flags|=2048),c!==null&&X(bl),null;case 24:return g=null,c!==null&&(g=c.memoizedState.cache),p.memoizedState.cache!==g&&(p.flags|=2048),ii(Jn),xn(p),null;case 25:return null;case 30:return null}throw Error(r(156,p.tag))}function I6(c,p){switch(Uw(p),p.tag){case 1:return c=p.flags,c&65536?(p.flags=c&-65537|128,p):null;case 3:return ii(Jn),gt(),c=p.flags,(c&65536)!==0&&(c&128)===0?(p.flags=c&-65537|128,p):null;case 26:case 27:case 5:return At(p),null;case 31:if(p.memoizedState!==null){if(ts(p),p.alternate===null)throw Error(r(340));gl()}return c=p.flags,c&65536?(p.flags=c&-65537|128,p):null;case 13:if(ts(p),c=p.memoizedState,c!==null&&c.dehydrated!==null){if(p.alternate===null)throw Error(r(340));gl()}return c=p.flags,c&65536?(p.flags=c&-65537|128,p):null;case 19:return X(jn),null;case 4:return gt(),null;case 10:return ii(p.type),null;case 22:case 23:return ts(p),r2(),c!==null&&X(bl),c=p.flags,c&65536?(p.flags=c&-65537|128,p):null;case 24:return ii(Jn),null;case 25:return null;default:return null}}function qA(c,p){switch(Uw(p),p.tag){case 3:ii(Jn),gt();break;case 26:case 27:case 5:At(p);break;case 4:gt();break;case 31:p.memoizedState!==null&&ts(p);break;case 13:ts(p);break;case 19:X(jn);break;case 10:ii(p.type);break;case 22:case 23:ts(p),r2(),c!==null&&X(bl);break;case 24:ii(Jn)}}function ef(c,p){try{var g=p.updateQueue,x=g!==null?g.lastEffect:null;if(x!==null){var k=x.next;g=k;do{if((g.tag&c)===c){x=void 0;var E=g.create,F=g.inst;x=E(),F.destroy=x}g=g.next}while(g!==k)}}catch(W){rn(p,p.return,W)}}function ou(c,p,g){try{var x=p.updateQueue,k=x!==null?x.lastEffect:null;if(k!==null){var E=k.next;x=E;do{if((x.tag&c)===c){var F=x.inst,W=F.destroy;if(W!==void 0){F.destroy=void 0,k=p;var nt=g,mt=W;try{mt()}catch(Nt){rn(k,nt,Nt)}}}x=x.next}while(x!==E)}}catch(Nt){rn(p,p.return,Nt)}}function KA(c){var p=c.updateQueue;if(p!==null){var g=c.stateNode;try{BR(p,g)}catch(x){rn(c,c.return,x)}}}function XA(c,p,g){g.props=Nl(c.type,c.memoizedProps),g.state=c.memoizedState;try{g.componentWillUnmount()}catch(x){rn(c,p,x)}}function nf(c,p){try{var g=c.ref;if(g!==null){switch(c.tag){case 26:case 27:case 5:var x=c.stateNode;break;case 30:x=c.stateNode;break;default:x=c.stateNode}typeof g=="function"?c.refCleanup=g(x):g.current=x}}catch(k){rn(c,p,k)}}function go(c,p){var g=c.ref,x=c.refCleanup;if(g!==null)if(typeof x=="function")try{x()}catch(k){rn(c,p,k)}finally{c.refCleanup=null,c=c.alternate,c!=null&&(c.refCleanup=null)}else if(typeof g=="function")try{g(null)}catch(k){rn(c,p,k)}else g.current=null}function YA(c){var p=c.type,g=c.memoizedProps,x=c.stateNode;try{t:switch(p){case"button":case"input":case"select":case"textarea":g.autoFocus&&x.focus();break t;case"img":g.src?x.src=g.src:g.srcSet&&(x.srcset=g.srcSet)}}catch(k){rn(c,c.return,k)}}function F2(c,p,g){try{var x=c.stateNode;Y6(x,c.type,g,p),x[Ia]=p}catch(k){rn(c,c.return,k)}}function QA(c){return c.tag===5||c.tag===3||c.tag===26||c.tag===27&&pu(c.type)||c.tag===4}function M2(c){t:for(;;){for(;c.sibling===null;){if(c.return===null||QA(c.return))return null;c=c.return}for(c.sibling.return=c.return,c=c.sibling;c.tag!==5&&c.tag!==6&&c.tag!==18;){if(c.tag===27&&pu(c.type)||c.flags&2||c.child===null||c.tag===4)continue t;c.child.return=c,c=c.child}if(!(c.flags&2))return c.stateNode}}function L2(c,p,g){var x=c.tag;if(x===5||x===6)c=c.stateNode,p?(g.nodeType===9?g.body:g.nodeName==="HTML"?g.ownerDocument.body:g).insertBefore(c,p):(p=g.nodeType===9?g.body:g.nodeName==="HTML"?g.ownerDocument.body:g,p.appendChild(c),g=g._reactRootContainer,g!=null||p.onclick!==null||(p.onclick=ni));else if(x!==4&&(x===27&&pu(c.type)&&(g=c.stateNode,p=null),c=c.child,c!==null))for(L2(c,p,g),c=c.sibling;c!==null;)L2(c,p,g),c=c.sibling}function sy(c,p,g){var x=c.tag;if(x===5||x===6)c=c.stateNode,p?g.insertBefore(c,p):g.appendChild(c);else if(x!==4&&(x===27&&pu(c.type)&&(g=c.stateNode),c=c.child,c!==null))for(sy(c,p,g),c=c.sibling;c!==null;)sy(c,p,g),c=c.sibling}function ZA(c){var p=c.stateNode,g=c.memoizedProps;try{for(var x=c.type,k=p.attributes;k.length;)p.removeAttributeNode(k[0]);Xr(p,x,g),p[Hr]=c,p[Ia]=g}catch(E){rn(c,c.return,E)}}var di=!1,nr=!1,B2=!1,JA=typeof WeakSet=="function"?WeakSet:Set,_r=null;function _6(c,p){if(c=c.containerInfo,sS=Ty,c=hR(c),Aw(c)){if("selectionStart"in c)var g={start:c.selectionStart,end:c.selectionEnd};else t:{g=(g=c.ownerDocument)&&g.defaultView||window;var x=g.getSelection&&g.getSelection();if(x&&x.rangeCount!==0){g=x.anchorNode;var k=x.anchorOffset,E=x.focusNode;x=x.focusOffset;try{g.nodeType,E.nodeType}catch{g=null;break t}var F=0,W=-1,nt=-1,mt=0,Nt=0,_t=c,vt=null;e:for(;;){for(var wt;_t!==g||k!==0&&_t.nodeType!==3||(W=F+k),_t!==E||x!==0&&_t.nodeType!==3||(nt=F+x),_t.nodeType===3&&(F+=_t.nodeValue.length),(wt=_t.firstChild)!==null;)vt=_t,_t=wt;for(;;){if(_t===c)break e;if(vt===g&&++mt===k&&(W=F),vt===E&&++Nt===x&&(nt=F),(wt=_t.nextSibling)!==null)break;_t=vt,vt=_t.parentNode}_t=wt}g=W===-1||nt===-1?null:{start:W,end:nt}}else g=null}g=g||{start:0,end:0}}else g=null;for(oS={focusedElem:c,selectionRange:g},Ty=!1,_r=p;_r!==null;)if(p=_r,c=p.child,(p.subtreeFlags&1028)!==0&&c!==null)c.return=p,_r=c;else for(;_r!==null;){switch(p=_r,E=p.alternate,c=p.flags,p.tag){case 0:if((c&4)!==0&&(c=p.updateQueue,c=c!==null?c.events:null,c!==null))for(g=0;g<c.length;g++)k=c[g],k.ref.impl=k.nextImpl;break;case 11:case 15:break;case 1:if((c&1024)!==0&&E!==null){c=void 0,g=p,k=E.memoizedProps,E=E.memoizedState,x=g.stateNode;try{var qt=Nl(g.type,k);c=x.getSnapshotBeforeUpdate(qt,E),x.__reactInternalSnapshotBeforeUpdate=c}catch(le){rn(g,g.return,le)}}break;case 3:if((c&1024)!==0){if(c=p.stateNode.containerInfo,g=c.nodeType,g===9)lS(c);else if(g===1)switch(c.nodeName){case"HEAD":case"HTML":case"BODY":lS(c);break;default:c.textContent=""}}break;case 5:case 26:case 27:case 6:case 4:case 17:break;default:if((c&1024)!==0)throw Error(r(163))}if(c=p.sibling,c!==null){c.return=p.return,_r=c;break}_r=p.return}}function tD(c,p,g){var x=g.flags;switch(g.tag){case 0:case 11:case 15:fi(c,g),x&4&&ef(5,g);break;case 1:if(fi(c,g),x&4)if(c=g.stateNode,p===null)try{c.componentDidMount()}catch(F){rn(g,g.return,F)}else{var k=Nl(g.type,p.memoizedProps);p=p.memoizedState;try{c.componentDidUpdate(k,p,c.__reactInternalSnapshotBeforeUpdate)}catch(F){rn(g,g.return,F)}}x&64&&KA(g),x&512&&nf(g,g.return);break;case 3:if(fi(c,g),x&64&&(c=g.updateQueue,c!==null)){if(p=null,g.child!==null)switch(g.child.tag){case 27:case 5:p=g.child.stateNode;break;case 1:p=g.child.stateNode}try{BR(c,p)}catch(F){rn(g,g.return,F)}}break;case 27:p===null&&x&4&&ZA(g);case 26:case 5:fi(c,g),p===null&&x&4&&YA(g),x&512&&nf(g,g.return);break;case 12:fi(c,g);break;case 31:fi(c,g),x&4&&rD(c,g);break;case 13:fi(c,g),x&4&&aD(c,g),x&64&&(c=g.memoizedState,c!==null&&(c=c.dehydrated,c!==null&&(g=B6.bind(null,g),aj(c,g))));break;case 22:if(x=g.memoizedState!==null||di,!x){p=p!==null&&p.memoizedState!==null||nr,k=di;var E=nr;di=x,(nr=p)&&!E?mi(c,g,(g.subtreeFlags&8772)!==0):fi(c,g),di=k,nr=E}break;case 30:break;default:fi(c,g)}}function eD(c){var p=c.alternate;p!==null&&(c.alternate=null,eD(p)),c.child=null,c.deletions=null,c.sibling=null,c.tag===5&&(p=c.stateNode,p!==null&&fw(p)),c.stateNode=null,c.return=null,c.dependencies=null,c.memoizedProps=null,c.memoizedState=null,c.pendingProps=null,c.stateNode=null,c.updateQueue=null}var kn=null,Ra=!1;function pi(c,p,g){for(g=g.child;g!==null;)nD(c,p,g),g=g.sibling}function nD(c,p,g){if(Dn&&typeof Dn.onCommitFiberUnmount=="function")try{Dn.onCommitFiberUnmount(Er,g)}catch{}switch(g.tag){case 26:nr||go(g,p),pi(c,p,g),g.memoizedState?g.memoizedState.count--:g.stateNode&&(g=g.stateNode,g.parentNode.removeChild(g));break;case 27:nr||go(g,p);var x=kn,k=Ra;pu(g.type)&&(kn=g.stateNode,Ra=!1),pi(c,p,g),df(g.stateNode),kn=x,Ra=k;break;case 5:nr||go(g,p);case 6:if(x=kn,k=Ra,kn=null,pi(c,p,g),kn=x,Ra=k,kn!==null)if(Ra)try{(kn.nodeType===9?kn.body:kn.nodeName==="HTML"?kn.ownerDocument.body:kn).removeChild(g.stateNode)}catch(E){rn(g,p,E)}else try{kn.removeChild(g.stateNode)}catch(E){rn(g,p,E)}break;case 18:kn!==null&&(Ra?(c=kn,KD(c.nodeType===9?c.body:c.nodeName==="HTML"?c.ownerDocument.body:c,g.stateNode),yh(c)):KD(kn,g.stateNode));break;case 4:x=kn,k=Ra,kn=g.stateNode.containerInfo,Ra=!0,pi(c,p,g),kn=x,Ra=k;break;case 0:case 11:case 14:case 15:ou(2,g,p),nr||ou(4,g,p),pi(c,p,g);break;case 1:nr||(go(g,p),x=g.stateNode,typeof x.componentWillUnmount=="function"&&XA(g,p,x)),pi(c,p,g);break;case 21:pi(c,p,g);break;case 22:nr=(x=nr)||g.memoizedState!==null,pi(c,p,g),nr=x;break;default:pi(c,p,g)}}function rD(c,p){if(p.memoizedState===null&&(c=p.alternate,c!==null&&(c=c.memoizedState,c!==null))){c=c.dehydrated;try{yh(c)}catch(g){rn(p,p.return,g)}}}function aD(c,p){if(p.memoizedState===null&&(c=p.alternate,c!==null&&(c=c.memoizedState,c!==null&&(c=c.dehydrated,c!==null))))try{yh(c)}catch(g){rn(p,p.return,g)}}function R6(c){switch(c.tag){case 31:case 13:case 19:var p=c.stateNode;return p===null&&(p=c.stateNode=new JA),p;case 22:return c=c.stateNode,p=c._retryCache,p===null&&(p=c._retryCache=new JA),p;default:throw Error(r(435,c.tag))}}function oy(c,p){var g=R6(c);p.forEach(function(x){if(!g.has(x)){g.add(x);var k=z6.bind(null,c,x);x.then(k,k)}})}function Aa(c,p){var g=p.deletions;if(g!==null)for(var x=0;x<g.length;x++){var k=g[x],E=c,F=p,W=F;t:for(;W!==null;){switch(W.tag){case 27:if(pu(W.type)){kn=W.stateNode,Ra=!1;break t}break;case 5:kn=W.stateNode,Ra=!1;break t;case 3:case 4:kn=W.stateNode.containerInfo,Ra=!0;break t}W=W.return}if(kn===null)throw Error(r(160));nD(E,F,k),kn=null,Ra=!1,E=k.alternate,E!==null&&(E.return=null),k.return=null}if(p.subtreeFlags&13886)for(p=p.child;p!==null;)sD(p,c),p=p.sibling}var js=null;function sD(c,p){var g=c.alternate,x=c.flags;switch(c.tag){case 0:case 11:case 14:case 15:Aa(p,c),Da(c),x&4&&(ou(3,c,c.return),ef(3,c),ou(5,c,c.return));break;case 1:Aa(p,c),Da(c),x&512&&(nr||g===null||go(g,g.return)),x&64&&di&&(c=c.updateQueue,c!==null&&(x=c.callbacks,x!==null&&(g=c.shared.hiddenCallbacks,c.shared.hiddenCallbacks=g===null?x:g.concat(x))));break;case 26:var k=js;if(Aa(p,c),Da(c),x&512&&(nr||g===null||go(g,g.return)),x&4){var E=g!==null?g.memoizedState:null;if(x=c.memoizedState,g===null)if(x===null)if(c.stateNode===null){t:{x=c.type,g=c.memoizedProps,k=k.ownerDocument||k;e:switch(x){case"title":E=k.getElementsByTagName("title")[0],(!E||E[_p]||E[Hr]||E.namespaceURI==="http://www.w3.org/2000/svg"||E.hasAttribute("itemprop"))&&(E=k.createElement(x),k.head.insertBefore(E,k.querySelector("head > title"))),Xr(E,x,g),E[Hr]=c,Ir(E),x=E;break t;case"link":var F=s$("link","href",k).get(x+(g.href||""));if(F){for(var W=0;W<F.length;W++)if(E=F[W],E.getAttribute("href")===(g.href==null||g.href===""?null:g.href)&&E.getAttribute("rel")===(g.rel==null?null:g.rel)&&E.getAttribute("title")===(g.title==null?null:g.title)&&E.getAttribute("crossorigin")===(g.crossOrigin==null?null:g.crossOrigin)){F.splice(W,1);break e}}E=k.createElement(x),Xr(E,x,g),k.head.appendChild(E);break;case"meta":if(F=s$("meta","content",k).get(x+(g.content||""))){for(W=0;W<F.length;W++)if(E=F[W],E.getAttribute("content")===(g.content==null?null:""+g.content)&&E.getAttribute("name")===(g.name==null?null:g.name)&&E.getAttribute("property")===(g.property==null?null:g.property)&&E.getAttribute("http-equiv")===(g.httpEquiv==null?null:g.httpEquiv)&&E.getAttribute("charset")===(g.charSet==null?null:g.charSet)){F.splice(W,1);break e}}E=k.createElement(x),Xr(E,x,g),k.head.appendChild(E);break;default:throw Error(r(468,x))}E[Hr]=c,Ir(E),x=E}c.stateNode=x}else o$(k,c.type,c.stateNode);else c.stateNode=a$(k,x,c.memoizedProps);else E!==x?(E===null?g.stateNode!==null&&(g=g.stateNode,g.parentNode.removeChild(g)):E.count--,x===null?o$(k,c.type,c.stateNode):a$(k,x,c.memoizedProps)):x===null&&c.stateNode!==null&&F2(c,c.memoizedProps,g.memoizedProps)}break;case 27:Aa(p,c),Da(c),x&512&&(nr||g===null||go(g,g.return)),g!==null&&x&4&&F2(c,c.memoizedProps,g.memoizedProps);break;case 5:if(Aa(p,c),Da(c),x&512&&(nr||g===null||go(g,g.return)),c.flags&32){k=c.stateNode;try{Vc(k,"")}catch(qt){rn(c,c.return,qt)}}x&4&&c.stateNode!=null&&(k=c.memoizedProps,F2(c,k,g!==null?g.memoizedProps:k)),x&1024&&(B2=!0);break;case 6:if(Aa(p,c),Da(c),x&4){if(c.stateNode===null)throw Error(r(162));x=c.memoizedProps,g=c.stateNode;try{g.nodeValue=x}catch(qt){rn(c,c.return,qt)}}break;case 3:if(Sy=null,k=js,js=xy(p.containerInfo),Aa(p,c),js=k,Da(c),x&4&&g!==null&&g.memoizedState.isDehydrated)try{yh(p.containerInfo)}catch(qt){rn(c,c.return,qt)}B2&&(B2=!1,oD(c));break;case 4:x=js,js=xy(c.stateNode.containerInfo),Aa(p,c),Da(c),js=x;break;case 12:Aa(p,c),Da(c);break;case 31:Aa(p,c),Da(c),x&4&&(x=c.updateQueue,x!==null&&(c.updateQueue=null,oy(c,x)));break;case 13:Aa(p,c),Da(c),c.child.flags&8192&&c.memoizedState!==null!=(g!==null&&g.memoizedState!==null)&&(uy=Ge()),x&4&&(x=c.updateQueue,x!==null&&(c.updateQueue=null,oy(c,x)));break;case 22:k=c.memoizedState!==null;var nt=g!==null&&g.memoizedState!==null,mt=di,Nt=nr;if(di=mt||k,nr=Nt||nt,Aa(p,c),nr=Nt,di=mt,Da(c),x&8192)t:for(p=c.stateNode,p._visibility=k?p._visibility&-2:p._visibility|1,k&&(g===null||nt||di||nr||kl(c)),g=null,p=c;;){if(p.tag===5||p.tag===26){if(g===null){nt=g=p;try{if(E=nt.stateNode,k)F=E.style,typeof F.setProperty=="function"?F.setProperty("display","none","important"):F.display="none";else{W=nt.stateNode;var _t=nt.memoizedProps.style,vt=_t!=null&&_t.hasOwnProperty("display")?_t.display:null;W.style.display=vt==null||typeof vt=="boolean"?"":(""+vt).trim()}}catch(qt){rn(nt,nt.return,qt)}}}else if(p.tag===6){if(g===null){nt=p;try{nt.stateNode.nodeValue=k?"":nt.memoizedProps}catch(qt){rn(nt,nt.return,qt)}}}else if(p.tag===18){if(g===null){nt=p;try{var wt=nt.stateNode;k?XD(wt,!0):XD(nt.stateNode,!1)}catch(qt){rn(nt,nt.return,qt)}}}else if((p.tag!==22&&p.tag!==23||p.memoizedState===null||p===c)&&p.child!==null){p.child.return=p,p=p.child;continue}if(p===c)break t;for(;p.sibling===null;){if(p.return===null||p.return===c)break t;g===p&&(g=null),p=p.return}g===p&&(g=null),p.sibling.return=p.return,p=p.sibling}x&4&&(x=c.updateQueue,x!==null&&(g=x.retryQueue,g!==null&&(x.retryQueue=null,oy(c,g))));break;case 19:Aa(p,c),Da(c),x&4&&(x=c.updateQueue,x!==null&&(c.updateQueue=null,oy(c,x)));break;case 30:break;case 21:break;default:Aa(p,c),Da(c)}}function Da(c){var p=c.flags;if(p&2){try{for(var g,x=c.return;x!==null;){if(QA(x)){g=x;break}x=x.return}if(g==null)throw Error(r(160));switch(g.tag){case 27:var k=g.stateNode,E=M2(c);sy(c,E,k);break;case 5:var F=g.stateNode;g.flags&32&&(Vc(F,""),g.flags&=-33);var W=M2(c);sy(c,W,F);break;case 3:case 4:var nt=g.stateNode.containerInfo,mt=M2(c);L2(c,mt,nt);break;default:throw Error(r(161))}}catch(Nt){rn(c,c.return,Nt)}c.flags&=-3}p&4096&&(c.flags&=-4097)}function oD(c){if(c.subtreeFlags&1024)for(c=c.child;c!==null;){var p=c;oD(p),p.tag===5&&p.flags&1024&&p.stateNode.reset(),c=c.sibling}}function fi(c,p){if(p.subtreeFlags&8772)for(p=p.child;p!==null;)tD(c,p.alternate,p),p=p.sibling}function kl(c){for(c=c.child;c!==null;){var p=c;switch(p.tag){case 0:case 11:case 14:case 15:ou(4,p,p.return),kl(p);break;case 1:go(p,p.return);var g=p.stateNode;typeof g.componentWillUnmount=="function"&&XA(p,p.return,g),kl(p);break;case 27:df(p.stateNode);case 26:case 5:go(p,p.return),kl(p);break;case 22:p.memoizedState===null&&kl(p);break;case 30:kl(p);break;default:kl(p)}c=c.sibling}}function mi(c,p,g){for(g=g&&(p.subtreeFlags&8772)!==0,p=p.child;p!==null;){var x=p.alternate,k=c,E=p,F=E.flags;switch(E.tag){case 0:case 11:case 15:mi(k,E,g),ef(4,E);break;case 1:if(mi(k,E,g),x=E,k=x.stateNode,typeof k.componentDidMount=="function")try{k.componentDidMount()}catch(mt){rn(x,x.return,mt)}if(x=E,k=x.updateQueue,k!==null){var W=x.stateNode;try{var nt=k.shared.hiddenCallbacks;if(nt!==null)for(k.shared.hiddenCallbacks=null,k=0;k<nt.length;k++)LR(nt[k],W)}catch(mt){rn(x,x.return,mt)}}g&&F&64&&KA(E),nf(E,E.return);break;case 27:ZA(E);case 26:case 5:mi(k,E,g),g&&x===null&&F&4&&YA(E),nf(E,E.return);break;case 12:mi(k,E,g);break;case 31:mi(k,E,g),g&&F&4&&rD(k,E);break;case 13:mi(k,E,g),g&&F&4&&aD(k,E);break;case 22:E.memoizedState===null&&mi(k,E,g),nf(E,E.return);break;case 30:break;default:mi(k,E,g)}p=p.sibling}}function z2(c,p){var g=null;c!==null&&c.memoizedState!==null&&c.memoizedState.cachePool!==null&&(g=c.memoizedState.cachePool.pool),c=null,p.memoizedState!==null&&p.memoizedState.cachePool!==null&&(c=p.memoizedState.cachePool.pool),c!==g&&(c!=null&&c.refCount++,g!=null&&Up(g))}function P2(c,p){c=null,p.alternate!==null&&(c=p.alternate.memoizedState.cache),p=p.memoizedState.cache,p!==c&&(p.refCount++,c!=null&&Up(c))}function qs(c,p,g,x){if(p.subtreeFlags&10256)for(p=p.child;p!==null;)iD(c,p,g,x),p=p.sibling}function iD(c,p,g,x){var k=p.flags;switch(p.tag){case 0:case 11:case 15:qs(c,p,g,x),k&2048&&ef(9,p);break;case 1:qs(c,p,g,x);break;case 3:qs(c,p,g,x),k&2048&&(c=null,p.alternate!==null&&(c=p.alternate.memoizedState.cache),p=p.memoizedState.cache,p!==c&&(p.refCount++,c!=null&&Up(c)));break;case 12:if(k&2048){qs(c,p,g,x),c=p.stateNode;try{var E=p.memoizedProps,F=E.id,W=E.onPostCommit;typeof W=="function"&&W(F,p.alternate===null?"mount":"update",c.passiveEffectDuration,-0)}catch(nt){rn(p,p.return,nt)}}else qs(c,p,g,x);break;case 31:qs(c,p,g,x);break;case 13:qs(c,p,g,x);break;case 23:break;case 22:E=p.stateNode,F=p.alternate,p.memoizedState!==null?E._visibility&2?qs(c,p,g,x):rf(c,p):E._visibility&2?qs(c,p,g,x):(E._visibility|=2,ih(c,p,g,x,(p.subtreeFlags&10256)!==0||!1)),k&2048&&z2(F,p);break;case 24:qs(c,p,g,x),k&2048&&P2(p.alternate,p);break;default:qs(c,p,g,x)}}function ih(c,p,g,x,k){for(k=k&&((p.subtreeFlags&10256)!==0||!1),p=p.child;p!==null;){var E=c,F=p,W=g,nt=x,mt=F.flags;switch(F.tag){case 0:case 11:case 15:ih(E,F,W,nt,k),ef(8,F);break;case 23:break;case 22:var Nt=F.stateNode;F.memoizedState!==null?Nt._visibility&2?ih(E,F,W,nt,k):rf(E,F):(Nt._visibility|=2,ih(E,F,W,nt,k)),k&&mt&2048&&z2(F.alternate,F);break;case 24:ih(E,F,W,nt,k),k&&mt&2048&&P2(F.alternate,F);break;default:ih(E,F,W,nt,k)}p=p.sibling}}function rf(c,p){if(p.subtreeFlags&10256)for(p=p.child;p!==null;){var g=c,x=p,k=x.flags;switch(x.tag){case 22:rf(g,x),k&2048&&z2(x.alternate,x);break;case 24:rf(g,x),k&2048&&P2(x.alternate,x);break;default:rf(g,x)}p=p.sibling}}var af=8192;function uh(c,p,g){if(c.subtreeFlags&af)for(c=c.child;c!==null;)uD(c,p,g),c=c.sibling}function uD(c,p,g){switch(c.tag){case 26:uh(c,p,g),c.flags&af&&c.memoizedState!==null&&gj(g,js,c.memoizedState,c.memoizedProps);break;case 5:uh(c,p,g);break;case 3:case 4:var x=js;js=xy(c.stateNode.containerInfo),uh(c,p,g),js=x;break;case 22:c.memoizedState===null&&(x=c.alternate,x!==null&&x.memoizedState!==null?(x=af,af=16777216,uh(c,p,g),af=x):uh(c,p,g));break;default:uh(c,p,g)}}function lD(c){var p=c.alternate;if(p!==null&&(c=p.child,c!==null)){p.child=null;do p=c.sibling,c.sibling=null,c=p;while(c!==null)}}function sf(c){var p=c.deletions;if((c.flags&16)!==0){if(p!==null)for(var g=0;g<p.length;g++){var x=p[g];_r=x,hD(x,c)}lD(c)}if(c.subtreeFlags&10256)for(c=c.child;c!==null;)cD(c),c=c.sibling}function cD(c){switch(c.tag){case 0:case 11:case 15:sf(c),c.flags&2048&&ou(9,c,c.return);break;case 3:sf(c);break;case 12:sf(c);break;case 22:var p=c.stateNode;c.memoizedState!==null&&p._visibility&2&&(c.return===null||c.return.tag!==13)?(p._visibility&=-3,iy(c)):sf(c);break;default:sf(c)}}function iy(c){var p=c.deletions;if((c.flags&16)!==0){if(p!==null)for(var g=0;g<p.length;g++){var x=p[g];_r=x,hD(x,c)}lD(c)}for(c=c.child;c!==null;){switch(p=c,p.tag){case 0:case 11:case 15:ou(8,p,p.return),iy(p);break;case 22:g=p.stateNode,g._visibility&2&&(g._visibility&=-3,iy(p));break;default:iy(p)}c=c.sibling}}function hD(c,p){for(;_r!==null;){var g=_r;switch(g.tag){case 0:case 11:case 15:ou(8,g,p);break;case 23:case 22:if(g.memoizedState!==null&&g.memoizedState.cachePool!==null){var x=g.memoizedState.cachePool.pool;x!=null&&x.refCount++}break;case 24:Up(g.memoizedState.cache)}if(x=g.child,x!==null)x.return=g,_r=x;else t:for(g=c;_r!==null;){x=_r;var k=x.sibling,E=x.return;if(eD(x),x===g){_r=null;break t}if(k!==null){k.return=E,_r=k;break t}_r=E}}}var A6={getCacheForType:function(c){var p=qr(Jn),g=p.data.get(c);return g===void 0&&(g=c(),p.data.set(c,g)),g},cacheSignal:function(){return qr(Jn).controller.signal}},D6=typeof WeakMap=="function"?WeakMap:Map,Ye=0,dn=null,Fe=null,ze=0,nn=0,es=null,iu=!1,lh=!1,V2=!1,gi=0,Bn=0,uu=0,Tl=0,U2=0,ns=0,ch=0,of=null,$a=null,W2=!1,uy=0,dD=0,ly=1/0,cy=null,lu=null,pr=0,cu=null,hh=null,vi=0,G2=0,H2=null,pD=null,uf=0,j2=null;function rs(){return(Ye&2)!==0&&ze!==0?ze&-ze:B.T!==null?Z2():__()}function fD(){if(ns===0)if((ze&536870912)===0||Ve){var c=yv;yv<<=1,(yv&3932160)===0&&(yv=262144),ns=c}else ns=536870912;return c=Ja.current,c!==null&&(c.flags|=32),ns}function Oa(c,p,g){(c===dn&&(nn===2||nn===9)||c.cancelPendingCommit!==null)&&(dh(c,0),hu(c,ze,ns,!1)),Ip(c,g),((Ye&2)===0||c!==dn)&&(c===dn&&((Ye&2)===0&&(Tl|=g),Bn===4&&hu(c,ze,ns,!1)),vo(c))}function mD(c,p,g){if((Ye&6)!==0)throw Error(r(327));var x=!g&&(p&127)===0&&(p&c.expiredLanes)===0||Ep(c,p),k=x?F6(c,p):K2(c,p,!0),E=x;do{if(k===0){lh&&!x&&hu(c,p,0,!1);break}else{if(g=c.current.alternate,E&&!$6(g)){k=K2(c,p,!1),E=!1;continue}if(k===2){if(E=p,c.errorRecoveryDisabledLanes&E)var F=0;else F=c.pendingLanes&-536870913,F=F!==0?F:F&536870912?536870912:0;if(F!==0){p=F;t:{var W=c;k=of;var nt=W.current.memoizedState.isDehydrated;if(nt&&(dh(W,F).flags|=256),F=K2(W,F,!1),F!==2){if(V2&&!nt){W.errorRecoveryDisabledLanes|=E,Tl|=E,k=4;break t}E=$a,$a=k,E!==null&&($a===null?$a=E:$a.push.apply($a,E))}k=F}if(E=!1,k!==2)continue}}if(k===1){dh(c,0),hu(c,p,0,!0);break}t:{switch(x=c,E=k,E){case 0:case 1:throw Error(r(345));case 4:if((p&4194048)!==p)break;case 6:hu(x,p,ns,!iu);break t;case 2:$a=null;break;case 3:case 5:break;default:throw Error(r(329))}if((p&62914560)===p&&(k=uy+300-Ge(),10<k)){if(hu(x,p,ns,!iu),xv(x,0,!0)!==0)break t;vi=p,x.timeoutHandle=jD(gD.bind(null,x,g,$a,cy,W2,p,ns,Tl,ch,iu,E,"Throttled",-0,0),k);break t}gD(x,g,$a,cy,W2,p,ns,Tl,ch,iu,E,null,-0,0)}}break}while(!0);vo(c)}function gD(c,p,g,x,k,E,F,W,nt,mt,Nt,_t,vt,wt){if(c.timeoutHandle=-1,_t=p.subtreeFlags,_t&8192||(_t&16785408)===16785408){_t={stylesheets:null,count:0,imgCount:0,imgBytes:0,suspenseyImages:[],waitingForImages:!0,waitingForViewTransition:!1,unsuspend:ni},uD(p,E,_t);var qt=(E&62914560)===E?uy-Ge():(E&4194048)===E?dD-Ge():0;if(qt=vj(_t,qt),qt!==null){vi=E,c.cancelPendingCommit=qt(ND.bind(null,c,p,E,g,x,k,F,W,nt,Nt,_t,null,vt,wt)),hu(c,E,F,!mt);return}}ND(c,p,E,g,x,k,F,W,nt)}function $6(c){for(var p=c;;){var g=p.tag;if((g===0||g===11||g===15)&&p.flags&16384&&(g=p.updateQueue,g!==null&&(g=g.stores,g!==null)))for(var x=0;x<g.length;x++){var k=g[x],E=k.getSnapshot;k=k.value;try{if(!Qa(E(),k))return!1}catch{return!1}}if(g=p.child,p.subtreeFlags&16384&&g!==null)g.return=p,p=g;else{if(p===c)break;for(;p.sibling===null;){if(p.return===null||p.return===c)return!0;p=p.return}p.sibling.return=p.return,p=p.sibling}}return!0}function hu(c,p,g,x){p&=~U2,p&=~Tl,c.suspendedLanes|=p,c.pingedLanes&=~p,x&&(c.warmLanes|=p),x=c.expirationTimes;for(var k=p;0<k;){var E=31-Gr(k),F=1<<E;x[E]=-1,k&=~F}g!==0&&T_(c,g,p)}function hy(){return(Ye&6)===0?(lf(0),!1):!0}function q2(){if(Fe!==null){if(nn===0)var c=Fe.return;else c=Fe,oi=vl=null,l2(c),nh=null,Gp=0,c=Fe;for(;c!==null;)qA(c.alternate,c),c=c.return;Fe=null}}function dh(c,p){var g=c.timeoutHandle;g!==-1&&(c.timeoutHandle=-1,J6(g)),g=c.cancelPendingCommit,g!==null&&(c.cancelPendingCommit=null,g()),vi=0,q2(),dn=c,Fe=g=ai(c.current,null),ze=p,nn=0,es=null,iu=!1,lh=Ep(c,p),V2=!1,ch=ns=U2=Tl=uu=Bn=0,$a=of=null,W2=!1,(p&8)!==0&&(p|=p&32);var x=c.entangledLanes;if(x!==0)for(c=c.entanglements,x&=p;0<x;){var k=31-Gr(x),E=1<<k;p|=c[k],x&=~E}return gi=p,Dv(),g}function vD(c,p){Ne=null,B.H=Zp,p===eh||p===Pv?(p=$R(),nn=3):p===Qw?(p=$R(),nn=4):nn=p===k2?8:p!==null&&typeof p=="object"&&typeof p.then=="function"?6:1,es=p,Fe===null&&(Bn=1,ty(c,ks(p,c.current)))}function yD(){var c=Ja.current;return c===null?!0:(ze&4194048)===ze?_s===null:(ze&62914560)===ze||(ze&536870912)!==0?c===_s:!1}function bD(){var c=B.H;return B.H=Zp,c===null?Zp:c}function xD(){var c=B.A;return B.A=A6,c}function dy(){Bn=4,iu||(ze&4194048)!==ze&&Ja.current!==null||(lh=!0),(uu&134217727)===0&&(Tl&134217727)===0||dn===null||hu(dn,ze,ns,!1)}function K2(c,p,g){var x=Ye;Ye|=2;var k=bD(),E=xD();(dn!==c||ze!==p)&&(cy=null,dh(c,p)),p=!1;var F=Bn;t:do try{if(nn!==0&&Fe!==null){var W=Fe,nt=es;switch(nn){case 8:q2(),F=6;break t;case 3:case 2:case 9:case 6:Ja.current===null&&(p=!0);var mt=nn;if(nn=0,es=null,ph(c,W,nt,mt),g&&lh){F=0;break t}break;default:mt=nn,nn=0,es=null,ph(c,W,nt,mt)}}O6(),F=Bn;break}catch(Nt){vD(c,Nt)}while(!0);return p&&c.shellSuspendCounter++,oi=vl=null,Ye=x,B.H=k,B.A=E,Fe===null&&(dn=null,ze=0,Dv()),F}function O6(){for(;Fe!==null;)wD(Fe)}function F6(c,p){var g=Ye;Ye|=2;var x=bD(),k=xD();dn!==c||ze!==p?(cy=null,ly=Ge()+500,dh(c,p)):lh=Ep(c,p);t:do try{if(nn!==0&&Fe!==null){p=Fe;var E=es;e:switch(nn){case 1:nn=0,es=null,ph(c,p,E,1);break;case 2:case 9:if(AR(E)){nn=0,es=null,SD(p);break}p=function(){nn!==2&&nn!==9||dn!==c||(nn=7),vo(c)},E.then(p,p);break t;case 3:nn=7;break t;case 4:nn=5;break t;case 7:AR(E)?(nn=0,es=null,SD(p)):(nn=0,es=null,ph(c,p,E,7));break;case 5:var F=null;switch(Fe.tag){case 26:F=Fe.memoizedState;case 5:case 27:var W=Fe;if(F?i$(F):W.stateNode.complete){nn=0,es=null;var nt=W.sibling;if(nt!==null)Fe=nt;else{var mt=W.return;mt!==null?(Fe=mt,py(mt)):Fe=null}break e}}nn=0,es=null,ph(c,p,E,5);break;case 6:nn=0,es=null,ph(c,p,E,6);break;case 8:q2(),Bn=6;break t;default:throw Error(r(462))}}M6();break}catch(Nt){vD(c,Nt)}while(!0);return oi=vl=null,B.H=x,B.A=k,Ye=g,Fe!==null?0:(dn=null,ze=0,Dv(),Bn)}function M6(){for(;Fe!==null&&!vn();)wD(Fe)}function wD(c){var p=HA(c.alternate,c,gi);c.memoizedProps=c.pendingProps,p===null?py(c):Fe=p}function SD(c){var p=c,g=p.alternate;switch(p.tag){case 15:case 0:p=zA(g,p,p.pendingProps,p.type,void 0,ze);break;case 11:p=zA(g,p,p.pendingProps,p.type.render,p.ref,ze);break;case 5:l2(p);default:qA(g,p),p=Fe=xR(p,gi),p=HA(g,p,gi)}c.memoizedProps=c.pendingProps,p===null?py(c):Fe=p}function ph(c,p,g,x){oi=vl=null,l2(p),nh=null,Gp=0;var k=p.return;try{if(N6(c,k,p,g,ze)){Bn=1,ty(c,ks(g,c.current)),Fe=null;return}}catch(E){if(k!==null)throw Fe=k,E;Bn=1,ty(c,ks(g,c.current)),Fe=null;return}p.flags&32768?(Ve||x===1?c=!0:lh||(ze&536870912)!==0?c=!1:(iu=c=!0,(x===2||x===9||x===3||x===6)&&(x=Ja.current,x!==null&&x.tag===13&&(x.flags|=16384))),CD(p,c)):py(p)}function py(c){var p=c;do{if((p.flags&32768)!==0){CD(p,iu);return}c=p.return;var g=E6(p.alternate,p,gi);if(g!==null){Fe=g;return}if(p=p.sibling,p!==null){Fe=p;return}Fe=p=c}while(p!==null);Bn===0&&(Bn=5)}function CD(c,p){do{var g=I6(c.alternate,c);if(g!==null){g.flags&=32767,Fe=g;return}if(g=c.return,g!==null&&(g.flags|=32768,g.subtreeFlags=0,g.deletions=null),!p&&(c=c.sibling,c!==null)){Fe=c;return}Fe=c=g}while(c!==null);Bn=6,Fe=null}function ND(c,p,g,x,k,E,F,W,nt){c.cancelPendingCommit=null;do fy();while(pr!==0);if((Ye&6)!==0)throw Error(r(327));if(p!==null){if(p===c.current)throw Error(r(177));if(E=p.lanes|p.childLanes,E|=Mw,mH(c,g,E,F,W,nt),c===dn&&(Fe=dn=null,ze=0),hh=p,cu=c,vi=g,G2=E,H2=k,pD=x,(p.subtreeFlags&10256)!==0||(p.flags&10256)!==0?(c.callbackNode=null,c.callbackPriority=0,P6(ge,function(){return _D(),null})):(c.callbackNode=null,c.callbackPriority=0),x=(p.flags&13878)!==0,(p.subtreeFlags&13878)!==0||x){x=B.T,B.T=null,k=j.p,j.p=2,F=Ye,Ye|=4;try{_6(c,p,g)}finally{Ye=F,j.p=k,B.T=x}}pr=1,kD(),TD(),ED()}}function kD(){if(pr===1){pr=0;var c=cu,p=hh,g=(p.flags&13878)!==0;if((p.subtreeFlags&13878)!==0||g){g=B.T,B.T=null;var x=j.p;j.p=2;var k=Ye;Ye|=4;try{sD(p,c);var E=oS,F=hR(c.containerInfo),W=E.focusedElem,nt=E.selectionRange;if(F!==W&&W&&W.ownerDocument&&cR(W.ownerDocument.documentElement,W)){if(nt!==null&&Aw(W)){var mt=nt.start,Nt=nt.end;if(Nt===void 0&&(Nt=mt),"selectionStart"in W)W.selectionStart=mt,W.selectionEnd=Math.min(Nt,W.value.length);else{var _t=W.ownerDocument||document,vt=_t&&_t.defaultView||window;if(vt.getSelection){var wt=vt.getSelection(),qt=W.textContent.length,le=Math.min(nt.start,qt),ln=nt.end===void 0?le:Math.min(nt.end,qt);!wt.extend&&le>ln&&(F=ln,ln=le,le=F);var ht=lR(W,le),it=lR(W,ln);if(ht&&it&&(wt.rangeCount!==1||wt.anchorNode!==ht.node||wt.anchorOffset!==ht.offset||wt.focusNode!==it.node||wt.focusOffset!==it.offset)){var ft=_t.createRange();ft.setStart(ht.node,ht.offset),wt.removeAllRanges(),le>ln?(wt.addRange(ft),wt.extend(it.node,it.offset)):(ft.setEnd(it.node,it.offset),wt.addRange(ft))}}}}for(_t=[],wt=W;wt=wt.parentNode;)wt.nodeType===1&&_t.push({element:wt,left:wt.scrollLeft,top:wt.scrollTop});for(typeof W.focus=="function"&&W.focus(),W=0;W<_t.length;W++){var Et=_t[W];Et.element.scrollLeft=Et.left,Et.element.scrollTop=Et.top}}Ty=!!sS,oS=sS=null}finally{Ye=k,j.p=x,B.T=g}}c.current=p,pr=2}}function TD(){if(pr===2){pr=0;var c=cu,p=hh,g=(p.flags&8772)!==0;if((p.subtreeFlags&8772)!==0||g){g=B.T,B.T=null;var x=j.p;j.p=2;var k=Ye;Ye|=4;try{tD(c,p.alternate,p)}finally{Ye=k,j.p=x,B.T=g}}pr=3}}function ED(){if(pr===4||pr===3){pr=0,Hn();var c=cu,p=hh,g=vi,x=pD;(p.subtreeFlags&10256)!==0||(p.flags&10256)!==0?pr=5:(pr=0,hh=cu=null,ID(c,c.pendingLanes));var k=c.pendingLanes;if(k===0&&(lu=null),dw(g),p=p.stateNode,Dn&&typeof Dn.onCommitFiberRoot=="function")try{Dn.onCommitFiberRoot(Er,p,void 0,(p.current.flags&128)===128)}catch{}if(x!==null){p=B.T,k=j.p,j.p=2,B.T=null;try{for(var E=c.onRecoverableError,F=0;F<x.length;F++){var W=x[F];E(W.value,{componentStack:W.stack})}}finally{B.T=p,j.p=k}}(vi&3)!==0&&fy(),vo(c),k=c.pendingLanes,(g&261930)!==0&&(k&42)!==0?c===j2?uf++:(uf=0,j2=c):uf=0,lf(0)}}function ID(c,p){(c.pooledCacheLanes&=p)===0&&(p=c.pooledCache,p!=null&&(c.pooledCache=null,Up(p)))}function fy(){return kD(),TD(),ED(),_D()}function _D(){if(pr!==5)return!1;var c=cu,p=G2;G2=0;var g=dw(vi),x=B.T,k=j.p;try{j.p=32>g?32:g,B.T=null,g=H2,H2=null;var E=cu,F=vi;if(pr=0,hh=cu=null,vi=0,(Ye&6)!==0)throw Error(r(331));var W=Ye;if(Ye|=4,cD(E.current),iD(E,E.current,F,g),Ye=W,lf(0,!1),Dn&&typeof Dn.onPostCommitFiberRoot=="function")try{Dn.onPostCommitFiberRoot(Er,E)}catch{}return!0}finally{j.p=k,B.T=x,ID(c,p)}}function RD(c,p,g){p=ks(g,p),p=N2(c.stateNode,p,2),c=ru(c,p,2),c!==null&&(Ip(c,2),vo(c))}function rn(c,p,g){if(c.tag===3)RD(c,c,g);else for(;p!==null;){if(p.tag===3){RD(p,c,g);break}else if(p.tag===1){var x=p.stateNode;if(typeof p.type.getDerivedStateFromError=="function"||typeof x.componentDidCatch=="function"&&(lu===null||!lu.has(x))){c=ks(g,c),g=AA(2),x=ru(p,g,2),x!==null&&(DA(g,x,p,c),Ip(x,2),vo(x));break}}p=p.return}}function X2(c,p,g){var x=c.pingCache;if(x===null){x=c.pingCache=new D6;var k=new Set;x.set(p,k)}else k=x.get(p),k===void 0&&(k=new Set,x.set(p,k));k.has(g)||(V2=!0,k.add(g),c=L6.bind(null,c,p,g),p.then(c,c))}function L6(c,p,g){var x=c.pingCache;x!==null&&x.delete(p),c.pingedLanes|=c.suspendedLanes&g,c.warmLanes&=~g,dn===c&&(ze&g)===g&&(Bn===4||Bn===3&&(ze&62914560)===ze&&300>Ge()-uy?(Ye&2)===0&&dh(c,0):U2|=g,ch===ze&&(ch=0)),vo(c)}function AD(c,p){p===0&&(p=k_()),c=fl(c,p),c!==null&&(Ip(c,p),vo(c))}function B6(c){var p=c.memoizedState,g=0;p!==null&&(g=p.retryLane),AD(c,g)}function z6(c,p){var g=0;switch(c.tag){case 31:case 13:var x=c.stateNode,k=c.memoizedState;k!==null&&(g=k.retryLane);break;case 19:x=c.stateNode;break;case 22:x=c.stateNode._retryCache;break;default:throw Error(r(314))}x!==null&&x.delete(p),AD(c,g)}function P6(c,p){return We(c,p)}var my=null,fh=null,Y2=!1,gy=!1,Q2=!1,du=0;function vo(c){c!==fh&&c.next===null&&(fh===null?my=fh=c:fh=fh.next=c),gy=!0,Y2||(Y2=!0,U6())}function lf(c,p){if(!Q2&&gy){Q2=!0;do for(var g=!1,x=my;x!==null;){if(c!==0){var k=x.pendingLanes;if(k===0)var E=0;else{var F=x.suspendedLanes,W=x.pingedLanes;E=(1<<31-Gr(42|c)+1)-1,E&=k&~(F&~W),E=E&201326741?E&201326741|1:E?E|2:0}E!==0&&(g=!0,FD(x,E))}else E=ze,E=xv(x,x===dn?E:0,x.cancelPendingCommit!==null||x.timeoutHandle!==-1),(E&3)===0||Ep(x,E)||(g=!0,FD(x,E));x=x.next}while(g);Q2=!1}}function V6(){DD()}function DD(){gy=Y2=!1;var c=0;du!==0&&Z6()&&(c=du);for(var p=Ge(),g=null,x=my;x!==null;){var k=x.next,E=$D(x,p);E===0?(x.next=null,g===null?my=k:g.next=k,k===null&&(fh=g)):(g=x,(c!==0||(E&3)!==0)&&(gy=!0)),x=k}pr!==0&&pr!==5||lf(c),du!==0&&(du=0)}function $D(c,p){for(var g=c.suspendedLanes,x=c.pingedLanes,k=c.expirationTimes,E=c.pendingLanes&-62914561;0<E;){var F=31-Gr(E),W=1<<F,nt=k[F];nt===-1?((W&g)===0||(W&x)!==0)&&(k[F]=fH(W,p)):nt<=p&&(c.expiredLanes|=W),E&=~W}if(p=dn,g=ze,g=xv(c,c===p?g:0,c.cancelPendingCommit!==null||c.timeoutHandle!==-1),x=c.callbackNode,g===0||c===p&&(nn===2||nn===9)||c.cancelPendingCommit!==null)return x!==null&&x!==null&&hn(x),c.callbackNode=null,c.callbackPriority=0;if((g&3)===0||Ep(c,g)){if(p=g&-g,p===c.callbackPriority)return p;switch(x!==null&&hn(x),dw(g)){case 2:case 8:g=Ce;break;case 32:g=ge;break;case 268435456:g=hr;break;default:g=ge}return x=OD.bind(null,c),g=We(g,x),c.callbackPriority=p,c.callbackNode=g,p}return x!==null&&x!==null&&hn(x),c.callbackPriority=2,c.callbackNode=null,2}function OD(c,p){if(pr!==0&&pr!==5)return c.callbackNode=null,c.callbackPriority=0,null;var g=c.callbackNode;if(fy()&&c.callbackNode!==g)return null;var x=ze;return x=xv(c,c===dn?x:0,c.cancelPendingCommit!==null||c.timeoutHandle!==-1),x===0?null:(mD(c,x,p),$D(c,Ge()),c.callbackNode!=null&&c.callbackNode===g?OD.bind(null,c):null)}function FD(c,p){if(fy())return null;mD(c,p,!0)}function U6(){tj(function(){(Ye&6)!==0?We(Ht,V6):DD()})}function Z2(){if(du===0){var c=Jc;c===0&&(c=Oc,Oc<<=1,(Oc&261888)===0&&(Oc=256)),du=c}return du}function MD(c){return c==null||typeof c=="symbol"||typeof c=="boolean"?null:typeof c=="function"?c:Nv(""+c)}function LD(c,p){var g=p.ownerDocument.createElement("input");return g.name=p.name,g.value=p.value,c.id&&g.setAttribute("form",c.id),p.parentNode.insertBefore(g,p),c=new FormData(c),g.parentNode.removeChild(g),c}function W6(c,p,g,x,k){if(p==="submit"&&g&&g.stateNode===k){var E=MD((k[Ia]||null).action),F=x.submitter;F&&(p=(p=F[Ia]||null)?MD(p.formAction):F.getAttribute("formAction"),p!==null&&(E=p,F=null));var W=new Iv("action","action",null,x,k);c.push({event:W,listeners:[{instance:null,listener:function(){if(x.defaultPrevented){if(du!==0){var nt=F?LD(k,F):new FormData(k);y2(g,{pending:!0,data:nt,method:k.method,action:E},null,nt)}}else typeof E=="function"&&(W.preventDefault(),nt=F?LD(k,F):new FormData(k),y2(g,{pending:!0,data:nt,method:k.method,action:E},E,nt))},currentTarget:k}]})}}for(var J2=0;J2<Fw.length;J2++){var tS=Fw[J2],G6=tS.toLowerCase(),H6=tS[0].toUpperCase()+tS.slice(1);Hs(G6,"on"+H6)}Hs(fR,"onAnimationEnd"),Hs(mR,"onAnimationIteration"),Hs(gR,"onAnimationStart"),Hs("dblclick","onDoubleClick"),Hs("focusin","onFocus"),Hs("focusout","onBlur"),Hs(i6,"onTransitionRun"),Hs(u6,"onTransitionStart"),Hs(l6,"onTransitionCancel"),Hs(vR,"onTransitionEnd"),zc("onMouseEnter",["mouseout","mouseover"]),zc("onMouseLeave",["mouseout","mouseover"]),zc("onPointerEnter",["pointerout","pointerover"]),zc("onPointerLeave",["pointerout","pointerover"]),cl("onChange","change click focusin focusout input keydown keyup selectionchange".split(" ")),cl("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")),cl("onBeforeInput",["compositionend","keypress","textInput","paste"]),cl("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" ")),cl("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" ")),cl("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var cf="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),j6=new Set("beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(cf));function BD(c,p){p=(p&4)!==0;for(var g=0;g<c.length;g++){var x=c[g],k=x.event;x=x.listeners;t:{var E=void 0;if(p)for(var F=x.length-1;0<=F;F--){var W=x[F],nt=W.instance,mt=W.currentTarget;if(W=W.listener,nt!==E&&k.isPropagationStopped())break t;E=W,k.currentTarget=mt;try{E(k)}catch(Nt){Av(Nt)}k.currentTarget=null,E=nt}else for(F=0;F<x.length;F++){if(W=x[F],nt=W.instance,mt=W.currentTarget,W=W.listener,nt!==E&&k.isPropagationStopped())break t;E=W,k.currentTarget=mt;try{E(k)}catch(Nt){Av(Nt)}k.currentTarget=null,E=nt}}}}function Me(c,p){var g=p[pw];g===void 0&&(g=p[pw]=new Set);var x=c+"__bubble";g.has(x)||(zD(p,c,2,!1),g.add(x))}function eS(c,p,g){var x=0;p&&(x|=4),zD(g,c,x,p)}var vy="_reactListening"+Math.random().toString(36).slice(2);function nS(c){if(!c[vy]){c[vy]=!0,D_.forEach(function(g){g!=="selectionchange"&&(j6.has(g)||eS(g,!1,c),eS(g,!0,c))});var p=c.nodeType===9?c:c.ownerDocument;p===null||p[vy]||(p[vy]=!0,eS("selectionchange",!1,p))}}function zD(c,p,g,x){switch(f$(p)){case 2:var k=xj;break;case 8:k=wj;break;default:k=vS}g=k.bind(null,p,g,c),k=void 0,!Sw||p!=="touchstart"&&p!=="touchmove"&&p!=="wheel"||(k=!0),x?k!==void 0?c.addEventListener(p,g,{capture:!0,passive:k}):c.addEventListener(p,g,!0):k!==void 0?c.addEventListener(p,g,{passive:k}):c.addEventListener(p,g,!1)}function rS(c,p,g,x,k){var E=x;if((p&1)===0&&(p&2)===0&&x!==null)t:for(;;){if(x===null)return;var F=x.tag;if(F===3||F===4){var W=x.stateNode.containerInfo;if(W===k)break;if(F===4)for(F=x.return;F!==null;){var nt=F.tag;if((nt===3||nt===4)&&F.stateNode.containerInfo===k)return;F=F.return}for(;W!==null;){if(F=Mc(W),F===null)return;if(nt=F.tag,nt===5||nt===6||nt===26||nt===27){x=E=F;continue t}W=W.parentNode}}x=x.return}G_(function(){var mt=E,Nt=xw(g),_t=[];t:{var vt=yR.get(c);if(vt!==void 0){var wt=Iv,qt=c;switch(c){case"keypress":if(Tv(g)===0)break t;case"keydown":case"keyup":wt=zH;break;case"focusin":qt="focus",wt=Tw;break;case"focusout":qt="blur",wt=Tw;break;case"beforeblur":case"afterblur":wt=Tw;break;case"click":if(g.button===2)break t;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":wt=q_;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":wt=EH;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":wt=UH;break;case fR:case mR:case gR:wt=RH;break;case vR:wt=GH;break;case"scroll":case"scrollend":wt=kH;break;case"wheel":wt=jH;break;case"copy":case"cut":case"paste":wt=DH;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":wt=X_;break;case"toggle":case"beforetoggle":wt=KH}var le=(p&4)!==0,ln=!le&&(c==="scroll"||c==="scrollend"),ht=le?vt!==null?vt+"Capture":null:vt;le=[];for(var it=mt,ft;it!==null;){var Et=it;if(ft=Et.stateNode,Et=Et.tag,Et!==5&&Et!==26&&Et!==27||ft===null||ht===null||(Et=Ap(it,ht),Et!=null&&le.push(hf(it,Et,ft))),ln)break;it=it.return}0<le.length&&(vt=new wt(vt,qt,null,g,Nt),_t.push({event:vt,listeners:le}))}}if((p&7)===0){t:{if(vt=c==="mouseover"||c==="pointerover",wt=c==="mouseout"||c==="pointerout",vt&&g!==bw&&(qt=g.relatedTarget||g.fromElement)&&(Mc(qt)||qt[Fc]))break t;if((wt||vt)&&(vt=Nt.window===Nt?Nt:(vt=Nt.ownerDocument)?vt.defaultView||vt.parentWindow:window,wt?(qt=g.relatedTarget||g.toElement,wt=mt,qt=qt?Mc(qt):null,qt!==null&&(ln=s(qt),le=qt.tag,qt!==ln||le!==5&&le!==27&&le!==6)&&(qt=null)):(wt=null,qt=mt),wt!==qt)){if(le=q_,Et="onMouseLeave",ht="onMouseEnter",it="mouse",(c==="pointerout"||c==="pointerover")&&(le=X_,Et="onPointerLeave",ht="onPointerEnter",it="pointer"),ln=wt==null?vt:Rp(wt),ft=qt==null?vt:Rp(qt),vt=new le(Et,it+"leave",wt,g,Nt),vt.target=ln,vt.relatedTarget=ft,Et=null,Mc(Nt)===mt&&(le=new le(ht,it+"enter",qt,g,Nt),le.target=ft,le.relatedTarget=ln,Et=le),ln=Et,wt&&qt)e:{for(le=q6,ht=wt,it=qt,ft=0,Et=ht;Et;Et=le(Et))ft++;Et=0;for(var ie=it;ie;ie=le(ie))Et++;for(;0<ft-Et;)ht=le(ht),ft--;for(;0<Et-ft;)it=le(it),Et--;for(;ft--;){if(ht===it||it!==null&&ht===it.alternate){le=ht;break e}ht=le(ht),it=le(it)}le=null}else le=null;wt!==null&&PD(_t,vt,wt,le,!1),qt!==null&&ln!==null&&PD(_t,ln,qt,le,!0)}}t:{if(vt=mt?Rp(mt):window,wt=vt.nodeName&&vt.nodeName.toLowerCase(),wt==="select"||wt==="input"&&vt.type==="file")var qe=rR;else if(eR(vt))if(aR)qe=a6;else{qe=n6;var te=e6}else wt=vt.nodeName,!wt||wt.toLowerCase()!=="input"||vt.type!=="checkbox"&&vt.type!=="radio"?mt&&yw(mt.elementType)&&(qe=rR):qe=r6;if(qe&&(qe=qe(c,mt))){nR(_t,qe,g,Nt);break t}te&&te(c,vt,mt),c==="focusout"&&mt&&vt.type==="number"&&mt.memoizedProps.value!=null&&vw(vt,"number",vt.value)}switch(te=mt?Rp(mt):window,c){case"focusin":(eR(te)||te.contentEditable==="true")&&(Hc=te,Dw=mt,zp=null);break;case"focusout":zp=Dw=Hc=null;break;case"mousedown":$w=!0;break;case"contextmenu":case"mouseup":case"dragend":$w=!1,dR(_t,g,Nt);break;case"selectionchange":if(o6)break;case"keydown":case"keyup":dR(_t,g,Nt)}var Te;if(Iw)t:{switch(c){case"compositionstart":var Pe="onCompositionStart";break t;case"compositionend":Pe="onCompositionEnd";break t;case"compositionupdate":Pe="onCompositionUpdate";break t}Pe=void 0}else Gc?J_(c,g)&&(Pe="onCompositionEnd"):c==="keydown"&&g.keyCode===229&&(Pe="onCompositionStart");Pe&&(Y_&&g.locale!=="ko"&&(Gc||Pe!=="onCompositionStart"?Pe==="onCompositionEnd"&&Gc&&(Te=H_()):(Yi=Nt,Cw="value"in Yi?Yi.value:Yi.textContent,Gc=!0)),te=yy(mt,Pe),0<te.length&&(Pe=new K_(Pe,c,null,g,Nt),_t.push({event:Pe,listeners:te}),Te?Pe.data=Te:(Te=tR(g),Te!==null&&(Pe.data=Te)))),(Te=YH?QH(c,g):ZH(c,g))&&(Pe=yy(mt,"onBeforeInput"),0<Pe.length&&(te=new K_("onBeforeInput","beforeinput",null,g,Nt),_t.push({event:te,listeners:Pe}),te.data=Te)),W6(_t,c,mt,g,Nt)}BD(_t,p)})}function hf(c,p,g){return{instance:c,listener:p,currentTarget:g}}function yy(c,p){for(var g=p+"Capture",x=[];c!==null;){var k=c,E=k.stateNode;if(k=k.tag,k!==5&&k!==26&&k!==27||E===null||(k=Ap(c,g),k!=null&&x.unshift(hf(c,k,E)),k=Ap(c,p),k!=null&&x.push(hf(c,k,E))),c.tag===3)return x;c=c.return}return[]}function q6(c){if(c===null)return null;do c=c.return;while(c&&c.tag!==5&&c.tag!==27);return c||null}function PD(c,p,g,x,k){for(var E=p._reactName,F=[];g!==null&&g!==x;){var W=g,nt=W.alternate,mt=W.stateNode;if(W=W.tag,nt!==null&&nt===x)break;W!==5&&W!==26&&W!==27||mt===null||(nt=mt,k?(mt=Ap(g,E),mt!=null&&F.unshift(hf(g,mt,nt))):k||(mt=Ap(g,E),mt!=null&&F.push(hf(g,mt,nt)))),g=g.return}F.length!==0&&c.push({event:p,listeners:F})}var K6=/\r\n?/g,X6=/\u0000|\uFFFD/g;function VD(c){return(typeof c=="string"?c:""+c).replace(K6,`
`).replace(X6,"")}function UD(c,p){return p=VD(p),VD(c)===p}function un(c,p,g,x,k,E){switch(g){case"children":typeof x=="string"?p==="body"||p==="textarea"&&x===""||Vc(c,x):(typeof x=="number"||typeof x=="bigint")&&p!=="body"&&Vc(c,""+x);break;case"className":Sv(c,"class",x);break;case"tabIndex":Sv(c,"tabindex",x);break;case"dir":case"role":case"viewBox":case"width":case"height":Sv(c,g,x);break;case"style":U_(c,x,E);break;case"data":if(p!=="object"){Sv(c,"data",x);break}case"src":case"href":if(x===""&&(p!=="a"||g!=="href")){c.removeAttribute(g);break}if(x==null||typeof x=="function"||typeof x=="symbol"||typeof x=="boolean"){c.removeAttribute(g);break}x=Nv(""+x),c.setAttribute(g,x);break;case"action":case"formAction":if(typeof x=="function"){c.setAttribute(g,"javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')");break}else typeof E=="function"&&(g==="formAction"?(p!=="input"&&un(c,p,"name",k.name,k,null),un(c,p,"formEncType",k.formEncType,k,null),un(c,p,"formMethod",k.formMethod,k,null),un(c,p,"formTarget",k.formTarget,k,null)):(un(c,p,"encType",k.encType,k,null),un(c,p,"method",k.method,k,null),un(c,p,"target",k.target,k,null)));if(x==null||typeof x=="symbol"||typeof x=="boolean"){c.removeAttribute(g);break}x=Nv(""+x),c.setAttribute(g,x);break;case"onClick":x!=null&&(c.onclick=ni);break;case"onScroll":x!=null&&Me("scroll",c);break;case"onScrollEnd":x!=null&&Me("scrollend",c);break;case"dangerouslySetInnerHTML":if(x!=null){if(typeof x!="object"||!("__html"in x))throw Error(r(61));if(g=x.__html,g!=null){if(k.children!=null)throw Error(r(60));c.innerHTML=g}}break;case"multiple":c.multiple=x&&typeof x!="function"&&typeof x!="symbol";break;case"muted":c.muted=x&&typeof x!="function"&&typeof x!="symbol";break;case"suppressContentEditableWarning":case"suppressHydrationWarning":case"defaultValue":case"defaultChecked":case"innerHTML":case"ref":break;case"autoFocus":break;case"xlinkHref":if(x==null||typeof x=="function"||typeof x=="boolean"||typeof x=="symbol"){c.removeAttribute("xlink:href");break}g=Nv(""+x),c.setAttributeNS("http://www.w3.org/1999/xlink","xlink:href",g);break;case"contentEditable":case"spellCheck":case"draggable":case"value":case"autoReverse":case"externalResourcesRequired":case"focusable":case"preserveAlpha":x!=null&&typeof x!="function"&&typeof x!="symbol"?c.setAttribute(g,""+x):c.removeAttribute(g);break;case"inert":case"allowFullScreen":case"async":case"autoPlay":case"controls":case"default":case"defer":case"disabled":case"disablePictureInPicture":case"disableRemotePlayback":case"formNoValidate":case"hidden":case"loop":case"noModule":case"noValidate":case"open":case"playsInline":case"readOnly":case"required":case"reversed":case"scoped":case"seamless":case"itemScope":x&&typeof x!="function"&&typeof x!="symbol"?c.setAttribute(g,""):c.removeAttribute(g);break;case"capture":case"download":x===!0?c.setAttribute(g,""):x!==!1&&x!=null&&typeof x!="function"&&typeof x!="symbol"?c.setAttribute(g,x):c.removeAttribute(g);break;case"cols":case"rows":case"size":case"span":x!=null&&typeof x!="function"&&typeof x!="symbol"&&!isNaN(x)&&1<=x?c.setAttribute(g,x):c.removeAttribute(g);break;case"rowSpan":case"start":x==null||typeof x=="function"||typeof x=="symbol"||isNaN(x)?c.removeAttribute(g):c.setAttribute(g,x);break;case"popover":Me("beforetoggle",c),Me("toggle",c),wv(c,"popover",x);break;case"xlinkActuate":ei(c,"http://www.w3.org/1999/xlink","xlink:actuate",x);break;case"xlinkArcrole":ei(c,"http://www.w3.org/1999/xlink","xlink:arcrole",x);break;case"xlinkRole":ei(c,"http://www.w3.org/1999/xlink","xlink:role",x);break;case"xlinkShow":ei(c,"http://www.w3.org/1999/xlink","xlink:show",x);break;case"xlinkTitle":ei(c,"http://www.w3.org/1999/xlink","xlink:title",x);break;case"xlinkType":ei(c,"http://www.w3.org/1999/xlink","xlink:type",x);break;case"xmlBase":ei(c,"http://www.w3.org/XML/1998/namespace","xml:base",x);break;case"xmlLang":ei(c,"http://www.w3.org/XML/1998/namespace","xml:lang",x);break;case"xmlSpace":ei(c,"http://www.w3.org/XML/1998/namespace","xml:space",x);break;case"is":wv(c,"is",x);break;case"innerText":case"textContent":break;default:(!(2<g.length)||g[0]!=="o"&&g[0]!=="O"||g[1]!=="n"&&g[1]!=="N")&&(g=CH.get(g)||g,wv(c,g,x))}}function aS(c,p,g,x,k,E){switch(g){case"style":U_(c,x,E);break;case"dangerouslySetInnerHTML":if(x!=null){if(typeof x!="object"||!("__html"in x))throw Error(r(61));if(g=x.__html,g!=null){if(k.children!=null)throw Error(r(60));c.innerHTML=g}}break;case"children":typeof x=="string"?Vc(c,x):(typeof x=="number"||typeof x=="bigint")&&Vc(c,""+x);break;case"onScroll":x!=null&&Me("scroll",c);break;case"onScrollEnd":x!=null&&Me("scrollend",c);break;case"onClick":x!=null&&(c.onclick=ni);break;case"suppressContentEditableWarning":case"suppressHydrationWarning":case"innerHTML":case"ref":break;case"innerText":case"textContent":break;default:if(!$_.hasOwnProperty(g))t:{if(g[0]==="o"&&g[1]==="n"&&(k=g.endsWith("Capture"),p=g.slice(2,k?g.length-7:void 0),E=c[Ia]||null,E=E!=null?E[g]:null,typeof E=="function"&&c.removeEventListener(p,E,k),typeof x=="function")){typeof E!="function"&&E!==null&&(g in c?c[g]=null:c.hasAttribute(g)&&c.removeAttribute(g)),c.addEventListener(p,x,k);break t}g in c?c[g]=x:x===!0?c.setAttribute(g,""):wv(c,g,x)}}}function Xr(c,p,g){switch(p){case"div":case"span":case"svg":case"path":case"a":case"g":case"p":case"li":break;case"img":Me("error",c),Me("load",c);var x=!1,k=!1,E;for(E in g)if(g.hasOwnProperty(E)){var F=g[E];if(F!=null)switch(E){case"src":x=!0;break;case"srcSet":k=!0;break;case"children":case"dangerouslySetInnerHTML":throw Error(r(137,p));default:un(c,p,E,F,g,null)}}k&&un(c,p,"srcSet",g.srcSet,g,null),x&&un(c,p,"src",g.src,g,null);return;case"input":Me("invalid",c);var W=E=F=k=null,nt=null,mt=null;for(x in g)if(g.hasOwnProperty(x)){var Nt=g[x];if(Nt!=null)switch(x){case"name":k=Nt;break;case"type":F=Nt;break;case"checked":nt=Nt;break;case"defaultChecked":mt=Nt;break;case"value":E=Nt;break;case"defaultValue":W=Nt;break;case"children":case"dangerouslySetInnerHTML":if(Nt!=null)throw Error(r(137,p));break;default:un(c,p,x,Nt,g,null)}}B_(c,E,W,nt,mt,F,k,!1);return;case"select":Me("invalid",c),x=F=E=null;for(k in g)if(g.hasOwnProperty(k)&&(W=g[k],W!=null))switch(k){case"value":E=W;break;case"defaultValue":F=W;break;case"multiple":x=W;default:un(c,p,k,W,g,null)}p=E,g=F,c.multiple=!!x,p!=null?Pc(c,!!x,p,!1):g!=null&&Pc(c,!!x,g,!0);return;case"textarea":Me("invalid",c),E=k=x=null;for(F in g)if(g.hasOwnProperty(F)&&(W=g[F],W!=null))switch(F){case"value":x=W;break;case"defaultValue":k=W;break;case"children":E=W;break;case"dangerouslySetInnerHTML":if(W!=null)throw Error(r(91));break;default:un(c,p,F,W,g,null)}P_(c,x,k,E);return;case"option":for(nt in g)g.hasOwnProperty(nt)&&(x=g[nt],x!=null)&&(nt==="selected"?c.selected=x&&typeof x!="function"&&typeof x!="symbol":un(c,p,nt,x,g,null));return;case"dialog":Me("beforetoggle",c),Me("toggle",c),Me("cancel",c),Me("close",c);break;case"iframe":case"object":Me("load",c);break;case"video":case"audio":for(x=0;x<cf.length;x++)Me(cf[x],c);break;case"image":Me("error",c),Me("load",c);break;case"details":Me("toggle",c);break;case"embed":case"source":case"link":Me("error",c),Me("load",c);case"area":case"base":case"br":case"col":case"hr":case"keygen":case"meta":case"param":case"track":case"wbr":case"menuitem":for(mt in g)if(g.hasOwnProperty(mt)&&(x=g[mt],x!=null))switch(mt){case"children":case"dangerouslySetInnerHTML":throw Error(r(137,p));default:un(c,p,mt,x,g,null)}return;default:if(yw(p)){for(Nt in g)g.hasOwnProperty(Nt)&&(x=g[Nt],x!==void 0&&aS(c,p,Nt,x,g,void 0));return}}for(W in g)g.hasOwnProperty(W)&&(x=g[W],x!=null&&un(c,p,W,x,g,null))}function Y6(c,p,g,x){switch(p){case"div":case"span":case"svg":case"path":case"a":case"g":case"p":case"li":break;case"input":var k=null,E=null,F=null,W=null,nt=null,mt=null,Nt=null;for(wt in g){var _t=g[wt];if(g.hasOwnProperty(wt)&&_t!=null)switch(wt){case"checked":break;case"value":break;case"defaultValue":nt=_t;default:x.hasOwnProperty(wt)||un(c,p,wt,null,x,_t)}}for(var vt in x){var wt=x[vt];if(_t=g[vt],x.hasOwnProperty(vt)&&(wt!=null||_t!=null))switch(vt){case"type":E=wt;break;case"name":k=wt;break;case"checked":mt=wt;break;case"defaultChecked":Nt=wt;break;case"value":F=wt;break;case"defaultValue":W=wt;break;case"children":case"dangerouslySetInnerHTML":if(wt!=null)throw Error(r(137,p));break;default:wt!==_t&&un(c,p,vt,wt,x,_t)}}gw(c,F,W,nt,mt,Nt,E,k);return;case"select":wt=F=W=vt=null;for(E in g)if(nt=g[E],g.hasOwnProperty(E)&&nt!=null)switch(E){case"value":break;case"multiple":wt=nt;default:x.hasOwnProperty(E)||un(c,p,E,null,x,nt)}for(k in x)if(E=x[k],nt=g[k],x.hasOwnProperty(k)&&(E!=null||nt!=null))switch(k){case"value":vt=E;break;case"defaultValue":W=E;break;case"multiple":F=E;default:E!==nt&&un(c,p,k,E,x,nt)}p=W,g=F,x=wt,vt!=null?Pc(c,!!g,vt,!1):!!x!=!!g&&(p!=null?Pc(c,!!g,p,!0):Pc(c,!!g,g?[]:"",!1));return;case"textarea":wt=vt=null;for(W in g)if(k=g[W],g.hasOwnProperty(W)&&k!=null&&!x.hasOwnProperty(W))switch(W){case"value":break;case"children":break;default:un(c,p,W,null,x,k)}for(F in x)if(k=x[F],E=g[F],x.hasOwnProperty(F)&&(k!=null||E!=null))switch(F){case"value":vt=k;break;case"defaultValue":wt=k;break;case"children":break;case"dangerouslySetInnerHTML":if(k!=null)throw Error(r(91));break;default:k!==E&&un(c,p,F,k,x,E)}z_(c,vt,wt);return;case"option":for(var qt in g)vt=g[qt],g.hasOwnProperty(qt)&&vt!=null&&!x.hasOwnProperty(qt)&&(qt==="selected"?c.selected=!1:un(c,p,qt,null,x,vt));for(nt in x)vt=x[nt],wt=g[nt],x.hasOwnProperty(nt)&&vt!==wt&&(vt!=null||wt!=null)&&(nt==="selected"?c.selected=vt&&typeof vt!="function"&&typeof vt!="symbol":un(c,p,nt,vt,x,wt));return;case"img":case"link":case"area":case"base":case"br":case"col":case"embed":case"hr":case"keygen":case"meta":case"param":case"source":case"track":case"wbr":case"menuitem":for(var le in g)vt=g[le],g.hasOwnProperty(le)&&vt!=null&&!x.hasOwnProperty(le)&&un(c,p,le,null,x,vt);for(mt in x)if(vt=x[mt],wt=g[mt],x.hasOwnProperty(mt)&&vt!==wt&&(vt!=null||wt!=null))switch(mt){case"children":case"dangerouslySetInnerHTML":if(vt!=null)throw Error(r(137,p));break;default:un(c,p,mt,vt,x,wt)}return;default:if(yw(p)){for(var ln in g)vt=g[ln],g.hasOwnProperty(ln)&&vt!==void 0&&!x.hasOwnProperty(ln)&&aS(c,p,ln,void 0,x,vt);for(Nt in x)vt=x[Nt],wt=g[Nt],!x.hasOwnProperty(Nt)||vt===wt||vt===void 0&&wt===void 0||aS(c,p,Nt,vt,x,wt);return}}for(var ht in g)vt=g[ht],g.hasOwnProperty(ht)&&vt!=null&&!x.hasOwnProperty(ht)&&un(c,p,ht,null,x,vt);for(_t in x)vt=x[_t],wt=g[_t],!x.hasOwnProperty(_t)||vt===wt||vt==null&&wt==null||un(c,p,_t,vt,x,wt)}function WD(c){switch(c){case"css":case"script":case"font":case"img":case"image":case"input":case"link":return!0;default:return!1}}function Q6(){if(typeof performance.getEntriesByType=="function"){for(var c=0,p=0,g=performance.getEntriesByType("resource"),x=0;x<g.length;x++){var k=g[x],E=k.transferSize,F=k.initiatorType,W=k.duration;if(E&&W&&WD(F)){for(F=0,W=k.responseEnd,x+=1;x<g.length;x++){var nt=g[x],mt=nt.startTime;if(mt>W)break;var Nt=nt.transferSize,_t=nt.initiatorType;Nt&&WD(_t)&&(nt=nt.responseEnd,F+=Nt*(nt<W?1:(W-mt)/(nt-mt)))}if(--x,p+=8*(E+F)/(k.duration/1e3),c++,10<c)break}}if(0<c)return p/c/1e6}return navigator.connection&&(c=navigator.connection.downlink,typeof c=="number")?c:5}var sS=null,oS=null;function by(c){return c.nodeType===9?c:c.ownerDocument}function GD(c){switch(c){case"http://www.w3.org/2000/svg":return 1;case"http://www.w3.org/1998/Math/MathML":return 2;default:return 0}}function HD(c,p){if(c===0)switch(p){case"svg":return 1;case"math":return 2;default:return 0}return c===1&&p==="foreignObject"?0:c}function iS(c,p){return c==="textarea"||c==="noscript"||typeof p.children=="string"||typeof p.children=="number"||typeof p.children=="bigint"||typeof p.dangerouslySetInnerHTML=="object"&&p.dangerouslySetInnerHTML!==null&&p.dangerouslySetInnerHTML.__html!=null}var uS=null;function Z6(){var c=window.event;return c&&c.type==="popstate"?c===uS?!1:(uS=c,!0):(uS=null,!1)}var jD=typeof setTimeout=="function"?setTimeout:void 0,J6=typeof clearTimeout=="function"?clearTimeout:void 0,qD=typeof Promise=="function"?Promise:void 0,tj=typeof queueMicrotask=="function"?queueMicrotask:typeof qD<"u"?function(c){return qD.resolve(null).then(c).catch(ej)}:jD;function ej(c){setTimeout(function(){throw c})}function pu(c){return c==="head"}function KD(c,p){var g=p,x=0;do{var k=g.nextSibling;if(c.removeChild(g),k&&k.nodeType===8)if(g=k.data,g==="/$"||g==="/&"){if(x===0){c.removeChild(k),yh(p);return}x--}else if(g==="$"||g==="$?"||g==="$~"||g==="$!"||g==="&")x++;else if(g==="html")df(c.ownerDocument.documentElement);else if(g==="head"){g=c.ownerDocument.head,df(g);for(var E=g.firstChild;E;){var F=E.nextSibling,W=E.nodeName;E[_p]||W==="SCRIPT"||W==="STYLE"||W==="LINK"&&E.rel.toLowerCase()==="stylesheet"||g.removeChild(E),E=F}}else g==="body"&&df(c.ownerDocument.body);g=k}while(g);yh(p)}function XD(c,p){var g=c;c=0;do{var x=g.nextSibling;if(g.nodeType===1?p?(g._stashedDisplay=g.style.display,g.style.display="none"):(g.style.display=g._stashedDisplay||"",g.getAttribute("style")===""&&g.removeAttribute("style")):g.nodeType===3&&(p?(g._stashedText=g.nodeValue,g.nodeValue=""):g.nodeValue=g._stashedText||""),x&&x.nodeType===8)if(g=x.data,g==="/$"){if(c===0)break;c--}else g!=="$"&&g!=="$?"&&g!=="$~"&&g!=="$!"||c++;g=x}while(g)}function lS(c){var p=c.firstChild;for(p&&p.nodeType===10&&(p=p.nextSibling);p;){var g=p;switch(p=p.nextSibling,g.nodeName){case"HTML":case"HEAD":case"BODY":lS(g),fw(g);continue;case"SCRIPT":case"STYLE":continue;case"LINK":if(g.rel.toLowerCase()==="stylesheet")continue}c.removeChild(g)}}function nj(c,p,g,x){for(;c.nodeType===1;){var k=g;if(c.nodeName.toLowerCase()!==p.toLowerCase()){if(!x&&(c.nodeName!=="INPUT"||c.type!=="hidden"))break}else if(x){if(!c[_p])switch(p){case"meta":if(!c.hasAttribute("itemprop"))break;return c;case"link":if(E=c.getAttribute("rel"),E==="stylesheet"&&c.hasAttribute("data-precedence"))break;if(E!==k.rel||c.getAttribute("href")!==(k.href==null||k.href===""?null:k.href)||c.getAttribute("crossorigin")!==(k.crossOrigin==null?null:k.crossOrigin)||c.getAttribute("title")!==(k.title==null?null:k.title))break;return c;case"style":if(c.hasAttribute("data-precedence"))break;return c;case"script":if(E=c.getAttribute("src"),(E!==(k.src==null?null:k.src)||c.getAttribute("type")!==(k.type==null?null:k.type)||c.getAttribute("crossorigin")!==(k.crossOrigin==null?null:k.crossOrigin))&&E&&c.hasAttribute("async")&&!c.hasAttribute("itemprop"))break;return c;default:return c}}else if(p==="input"&&c.type==="hidden"){var E=k.name==null?null:""+k.name;if(k.type==="hidden"&&c.getAttribute("name")===E)return c}else return c;if(c=Rs(c.nextSibling),c===null)break}return null}function rj(c,p,g){if(p==="")return null;for(;c.nodeType!==3;)if((c.nodeType!==1||c.nodeName!=="INPUT"||c.type!=="hidden")&&!g||(c=Rs(c.nextSibling),c===null))return null;return c}function YD(c,p){for(;c.nodeType!==8;)if((c.nodeType!==1||c.nodeName!=="INPUT"||c.type!=="hidden")&&!p||(c=Rs(c.nextSibling),c===null))return null;return c}function cS(c){return c.data==="$?"||c.data==="$~"}function hS(c){return c.data==="$!"||c.data==="$?"&&c.ownerDocument.readyState!=="loading"}function aj(c,p){var g=c.ownerDocument;if(c.data==="$~")c._reactRetry=p;else if(c.data!=="$?"||g.readyState!=="loading")p();else{var x=function(){p(),g.removeEventListener("DOMContentLoaded",x)};g.addEventListener("DOMContentLoaded",x),c._reactRetry=x}}function Rs(c){for(;c!=null;c=c.nextSibling){var p=c.nodeType;if(p===1||p===3)break;if(p===8){if(p=c.data,p==="$"||p==="$!"||p==="$?"||p==="$~"||p==="&"||p==="F!"||p==="F")break;if(p==="/$"||p==="/&")return null}}return c}var dS=null;function QD(c){c=c.nextSibling;for(var p=0;c;){if(c.nodeType===8){var g=c.data;if(g==="/$"||g==="/&"){if(p===0)return Rs(c.nextSibling);p--}else g!=="$"&&g!=="$!"&&g!=="$?"&&g!=="$~"&&g!=="&"||p++}c=c.nextSibling}return null}function ZD(c){c=c.previousSibling;for(var p=0;c;){if(c.nodeType===8){var g=c.data;if(g==="$"||g==="$!"||g==="$?"||g==="$~"||g==="&"){if(p===0)return c;p--}else g!=="/$"&&g!=="/&"||p++}c=c.previousSibling}return null}function JD(c,p,g){switch(p=by(g),c){case"html":if(c=p.documentElement,!c)throw Error(r(452));return c;case"head":if(c=p.head,!c)throw Error(r(453));return c;case"body":if(c=p.body,!c)throw Error(r(454));return c;default:throw Error(r(451))}}function df(c){for(var p=c.attributes;p.length;)c.removeAttributeNode(p[0]);fw(c)}var As=new Map,t$=new Set;function xy(c){return typeof c.getRootNode=="function"?c.getRootNode():c.nodeType===9?c:c.ownerDocument}var yi=j.d;j.d={f:sj,r:oj,D:ij,C:uj,L:lj,m:cj,X:dj,S:hj,M:pj};function sj(){var c=yi.f(),p=hy();return c||p}function oj(c){var p=Lc(c);p!==null&&p.tag===5&&p.type==="form"?vA(p):yi.r(c)}var mh=typeof document>"u"?null:document;function e$(c,p,g){var x=mh;if(x&&typeof p=="string"&&p){var k=Cs(p);k='link[rel="'+c+'"][href="'+k+'"]',typeof g=="string"&&(k+='[crossorigin="'+g+'"]'),t$.has(k)||(t$.add(k),c={rel:c,crossOrigin:g,href:p},x.querySelector(k)===null&&(p=x.createElement("link"),Xr(p,"link",c),Ir(p),x.head.appendChild(p)))}}function ij(c){yi.D(c),e$("dns-prefetch",c,null)}function uj(c,p){yi.C(c,p),e$("preconnect",c,p)}function lj(c,p,g){yi.L(c,p,g);var x=mh;if(x&&c&&p){var k='link[rel="preload"][as="'+Cs(p)+'"]';p==="image"&&g&&g.imageSrcSet?(k+='[imagesrcset="'+Cs(g.imageSrcSet)+'"]',typeof g.imageSizes=="string"&&(k+='[imagesizes="'+Cs(g.imageSizes)+'"]')):k+='[href="'+Cs(c)+'"]';var E=k;switch(p){case"style":E=gh(c);break;case"script":E=vh(c)}As.has(E)||(c=d({rel:"preload",href:p==="image"&&g&&g.imageSrcSet?void 0:c,as:p},g),As.set(E,c),x.querySelector(k)!==null||p==="style"&&x.querySelector(pf(E))||p==="script"&&x.querySelector(ff(E))||(p=x.createElement("link"),Xr(p,"link",c),Ir(p),x.head.appendChild(p)))}}function cj(c,p){yi.m(c,p);var g=mh;if(g&&c){var x=p&&typeof p.as=="string"?p.as:"script",k='link[rel="modulepreload"][as="'+Cs(x)+'"][href="'+Cs(c)+'"]',E=k;switch(x){case"audioworklet":case"paintworklet":case"serviceworker":case"sharedworker":case"worker":case"script":E=vh(c)}if(!As.has(E)&&(c=d({rel:"modulepreload",href:c},p),As.set(E,c),g.querySelector(k)===null)){switch(x){case"audioworklet":case"paintworklet":case"serviceworker":case"sharedworker":case"worker":case"script":if(g.querySelector(ff(E)))return}x=g.createElement("link"),Xr(x,"link",c),Ir(x),g.head.appendChild(x)}}}function hj(c,p,g){yi.S(c,p,g);var x=mh;if(x&&c){var k=Bc(x).hoistableStyles,E=gh(c);p=p||"default";var F=k.get(E);if(!F){var W={loading:0,preload:null};if(F=x.querySelector(pf(E)))W.loading=5;else{c=d({rel:"stylesheet",href:c,"data-precedence":p},g),(g=As.get(E))&&pS(c,g);var nt=F=x.createElement("link");Ir(nt),Xr(nt,"link",c),nt._p=new Promise(function(mt,Nt){nt.onload=mt,nt.onerror=Nt}),nt.addEventListener("load",function(){W.loading|=1}),nt.addEventListener("error",function(){W.loading|=2}),W.loading|=4,wy(F,p,x)}F={type:"stylesheet",instance:F,count:1,state:W},k.set(E,F)}}}function dj(c,p){yi.X(c,p);var g=mh;if(g&&c){var x=Bc(g).hoistableScripts,k=vh(c),E=x.get(k);E||(E=g.querySelector(ff(k)),E||(c=d({src:c,async:!0},p),(p=As.get(k))&&fS(c,p),E=g.createElement("script"),Ir(E),Xr(E,"link",c),g.head.appendChild(E)),E={type:"script",instance:E,count:1,state:null},x.set(k,E))}}function pj(c,p){yi.M(c,p);var g=mh;if(g&&c){var x=Bc(g).hoistableScripts,k=vh(c),E=x.get(k);E||(E=g.querySelector(ff(k)),E||(c=d({src:c,async:!0,type:"module"},p),(p=As.get(k))&&fS(c,p),E=g.createElement("script"),Ir(E),Xr(E,"link",c),g.head.appendChild(E)),E={type:"script",instance:E,count:1,state:null},x.set(k,E))}}function n$(c,p,g,x){var k=(k=pt.current)?xy(k):null;if(!k)throw Error(r(446));switch(c){case"meta":case"title":return null;case"style":return typeof g.precedence=="string"&&typeof g.href=="string"?(p=gh(g.href),g=Bc(k).hoistableStyles,x=g.get(p),x||(x={type:"style",instance:null,count:0,state:null},g.set(p,x)),x):{type:"void",instance:null,count:0,state:null};case"link":if(g.rel==="stylesheet"&&typeof g.href=="string"&&typeof g.precedence=="string"){c=gh(g.href);var E=Bc(k).hoistableStyles,F=E.get(c);if(F||(k=k.ownerDocument||k,F={type:"stylesheet",instance:null,count:0,state:{loading:0,preload:null}},E.set(c,F),(E=k.querySelector(pf(c)))&&!E._p&&(F.instance=E,F.state.loading=5),As.has(c)||(g={rel:"preload",as:"style",href:g.href,crossOrigin:g.crossOrigin,integrity:g.integrity,media:g.media,hrefLang:g.hrefLang,referrerPolicy:g.referrerPolicy},As.set(c,g),E||fj(k,c,g,F.state))),p&&x===null)throw Error(r(528,""));return F}if(p&&x!==null)throw Error(r(529,""));return null;case"script":return p=g.async,g=g.src,typeof g=="string"&&p&&typeof p!="function"&&typeof p!="symbol"?(p=vh(g),g=Bc(k).hoistableScripts,x=g.get(p),x||(x={type:"script",instance:null,count:0,state:null},g.set(p,x)),x):{type:"void",instance:null,count:0,state:null};default:throw Error(r(444,c))}}function gh(c){return'href="'+Cs(c)+'"'}function pf(c){return'link[rel="stylesheet"]['+c+"]"}function r$(c){return d({},c,{"data-precedence":c.precedence,precedence:null})}function fj(c,p,g,x){c.querySelector('link[rel="preload"][as="style"]['+p+"]")?x.loading=1:(p=c.createElement("link"),x.preload=p,p.addEventListener("load",function(){return x.loading|=1}),p.addEventListener("error",function(){return x.loading|=2}),Xr(p,"link",g),Ir(p),c.head.appendChild(p))}function vh(c){return'[src="'+Cs(c)+'"]'}function ff(c){return"script[async]"+c}function a$(c,p,g){if(p.count++,p.instance===null)switch(p.type){case"style":var x=c.querySelector('style[data-href~="'+Cs(g.href)+'"]');if(x)return p.instance=x,Ir(x),x;var k=d({},g,{"data-href":g.href,"data-precedence":g.precedence,href:null,precedence:null});return x=(c.ownerDocument||c).createElement("style"),Ir(x),Xr(x,"style",k),wy(x,g.precedence,c),p.instance=x;case"stylesheet":k=gh(g.href);var E=c.querySelector(pf(k));if(E)return p.state.loading|=4,p.instance=E,Ir(E),E;x=r$(g),(k=As.get(k))&&pS(x,k),E=(c.ownerDocument||c).createElement("link"),Ir(E);var F=E;return F._p=new Promise(function(W,nt){F.onload=W,F.onerror=nt}),Xr(E,"link",x),p.state.loading|=4,wy(E,g.precedence,c),p.instance=E;case"script":return E=vh(g.src),(k=c.querySelector(ff(E)))?(p.instance=k,Ir(k),k):(x=g,(k=As.get(E))&&(x=d({},g),fS(x,k)),c=c.ownerDocument||c,k=c.createElement("script"),Ir(k),Xr(k,"link",x),c.head.appendChild(k),p.instance=k);case"void":return null;default:throw Error(r(443,p.type))}else p.type==="stylesheet"&&(p.state.loading&4)===0&&(x=p.instance,p.state.loading|=4,wy(x,g.precedence,c));return p.instance}function wy(c,p,g){for(var x=g.querySelectorAll('link[rel="stylesheet"][data-precedence],style[data-precedence]'),k=x.length?x[x.length-1]:null,E=k,F=0;F<x.length;F++){var W=x[F];if(W.dataset.precedence===p)E=W;else if(E!==k)break}E?E.parentNode.insertBefore(c,E.nextSibling):(p=g.nodeType===9?g.head:g,p.insertBefore(c,p.firstChild))}function pS(c,p){c.crossOrigin==null&&(c.crossOrigin=p.crossOrigin),c.referrerPolicy==null&&(c.referrerPolicy=p.referrerPolicy),c.title==null&&(c.title=p.title)}function fS(c,p){c.crossOrigin==null&&(c.crossOrigin=p.crossOrigin),c.referrerPolicy==null&&(c.referrerPolicy=p.referrerPolicy),c.integrity==null&&(c.integrity=p.integrity)}var Sy=null;function s$(c,p,g){if(Sy===null){var x=new Map,k=Sy=new Map;k.set(g,x)}else k=Sy,x=k.get(g),x||(x=new Map,k.set(g,x));if(x.has(c))return x;for(x.set(c,null),g=g.getElementsByTagName(c),k=0;k<g.length;k++){var E=g[k];if(!(E[_p]||E[Hr]||c==="link"&&E.getAttribute("rel")==="stylesheet")&&E.namespaceURI!=="http://www.w3.org/2000/svg"){var F=E.getAttribute(p)||"";F=c+F;var W=x.get(F);W?W.push(E):x.set(F,[E])}}return x}function o$(c,p,g){c=c.ownerDocument||c,c.head.insertBefore(g,p==="title"?c.querySelector("head > title"):null)}function mj(c,p,g){if(g===1||p.itemProp!=null)return!1;switch(c){case"meta":case"title":return!0;case"style":if(typeof p.precedence!="string"||typeof p.href!="string"||p.href==="")break;return!0;case"link":if(typeof p.rel!="string"||typeof p.href!="string"||p.href===""||p.onLoad||p.onError)break;return p.rel==="stylesheet"?(c=p.disabled,typeof p.precedence=="string"&&c==null):!0;case"script":if(p.async&&typeof p.async!="function"&&typeof p.async!="symbol"&&!p.onLoad&&!p.onError&&p.src&&typeof p.src=="string")return!0}return!1}function i$(c){return!(c.type==="stylesheet"&&(c.state.loading&3)===0)}function gj(c,p,g,x){if(g.type==="stylesheet"&&(typeof x.media!="string"||matchMedia(x.media).matches!==!1)&&(g.state.loading&4)===0){if(g.instance===null){var k=gh(x.href),E=p.querySelector(pf(k));if(E){p=E._p,p!==null&&typeof p=="object"&&typeof p.then=="function"&&(c.count++,c=Cy.bind(c),p.then(c,c)),g.state.loading|=4,g.instance=E,Ir(E);return}E=p.ownerDocument||p,x=r$(x),(k=As.get(k))&&pS(x,k),E=E.createElement("link"),Ir(E);var F=E;F._p=new Promise(function(W,nt){F.onload=W,F.onerror=nt}),Xr(E,"link",x),g.instance=E}c.stylesheets===null&&(c.stylesheets=new Map),c.stylesheets.set(g,p),(p=g.state.preload)&&(g.state.loading&3)===0&&(c.count++,g=Cy.bind(c),p.addEventListener("load",g),p.addEventListener("error",g))}}var mS=0;function vj(c,p){return c.stylesheets&&c.count===0&&ky(c,c.stylesheets),0<c.count||0<c.imgCount?function(g){var x=setTimeout(function(){if(c.stylesheets&&ky(c,c.stylesheets),c.unsuspend){var E=c.unsuspend;c.unsuspend=null,E()}},6e4+p);0<c.imgBytes&&mS===0&&(mS=62500*Q6());var k=setTimeout(function(){if(c.waitingForImages=!1,c.count===0&&(c.stylesheets&&ky(c,c.stylesheets),c.unsuspend)){var E=c.unsuspend;c.unsuspend=null,E()}},(c.imgBytes>mS?50:800)+p);return c.unsuspend=g,function(){c.unsuspend=null,clearTimeout(x),clearTimeout(k)}}:null}function Cy(){if(this.count--,this.count===0&&(this.imgCount===0||!this.waitingForImages)){if(this.stylesheets)ky(this,this.stylesheets);else if(this.unsuspend){var c=this.unsuspend;this.unsuspend=null,c()}}}var Ny=null;function ky(c,p){c.stylesheets=null,c.unsuspend!==null&&(c.count++,Ny=new Map,p.forEach(yj,c),Ny=null,Cy.call(c))}function yj(c,p){if(!(p.state.loading&4)){var g=Ny.get(c);if(g)var x=g.get(null);else{g=new Map,Ny.set(c,g);for(var k=c.querySelectorAll("link[data-precedence],style[data-precedence]"),E=0;E<k.length;E++){var F=k[E];(F.nodeName==="LINK"||F.getAttribute("media")!=="not all")&&(g.set(F.dataset.precedence,F),x=F)}x&&g.set(null,x)}k=p.instance,F=k.getAttribute("data-precedence"),E=g.get(F)||x,E===x&&g.set(null,k),g.set(F,k),this.count++,x=Cy.bind(this),k.addEventListener("load",x),k.addEventListener("error",x),E?E.parentNode.insertBefore(k,E.nextSibling):(c=c.nodeType===9?c.head:c,c.insertBefore(k,c.firstChild)),p.state.loading|=4}}var mf={$$typeof:N,Provider:null,Consumer:null,_currentValue:K,_currentValue2:K,_threadCount:0};function bj(c,p,g,x,k,E,F,W,nt){this.tag=1,this.containerInfo=c,this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.next=this.pendingContext=this.context=this.cancelPendingCommit=null,this.callbackPriority=0,this.expirationTimes=cw(-1),this.entangledLanes=this.shellSuspendCounter=this.errorRecoveryDisabledLanes=this.expiredLanes=this.warmLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=cw(0),this.hiddenUpdates=cw(null),this.identifierPrefix=x,this.onUncaughtError=k,this.onCaughtError=E,this.onRecoverableError=F,this.pooledCache=null,this.pooledCacheLanes=0,this.formState=nt,this.incompleteTransitions=new Map}function u$(c,p,g,x,k,E,F,W,nt,mt,Nt,_t){return c=new bj(c,p,g,F,nt,mt,Nt,_t,W),p=1,E===!0&&(p|=24),E=Za(3,null,null,p),c.current=E,E.stateNode=c,p=Kw(),p.refCount++,c.pooledCache=p,p.refCount++,E.memoizedState={element:x,isDehydrated:g,cache:p},Zw(E),c}function l$(c){return c?(c=Kc,c):Kc}function c$(c,p,g,x,k,E){k=l$(k),x.context===null?x.context=k:x.pendingContext=k,x=nu(p),x.payload={element:g},E=E===void 0?null:E,E!==null&&(x.callback=E),g=ru(c,x,p),g!==null&&(Oa(g,c,p),jp(g,c,p))}function h$(c,p){if(c=c.memoizedState,c!==null&&c.dehydrated!==null){var g=c.retryLane;c.retryLane=g!==0&&g<p?g:p}}function gS(c,p){h$(c,p),(c=c.alternate)&&h$(c,p)}function d$(c){if(c.tag===13||c.tag===31){var p=fl(c,67108864);p!==null&&Oa(p,c,67108864),gS(c,67108864)}}function p$(c){if(c.tag===13||c.tag===31){var p=rs();p=hw(p);var g=fl(c,p);g!==null&&Oa(g,c,p),gS(c,p)}}var Ty=!0;function xj(c,p,g,x){var k=B.T;B.T=null;var E=j.p;try{j.p=2,vS(c,p,g,x)}finally{j.p=E,B.T=k}}function wj(c,p,g,x){var k=B.T;B.T=null;var E=j.p;try{j.p=8,vS(c,p,g,x)}finally{j.p=E,B.T=k}}function vS(c,p,g,x){if(Ty){var k=yS(x);if(k===null)rS(c,p,x,Ey,g),m$(c,x);else if(Cj(k,c,p,g,x))x.stopPropagation();else if(m$(c,x),p&4&&-1<Sj.indexOf(c)){for(;k!==null;){var E=Lc(k);if(E!==null)switch(E.tag){case 3:if(E=E.stateNode,E.current.memoizedState.isDehydrated){var F=ll(E.pendingLanes);if(F!==0){var W=E;for(W.pendingLanes|=2,W.entangledLanes|=2;F;){var nt=1<<31-Gr(F);W.entanglements[1]|=nt,F&=~nt}vo(E),(Ye&6)===0&&(ly=Ge()+500,lf(0))}}break;case 31:case 13:W=fl(E,2),W!==null&&Oa(W,E,2),hy(),gS(E,2)}if(E=yS(x),E===null&&rS(c,p,x,Ey,g),E===k)break;k=E}k!==null&&x.stopPropagation()}else rS(c,p,x,null,g)}}function yS(c){return c=xw(c),bS(c)}var Ey=null;function bS(c){if(Ey=null,c=Mc(c),c!==null){var p=s(c);if(p===null)c=null;else{var g=p.tag;if(g===13){if(c=o(p),c!==null)return c;c=null}else if(g===31){if(c=i(p),c!==null)return c;c=null}else if(g===3){if(p.stateNode.current.memoizedState.isDehydrated)return p.tag===3?p.stateNode.containerInfo:null;c=null}else p!==c&&(c=null)}}return Ey=c,null}function f$(c){switch(c){case"beforetoggle":case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"toggle":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return 2;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return 8;case"message":switch(Ot()){case Ht:return 2;case Ce:return 8;case ge:case en:return 32;case hr:return 268435456;default:return 32}default:return 32}}var xS=!1,fu=null,mu=null,gu=null,gf=new Map,vf=new Map,vu=[],Sj="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(" ");function m$(c,p){switch(c){case"focusin":case"focusout":fu=null;break;case"dragenter":case"dragleave":mu=null;break;case"mouseover":case"mouseout":gu=null;break;case"pointerover":case"pointerout":gf.delete(p.pointerId);break;case"gotpointercapture":case"lostpointercapture":vf.delete(p.pointerId)}}function yf(c,p,g,x,k,E){return c===null||c.nativeEvent!==E?(c={blockedOn:p,domEventName:g,eventSystemFlags:x,nativeEvent:E,targetContainers:[k]},p!==null&&(p=Lc(p),p!==null&&d$(p)),c):(c.eventSystemFlags|=x,p=c.targetContainers,k!==null&&p.indexOf(k)===-1&&p.push(k),c)}function Cj(c,p,g,x,k){switch(p){case"focusin":return fu=yf(fu,c,p,g,x,k),!0;case"dragenter":return mu=yf(mu,c,p,g,x,k),!0;case"mouseover":return gu=yf(gu,c,p,g,x,k),!0;case"pointerover":var E=k.pointerId;return gf.set(E,yf(gf.get(E)||null,c,p,g,x,k)),!0;case"gotpointercapture":return E=k.pointerId,vf.set(E,yf(vf.get(E)||null,c,p,g,x,k)),!0}return!1}function g$(c){var p=Mc(c.target);if(p!==null){var g=s(p);if(g!==null){if(p=g.tag,p===13){if(p=o(g),p!==null){c.blockedOn=p,R_(c.priority,function(){p$(g)});return}}else if(p===31){if(p=i(g),p!==null){c.blockedOn=p,R_(c.priority,function(){p$(g)});return}}else if(p===3&&g.stateNode.current.memoizedState.isDehydrated){c.blockedOn=g.tag===3?g.stateNode.containerInfo:null;return}}}c.blockedOn=null}function Iy(c){if(c.blockedOn!==null)return!1;for(var p=c.targetContainers;0<p.length;){var g=yS(c.nativeEvent);if(g===null){g=c.nativeEvent;var x=new g.constructor(g.type,g);bw=x,g.target.dispatchEvent(x),bw=null}else return p=Lc(g),p!==null&&d$(p),c.blockedOn=g,!1;p.shift()}return!0}function v$(c,p,g){Iy(c)&&g.delete(p)}function Nj(){xS=!1,fu!==null&&Iy(fu)&&(fu=null),mu!==null&&Iy(mu)&&(mu=null),gu!==null&&Iy(gu)&&(gu=null),gf.forEach(v$),vf.forEach(v$)}function _y(c,p){c.blockedOn===p&&(c.blockedOn=null,xS||(xS=!0,n.unstable_scheduleCallback(n.unstable_NormalPriority,Nj)))}var Ry=null;function y$(c){Ry!==c&&(Ry=c,n.unstable_scheduleCallback(n.unstable_NormalPriority,function(){Ry===c&&(Ry=null);for(var p=0;p<c.length;p+=3){var g=c[p],x=c[p+1],k=c[p+2];if(typeof x!="function"){if(bS(x||g)===null)continue;break}var E=Lc(g);E!==null&&(c.splice(p,3),p-=3,y2(E,{pending:!0,data:k,method:g.method,action:x},x,k))}}))}function yh(c){function p(nt){return _y(nt,c)}fu!==null&&_y(fu,c),mu!==null&&_y(mu,c),gu!==null&&_y(gu,c),gf.forEach(p),vf.forEach(p);for(var g=0;g<vu.length;g++){var x=vu[g];x.blockedOn===c&&(x.blockedOn=null)}for(;0<vu.length&&(g=vu[0],g.blockedOn===null);)g$(g),g.blockedOn===null&&vu.shift();if(g=(c.ownerDocument||c).$$reactFormReplay,g!=null)for(x=0;x<g.length;x+=3){var k=g[x],E=g[x+1],F=k[Ia]||null;if(typeof E=="function")F||y$(g);else if(F){var W=null;if(E&&E.hasAttribute("formAction")){if(k=E,F=E[Ia]||null)W=F.formAction;else if(bS(k)!==null)continue}else W=F.action;typeof W=="function"?g[x+1]=W:(g.splice(x,3),x-=3),y$(g)}}}function b$(){function c(E){E.canIntercept&&E.info==="react-transition"&&E.intercept({handler:function(){return new Promise(function(F){return k=F})},focusReset:"manual",scroll:"manual"})}function p(){k!==null&&(k(),k=null),x||setTimeout(g,20)}function g(){if(!x&&!navigation.transition){var E=navigation.currentEntry;E&&E.url!=null&&navigation.navigate(E.url,{state:E.getState(),info:"react-transition",history:"replace"})}}if(typeof navigation=="object"){var x=!1,k=null;return navigation.addEventListener("navigate",c),navigation.addEventListener("navigatesuccess",p),navigation.addEventListener("navigateerror",p),setTimeout(g,100),function(){x=!0,navigation.removeEventListener("navigate",c),navigation.removeEventListener("navigatesuccess",p),navigation.removeEventListener("navigateerror",p),k!==null&&(k(),k=null)}}}function wS(c){this._internalRoot=c}Ay.prototype.render=wS.prototype.render=function(c){var p=this._internalRoot;if(p===null)throw Error(r(409));var g=p.current,x=rs();c$(g,x,c,p,null,null)},Ay.prototype.unmount=wS.prototype.unmount=function(){var c=this._internalRoot;if(c!==null){this._internalRoot=null;var p=c.containerInfo;c$(c.current,2,null,c,null,null),hy(),p[Fc]=null}};function Ay(c){this._internalRoot=c}Ay.prototype.unstable_scheduleHydration=function(c){if(c){var p=__();c={blockedOn:null,target:c,priority:p};for(var g=0;g<vu.length&&p!==0&&p<vu[g].priority;g++);vu.splice(g,0,c),g===0&&g$(c)}};var x$=t.version;if(x$!=="19.2.4")throw Error(r(527,x$,"19.2.4"));j.findDOMNode=function(c){var p=c._reactInternals;if(p===void 0)throw typeof c.render=="function"?Error(r(188)):(c=Object.keys(c).join(","),Error(r(268,c)));return c=l(p),c=c!==null?h(c):null,c=c===null?null:c.stateNode,c};var kj={bundleType:0,version:"19.2.4",rendererPackageName:"react-dom",currentDispatcherRef:B,reconcilerVersion:"19.2.4"};if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__<"u"){var Dy=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!Dy.isDisabled&&Dy.supportsFiber)try{Er=Dy.inject(kj),Dn=Dy}catch{}}return xf.createRoot=function(c,p){if(!a(c))throw Error(r(299));var g=!1,x="",k=EA,E=IA,F=_A;return p!=null&&(p.unstable_strictMode===!0&&(g=!0),p.identifierPrefix!==void 0&&(x=p.identifierPrefix),p.onUncaughtError!==void 0&&(k=p.onUncaughtError),p.onCaughtError!==void 0&&(E=p.onCaughtError),p.onRecoverableError!==void 0&&(F=p.onRecoverableError)),p=u$(c,1,!1,null,null,g,x,null,k,E,F,b$),c[Fc]=p.current,nS(c),new wS(p)},xf.hydrateRoot=function(c,p,g){if(!a(c))throw Error(r(299));var x=!1,k="",E=EA,F=IA,W=_A,nt=null;return g!=null&&(g.unstable_strictMode===!0&&(x=!0),g.identifierPrefix!==void 0&&(k=g.identifierPrefix),g.onUncaughtError!==void 0&&(E=g.onUncaughtError),g.onCaughtError!==void 0&&(F=g.onCaughtError),g.onRecoverableError!==void 0&&(W=g.onRecoverableError),g.formState!==void 0&&(nt=g.formState)),p=u$(c,1,!0,p,g??null,x,k,nt,E,F,W,b$),p.context=l$(null),g=p.current,x=rs(),x=hw(x),k=nu(x),k.callback=null,ru(g,k,x),g=x,p.current.lanes=g,Ip(p,g),vo(p),c[Fc]=p.current,nS(c),new Ay(p)},xf.version="19.2.4",xf}var R$;function Bj(){if(R$)return NS.exports;R$=1;function n(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(n)}catch(t){console.error(t)}}return n(),NS.exports=Lj(),NS.exports}var zj=Bj(),IS={exports:{}},_S,A$;function Pj(){if(A$)return _S;A$=1;var n="SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";return _S=n,_S}var RS,D$;function Vj(){if(D$)return RS;D$=1;var n=Pj();function t(){}function e(){}return e.resetWarningCache=t,RS=function(){function r(o,i,u,l,h,d){if(d!==n){var f=new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types");throw f.name="Invariant Violation",f}}r.isRequired=r;function a(){return r}var s={array:r,bigint:r,bool:r,func:r,number:r,object:r,string:r,symbol:r,any:r,arrayOf:a,element:r,elementType:r,instanceOf:a,node:r,objectOf:a,oneOf:a,oneOfType:a,shape:a,exact:a,checkPropTypes:e,resetWarningCache:t};return s.PropTypes=s,s},RS}var $$;function Uj(){return $$||($$=1,IS.exports=Vj()()),IS.exports}var Wj=Uj();const pn=bm(Wj);function fc(n,t,e,r){function a(s){return s instanceof e?s:new e(function(o){o(s)})}return new(e||(e=Promise))(function(s,o){function i(h){try{l(r.next(h))}catch(d){o(d)}}function u(h){try{l(r.throw(h))}catch(d){o(d)}}function l(h){h.done?s(h.value):a(h.value).then(i,u)}l((r=r.apply(n,t||[])).next())})}const Gj=new Map([["1km","application/vnd.1000minds.decision-model+xml"],["3dml","text/vnd.in3d.3dml"],["3ds","image/x-3ds"],["3g2","video/3gpp2"],["3gp","video/3gp"],["3gpp","video/3gpp"],["3mf","model/3mf"],["7z","application/x-7z-compressed"],["7zip","application/x-7z-compressed"],["123","application/vnd.lotus-1-2-3"],["aab","application/x-authorware-bin"],["aac","audio/x-acc"],["aam","application/x-authorware-map"],["aas","application/x-authorware-seg"],["abw","application/x-abiword"],["ac","application/vnd.nokia.n-gage.ac+xml"],["ac3","audio/ac3"],["acc","application/vnd.americandynamics.acc"],["ace","application/x-ace-compressed"],["acu","application/vnd.acucobol"],["acutc","application/vnd.acucorp"],["adp","audio/adpcm"],["aep","application/vnd.audiograph"],["afm","application/x-font-type1"],["afp","application/vnd.ibm.modcap"],["ahead","application/vnd.ahead.space"],["ai","application/pdf"],["aif","audio/x-aiff"],["aifc","audio/x-aiff"],["aiff","audio/x-aiff"],["air","application/vnd.adobe.air-application-installer-package+zip"],["ait","application/vnd.dvb.ait"],["ami","application/vnd.amiga.ami"],["amr","audio/amr"],["apk","application/vnd.android.package-archive"],["apng","image/apng"],["appcache","text/cache-manifest"],["application","application/x-ms-application"],["apr","application/vnd.lotus-approach"],["arc","application/x-freearc"],["arj","application/x-arj"],["asc","application/pgp-signature"],["asf","video/x-ms-asf"],["asm","text/x-asm"],["aso","application/vnd.accpac.simply.aso"],["asx","video/x-ms-asf"],["atc","application/vnd.acucorp"],["atom","application/atom+xml"],["atomcat","application/atomcat+xml"],["atomdeleted","application/atomdeleted+xml"],["atomsvc","application/atomsvc+xml"],["atx","application/vnd.antix.game-component"],["au","audio/x-au"],["avi","video/x-msvideo"],["avif","image/avif"],["aw","application/applixware"],["azf","application/vnd.airzip.filesecure.azf"],["azs","application/vnd.airzip.filesecure.azs"],["azv","image/vnd.airzip.accelerator.azv"],["azw","application/vnd.amazon.ebook"],["b16","image/vnd.pco.b16"],["bat","application/x-msdownload"],["bcpio","application/x-bcpio"],["bdf","application/x-font-bdf"],["bdm","application/vnd.syncml.dm+wbxml"],["bdoc","application/x-bdoc"],["bed","application/vnd.realvnc.bed"],["bh2","application/vnd.fujitsu.oasysprs"],["bin","application/octet-stream"],["blb","application/x-blorb"],["blorb","application/x-blorb"],["bmi","application/vnd.bmi"],["bmml","application/vnd.balsamiq.bmml+xml"],["bmp","image/bmp"],["book","application/vnd.framemaker"],["box","application/vnd.previewsystems.box"],["boz","application/x-bzip2"],["bpk","application/octet-stream"],["bpmn","application/octet-stream"],["bsp","model/vnd.valve.source.compiled-map"],["btif","image/prs.btif"],["buffer","application/octet-stream"],["bz","application/x-bzip"],["bz2","application/x-bzip2"],["c","text/x-c"],["c4d","application/vnd.clonk.c4group"],["c4f","application/vnd.clonk.c4group"],["c4g","application/vnd.clonk.c4group"],["c4p","application/vnd.clonk.c4group"],["c4u","application/vnd.clonk.c4group"],["c11amc","application/vnd.cluetrust.cartomobile-config"],["c11amz","application/vnd.cluetrust.cartomobile-config-pkg"],["cab","application/vnd.ms-cab-compressed"],["caf","audio/x-caf"],["cap","application/vnd.tcpdump.pcap"],["car","application/vnd.curl.car"],["cat","application/vnd.ms-pki.seccat"],["cb7","application/x-cbr"],["cba","application/x-cbr"],["cbr","application/x-cbr"],["cbt","application/x-cbr"],["cbz","application/x-cbr"],["cc","text/x-c"],["cco","application/x-cocoa"],["cct","application/x-director"],["ccxml","application/ccxml+xml"],["cdbcmsg","application/vnd.contact.cmsg"],["cda","application/x-cdf"],["cdf","application/x-netcdf"],["cdfx","application/cdfx+xml"],["cdkey","application/vnd.mediastation.cdkey"],["cdmia","application/cdmi-capability"],["cdmic","application/cdmi-container"],["cdmid","application/cdmi-domain"],["cdmio","application/cdmi-object"],["cdmiq","application/cdmi-queue"],["cdr","application/cdr"],["cdx","chemical/x-cdx"],["cdxml","application/vnd.chemdraw+xml"],["cdy","application/vnd.cinderella"],["cer","application/pkix-cert"],["cfs","application/x-cfs-compressed"],["cgm","image/cgm"],["chat","application/x-chat"],["chm","application/vnd.ms-htmlhelp"],["chrt","application/vnd.kde.kchart"],["cif","chemical/x-cif"],["cii","application/vnd.anser-web-certificate-issue-initiation"],["cil","application/vnd.ms-artgalry"],["cjs","application/node"],["cla","application/vnd.claymore"],["class","application/octet-stream"],["clkk","application/vnd.crick.clicker.keyboard"],["clkp","application/vnd.crick.clicker.palette"],["clkt","application/vnd.crick.clicker.template"],["clkw","application/vnd.crick.clicker.wordbank"],["clkx","application/vnd.crick.clicker"],["clp","application/x-msclip"],["cmc","application/vnd.cosmocaller"],["cmdf","chemical/x-cmdf"],["cml","chemical/x-cml"],["cmp","application/vnd.yellowriver-custom-menu"],["cmx","image/x-cmx"],["cod","application/vnd.rim.cod"],["coffee","text/coffeescript"],["com","application/x-msdownload"],["conf","text/plain"],["cpio","application/x-cpio"],["cpp","text/x-c"],["cpt","application/mac-compactpro"],["crd","application/x-mscardfile"],["crl","application/pkix-crl"],["crt","application/x-x509-ca-cert"],["crx","application/x-chrome-extension"],["cryptonote","application/vnd.rig.cryptonote"],["csh","application/x-csh"],["csl","application/vnd.citationstyles.style+xml"],["csml","chemical/x-csml"],["csp","application/vnd.commonspace"],["csr","application/octet-stream"],["css","text/css"],["cst","application/x-director"],["csv","text/csv"],["cu","application/cu-seeme"],["curl","text/vnd.curl"],["cww","application/prs.cww"],["cxt","application/x-director"],["cxx","text/x-c"],["dae","model/vnd.collada+xml"],["daf","application/vnd.mobius.daf"],["dart","application/vnd.dart"],["dataless","application/vnd.fdsn.seed"],["davmount","application/davmount+xml"],["dbf","application/vnd.dbf"],["dbk","application/docbook+xml"],["dcr","application/x-director"],["dcurl","text/vnd.curl.dcurl"],["dd2","application/vnd.oma.dd2+xml"],["ddd","application/vnd.fujixerox.ddd"],["ddf","application/vnd.syncml.dmddf+xml"],["dds","image/vnd.ms-dds"],["deb","application/x-debian-package"],["def","text/plain"],["deploy","application/octet-stream"],["der","application/x-x509-ca-cert"],["dfac","application/vnd.dreamfactory"],["dgc","application/x-dgc-compressed"],["dic","text/x-c"],["dir","application/x-director"],["dis","application/vnd.mobius.dis"],["disposition-notification","message/disposition-notification"],["dist","application/octet-stream"],["distz","application/octet-stream"],["djv","image/vnd.djvu"],["djvu","image/vnd.djvu"],["dll","application/octet-stream"],["dmg","application/x-apple-diskimage"],["dmn","application/octet-stream"],["dmp","application/vnd.tcpdump.pcap"],["dms","application/octet-stream"],["dna","application/vnd.dna"],["doc","application/msword"],["docm","application/vnd.ms-word.template.macroEnabled.12"],["docx","application/vnd.openxmlformats-officedocument.wordprocessingml.document"],["dot","application/msword"],["dotm","application/vnd.ms-word.template.macroEnabled.12"],["dotx","application/vnd.openxmlformats-officedocument.wordprocessingml.template"],["dp","application/vnd.osgi.dp"],["dpg","application/vnd.dpgraph"],["dra","audio/vnd.dra"],["drle","image/dicom-rle"],["dsc","text/prs.lines.tag"],["dssc","application/dssc+der"],["dtb","application/x-dtbook+xml"],["dtd","application/xml-dtd"],["dts","audio/vnd.dts"],["dtshd","audio/vnd.dts.hd"],["dump","application/octet-stream"],["dvb","video/vnd.dvb.file"],["dvi","application/x-dvi"],["dwd","application/atsc-dwd+xml"],["dwf","model/vnd.dwf"],["dwg","image/vnd.dwg"],["dxf","image/vnd.dxf"],["dxp","application/vnd.spotfire.dxp"],["dxr","application/x-director"],["ear","application/java-archive"],["ecelp4800","audio/vnd.nuera.ecelp4800"],["ecelp7470","audio/vnd.nuera.ecelp7470"],["ecelp9600","audio/vnd.nuera.ecelp9600"],["ecma","application/ecmascript"],["edm","application/vnd.novadigm.edm"],["edx","application/vnd.novadigm.edx"],["efif","application/vnd.picsel"],["ei6","application/vnd.pg.osasli"],["elc","application/octet-stream"],["emf","image/emf"],["eml","message/rfc822"],["emma","application/emma+xml"],["emotionml","application/emotionml+xml"],["emz","application/x-msmetafile"],["eol","audio/vnd.digital-winds"],["eot","application/vnd.ms-fontobject"],["eps","application/postscript"],["epub","application/epub+zip"],["es","application/ecmascript"],["es3","application/vnd.eszigno3+xml"],["esa","application/vnd.osgi.subsystem"],["esf","application/vnd.epson.esf"],["et3","application/vnd.eszigno3+xml"],["etx","text/x-setext"],["eva","application/x-eva"],["evy","application/x-envoy"],["exe","application/octet-stream"],["exi","application/exi"],["exp","application/express"],["exr","image/aces"],["ext","application/vnd.novadigm.ext"],["ez","application/andrew-inset"],["ez2","application/vnd.ezpix-album"],["ez3","application/vnd.ezpix-package"],["f","text/x-fortran"],["f4v","video/mp4"],["f77","text/x-fortran"],["f90","text/x-fortran"],["fbs","image/vnd.fastbidsheet"],["fcdt","application/vnd.adobe.formscentral.fcdt"],["fcs","application/vnd.isac.fcs"],["fdf","application/vnd.fdf"],["fdt","application/fdt+xml"],["fe_launch","application/vnd.denovo.fcselayout-link"],["fg5","application/vnd.fujitsu.oasysgp"],["fgd","application/x-director"],["fh","image/x-freehand"],["fh4","image/x-freehand"],["fh5","image/x-freehand"],["fh7","image/x-freehand"],["fhc","image/x-freehand"],["fig","application/x-xfig"],["fits","image/fits"],["flac","audio/x-flac"],["fli","video/x-fli"],["flo","application/vnd.micrografx.flo"],["flv","video/x-flv"],["flw","application/vnd.kde.kivio"],["flx","text/vnd.fmi.flexstor"],["fly","text/vnd.fly"],["fm","application/vnd.framemaker"],["fnc","application/vnd.frogans.fnc"],["fo","application/vnd.software602.filler.form+xml"],["for","text/x-fortran"],["fpx","image/vnd.fpx"],["frame","application/vnd.framemaker"],["fsc","application/vnd.fsc.weblaunch"],["fst","image/vnd.fst"],["ftc","application/vnd.fluxtime.clip"],["fti","application/vnd.anser-web-funds-transfer-initiation"],["fvt","video/vnd.fvt"],["fxp","application/vnd.adobe.fxp"],["fxpl","application/vnd.adobe.fxp"],["fzs","application/vnd.fuzzysheet"],["g2w","application/vnd.geoplan"],["g3","image/g3fax"],["g3w","application/vnd.geospace"],["gac","application/vnd.groove-account"],["gam","application/x-tads"],["gbr","application/rpki-ghostbusters"],["gca","application/x-gca-compressed"],["gdl","model/vnd.gdl"],["gdoc","application/vnd.google-apps.document"],["geo","application/vnd.dynageo"],["geojson","application/geo+json"],["gex","application/vnd.geometry-explorer"],["ggb","application/vnd.geogebra.file"],["ggt","application/vnd.geogebra.tool"],["ghf","application/vnd.groove-help"],["gif","image/gif"],["gim","application/vnd.groove-identity-message"],["glb","model/gltf-binary"],["gltf","model/gltf+json"],["gml","application/gml+xml"],["gmx","application/vnd.gmx"],["gnumeric","application/x-gnumeric"],["gpg","application/gpg-keys"],["gph","application/vnd.flographit"],["gpx","application/gpx+xml"],["gqf","application/vnd.grafeq"],["gqs","application/vnd.grafeq"],["gram","application/srgs"],["gramps","application/x-gramps-xml"],["gre","application/vnd.geometry-explorer"],["grv","application/vnd.groove-injector"],["grxml","application/srgs+xml"],["gsf","application/x-font-ghostscript"],["gsheet","application/vnd.google-apps.spreadsheet"],["gslides","application/vnd.google-apps.presentation"],["gtar","application/x-gtar"],["gtm","application/vnd.groove-tool-message"],["gtw","model/vnd.gtw"],["gv","text/vnd.graphviz"],["gxf","application/gxf"],["gxt","application/vnd.geonext"],["gz","application/gzip"],["gzip","application/gzip"],["h","text/x-c"],["h261","video/h261"],["h263","video/h263"],["h264","video/h264"],["hal","application/vnd.hal+xml"],["hbci","application/vnd.hbci"],["hbs","text/x-handlebars-template"],["hdd","application/x-virtualbox-hdd"],["hdf","application/x-hdf"],["heic","image/heic"],["heics","image/heic-sequence"],["heif","image/heif"],["heifs","image/heif-sequence"],["hej2","image/hej2k"],["held","application/atsc-held+xml"],["hh","text/x-c"],["hjson","application/hjson"],["hlp","application/winhlp"],["hpgl","application/vnd.hp-hpgl"],["hpid","application/vnd.hp-hpid"],["hps","application/vnd.hp-hps"],["hqx","application/mac-binhex40"],["hsj2","image/hsj2"],["htc","text/x-component"],["htke","application/vnd.kenameaapp"],["htm","text/html"],["html","text/html"],["hvd","application/vnd.yamaha.hv-dic"],["hvp","application/vnd.yamaha.hv-voice"],["hvs","application/vnd.yamaha.hv-script"],["i2g","application/vnd.intergeo"],["icc","application/vnd.iccprofile"],["ice","x-conference/x-cooltalk"],["icm","application/vnd.iccprofile"],["ico","image/x-icon"],["ics","text/calendar"],["ief","image/ief"],["ifb","text/calendar"],["ifm","application/vnd.shana.informed.formdata"],["iges","model/iges"],["igl","application/vnd.igloader"],["igm","application/vnd.insors.igm"],["igs","model/iges"],["igx","application/vnd.micrografx.igx"],["iif","application/vnd.shana.informed.interchange"],["img","application/octet-stream"],["imp","application/vnd.accpac.simply.imp"],["ims","application/vnd.ms-ims"],["in","text/plain"],["ini","text/plain"],["ink","application/inkml+xml"],["inkml","application/inkml+xml"],["install","application/x-install-instructions"],["iota","application/vnd.astraea-software.iota"],["ipfix","application/ipfix"],["ipk","application/vnd.shana.informed.package"],["irm","application/vnd.ibm.rights-management"],["irp","application/vnd.irepository.package+xml"],["iso","application/x-iso9660-image"],["itp","application/vnd.shana.informed.formtemplate"],["its","application/its+xml"],["ivp","application/vnd.immervision-ivp"],["ivu","application/vnd.immervision-ivu"],["jad","text/vnd.sun.j2me.app-descriptor"],["jade","text/jade"],["jam","application/vnd.jam"],["jar","application/java-archive"],["jardiff","application/x-java-archive-diff"],["java","text/x-java-source"],["jhc","image/jphc"],["jisp","application/vnd.jisp"],["jls","image/jls"],["jlt","application/vnd.hp-jlyt"],["jng","image/x-jng"],["jnlp","application/x-java-jnlp-file"],["joda","application/vnd.joost.joda-archive"],["jp2","image/jp2"],["jpe","image/jpeg"],["jpeg","image/jpeg"],["jpf","image/jpx"],["jpg","image/jpeg"],["jpg2","image/jp2"],["jpgm","video/jpm"],["jpgv","video/jpeg"],["jph","image/jph"],["jpm","video/jpm"],["jpx","image/jpx"],["js","application/javascript"],["json","application/json"],["json5","application/json5"],["jsonld","application/ld+json"],["jsonl","application/jsonl"],["jsonml","application/jsonml+json"],["jsx","text/jsx"],["jxr","image/jxr"],["jxra","image/jxra"],["jxrs","image/jxrs"],["jxs","image/jxs"],["jxsc","image/jxsc"],["jxsi","image/jxsi"],["jxss","image/jxss"],["kar","audio/midi"],["karbon","application/vnd.kde.karbon"],["kdb","application/octet-stream"],["kdbx","application/x-keepass2"],["key","application/x-iwork-keynote-sffkey"],["kfo","application/vnd.kde.kformula"],["kia","application/vnd.kidspiration"],["kml","application/vnd.google-earth.kml+xml"],["kmz","application/vnd.google-earth.kmz"],["kne","application/vnd.kinar"],["knp","application/vnd.kinar"],["kon","application/vnd.kde.kontour"],["kpr","application/vnd.kde.kpresenter"],["kpt","application/vnd.kde.kpresenter"],["kpxx","application/vnd.ds-keypoint"],["ksp","application/vnd.kde.kspread"],["ktr","application/vnd.kahootz"],["ktx","image/ktx"],["ktx2","image/ktx2"],["ktz","application/vnd.kahootz"],["kwd","application/vnd.kde.kword"],["kwt","application/vnd.kde.kword"],["lasxml","application/vnd.las.las+xml"],["latex","application/x-latex"],["lbd","application/vnd.llamagraphics.life-balance.desktop"],["lbe","application/vnd.llamagraphics.life-balance.exchange+xml"],["les","application/vnd.hhe.lesson-player"],["less","text/less"],["lgr","application/lgr+xml"],["lha","application/octet-stream"],["link66","application/vnd.route66.link66+xml"],["list","text/plain"],["list3820","application/vnd.ibm.modcap"],["listafp","application/vnd.ibm.modcap"],["litcoffee","text/coffeescript"],["lnk","application/x-ms-shortcut"],["log","text/plain"],["lostxml","application/lost+xml"],["lrf","application/octet-stream"],["lrm","application/vnd.ms-lrm"],["ltf","application/vnd.frogans.ltf"],["lua","text/x-lua"],["luac","application/x-lua-bytecode"],["lvp","audio/vnd.lucent.voice"],["lwp","application/vnd.lotus-wordpro"],["lzh","application/octet-stream"],["m1v","video/mpeg"],["m2a","audio/mpeg"],["m2v","video/mpeg"],["m3a","audio/mpeg"],["m3u","text/plain"],["m3u8","application/vnd.apple.mpegurl"],["m4a","audio/x-m4a"],["m4p","application/mp4"],["m4s","video/iso.segment"],["m4u","application/vnd.mpegurl"],["m4v","video/x-m4v"],["m13","application/x-msmediaview"],["m14","application/x-msmediaview"],["m21","application/mp21"],["ma","application/mathematica"],["mads","application/mads+xml"],["maei","application/mmt-aei+xml"],["mag","application/vnd.ecowin.chart"],["maker","application/vnd.framemaker"],["man","text/troff"],["manifest","text/cache-manifest"],["map","application/json"],["mar","application/octet-stream"],["markdown","text/markdown"],["mathml","application/mathml+xml"],["mb","application/mathematica"],["mbk","application/vnd.mobius.mbk"],["mbox","application/mbox"],["mc1","application/vnd.medcalcdata"],["mcd","application/vnd.mcd"],["mcurl","text/vnd.curl.mcurl"],["md","text/markdown"],["mdb","application/x-msaccess"],["mdi","image/vnd.ms-modi"],["mdx","text/mdx"],["me","text/troff"],["mesh","model/mesh"],["meta4","application/metalink4+xml"],["metalink","application/metalink+xml"],["mets","application/mets+xml"],["mfm","application/vnd.mfmp"],["mft","application/rpki-manifest"],["mgp","application/vnd.osgeo.mapguide.package"],["mgz","application/vnd.proteus.magazine"],["mid","audio/midi"],["midi","audio/midi"],["mie","application/x-mie"],["mif","application/vnd.mif"],["mime","message/rfc822"],["mj2","video/mj2"],["mjp2","video/mj2"],["mjs","application/javascript"],["mk3d","video/x-matroska"],["mka","audio/x-matroska"],["mkd","text/x-markdown"],["mks","video/x-matroska"],["mkv","video/x-matroska"],["mlp","application/vnd.dolby.mlp"],["mmd","application/vnd.chipnuts.karaoke-mmd"],["mmf","application/vnd.smaf"],["mml","text/mathml"],["mmr","image/vnd.fujixerox.edmics-mmr"],["mng","video/x-mng"],["mny","application/x-msmoney"],["mobi","application/x-mobipocket-ebook"],["mods","application/mods+xml"],["mov","video/quicktime"],["movie","video/x-sgi-movie"],["mp2","audio/mpeg"],["mp2a","audio/mpeg"],["mp3","audio/mpeg"],["mp4","video/mp4"],["mp4a","audio/mp4"],["mp4s","application/mp4"],["mp4v","video/mp4"],["mp21","application/mp21"],["mpc","application/vnd.mophun.certificate"],["mpd","application/dash+xml"],["mpe","video/mpeg"],["mpeg","video/mpeg"],["mpg","video/mpeg"],["mpg4","video/mp4"],["mpga","audio/mpeg"],["mpkg","application/vnd.apple.installer+xml"],["mpm","application/vnd.blueice.multipass"],["mpn","application/vnd.mophun.application"],["mpp","application/vnd.ms-project"],["mpt","application/vnd.ms-project"],["mpy","application/vnd.ibm.minipay"],["mqy","application/vnd.mobius.mqy"],["mrc","application/marc"],["mrcx","application/marcxml+xml"],["ms","text/troff"],["mscml","application/mediaservercontrol+xml"],["mseed","application/vnd.fdsn.mseed"],["mseq","application/vnd.mseq"],["msf","application/vnd.epson.msf"],["msg","application/vnd.ms-outlook"],["msh","model/mesh"],["msi","application/x-msdownload"],["msl","application/vnd.mobius.msl"],["msm","application/octet-stream"],["msp","application/octet-stream"],["msty","application/vnd.muvee.style"],["mtl","model/mtl"],["mts","model/vnd.mts"],["mus","application/vnd.musician"],["musd","application/mmt-usd+xml"],["musicxml","application/vnd.recordare.musicxml+xml"],["mvb","application/x-msmediaview"],["mvt","application/vnd.mapbox-vector-tile"],["mwf","application/vnd.mfer"],["mxf","application/mxf"],["mxl","application/vnd.recordare.musicxml"],["mxmf","audio/mobile-xmf"],["mxml","application/xv+xml"],["mxs","application/vnd.triscape.mxs"],["mxu","video/vnd.mpegurl"],["n-gage","application/vnd.nokia.n-gage.symbian.install"],["n3","text/n3"],["nb","application/mathematica"],["nbp","application/vnd.wolfram.player"],["nc","application/x-netcdf"],["ncx","application/x-dtbncx+xml"],["nfo","text/x-nfo"],["ngdat","application/vnd.nokia.n-gage.data"],["nitf","application/vnd.nitf"],["nlu","application/vnd.neurolanguage.nlu"],["nml","application/vnd.enliven"],["nnd","application/vnd.noblenet-directory"],["nns","application/vnd.noblenet-sealer"],["nnw","application/vnd.noblenet-web"],["npx","image/vnd.net-fpx"],["nq","application/n-quads"],["nsc","application/x-conference"],["nsf","application/vnd.lotus-notes"],["nt","application/n-triples"],["ntf","application/vnd.nitf"],["numbers","application/x-iwork-numbers-sffnumbers"],["nzb","application/x-nzb"],["oa2","application/vnd.fujitsu.oasys2"],["oa3","application/vnd.fujitsu.oasys3"],["oas","application/vnd.fujitsu.oasys"],["obd","application/x-msbinder"],["obgx","application/vnd.openblox.game+xml"],["obj","model/obj"],["oda","application/oda"],["odb","application/vnd.oasis.opendocument.database"],["odc","application/vnd.oasis.opendocument.chart"],["odf","application/vnd.oasis.opendocument.formula"],["odft","application/vnd.oasis.opendocument.formula-template"],["odg","application/vnd.oasis.opendocument.graphics"],["odi","application/vnd.oasis.opendocument.image"],["odm","application/vnd.oasis.opendocument.text-master"],["odp","application/vnd.oasis.opendocument.presentation"],["ods","application/vnd.oasis.opendocument.spreadsheet"],["odt","application/vnd.oasis.opendocument.text"],["oga","audio/ogg"],["ogex","model/vnd.opengex"],["ogg","audio/ogg"],["ogv","video/ogg"],["ogx","application/ogg"],["omdoc","application/omdoc+xml"],["onepkg","application/onenote"],["onetmp","application/onenote"],["onetoc","application/onenote"],["onetoc2","application/onenote"],["opf","application/oebps-package+xml"],["opml","text/x-opml"],["oprc","application/vnd.palm"],["opus","audio/ogg"],["org","text/x-org"],["osf","application/vnd.yamaha.openscoreformat"],["osfpvg","application/vnd.yamaha.openscoreformat.osfpvg+xml"],["osm","application/vnd.openstreetmap.data+xml"],["otc","application/vnd.oasis.opendocument.chart-template"],["otf","font/otf"],["otg","application/vnd.oasis.opendocument.graphics-template"],["oth","application/vnd.oasis.opendocument.text-web"],["oti","application/vnd.oasis.opendocument.image-template"],["otp","application/vnd.oasis.opendocument.presentation-template"],["ots","application/vnd.oasis.opendocument.spreadsheet-template"],["ott","application/vnd.oasis.opendocument.text-template"],["ova","application/x-virtualbox-ova"],["ovf","application/x-virtualbox-ovf"],["owl","application/rdf+xml"],["oxps","application/oxps"],["oxt","application/vnd.openofficeorg.extension"],["p","text/x-pascal"],["p7a","application/x-pkcs7-signature"],["p7b","application/x-pkcs7-certificates"],["p7c","application/pkcs7-mime"],["p7m","application/pkcs7-mime"],["p7r","application/x-pkcs7-certreqresp"],["p7s","application/pkcs7-signature"],["p8","application/pkcs8"],["p10","application/x-pkcs10"],["p12","application/x-pkcs12"],["pac","application/x-ns-proxy-autoconfig"],["pages","application/x-iwork-pages-sffpages"],["pas","text/x-pascal"],["paw","application/vnd.pawaafile"],["pbd","application/vnd.powerbuilder6"],["pbm","image/x-portable-bitmap"],["pcap","application/vnd.tcpdump.pcap"],["pcf","application/x-font-pcf"],["pcl","application/vnd.hp-pcl"],["pclxl","application/vnd.hp-pclxl"],["pct","image/x-pict"],["pcurl","application/vnd.curl.pcurl"],["pcx","image/x-pcx"],["pdb","application/x-pilot"],["pde","text/x-processing"],["pdf","application/pdf"],["pem","application/x-x509-user-cert"],["pfa","application/x-font-type1"],["pfb","application/x-font-type1"],["pfm","application/x-font-type1"],["pfr","application/font-tdpfr"],["pfx","application/x-pkcs12"],["pgm","image/x-portable-graymap"],["pgn","application/x-chess-pgn"],["pgp","application/pgp"],["php","application/x-httpd-php"],["php3","application/x-httpd-php"],["php4","application/x-httpd-php"],["phps","application/x-httpd-php-source"],["phtml","application/x-httpd-php"],["pic","image/x-pict"],["pkg","application/octet-stream"],["pki","application/pkixcmp"],["pkipath","application/pkix-pkipath"],["pkpass","application/vnd.apple.pkpass"],["pl","application/x-perl"],["plb","application/vnd.3gpp.pic-bw-large"],["plc","application/vnd.mobius.plc"],["plf","application/vnd.pocketlearn"],["pls","application/pls+xml"],["pm","application/x-perl"],["pml","application/vnd.ctc-posml"],["png","image/png"],["pnm","image/x-portable-anymap"],["portpkg","application/vnd.macports.portpkg"],["pot","application/vnd.ms-powerpoint"],["potm","application/vnd.ms-powerpoint.presentation.macroEnabled.12"],["potx","application/vnd.openxmlformats-officedocument.presentationml.template"],["ppa","application/vnd.ms-powerpoint"],["ppam","application/vnd.ms-powerpoint.addin.macroEnabled.12"],["ppd","application/vnd.cups-ppd"],["ppm","image/x-portable-pixmap"],["pps","application/vnd.ms-powerpoint"],["ppsm","application/vnd.ms-powerpoint.slideshow.macroEnabled.12"],["ppsx","application/vnd.openxmlformats-officedocument.presentationml.slideshow"],["ppt","application/powerpoint"],["pptm","application/vnd.ms-powerpoint.presentation.macroEnabled.12"],["pptx","application/vnd.openxmlformats-officedocument.presentationml.presentation"],["pqa","application/vnd.palm"],["prc","application/x-pilot"],["pre","application/vnd.lotus-freelance"],["prf","application/pics-rules"],["provx","application/provenance+xml"],["ps","application/postscript"],["psb","application/vnd.3gpp.pic-bw-small"],["psd","application/x-photoshop"],["psf","application/x-font-linux-psf"],["pskcxml","application/pskc+xml"],["pti","image/prs.pti"],["ptid","application/vnd.pvi.ptid1"],["pub","application/x-mspublisher"],["pvb","application/vnd.3gpp.pic-bw-var"],["pwn","application/vnd.3m.post-it-notes"],["pya","audio/vnd.ms-playready.media.pya"],["pyv","video/vnd.ms-playready.media.pyv"],["qam","application/vnd.epson.quickanime"],["qbo","application/vnd.intu.qbo"],["qfx","application/vnd.intu.qfx"],["qps","application/vnd.publishare-delta-tree"],["qt","video/quicktime"],["qwd","application/vnd.quark.quarkxpress"],["qwt","application/vnd.quark.quarkxpress"],["qxb","application/vnd.quark.quarkxpress"],["qxd","application/vnd.quark.quarkxpress"],["qxl","application/vnd.quark.quarkxpress"],["qxt","application/vnd.quark.quarkxpress"],["ra","audio/x-realaudio"],["ram","audio/x-pn-realaudio"],["raml","application/raml+yaml"],["rapd","application/route-apd+xml"],["rar","application/x-rar"],["ras","image/x-cmu-raster"],["rcprofile","application/vnd.ipunplugged.rcprofile"],["rdf","application/rdf+xml"],["rdz","application/vnd.data-vision.rdz"],["relo","application/p2p-overlay+xml"],["rep","application/vnd.businessobjects"],["res","application/x-dtbresource+xml"],["rgb","image/x-rgb"],["rif","application/reginfo+xml"],["rip","audio/vnd.rip"],["ris","application/x-research-info-systems"],["rl","application/resource-lists+xml"],["rlc","image/vnd.fujixerox.edmics-rlc"],["rld","application/resource-lists-diff+xml"],["rm","audio/x-pn-realaudio"],["rmi","audio/midi"],["rmp","audio/x-pn-realaudio-plugin"],["rms","application/vnd.jcp.javame.midlet-rms"],["rmvb","application/vnd.rn-realmedia-vbr"],["rnc","application/relax-ng-compact-syntax"],["rng","application/xml"],["roa","application/rpki-roa"],["roff","text/troff"],["rp9","application/vnd.cloanto.rp9"],["rpm","audio/x-pn-realaudio-plugin"],["rpss","application/vnd.nokia.radio-presets"],["rpst","application/vnd.nokia.radio-preset"],["rq","application/sparql-query"],["rs","application/rls-services+xml"],["rsa","application/x-pkcs7"],["rsat","application/atsc-rsat+xml"],["rsd","application/rsd+xml"],["rsheet","application/urc-ressheet+xml"],["rss","application/rss+xml"],["rtf","text/rtf"],["rtx","text/richtext"],["run","application/x-makeself"],["rusd","application/route-usd+xml"],["rv","video/vnd.rn-realvideo"],["s","text/x-asm"],["s3m","audio/s3m"],["saf","application/vnd.yamaha.smaf-audio"],["sass","text/x-sass"],["sbml","application/sbml+xml"],["sc","application/vnd.ibm.secure-container"],["scd","application/x-msschedule"],["scm","application/vnd.lotus-screencam"],["scq","application/scvp-cv-request"],["scs","application/scvp-cv-response"],["scss","text/x-scss"],["scurl","text/vnd.curl.scurl"],["sda","application/vnd.stardivision.draw"],["sdc","application/vnd.stardivision.calc"],["sdd","application/vnd.stardivision.impress"],["sdkd","application/vnd.solent.sdkm+xml"],["sdkm","application/vnd.solent.sdkm+xml"],["sdp","application/sdp"],["sdw","application/vnd.stardivision.writer"],["sea","application/octet-stream"],["see","application/vnd.seemail"],["seed","application/vnd.fdsn.seed"],["sema","application/vnd.sema"],["semd","application/vnd.semd"],["semf","application/vnd.semf"],["senmlx","application/senml+xml"],["sensmlx","application/sensml+xml"],["ser","application/java-serialized-object"],["setpay","application/set-payment-initiation"],["setreg","application/set-registration-initiation"],["sfd-hdstx","application/vnd.hydrostatix.sof-data"],["sfs","application/vnd.spotfire.sfs"],["sfv","text/x-sfv"],["sgi","image/sgi"],["sgl","application/vnd.stardivision.writer-global"],["sgm","text/sgml"],["sgml","text/sgml"],["sh","application/x-sh"],["shar","application/x-shar"],["shex","text/shex"],["shf","application/shf+xml"],["shtml","text/html"],["sid","image/x-mrsid-image"],["sieve","application/sieve"],["sig","application/pgp-signature"],["sil","audio/silk"],["silo","model/mesh"],["sis","application/vnd.symbian.install"],["sisx","application/vnd.symbian.install"],["sit","application/x-stuffit"],["sitx","application/x-stuffitx"],["siv","application/sieve"],["skd","application/vnd.koan"],["skm","application/vnd.koan"],["skp","application/vnd.koan"],["skt","application/vnd.koan"],["sldm","application/vnd.ms-powerpoint.slide.macroenabled.12"],["sldx","application/vnd.openxmlformats-officedocument.presentationml.slide"],["slim","text/slim"],["slm","text/slim"],["sls","application/route-s-tsid+xml"],["slt","application/vnd.epson.salt"],["sm","application/vnd.stepmania.stepchart"],["smf","application/vnd.stardivision.math"],["smi","application/smil"],["smil","application/smil"],["smv","video/x-smv"],["smzip","application/vnd.stepmania.package"],["snd","audio/basic"],["snf","application/x-font-snf"],["so","application/octet-stream"],["spc","application/x-pkcs7-certificates"],["spdx","text/spdx"],["spf","application/vnd.yamaha.smaf-phrase"],["spl","application/x-futuresplash"],["spot","text/vnd.in3d.spot"],["spp","application/scvp-vp-response"],["spq","application/scvp-vp-request"],["spx","audio/ogg"],["sql","application/x-sql"],["src","application/x-wais-source"],["srt","application/x-subrip"],["sru","application/sru+xml"],["srx","application/sparql-results+xml"],["ssdl","application/ssdl+xml"],["sse","application/vnd.kodak-descriptor"],["ssf","application/vnd.epson.ssf"],["ssml","application/ssml+xml"],["sst","application/octet-stream"],["st","application/vnd.sailingtracker.track"],["stc","application/vnd.sun.xml.calc.template"],["std","application/vnd.sun.xml.draw.template"],["stf","application/vnd.wt.stf"],["sti","application/vnd.sun.xml.impress.template"],["stk","application/hyperstudio"],["stl","model/stl"],["stpx","model/step+xml"],["stpxz","model/step-xml+zip"],["stpz","model/step+zip"],["str","application/vnd.pg.format"],["stw","application/vnd.sun.xml.writer.template"],["styl","text/stylus"],["stylus","text/stylus"],["sub","text/vnd.dvb.subtitle"],["sus","application/vnd.sus-calendar"],["susp","application/vnd.sus-calendar"],["sv4cpio","application/x-sv4cpio"],["sv4crc","application/x-sv4crc"],["svc","application/vnd.dvb.service"],["svd","application/vnd.svd"],["svg","image/svg+xml"],["svgz","image/svg+xml"],["swa","application/x-director"],["swf","application/x-shockwave-flash"],["swi","application/vnd.aristanetworks.swi"],["swidtag","application/swid+xml"],["sxc","application/vnd.sun.xml.calc"],["sxd","application/vnd.sun.xml.draw"],["sxg","application/vnd.sun.xml.writer.global"],["sxi","application/vnd.sun.xml.impress"],["sxm","application/vnd.sun.xml.math"],["sxw","application/vnd.sun.xml.writer"],["t","text/troff"],["t3","application/x-t3vm-image"],["t38","image/t38"],["taglet","application/vnd.mynfc"],["tao","application/vnd.tao.intent-module-archive"],["tap","image/vnd.tencent.tap"],["tar","application/x-tar"],["tcap","application/vnd.3gpp2.tcap"],["tcl","application/x-tcl"],["td","application/urc-targetdesc+xml"],["teacher","application/vnd.smart.teacher"],["tei","application/tei+xml"],["teicorpus","application/tei+xml"],["tex","application/x-tex"],["texi","application/x-texinfo"],["texinfo","application/x-texinfo"],["text","text/plain"],["tfi","application/thraud+xml"],["tfm","application/x-tex-tfm"],["tfx","image/tiff-fx"],["tga","image/x-tga"],["tgz","application/x-tar"],["thmx","application/vnd.ms-officetheme"],["tif","image/tiff"],["tiff","image/tiff"],["tk","application/x-tcl"],["tmo","application/vnd.tmobile-livetv"],["toml","application/toml"],["torrent","application/x-bittorrent"],["tpl","application/vnd.groove-tool-template"],["tpt","application/vnd.trid.tpt"],["tr","text/troff"],["tra","application/vnd.trueapp"],["trig","application/trig"],["trm","application/x-msterminal"],["ts","video/mp2t"],["tsd","application/timestamped-data"],["tsv","text/tab-separated-values"],["ttc","font/collection"],["ttf","font/ttf"],["ttl","text/turtle"],["ttml","application/ttml+xml"],["twd","application/vnd.simtech-mindmapper"],["twds","application/vnd.simtech-mindmapper"],["txd","application/vnd.genomatix.tuxedo"],["txf","application/vnd.mobius.txf"],["txt","text/plain"],["u8dsn","message/global-delivery-status"],["u8hdr","message/global-headers"],["u8mdn","message/global-disposition-notification"],["u8msg","message/global"],["u32","application/x-authorware-bin"],["ubj","application/ubjson"],["udeb","application/x-debian-package"],["ufd","application/vnd.ufdl"],["ufdl","application/vnd.ufdl"],["ulx","application/x-glulx"],["umj","application/vnd.umajin"],["unityweb","application/vnd.unity"],["uoml","application/vnd.uoml+xml"],["uri","text/uri-list"],["uris","text/uri-list"],["urls","text/uri-list"],["usdz","model/vnd.usdz+zip"],["ustar","application/x-ustar"],["utz","application/vnd.uiq.theme"],["uu","text/x-uuencode"],["uva","audio/vnd.dece.audio"],["uvd","application/vnd.dece.data"],["uvf","application/vnd.dece.data"],["uvg","image/vnd.dece.graphic"],["uvh","video/vnd.dece.hd"],["uvi","image/vnd.dece.graphic"],["uvm","video/vnd.dece.mobile"],["uvp","video/vnd.dece.pd"],["uvs","video/vnd.dece.sd"],["uvt","application/vnd.dece.ttml+xml"],["uvu","video/vnd.uvvu.mp4"],["uvv","video/vnd.dece.video"],["uvva","audio/vnd.dece.audio"],["uvvd","application/vnd.dece.data"],["uvvf","application/vnd.dece.data"],["uvvg","image/vnd.dece.graphic"],["uvvh","video/vnd.dece.hd"],["uvvi","image/vnd.dece.graphic"],["uvvm","video/vnd.dece.mobile"],["uvvp","video/vnd.dece.pd"],["uvvs","video/vnd.dece.sd"],["uvvt","application/vnd.dece.ttml+xml"],["uvvu","video/vnd.uvvu.mp4"],["uvvv","video/vnd.dece.video"],["uvvx","application/vnd.dece.unspecified"],["uvvz","application/vnd.dece.zip"],["uvx","application/vnd.dece.unspecified"],["uvz","application/vnd.dece.zip"],["vbox","application/x-virtualbox-vbox"],["vbox-extpack","application/x-virtualbox-vbox-extpack"],["vcard","text/vcard"],["vcd","application/x-cdlink"],["vcf","text/x-vcard"],["vcg","application/vnd.groove-vcard"],["vcs","text/x-vcalendar"],["vcx","application/vnd.vcx"],["vdi","application/x-virtualbox-vdi"],["vds","model/vnd.sap.vds"],["vhd","application/x-virtualbox-vhd"],["vis","application/vnd.visionary"],["viv","video/vnd.vivo"],["vlc","application/videolan"],["vmdk","application/x-virtualbox-vmdk"],["vob","video/x-ms-vob"],["vor","application/vnd.stardivision.writer"],["vox","application/x-authorware-bin"],["vrml","model/vrml"],["vsd","application/vnd.visio"],["vsf","application/vnd.vsf"],["vss","application/vnd.visio"],["vst","application/vnd.visio"],["vsw","application/vnd.visio"],["vtf","image/vnd.valve.source.texture"],["vtt","text/vtt"],["vtu","model/vnd.vtu"],["vxml","application/voicexml+xml"],["w3d","application/x-director"],["wad","application/x-doom"],["wadl","application/vnd.sun.wadl+xml"],["war","application/java-archive"],["wasm","application/wasm"],["wav","audio/x-wav"],["wax","audio/x-ms-wax"],["wbmp","image/vnd.wap.wbmp"],["wbs","application/vnd.criticaltools.wbs+xml"],["wbxml","application/wbxml"],["wcm","application/vnd.ms-works"],["wdb","application/vnd.ms-works"],["wdp","image/vnd.ms-photo"],["weba","audio/webm"],["webapp","application/x-web-app-manifest+json"],["webm","video/webm"],["webmanifest","application/manifest+json"],["webp","image/webp"],["wg","application/vnd.pmi.widget"],["wgt","application/widget"],["wks","application/vnd.ms-works"],["wm","video/x-ms-wm"],["wma","audio/x-ms-wma"],["wmd","application/x-ms-wmd"],["wmf","image/wmf"],["wml","text/vnd.wap.wml"],["wmlc","application/wmlc"],["wmls","text/vnd.wap.wmlscript"],["wmlsc","application/vnd.wap.wmlscriptc"],["wmv","video/x-ms-wmv"],["wmx","video/x-ms-wmx"],["wmz","application/x-msmetafile"],["woff","font/woff"],["woff2","font/woff2"],["word","application/msword"],["wpd","application/vnd.wordperfect"],["wpl","application/vnd.ms-wpl"],["wps","application/vnd.ms-works"],["wqd","application/vnd.wqd"],["wri","application/x-mswrite"],["wrl","model/vrml"],["wsc","message/vnd.wfa.wsc"],["wsdl","application/wsdl+xml"],["wspolicy","application/wspolicy+xml"],["wtb","application/vnd.webturbo"],["wvx","video/x-ms-wvx"],["x3d","model/x3d+xml"],["x3db","model/x3d+fastinfoset"],["x3dbz","model/x3d+binary"],["x3dv","model/x3d-vrml"],["x3dvz","model/x3d+vrml"],["x3dz","model/x3d+xml"],["x32","application/x-authorware-bin"],["x_b","model/vnd.parasolid.transmit.binary"],["x_t","model/vnd.parasolid.transmit.text"],["xaml","application/xaml+xml"],["xap","application/x-silverlight-app"],["xar","application/vnd.xara"],["xav","application/xcap-att+xml"],["xbap","application/x-ms-xbap"],["xbd","application/vnd.fujixerox.docuworks.binder"],["xbm","image/x-xbitmap"],["xca","application/xcap-caps+xml"],["xcs","application/calendar+xml"],["xdf","application/xcap-diff+xml"],["xdm","application/vnd.syncml.dm+xml"],["xdp","application/vnd.adobe.xdp+xml"],["xdssc","application/dssc+xml"],["xdw","application/vnd.fujixerox.docuworks"],["xel","application/xcap-el+xml"],["xenc","application/xenc+xml"],["xer","application/patch-ops-error+xml"],["xfdf","application/vnd.adobe.xfdf"],["xfdl","application/vnd.xfdl"],["xht","application/xhtml+xml"],["xhtml","application/xhtml+xml"],["xhvml","application/xv+xml"],["xif","image/vnd.xiff"],["xl","application/excel"],["xla","application/vnd.ms-excel"],["xlam","application/vnd.ms-excel.addin.macroEnabled.12"],["xlc","application/vnd.ms-excel"],["xlf","application/xliff+xml"],["xlm","application/vnd.ms-excel"],["xls","application/vnd.ms-excel"],["xlsb","application/vnd.ms-excel.sheet.binary.macroEnabled.12"],["xlsm","application/vnd.ms-excel.sheet.macroEnabled.12"],["xlsx","application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"],["xlt","application/vnd.ms-excel"],["xltm","application/vnd.ms-excel.template.macroEnabled.12"],["xltx","application/vnd.openxmlformats-officedocument.spreadsheetml.template"],["xlw","application/vnd.ms-excel"],["xm","audio/xm"],["xml","application/xml"],["xns","application/xcap-ns+xml"],["xo","application/vnd.olpc-sugar"],["xop","application/xop+xml"],["xpi","application/x-xpinstall"],["xpl","application/xproc+xml"],["xpm","image/x-xpixmap"],["xpr","application/vnd.is-xpr"],["xps","application/vnd.ms-xpsdocument"],["xpw","application/vnd.intercon.formnet"],["xpx","application/vnd.intercon.formnet"],["xsd","application/xml"],["xsl","application/xml"],["xslt","application/xslt+xml"],["xsm","application/vnd.syncml+xml"],["xspf","application/xspf+xml"],["xul","application/vnd.mozilla.xul+xml"],["xvm","application/xv+xml"],["xvml","application/xv+xml"],["xwd","image/x-xwindowdump"],["xyz","chemical/x-xyz"],["xz","application/x-xz"],["yaml","text/yaml"],["yang","application/yang"],["yin","application/yin+xml"],["yml","text/yaml"],["ymp","text/x-suse-ymp"],["z","application/x-compress"],["z1","application/x-zmachine"],["z2","application/x-zmachine"],["z3","application/x-zmachine"],["z4","application/x-zmachine"],["z5","application/x-zmachine"],["z6","application/x-zmachine"],["z7","application/x-zmachine"],["z8","application/x-zmachine"],["zaz","application/vnd.zzazz.deck+xml"],["zip","application/zip"],["zir","application/vnd.zul"],["zirz","application/vnd.zul"],["zmm","application/vnd.handheld-entertainment+xml"],["zsh","text/x-scriptzsh"]]);function qh(n,t,e){const r=Hj(n),{webkitRelativePath:a}=n,s=typeof t=="string"?t:typeof a=="string"&&a.length>0?a:`./${n.name}`;return typeof r.path!="string"&&O$(r,"path",s),O$(r,"relativePath",s),r}function Hj(n){const{name:t}=n;if(t&&t.lastIndexOf(".")!==-1&&!n.type){const r=t.split(".").pop().toLowerCase(),a=Gj.get(r);a&&Object.defineProperty(n,"type",{value:a,writable:!1,configurable:!1,enumerable:!0})}return n}function O$(n,t,e){Object.defineProperty(n,t,{value:e,writable:!1,configurable:!1,enumerable:!0})}const jj=[".DS_Store","Thumbs.db"];function qj(n){return fc(this,void 0,void 0,function*(){return _0(n)&&Kj(n.dataTransfer)?Zj(n.dataTransfer,n.type):Xj(n)?Yj(n):Array.isArray(n)&&n.every(t=>"getFile"in t&&typeof t.getFile=="function")?Qj(n):[]})}function Kj(n){return _0(n)}function Xj(n){return _0(n)&&_0(n.target)}function _0(n){return typeof n=="object"&&n!==null}function Yj(n){return YC(n.target.files).map(t=>qh(t))}function Qj(n){return fc(this,void 0,void 0,function*(){return(yield Promise.all(n.map(e=>e.getFile()))).map(e=>qh(e))})}function Zj(n,t){return fc(this,void 0,void 0,function*(){if(n.items){const e=YC(n.items).filter(a=>a.kind==="file");if(t!=="drop")return e;const r=yield Promise.all(e.map(Jj));return F$(NM(r))}return F$(YC(n.files).map(e=>qh(e)))})}function F$(n){return n.filter(t=>jj.indexOf(t.name)===-1)}function YC(n){if(n===null)return[];const t=[];for(let e=0;e<n.length;e++){const r=n[e];t.push(r)}return t}function Jj(n){if(typeof n.webkitGetAsEntry!="function")return M$(n);const t=n.webkitGetAsEntry();return t&&t.isDirectory?kM(t):M$(n,t)}function NM(n){return n.reduce((t,e)=>[...t,...Array.isArray(e)?NM(e):[e]],[])}function M$(n,t){return fc(this,void 0,void 0,function*(){var e;if(globalThis.isSecureContext&&typeof n.getAsFileSystemHandle=="function"){const s=yield n.getAsFileSystemHandle();if(s===null)throw new Error(`${n} is not a File`);if(s!==void 0){const o=yield s.getFile();return o.handle=s,qh(o)}}const r=n.getAsFile();if(!r)throw new Error(`${n} is not a File`);return qh(r,(e=t?.fullPath)!==null&&e!==void 0?e:void 0)})}function t5(n){return fc(this,void 0,void 0,function*(){return n.isDirectory?kM(n):e5(n)})}function kM(n){const t=n.createReader();return new Promise((e,r)=>{const a=[];function s(){t.readEntries(o=>fc(this,void 0,void 0,function*(){if(o.length){const i=Promise.all(o.map(t5));a.push(i),s()}else try{const i=yield Promise.all(a);e(i)}catch(i){r(i)}}),o=>{r(o)})}s()})}function e5(n){return fc(this,void 0,void 0,function*(){return new Promise((t,e)=>{n.file(r=>{const a=qh(r,n.fullPath);t(a)},r=>{e(r)})})})}var $y={},L$;function n5(){return L$||(L$=1,$y.__esModule=!0,$y.default=function(n,t){if(n&&t){var e=Array.isArray(t)?t:t.split(",");if(e.length===0)return!0;var r=n.name||"",a=(n.type||"").toLowerCase(),s=a.replace(/\/.*$/,"");return e.some(function(o){var i=o.trim().toLowerCase();return i.charAt(0)==="."?r.toLowerCase().endsWith(i):i.endsWith("/*")?s===i.replace(/\/.*$/,""):a===i})}return!0}),$y}var r5=n5();const AS=bm(r5);function B$(n){return o5(n)||s5(n)||EM(n)||a5()}function a5(){throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)}function s5(n){if(typeof Symbol<"u"&&n[Symbol.iterator]!=null||n["@@iterator"]!=null)return Array.from(n)}function o5(n){if(Array.isArray(n))return QC(n)}function z$(n,t){var e=Object.keys(n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(n);t&&(r=r.filter(function(a){return Object.getOwnPropertyDescriptor(n,a).enumerable})),e.push.apply(e,r)}return e}function P$(n){for(var t=1;t<arguments.length;t++){var e=arguments[t]!=null?arguments[t]:{};t%2?z$(Object(e),!0).forEach(function(r){TM(n,r,e[r])}):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(e)):z$(Object(e)).forEach(function(r){Object.defineProperty(n,r,Object.getOwnPropertyDescriptor(e,r))})}return n}function TM(n,t,e){return t in n?Object.defineProperty(n,t,{value:e,enumerable:!0,configurable:!0,writable:!0}):n[t]=e,n}function Gf(n,t){return l5(n)||u5(n,t)||EM(n,t)||i5()}function i5(){throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)}function EM(n,t){if(n){if(typeof n=="string")return QC(n,t);var e=Object.prototype.toString.call(n).slice(8,-1);if(e==="Object"&&n.constructor&&(e=n.constructor.name),e==="Map"||e==="Set")return Array.from(n);if(e==="Arguments"||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(e))return QC(n,t)}}function QC(n,t){(t==null||t>n.length)&&(t=n.length);for(var e=0,r=new Array(t);e<t;e++)r[e]=n[e];return r}function u5(n,t){var e=n==null?null:typeof Symbol<"u"&&n[Symbol.iterator]||n["@@iterator"];if(e!=null){var r=[],a=!0,s=!1,o,i;try{for(e=e.call(n);!(a=(o=e.next()).done)&&(r.push(o.value),!(t&&r.length===t));a=!0);}catch(u){s=!0,i=u}finally{try{!a&&e.return!=null&&e.return()}finally{if(s)throw i}}return r}}function l5(n){if(Array.isArray(n))return n}var c5=typeof AS=="function"?AS:AS.default,h5="file-invalid-type",d5="file-too-large",p5="file-too-small",f5="too-many-files",m5=function(){var t=arguments.length>0&&arguments[0]!==void 0?arguments[0]:"",e=t.split(","),r=e.length>1?"one of ".concat(e.join(", ")):e[0];return{code:h5,message:"File type must be ".concat(r)}},V$=function(t){return{code:d5,message:"File is larger than ".concat(t," ").concat(t===1?"byte":"bytes")}},U$=function(t){return{code:p5,message:"File is smaller than ".concat(t," ").concat(t===1?"byte":"bytes")}},g5={code:f5,message:"Too many files"};function v5(n){return n.type===""&&typeof n.getAsFile=="function"}function IM(n,t){var e=n.type==="application/x-moz-file"||c5(n,t)||v5(n);return[e,e?null:m5(t)]}function _M(n,t,e){if(Fl(n.size))if(Fl(t)&&Fl(e)){if(n.size>e)return[!1,V$(e)];if(n.size<t)return[!1,U$(t)]}else{if(Fl(t)&&n.size<t)return[!1,U$(t)];if(Fl(e)&&n.size>e)return[!1,V$(e)]}return[!0,null]}function Fl(n){return n!=null}function y5(n){var t=n.files,e=n.accept,r=n.minSize,a=n.maxSize,s=n.multiple,o=n.maxFiles,i=n.validator;return!s&&t.length>1||s&&o>=1&&t.length>o?!1:t.every(function(u){var l=IM(u,e),h=Gf(l,1),d=h[0],f=_M(u,r,a),m=Gf(f,1),v=m[0],y=i?i(u):null;return d&&v&&!y})}function R0(n){return typeof n.isPropagationStopped=="function"?n.isPropagationStopped():typeof n.cancelBubble<"u"?n.cancelBubble:!1}function wf(n){return n.dataTransfer?Array.prototype.some.call(n.dataTransfer.types,function(t){return t==="Files"||t==="application/x-moz-file"}):!!n.target&&!!n.target.files}function W$(n){n.preventDefault()}function b5(n){return n.indexOf("MSIE")!==-1||n.indexOf("Trident/")!==-1}function x5(n){return n.indexOf("Edge/")!==-1}function w5(){var n=arguments.length>0&&arguments[0]!==void 0?arguments[0]:window.navigator.userAgent;return b5(n)||x5(n)}function yo(){for(var n=arguments.length,t=new Array(n),e=0;e<n;e++)t[e]=arguments[e];return function(r){for(var a=arguments.length,s=new Array(a>1?a-1:0),o=1;o<a;o++)s[o-1]=arguments[o];return t.some(function(i){return!R0(r)&&i&&i.apply(void 0,[r].concat(s)),R0(r)})}}function S5(){return"showOpenFilePicker"in window}function C5(n){if(Fl(n)){var t=Object.entries(n).filter(function(e){var r=Gf(e,2),a=r[0],s=r[1],o=!0;return RM(a)||(console.warn('Skipped "'.concat(a,'" because it is not a valid MIME type. Check https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Common_types for a list of valid MIME types.')),o=!1),(!Array.isArray(s)||!s.every(AM))&&(console.warn('Skipped "'.concat(a,'" because an invalid file extension was provided.')),o=!1),o}).reduce(function(e,r){var a=Gf(r,2),s=a[0],o=a[1];return P$(P$({},e),{},TM({},s,o))},{});return[{description:"Files",accept:t}]}return n}function N5(n){if(Fl(n))return Object.entries(n).reduce(function(t,e){var r=Gf(e,2),a=r[0],s=r[1];return[].concat(B$(t),[a],B$(s))},[]).filter(function(t){return RM(t)||AM(t)}).join(",")}function k5(n){return n instanceof DOMException&&(n.name==="AbortError"||n.code===n.ABORT_ERR)}function T5(n){return n instanceof DOMException&&(n.name==="SecurityError"||n.code===n.SECURITY_ERR)}function RM(n){return n==="audio/*"||n==="video/*"||n==="image/*"||n==="text/*"||n==="application/*"||/\w+\/[-+.\w]+/g.test(n)}function AM(n){return/^.*\.[\w]+$/.test(n)}var E5=["children"],I5=["open"],_5=["refKey","role","onKeyDown","onFocus","onBlur","onClick","onDragEnter","onDragOver","onDragLeave","onDrop"],R5=["refKey","onChange","onClick"];function G$(n){return $5(n)||D5(n)||DM(n)||A5()}function A5(){throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)}function D5(n){if(typeof Symbol<"u"&&n[Symbol.iterator]!=null||n["@@iterator"]!=null)return Array.from(n)}function $5(n){if(Array.isArray(n))return ZC(n)}function DS(n,t){return M5(n)||F5(n,t)||DM(n,t)||O5()}function O5(){throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)}function DM(n,t){if(n){if(typeof n=="string")return ZC(n,t);var e=Object.prototype.toString.call(n).slice(8,-1);if(e==="Object"&&n.constructor&&(e=n.constructor.name),e==="Map"||e==="Set")return Array.from(n);if(e==="Arguments"||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(e))return ZC(n,t)}}function ZC(n,t){(t==null||t>n.length)&&(t=n.length);for(var e=0,r=new Array(t);e<t;e++)r[e]=n[e];return r}function F5(n,t){var e=n==null?null:typeof Symbol<"u"&&n[Symbol.iterator]||n["@@iterator"];if(e!=null){var r=[],a=!0,s=!1,o,i;try{for(e=e.call(n);!(a=(o=e.next()).done)&&(r.push(o.value),!(t&&r.length===t));a=!0);}catch(u){s=!0,i=u}finally{try{!a&&e.return!=null&&e.return()}finally{if(s)throw i}}return r}}function M5(n){if(Array.isArray(n))return n}function H$(n,t){var e=Object.keys(n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(n);t&&(r=r.filter(function(a){return Object.getOwnPropertyDescriptor(n,a).enumerable})),e.push.apply(e,r)}return e}function wn(n){for(var t=1;t<arguments.length;t++){var e=arguments[t]!=null?arguments[t]:{};t%2?H$(Object(e),!0).forEach(function(r){JC(n,r,e[r])}):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(e)):H$(Object(e)).forEach(function(r){Object.defineProperty(n,r,Object.getOwnPropertyDescriptor(e,r))})}return n}function JC(n,t,e){return t in n?Object.defineProperty(n,t,{value:e,enumerable:!0,configurable:!0,writable:!0}):n[t]=e,n}function A0(n,t){if(n==null)return{};var e=L5(n,t),r,a;if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(n);for(a=0;a<s.length;a++)r=s[a],!(t.indexOf(r)>=0)&&Object.prototype.propertyIsEnumerable.call(n,r)&&(e[r]=n[r])}return e}function L5(n,t){if(n==null)return{};var e={},r=Object.keys(n),a,s;for(s=0;s<r.length;s++)a=r[s],!(t.indexOf(a)>=0)&&(e[a]=n[a]);return e}var kk=fe.forwardRef(function(n,t){var e=n.children,r=A0(n,E5),a=OM(r),s=a.open,o=A0(a,I5);return fe.useImperativeHandle(t,function(){return{open:s}},[s]),Dj.createElement(fe.Fragment,null,e(wn(wn({},o),{},{open:s})))});kk.displayName="Dropzone";var $M={disabled:!1,getFilesFromEvent:qj,maxSize:1/0,minSize:0,multiple:!0,maxFiles:0,preventDropOnDocument:!0,noClick:!1,noKeyboard:!1,noDrag:!1,noDragEventsBubbling:!1,validator:null,useFsAccessApi:!1,autoFocus:!1};kk.defaultProps=$M;kk.propTypes={children:pn.func,accept:pn.objectOf(pn.arrayOf(pn.string)),multiple:pn.bool,preventDropOnDocument:pn.bool,noClick:pn.bool,noKeyboard:pn.bool,noDrag:pn.bool,noDragEventsBubbling:pn.bool,minSize:pn.number,maxSize:pn.number,maxFiles:pn.number,disabled:pn.bool,getFilesFromEvent:pn.func,onFileDialogCancel:pn.func,onFileDialogOpen:pn.func,useFsAccessApi:pn.bool,autoFocus:pn.bool,onDragEnter:pn.func,onDragLeave:pn.func,onDragOver:pn.func,onDrop:pn.func,onDropAccepted:pn.func,onDropRejected:pn.func,onError:pn.func,validator:pn.func};var tN={isFocused:!1,isFileDialogActive:!1,isDragActive:!1,isDragAccept:!1,isDragReject:!1,isDragGlobal:!1,acceptedFiles:[],fileRejections:[]};function OM(){var n=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{},t=wn(wn({},$M),n),e=t.accept,r=t.disabled,a=t.getFilesFromEvent,s=t.maxSize,o=t.minSize,i=t.multiple,u=t.maxFiles,l=t.onDragEnter,h=t.onDragLeave,d=t.onDragOver,f=t.onDrop,m=t.onDropAccepted,v=t.onDropRejected,y=t.onFileDialogCancel,b=t.onFileDialogOpen,w=t.useFsAccessApi,S=t.autoFocus,N=t.preventDropOnDocument,C=t.noClick,T=t.noKeyboard,I=t.noDrag,_=t.noDragEventsBubbling,$=t.onError,R=t.validator,D=fe.useMemo(function(){return N5(e)},[e]),A=fe.useMemo(function(){return C5(e)},[e]),L=fe.useMemo(function(){return typeof b=="function"?b:j$},[b]),H=fe.useMemo(function(){return typeof y=="function"?y:j$},[y]),G=fe.useRef(null),q=fe.useRef(null),B=fe.useReducer(B5,tN),j=DS(B,2),K=j[0],z=j[1],U=K.isFocused,M=K.isFileDialogActive,X=fe.useRef(typeof window<"u"&&window.isSecureContext&&w&&S5()),Q=function(){!X.current&&M&&setTimeout(function(){if(q.current){var Ht=q.current.files;Ht.length||(z({type:"closeDialog"}),H())}},300)};fe.useEffect(function(){return window.addEventListener("focus",Q,!1),function(){window.removeEventListener("focus",Q,!1)}},[q,M,H,X]);var rt=fe.useRef([]),ct=fe.useRef([]),pt=function(Ht){G.current&&G.current.contains(Ht.target)||(Ht.preventDefault(),rt.current=[])};fe.useEffect(function(){return N&&(document.addEventListener("dragover",W$,!1),document.addEventListener("drop",pt,!1)),function(){N&&(document.removeEventListener("dragover",W$),document.removeEventListener("drop",pt))}},[G,N]),fe.useEffect(function(){var Ot=function(hr){ct.current=[].concat(G$(ct.current),[hr.target]),wf(hr)&&z({isDragGlobal:!0,type:"setDragGlobal"})},Ht=function(hr){ct.current=ct.current.filter(function(Wr){return Wr!==hr.target&&Wr!==null}),!(ct.current.length>0)&&z({isDragGlobal:!1,type:"setDragGlobal"})},Ce=function(){ct.current=[],z({isDragGlobal:!1,type:"setDragGlobal"})},ge=function(){ct.current=[],z({isDragGlobal:!1,type:"setDragGlobal"})};return document.addEventListener("dragenter",Ot,!1),document.addEventListener("dragleave",Ht,!1),document.addEventListener("dragend",Ce,!1),document.addEventListener("drop",ge,!1),function(){document.removeEventListener("dragenter",Ot),document.removeEventListener("dragleave",Ht),document.removeEventListener("dragend",Ce),document.removeEventListener("drop",ge)}},[G]),fe.useEffect(function(){return!r&&S&&G.current&&G.current.focus(),function(){}},[G,S,r]);var yt=fe.useCallback(function(Ot){$?$(Ot):console.error(Ot)},[$]),Tt=fe.useCallback(function(Ot){Ot.preventDefault(),Ot.persist(),hn(Ot),rt.current=[].concat(G$(rt.current),[Ot.target]),wf(Ot)&&Promise.resolve(a(Ot)).then(function(Ht){if(!(R0(Ot)&&!_)){var Ce=Ht.length,ge=Ce>0&&y5({files:Ht,accept:D,minSize:o,maxSize:s,multiple:i,maxFiles:u,validator:R}),en=Ce>0&&!ge;z({isDragAccept:ge,isDragReject:en,isDragActive:!0,type:"setDraggedFiles"}),l&&l(Ot)}}).catch(function(Ht){return yt(Ht)})},[a,l,yt,_,D,o,s,i,u,R]),gt=fe.useCallback(function(Ot){Ot.preventDefault(),Ot.persist(),hn(Ot);var Ht=wf(Ot);if(Ht&&Ot.dataTransfer)try{Ot.dataTransfer.dropEffect="copy"}catch{}return Ht&&d&&d(Ot),!1},[d,_]),Rt=fe.useCallback(function(Ot){Ot.preventDefault(),Ot.persist(),hn(Ot);var Ht=rt.current.filter(function(ge){return G.current&&G.current.contains(ge)}),Ce=Ht.indexOf(Ot.target);Ce!==-1&&Ht.splice(Ce,1),rt.current=Ht,!(Ht.length>0)&&(z({type:"setDraggedFiles",isDragActive:!1,isDragAccept:!1,isDragReject:!1}),wf(Ot)&&h&&h(Ot))},[G,h,_]),At=fe.useCallback(function(Ot,Ht){var Ce=[],ge=[];Ot.forEach(function(en){var hr=IM(en,D),Wr=DS(hr,2),ti=Wr[0],Er=Wr[1],Dn=_M(en,o,s),dr=DS(Dn,2),Gr=dr[0],Np=dr[1],kp=R?R(en):null;if(ti&&Gr&&!kp)Ce.push(en);else{var Tp=[Er,Np];kp&&(Tp=Tp.concat(kp)),ge.push({file:en,errors:Tp.filter(function(Oc){return Oc})})}}),(!i&&Ce.length>1||i&&u>=1&&Ce.length>u)&&(Ce.forEach(function(en){ge.push({file:en,errors:[g5]})}),Ce.splice(0)),z({acceptedFiles:Ce,fileRejections:ge,type:"setFiles"}),f&&f(Ce,ge,Ht),ge.length>0&&v&&v(ge,Ht),Ce.length>0&&m&&m(Ce,Ht)},[z,i,D,o,s,u,f,m,v,R]),Lt=fe.useCallback(function(Ot){Ot.preventDefault(),Ot.persist(),hn(Ot),rt.current=[],wf(Ot)&&Promise.resolve(a(Ot)).then(function(Ht){R0(Ot)&&!_||At(Ht,Ot)}).catch(function(Ht){return yt(Ht)}),z({type:"reset"})},[a,At,yt,_]),Mt=fe.useCallback(function(){if(X.current){z({type:"openDialog"}),L();var Ot={multiple:i,types:A};window.showOpenFilePicker(Ot).then(function(Ht){return a(Ht)}).then(function(Ht){At(Ht,null),z({type:"closeDialog"})}).catch(function(Ht){k5(Ht)?(H(Ht),z({type:"closeDialog"})):T5(Ht)?(X.current=!1,q.current?(q.current.value=null,q.current.click()):yt(new Error("Cannot open the file picker because the https://developer.mozilla.org/en-US/docs/Web/API/File_System_Access_API is not supported and no <input> was provided."))):yt(Ht)});return}q.current&&(z({type:"openDialog"}),L(),q.current.value=null,q.current.click())},[z,L,H,w,At,yt,A,i]),Wt=fe.useCallback(function(Ot){!G.current||!G.current.isEqualNode(Ot.target)||(Ot.key===" "||Ot.key==="Enter"||Ot.keyCode===32||Ot.keyCode===13)&&(Ot.preventDefault(),Mt())},[G,Mt]),se=fe.useCallback(function(){z({type:"focus"})},[]),Xt=fe.useCallback(function(){z({type:"blur"})},[]),Se=fe.useCallback(function(){C||(w5()?setTimeout(Mt,0):Mt())},[C,Mt]),pe=function(Ht){return r?null:Ht},Xe=function(Ht){return T?null:pe(Ht)},We=function(Ht){return I?null:pe(Ht)},hn=function(Ht){_&&Ht.stopPropagation()},vn=fe.useMemo(function(){return function(){var Ot=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{},Ht=Ot.refKey,Ce=Ht===void 0?"ref":Ht,ge=Ot.role,en=Ot.onKeyDown,hr=Ot.onFocus,Wr=Ot.onBlur,ti=Ot.onClick,Er=Ot.onDragEnter,Dn=Ot.onDragOver,dr=Ot.onDragLeave,Gr=Ot.onDrop,Np=A0(Ot,_5);return wn(wn(JC({onKeyDown:Xe(yo(en,Wt)),onFocus:Xe(yo(hr,se)),onBlur:Xe(yo(Wr,Xt)),onClick:pe(yo(ti,Se)),onDragEnter:We(yo(Er,Tt)),onDragOver:We(yo(Dn,gt)),onDragLeave:We(yo(dr,Rt)),onDrop:We(yo(Gr,Lt)),role:typeof ge=="string"&&ge!==""?ge:"presentation"},Ce,G),!r&&!T?{tabIndex:0}:{}),Np)}},[G,Wt,se,Xt,Se,Tt,gt,Rt,Lt,T,I,r]),Hn=fe.useCallback(function(Ot){Ot.stopPropagation()},[]),Ge=fe.useMemo(function(){return function(){var Ot=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{},Ht=Ot.refKey,Ce=Ht===void 0?"ref":Ht,ge=Ot.onChange,en=Ot.onClick,hr=A0(Ot,R5),Wr=JC({accept:D,multiple:i,type:"file",style:{border:0,clip:"rect(0, 0, 0, 0)",clipPath:"inset(50%)",height:"1px",margin:"0 -1px -1px 0",overflow:"hidden",padding:0,position:"absolute",width:"1px",whiteSpace:"nowrap"},onChange:pe(yo(ge,Lt)),onClick:pe(yo(en,Hn)),tabIndex:-1},Ce,q);return wn(wn({},Wr),hr)}},[q,e,i,Lt,r]);return wn(wn({},K),{},{isFocused:U&&!r,getRootProps:vn,getInputProps:Ge,rootRef:G,inputRef:q,open:pe(Mt)})}function B5(n,t){switch(t.type){case"focus":return wn(wn({},n),{},{isFocused:!0});case"blur":return wn(wn({},n),{},{isFocused:!1});case"openDialog":return wn(wn({},tN),{},{isFileDialogActive:!0});case"closeDialog":return wn(wn({},n),{},{isFileDialogActive:!1});case"setDraggedFiles":return wn(wn({},n),{},{isDragActive:t.isDragActive,isDragAccept:t.isDragAccept,isDragReject:t.isDragReject});case"setFiles":return wn(wn({},n),{},{acceptedFiles:t.acceptedFiles,fileRejections:t.fileRejections,isDragReject:!1});case"setDragGlobal":return wn(wn({},n),{},{isDragGlobal:t.isDragGlobal});case"reset":return wn({},tN);default:return n}}function j$(){}const FM=(...n)=>n.filter((t,e,r)=>!!t&&t.trim()!==""&&r.indexOf(t)===e).join(" ").trim();const z5=n=>n.replace(/([a-z0-9])([A-Z])/g,"$1-$2").toLowerCase();const P5=n=>n.replace(/^([A-Z])|[\s-_]+(\w)/g,(t,e,r)=>r?r.toUpperCase():e.toLowerCase());const q$=n=>{const t=P5(n);return t.charAt(0).toUpperCase()+t.slice(1)};var V5={xmlns:"http://www.w3.org/2000/svg",width:24,height:24,viewBox:"0 0 24 24",fill:"none",stroke:"currentColor",strokeWidth:2,strokeLinecap:"round",strokeLinejoin:"round"};const U5=n=>{for(const t in n)if(t.startsWith("aria-")||t==="role"||t==="title")return!0;return!1};const W5=fe.forwardRef(({color:n="currentColor",size:t=24,strokeWidth:e=2,absoluteStrokeWidth:r,className:a="",children:s,iconNode:o,...i},u)=>fe.createElement("svg",{ref:u,...V5,width:t,height:t,stroke:n,strokeWidth:r?Number(e)*24/Number(t):e,className:FM("lucide",a),...!s&&!U5(i)&&{"aria-hidden":"true"},...i},[...o.map(([l,h])=>fe.createElement(l,h)),...Array.isArray(s)?s:[s]]));const Xu=(n,t)=>{const e=fe.forwardRef(({className:r,...a},s)=>fe.createElement(W5,{ref:s,iconNode:t,className:FM(`lucide-${z5(q$(n))}`,`lucide-${n}`,r),...a}));return e.displayName=q$(n),e};const G5=[["circle",{cx:"12",cy:"12",r:"10",key:"1mglay"}],["path",{d:"M4.929 4.929 19.07 19.071",key:"196cmz"}]],H5=Xu("ban",G5);const j5=[["path",{d:"M19 17h2c.6 0 1-.4 1-1v-3c0-.9-.7-1.7-1.5-1.9C18.7 10.6 16 10 16 10s-1.3-1.4-2.2-2.3c-.5-.4-1.1-.7-1.8-.7H5c-.6 0-1.1.4-1.4.9l-1.4 2.9A3.7 3.7 0 0 0 2 12v4c0 .6.4 1 1 1h2",key:"5owen"}],["circle",{cx:"7",cy:"17",r:"2",key:"u2ysq9"}],["path",{d:"M9 17h6",key:"r8uit2"}],["circle",{cx:"17",cy:"17",r:"2",key:"axvx0g"}]],q5=Xu("car",j5);const K5=[["path",{d:"M12 15V3",key:"m9g1x1"}],["path",{d:"M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4",key:"ih7n3h"}],["path",{d:"m7 10 5 5 5-5",key:"brsn70"}]],X5=Xu("download",K5);const Y5=[["path",{d:"M6 22a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h8a2.4 2.4 0 0 1 1.704.706l3.588 3.588A2.4 2.4 0 0 1 20 8v12a2 2 0 0 1-2 2z",key:"1oefj6"}],["path",{d:"M14 2v5a1 1 0 0 0 1 1h5",key:"wfsgrz"}],["path",{d:"M10 9H8",key:"b1mrlr"}],["path",{d:"M16 13H8",key:"t4e002"}],["path",{d:"M16 17H8",key:"z1uh3a"}]],Q5=Xu("file-text",Y5);const Z5=[["path",{d:"M12.83 2.18a2 2 0 0 0-1.66 0L2.6 6.08a1 1 0 0 0 0 1.83l8.58 3.91a2 2 0 0 0 1.66 0l8.58-3.9a1 1 0 0 0 0-1.83z",key:"zw3jo"}],["path",{d:"M2 12a1 1 0 0 0 .58.91l8.6 3.91a2 2 0 0 0 1.65 0l8.58-3.9A1 1 0 0 0 22 12",key:"1wduqc"}],["path",{d:"M2 17a1 1 0 0 0 .58.91l8.6 3.91a2 2 0 0 0 1.65 0l8.58-3.9A1 1 0 0 0 22 17",key:"kqbvx6"}]],J5=Xu("layers",Z5);const tq=[["path",{d:"M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8",key:"v9h5vc"}],["path",{d:"M21 3v5h-5",key:"1q7to0"}],["path",{d:"M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16",key:"3uifl3"}],["path",{d:"M8 16H3v5",key:"1cv678"}]],eq=Xu("refresh-cw",tq);const nq=[["path",{d:"M12 3v12",key:"1x0j5s"}],["path",{d:"m17 8-5-5-5 5",key:"7q97r8"}],["path",{d:"M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4",key:"ih7n3h"}]],rq=Xu("upload",nq);const aq=[["path",{d:"M19 21v-2a4 4 0 0 0-4-4H9a4 4 0 0 0-4 4v2",key:"975kel"}],["circle",{cx:"12",cy:"7",r:"4",key:"17ys0d"}]],K$=Xu("user",aq);const sq=1e-7,oq=1e-4;class Tk{constructor(t,e){this.backend=t,this.dataMover=e,this.data=new WeakMap,this.dataIdsCount=0}get(t){return this.data.has(t)||this.dataMover.moveData(this.backend,t),this.data.get(t)}set(t,e){this.dataIdsCount++,this.data.set(t,e)}has(t){return this.data.has(t)}delete(t){return this.dataIdsCount--,this.data.delete(t)}numDataIds(){return this.dataIdsCount}}class Db{refCount(t){return Fa("refCount")}incRef(t){return Fa("incRef")}timerAvailable(){return!0}time(t){return Fa("time")}read(t){return Fa("read")}readSync(t){return Fa("readSync")}readToGPU(t,e){return Fa("readToGPU")}numDataIds(){return Fa("numDataIds")}disposeData(t,e){return Fa("disposeData")}write(t,e,r){return Fa("write")}move(t,e,r,a,s){return Fa("move")}createTensorFromGPUData(t,e,r){return Fa("createTensorFromGPUData")}memory(){return Fa("memory")}floatPrecision(){return Fa("floatPrecision")}epsilon(){return this.floatPrecision()===32?sq:oq}dispose(){return Fa("dispose")}}function Fa(n){throw new Error(`'${n}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function Ek(n){let t=n.length,e=0;for(;t>0;)e=Math.random()*t|0,t--,Ni(n,t,e)}function iq(n,t){if(n.length!==t.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${n.length}Second array length was ${t.length}`);let e=n.length,r=0;for(;e>0;)r=Math.random()*e|0,e--,Ni(n,e,r),Ni(t,e,r)}function Ou(n,t,e){return Math.max(n,Math.min(t,e))}function $b(n){return n%2===0?n:n+1}function Ni(n,t,e){const r=n[t];n[t]=n[e],n[e]=r}function MM(n){let t=0;for(let e=0;e<n.length;e++)t+=n[e];return t}function uq(n,t){const e=Math.random();return t*e+(1-e)*n}function lq(n,t){let e=0;for(let r=0;r<n.length;r++){const a=Number(n[r])-Number(t[r]);e+=a*a}return e}function P(n,t){if(!n)throw new Error(typeof t=="string"?t:t())}function Br(n,t,e=""){P(De(n,t),()=>e+` Shapes ${n} and ${t} must match`)}function mc(n){P(n!=null,()=>"The input to the tensor constructor must be a non-null value.")}function xt(n){if(n.length===0)return 1;let t=n[0];for(let e=1;e<n.length;e++)t*=n[e];return t}function cq(n){return n.length===0}function LM(n,t){if(n===t)return!0;if(n==null||t==null||n.length!==t.length)return!1;for(let e=0;e<n.length;e++)if(n[e]!==null&&t[e]!==null&&n[e]!==t[e])return!1;return!0}function De(n,t){if(n===t)return!0;if(n==null||t==null||n.length!==t.length)return!1;for(let e=0;e<n.length;e++)if(n[e]!==t[e])return!1;return!0}function Zl(n){return n%1===0}function hq(n){if(Math.tanh!=null)return Math.tanh(n);if(n===1/0)return 1;if(n===-1/0)return-1;{const t=Math.exp(2*n);return(t-1)/(t+1)}}function D0(n){const t=Math.ceil(Math.sqrt(n));return[t,Math.ceil(n/t)]}function dq(n){const t=new Uint32Array(n);for(let e=0;e<n;++e)t[e]=e;return Ek(t),t}function jl(n,t){return t<=n.length?n:n+" ".repeat(t-n.length)}function eN(n,t=a=>0,e,r){return new Promise((a,s)=>{let o=0;const i=()=>{if(n()){a();return}o++;const u=t(o);if(e!=null&&o>=e){s();return}r!=null?r(i,u):setTimeout(i,u)};i()})}function Ik(n,t){let e=1,r=-1;for(let s=0;s<n.length;++s)if(n[s]>=0)e*=n[s];else if(n[s]===-1){if(r!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${s}`);r=s}else if(n[s]<0)throw Error(`Shapes can not be < 0. Found ${n[s]} at dim ${s}`);if(r===-1){if(t>0&&t!==e)throw Error(`Size(${t}) must match the product of shape ${n}`);return n}if(e===0)throw Error(`Cannot infer the missing size in [${n}] when there are 0 elements`);if(t%e!==0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${e}`);const a=n.slice();return a[r]=t/e,a}function _e(n,t){const e=t.length;return n=n==null?t.map((r,a)=>a):[].concat(n),P(n.every(r=>r>=-e&&r<e),()=>`All values in axis param must be in range [-${e}, ${e}) but got axis ${n}`),P(n.every(r=>Zl(r)),()=>`All values in axis param must be integers but got axis ${n}`),n.map(r=>r<0?e+r:r)}function Oi(n,t){const e=[],r=[],a=t!=null&&Array.isArray(t)&&t.length===0,s=t==null||a?null:_e(t,n).sort();let o=0;for(let i=0;i<n.length;++i){if(s!=null){if(s[o]===i&&n[i]!==1)throw new Error(`Can't squeeze axis ${i} since its dim '${n[i]}' is not 1`);(s[o]==null||s[o]>i)&&n[i]===1&&(e.push(n[i]),r.push(i)),s[o]<=i&&o++}n[i]!==1&&(e.push(n[i]),r.push(i))}return{newShape:e,keptDims:r}}function xr(n,t){return On(n,t)}function On(n,t){let e=null;if(n==null||n==="float32")e=new Float32Array(t);else if(n==="int32")e=new Int32Array(t);else if(n==="bool")e=new Uint8Array(t);else if(n==="string")e=new Array(t);else throw new Error(`Unknown data type ${n}`);return e}function BM(n,t){for(let e=0;e<n.length;e++){const r=n[e];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${t} being uploaded contains ${r}.`)}}function zM(n){return n==="bool"||n==="complex64"||n==="float32"||n==="int32"||n==="string"}function _k(n,t){return!(t==="complex64"||t==="float32"&&n!=="complex64"||t==="int32"&&n!=="float32"&&n!=="complex64"||t==="bool"&&n==="bool")}function Hf(n){if(n==="float32"||n==="int32")return 4;if(n==="complex64")return 8;if(n==="bool")return 1;throw new Error(`Unknown dtype ${n}`)}function PM(n){if(n==null)return 0;let t=0;return n.forEach(e=>t+=e.length),t}function Io(n){return typeof n=="string"||n instanceof String}function VM(n){return typeof n=="boolean"}function $0(n){return typeof n=="number"}function gc(n){return Array.isArray(n)?gc(n[0]):n instanceof Float32Array?"float32":n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray?"int32":$0(n)?"float32":Io(n)?"string":VM(n)?"bool":"float32"}function Fu(n){return!!(n&&n.constructor&&n.call&&n.apply)}function O0(n,t){for(let e=t;e<n;++e)if(n%e===0)return e;return n}function oe(n){const t=n.length;if(t<2)return[];const e=new Array(t-1);e[t-2]=n[t-1];for(let r=t-3;r>=0;--r)e[r]=e[r+1]*n[r+1];return e}function UM(n,t,e,r=!1){const a=new Array;if(t.length===1){const s=t[0]*(r?2:1);for(let o=0;o<s;o++)a[o]=e[n+o]}else{const s=t[0],o=t.slice(1),i=o.reduce((u,l)=>u*l)*(r?2:1);for(let u=0;u<s;u++)a[u]=UM(n+u*i,o,e,r)}return a}function ms(n,t,e=!1){if(n.length===0)return t[0];const r=n.reduce((a,s)=>a*s)*(e?2:1);if(r===0)return[];if(r!==t.length)throw new Error(`[${n}] does not match the input size ${t.length}${e?" for a complex tensor":""}.`);return UM(0,n,t,e)}function WM(n,t){if(Array.isArray(n))return n;if(t==="float32")return n instanceof Float32Array?n:new Float32Array(n);if(t==="int32")return n instanceof Int32Array?n:new Int32Array(n);if(t==="bool"||t==="string")return Uint8Array.from(new Int32Array(n));throw new Error(`Unknown dtype ${t}`)}function Ob(n,t){const e=Mr(n,t);for(let r=0;r<e.length;r++)e[r]=1;return e}function Mr(n,t){if(t==null||t==="float32"||t==="complex64")return new Float32Array(n);if(t==="int32")return new Int32Array(n);if(t==="bool")return new Uint8Array(n);throw new Error(`Unknown data type ${t}`)}function Rk(n,t){const e=n.reduce((r,a)=>r*a,1);if(t==null||t==="float32")return ms(n,new Float32Array(e));if(t==="int32")return ms(n,new Int32Array(e));if(t==="bool")return ms(n,new Uint8Array(e));throw new Error(`Unknown data type ${t}`)}function Ya(n){n.forEach(t=>{P(Number.isInteger(t)&&t>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${n}].`)})}function eo(n,t,e){if(t===0)return 0;if(t===1)return n[0];let r=n[n.length-1];for(let a=0;a<n.length-1;++a)r+=e[a]*n[a];return r}function vc(n,t,e){if(t===0)return[];if(t===1)return[n];const r=new Array(t);for(let a=0;a<r.length-1;++a)r[a]=Math.floor(n/e[a]),n-=r[a]*e[a];return r[r.length-1]=n,r}function Mu(n){return n&&n.then&&typeof n.then=="function"}const X$="tfjsflags";class GM{constructor(t){this.global=t,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=pq,this.populateURLFlags()}setPlatform(t,e){this.platform!=null&&(dt().getBool("IS_TEST")||dt().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${t}.`)),this.platformName=t,this.platform=e}registerFlag(t,e,r){if(this.flagRegistry[t]={evaluationFn:e,setHook:r},this.urlFlags[t]!=null){const a=this.urlFlags[t];dt().getBool("IS_TEST")||dt().getBool("PROD")||console.warn(`Setting feature override from URL ${t}: ${a}.`),this.set(t,a)}}async getAsync(t){return t in this.flags?this.flags[t]:(this.flags[t]=await this.evaluateFlag(t),this.flags[t])}get(t){if(t in this.flags)return this.flags[t];const e=this.evaluateFlag(t);if(Mu(e))throw new Error(`Flag ${t} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[t]=e,this.flags[t]}getNumber(t){return this.get(t)}getBool(t){return this.get(t)}getString(t){return this.get(t)}getFlags(){return this.flags}get features(){return this.flags}set(t,e){if(this.flagRegistry[t]==null)throw new Error(`Cannot set flag ${t} as it has not been registered.`);this.flags[t]=e,this.flagRegistry[t].setHook!=null&&this.flagRegistry[t].setHook(e)}evaluateFlag(t){if(this.flagRegistry[t]==null)throw new Error(`Cannot evaluate flag '${t}': no evaluation function found.`);return this.flagRegistry[t].evaluationFn()}setFlags(t){this.flags=Object.assign({},t)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;const t=this.getQueryParams(this.global.location.search);X$ in t&&t[X$].split(",").forEach(r=>{const[a,s]=r.split(":");this.urlFlags[a]=mq(a,s)})}}function pq(n){const t={};return n.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(e,...r)=>(fq(t,r[0],r[1]),r.join("="))),t}function fq(n,t,e){n[decodeURIComponent(t)]=decodeURIComponent(e||"")}function mq(n,t){const e=t.toLowerCase();return e==="true"||e==="false"?e==="true":`${+e}`===e?+e:t}function dt(){return Ak}let Ak=null;function gq(n){Ak=n}let $S;function HM(){if($S==null){let n;if(typeof window<"u")n=window;else if(typeof global<"u")n=global;else if(typeof process<"u")n=process;else if(typeof self<"u")n=self;else throw new Error("Could not find a global object");$S=n}return $S}function vq(){const n=HM();return n._tfGlobals==null&&(n._tfGlobals=new Map),n._tfGlobals}function Dk(n,t){const e=vq();if(e.has(n))return e.get(n);{const r=t();return e.set(n,r),e.get(n)}}const xm="Abs",hd="Acos",dd="Acosh",yc="Add",wm="AddN",Fb="All",Mb="Any",Sm="ArgMax",Cm="ArgMin",pd="Asin",fd="Asinh",md="Atan",gd="Atanh",vd="Atan2",Nm="AvgPool",Lb="AvgPoolGrad",km="AvgPool3D",Bb="AvgPool3DGrad",Tm="BatchMatMul",Em="BatchToSpaceND",zb="Bincount",Im="BitwiseAnd",jM="BroadcastTo",Pb="BroadcastArgs",yd="Cast",bd="Ceil",xd="ClipByValue",Vb="Complex",_m="ComplexAbs",Rm="Concat",Am="Conv2D",Ub="Conv2DBackpropFilter",Dm="Conv2DBackpropInput",$m="Conv3D",Wb="Conv3DBackpropFilterV2",Gb="Conv3DBackpropInputV2",wd="Cos",Sd="Cosh",Hb="Cumprod",Om="Cumsum",jb="CropAndResize",qb="DenseBincount",Kb="DepthToSpace",Fm="DepthwiseConv2dNative",Xb="DepthwiseConv2dNativeBackpropFilter",Yb="DepthwiseConv2dNativeBackpropInput",Qb="Diag",Mm="Dilation2D",F0="Dilation2DBackpropInput",M0="Dilation2DBackpropFilter",Zb="Draw",Cd="RealDiv",Jb="Einsum",Nd="Elu",tx="EluGrad",kd="Erf",Lm="Equal",Td="Exp",Bm="ExpandDims",Ed="Expm1",ex="FFT",nx="Fill",rx="FlipLeftRight",Id="Floor",_d="FloorDiv",zm="FusedBatchNorm",Pm="GatherV2",ax="GatherNd",Vm="Greater",Rd="GreaterEqual",Ad="Identity",sx="IFFT",ox="Imag",Dd="IsFinite",$d="IsInf",Od="IsNan",Um="LeakyRelu",Wm="Less",Gm="LessEqual",ix="LinSpace",Fd="Log",Md="Log1p",Hm="LogicalAnd",jm="LogicalNot",qm="LogicalOr",yq="LogicalXor",qM="LogSoftmax",bq="LowerBound",Km="LRN",ux="LRNGrad",xq="MatrixBandPart",Xm="Max",Ld="Maximum",Ym="MaxPool",lx="MaxPoolGrad",Qm="MaxPool3D",cx="MaxPool3DGrad",hx="MaxPoolWithArgmax",Zm="Mean",Jm="Min",Bd="Minimum",tg="MirrorPad",zd="Mod",dx="Multinomial",Pd="Multiply",eg="Neg",ng="NotEqual",px="NonMaxSuppressionV3",fx="NonMaxSuppressionV4",mx="NonMaxSuppressionV5",rg="OnesLike",ag="OneHot",sg="Pack",og="PadV2",wq="Pool",Vd="Pow",ig="Prelu",ug="Prod",gx="RaggedGather",vx="RaggedRange",yx="RaggedTensorToTensor",bx="Range",xx="Real",Ud="Reciprocal",Wd="Relu",lg="Reshape",cg="ResizeNearestNeighbor",wx="ResizeNearestNeighborGrad",hg="ResizeBilinear",Sx="ResizeBilinearGrad",Gd="Relu6",dg="Reverse",Hd="Round",jd="Rsqrt",Cx="ScatterNd",Nx="TensorScatterUpdate",kx="SearchSorted",pg="Select",qd="Selu",fg="Slice",Kd="Sin",Xd="Sinh",Yd="Sign",Qd="Sigmoid",Zd="Softplus",Jd="Sqrt",mg="Sum",gg="SpaceToBatchND",vg="SplitV",yg="Softmax",Tx="SparseFillEmptyRows",Ex="SparseReshape",Ix="SparseSegmentMean",_x="SparseSegmentSum",Rx="SparseToDense",tp="SquaredDifference",Ax="Square",bg="StaticRegexReplace",Dx="StridedSlice",$x="StringNGrams",Ox="StringSplit",Fx="StringToHashBucketFast",ep="Sub",np="Tan",rp="Tanh",ap="Tile",Mx="TopK",Lx="Transform",ql="Transpose",Bx="Unique",xg="Unpack",wg="UnsortedSegmentSum",Sq="UpperBound",Sg="ZerosLike",sp="Step",L0="FromPixels",zx="RotateWithOffset",jf="_FusedMatMul",qf="FusedConv2D",Kf="FusedDepthwiseConv2D";function is(...n){dt().getBool("IS_TEST")||dt().getBool("PROD")||console.warn(...n)}function Cq(...n){dt().getBool("IS_TEST")||dt().getBool("PROD")||console.log(...n)}const Kh=Dk("kernelRegistry",()=>new Map),Xf=Dk("gradRegistry",()=>new Map);function Yf(n,t){const e=$k(n,t);return Kh.get(e)}function nN(n){return Xf.get(n)}function B0(n){const t=Kh.entries(),e=[];for(;;){const{done:r,value:a}=t.next();if(r)break;const[s,o]=a,[i]=s.split("_");i===n&&e.push(o)}return e}function Px(n){const{kernelName:t,backendName:e}=n,r=$k(t,e);Kh.has(r)&&is(`The kernel '${t}' for backend '${e}' is already registered`),Kh.set(r,n)}function KM(n){const{kernelName:t}=n;Xf.has(t)&&dt().getBool("DEBUG")&&is(`Overriding the gradient for '${t}'`),Xf.set(t,n)}function Nq(n,t){const e=$k(n,t);if(!Kh.has(e))throw new Error(`The kernel '${n}' for backend '${t}' is not registered`);Kh.delete(e)}function kq(n){if(!Xf.has(n))throw new Error(`The gradient '${n}' for backend is not registered`);Xf.delete(n)}function Tq(n,t){B0(n).forEach(r=>{const a=Object.assign({},r,{backendName:t});Px(a)})}function $k(n,t){return`${t}_${n}`}function XM(n){return n instanceof Float32Array||n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray}var OS,Y$;function Eq(){if(Y$)return OS;Y$=1,OS=t;var n=null;try{n=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function t(D,A,L){this.low=D|0,this.high=A|0,this.unsigned=!!L}t.prototype.__isLong__,Object.defineProperty(t.prototype,"__isLong__",{value:!0});function e(D){return(D&&D.__isLong__)===!0}t.isLong=e;var r={},a={};function s(D,A){var L,H,G;return A?(D>>>=0,(G=0<=D&&D<256)&&(H=a[D],H)?H:(L=i(D,(D|0)<0?-1:0,!0),G&&(a[D]=L),L)):(D|=0,(G=-128<=D&&D<128)&&(H=r[D],H)?H:(L=i(D,D<0?-1:0,!1),G&&(r[D]=L),L))}t.fromInt=s;function o(D,A){if(isNaN(D))return A?S:w;if(A){if(D<0)return S;if(D>=v)return _}else{if(D<=-y)return $;if(D+1>=y)return I}return D<0?o(-D,A).neg():i(D%m|0,D/m|0,A)}t.fromNumber=o;function i(D,A,L){return new t(D,A,L)}t.fromBits=i;var u=Math.pow;function l(D,A,L){if(D.length===0)throw Error("empty string");if(D==="NaN"||D==="Infinity"||D==="+Infinity"||D==="-Infinity")return w;if(typeof A=="number"?(L=A,A=!1):A=!!A,L=L||10,L<2||36<L)throw RangeError("radix");var H;if((H=D.indexOf("-"))>0)throw Error("interior hyphen");if(H===0)return l(D.substring(1),A,L).neg();for(var G=o(u(L,8)),q=w,B=0;B<D.length;B+=8){var j=Math.min(8,D.length-B),K=parseInt(D.substring(B,B+j),L);if(j<8){var z=o(u(L,j));q=q.mul(z).add(o(K))}else q=q.mul(G),q=q.add(o(K))}return q.unsigned=A,q}t.fromString=l;function h(D,A){return typeof D=="number"?o(D,A):typeof D=="string"?l(D,A):i(D.low,D.high,typeof A=="boolean"?A:D.unsigned)}t.fromValue=h;var d=65536,f=1<<24,m=d*d,v=m*m,y=v/2,b=s(f),w=s(0);t.ZERO=w;var S=s(0,!0);t.UZERO=S;var N=s(1);t.ONE=N;var C=s(1,!0);t.UONE=C;var T=s(-1);t.NEG_ONE=T;var I=i(-1,2147483647,!1);t.MAX_VALUE=I;var _=i(-1,-1,!0);t.MAX_UNSIGNED_VALUE=_;var $=i(0,-2147483648,!1);t.MIN_VALUE=$;var R=t.prototype;return R.toInt=function(){return this.unsigned?this.low>>>0:this.low},R.toNumber=function(){return this.unsigned?(this.high>>>0)*m+(this.low>>>0):this.high*m+(this.low>>>0)},R.toString=function(A){if(A=A||10,A<2||36<A)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq($)){var L=o(A),H=this.div(L),G=H.mul(L).sub(this);return H.toString(A)+G.toInt().toString(A)}else return"-"+this.neg().toString(A);for(var q=o(u(A,6),this.unsigned),B=this,j="";;){var K=B.div(q),z=B.sub(K.mul(q)).toInt()>>>0,U=z.toString(A);if(B=K,B.isZero())return U+j;for(;U.length<6;)U="0"+U;j=""+U+j}},R.getHighBits=function(){return this.high},R.getHighBitsUnsigned=function(){return this.high>>>0},R.getLowBits=function(){return this.low},R.getLowBitsUnsigned=function(){return this.low>>>0},R.getNumBitsAbs=function(){if(this.isNegative())return this.eq($)?64:this.neg().getNumBitsAbs();for(var A=this.high!=0?this.high:this.low,L=31;L>0&&(A&1<<L)==0;L--);return this.high!=0?L+33:L+1},R.isZero=function(){return this.high===0&&this.low===0},R.eqz=R.isZero,R.isNegative=function(){return!this.unsigned&&this.high<0},R.isPositive=function(){return this.unsigned||this.high>=0},R.isOdd=function(){return(this.low&1)===1},R.isEven=function(){return(this.low&1)===0},R.equals=function(A){return e(A)||(A=h(A)),this.unsigned!==A.unsigned&&this.high>>>31===1&&A.high>>>31===1?!1:this.high===A.high&&this.low===A.low},R.eq=R.equals,R.notEquals=function(A){return!this.eq(A)},R.neq=R.notEquals,R.ne=R.notEquals,R.lessThan=function(A){return this.comp(A)<0},R.lt=R.lessThan,R.lessThanOrEqual=function(A){return this.comp(A)<=0},R.lte=R.lessThanOrEqual,R.le=R.lessThanOrEqual,R.greaterThan=function(A){return this.comp(A)>0},R.gt=R.greaterThan,R.greaterThanOrEqual=function(A){return this.comp(A)>=0},R.gte=R.greaterThanOrEqual,R.ge=R.greaterThanOrEqual,R.compare=function(A){if(e(A)||(A=h(A)),this.eq(A))return 0;var L=this.isNegative(),H=A.isNegative();return L&&!H?-1:!L&&H?1:this.unsigned?A.high>>>0>this.high>>>0||A.high===this.high&&A.low>>>0>this.low>>>0?-1:1:this.sub(A).isNegative()?-1:1},R.comp=R.compare,R.negate=function(){return!this.unsigned&&this.eq($)?$:this.not().add(N)},R.neg=R.negate,R.add=function(A){e(A)||(A=h(A));var L=this.high>>>16,H=this.high&65535,G=this.low>>>16,q=this.low&65535,B=A.high>>>16,j=A.high&65535,K=A.low>>>16,z=A.low&65535,U=0,M=0,X=0,Q=0;return Q+=q+z,X+=Q>>>16,Q&=65535,X+=G+K,M+=X>>>16,X&=65535,M+=H+j,U+=M>>>16,M&=65535,U+=L+B,U&=65535,i(X<<16|Q,U<<16|M,this.unsigned)},R.subtract=function(A){return e(A)||(A=h(A)),this.add(A.neg())},R.sub=R.subtract,R.multiply=function(A){if(this.isZero())return w;if(e(A)||(A=h(A)),n){var L=n.mul(this.low,this.high,A.low,A.high);return i(L,n.get_high(),this.unsigned)}if(A.isZero())return w;if(this.eq($))return A.isOdd()?$:w;if(A.eq($))return this.isOdd()?$:w;if(this.isNegative())return A.isNegative()?this.neg().mul(A.neg()):this.neg().mul(A).neg();if(A.isNegative())return this.mul(A.neg()).neg();if(this.lt(b)&&A.lt(b))return o(this.toNumber()*A.toNumber(),this.unsigned);var H=this.high>>>16,G=this.high&65535,q=this.low>>>16,B=this.low&65535,j=A.high>>>16,K=A.high&65535,z=A.low>>>16,U=A.low&65535,M=0,X=0,Q=0,rt=0;return rt+=B*U,Q+=rt>>>16,rt&=65535,Q+=q*U,X+=Q>>>16,Q&=65535,Q+=B*z,X+=Q>>>16,Q&=65535,X+=G*U,M+=X>>>16,X&=65535,X+=q*z,M+=X>>>16,X&=65535,X+=B*K,M+=X>>>16,X&=65535,M+=H*U+G*z+q*K+B*j,M&=65535,i(Q<<16|rt,M<<16|X,this.unsigned)},R.mul=R.multiply,R.divide=function(A){if(e(A)||(A=h(A)),A.isZero())throw Error("division by zero");if(n){if(!this.unsigned&&this.high===-2147483648&&A.low===-1&&A.high===-1)return this;var L=(this.unsigned?n.div_u:n.div_s)(this.low,this.high,A.low,A.high);return i(L,n.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?S:w;var H,G,q;if(this.unsigned){if(A.unsigned||(A=A.toUnsigned()),A.gt(this))return S;if(A.gt(this.shru(1)))return C;q=S}else{if(this.eq($)){if(A.eq(N)||A.eq(T))return $;if(A.eq($))return N;var B=this.shr(1);return H=B.div(A).shl(1),H.eq(w)?A.isNegative()?N:T:(G=this.sub(A.mul(H)),q=H.add(G.div(A)),q)}else if(A.eq($))return this.unsigned?S:w;if(this.isNegative())return A.isNegative()?this.neg().div(A.neg()):this.neg().div(A).neg();if(A.isNegative())return this.div(A.neg()).neg();q=w}for(G=this;G.gte(A);){H=Math.max(1,Math.floor(G.toNumber()/A.toNumber()));for(var j=Math.ceil(Math.log(H)/Math.LN2),K=j<=48?1:u(2,j-48),z=o(H),U=z.mul(A);U.isNegative()||U.gt(G);)H-=K,z=o(H,this.unsigned),U=z.mul(A);z.isZero()&&(z=N),q=q.add(z),G=G.sub(U)}return q},R.div=R.divide,R.modulo=function(A){if(e(A)||(A=h(A)),n){var L=(this.unsigned?n.rem_u:n.rem_s)(this.low,this.high,A.low,A.high);return i(L,n.get_high(),this.unsigned)}return this.sub(this.div(A).mul(A))},R.mod=R.modulo,R.rem=R.modulo,R.not=function(){return i(~this.low,~this.high,this.unsigned)},R.and=function(A){return e(A)||(A=h(A)),i(this.low&A.low,this.high&A.high,this.unsigned)},R.or=function(A){return e(A)||(A=h(A)),i(this.low|A.low,this.high|A.high,this.unsigned)},R.xor=function(A){return e(A)||(A=h(A)),i(this.low^A.low,this.high^A.high,this.unsigned)},R.shiftLeft=function(A){return e(A)&&(A=A.toInt()),(A&=63)===0?this:A<32?i(this.low<<A,this.high<<A|this.low>>>32-A,this.unsigned):i(0,this.low<<A-32,this.unsigned)},R.shl=R.shiftLeft,R.shiftRight=function(A){return e(A)&&(A=A.toInt()),(A&=63)===0?this:A<32?i(this.low>>>A|this.high<<32-A,this.high>>A,this.unsigned):i(this.high>>A-32,this.high>=0?0:-1,this.unsigned)},R.shr=R.shiftRight,R.shiftRightUnsigned=function(A){if(e(A)&&(A=A.toInt()),A&=63,A===0)return this;var L=this.high;if(A<32){var H=this.low;return i(H>>>A|L<<32-A,L>>>A,this.unsigned)}else return A===32?i(L,0,this.unsigned):i(L>>>A-32,0,this.unsigned)},R.shru=R.shiftRightUnsigned,R.shr_u=R.shiftRightUnsigned,R.toSigned=function(){return this.unsigned?i(this.low,this.high,!1):this},R.toUnsigned=function(){return this.unsigned?this:i(this.low,this.high,!0)},R.toBytes=function(A){return A?this.toBytesLE():this.toBytesBE()},R.toBytesLE=function(){var A=this.high,L=this.low;return[L&255,L>>>8&255,L>>>16&255,L>>>24,A&255,A>>>8&255,A>>>16&255,A>>>24]},R.toBytesBE=function(){var A=this.high,L=this.low;return[A>>>24,A>>>16&255,A>>>8&255,A&255,L>>>24,L>>>16&255,L>>>8&255,L&255]},t.fromBytes=function(A,L,H){return H?t.fromBytesLE(A,L):t.fromBytesBE(A,L)},t.fromBytesLE=function(A,L){return new t(A[0]|A[1]<<8|A[2]<<16|A[3]<<24,A[4]|A[5]<<8|A[6]<<16|A[7]<<24,L)},t.fromBytesBE=function(A,L){return new t(A[4]<<24|A[5]<<16|A[6]<<8|A[7],A[0]<<24|A[1]<<16|A[2]<<8|A[3],L)},OS}var YM=Eq();const QM=bm(YM),Iq=Ij({__proto__:null,default:QM},[YM]);const Ml=QM||Iq;function Cg(n){return Ml.fromString(n,!0,16)}const ZM=Cg("c3a5c85c97cb3127"),Al=Cg("b492b66fbe98f273"),sa=Cg("9ae16a3b2f90404f");function rN(n){return n.xor(n.shru(47))}function JM(n,t,e){const r=n.slice(t,t+e);return Ml.fromBytes(Array.from(r),!0,!0)}function fn(n,t){return JM(n,t,8)}function Q$(n,t){return JM(n,t,4)}function mr(n,t){return t===0?n:n.shru(t).or(n.shl(64-t))}function Eu(n,t,e=Cg("9ddfea08eb382d69")){let r=n.xor(t).mul(e);r=r.xor(r.shru(47));let a=t.xor(r).mul(e);return a=a.xor(a.shru(47)),a=a.mul(e),a}function _q(n,t,e,r,a,s){a=a.add(n),s=mr(s.add(a).add(r),21);const o=a;return a=a.add(t),a=a.add(e),s=s.add(mr(a,44)),[a.add(r),s.add(o)]}function Oy(n,t,e,r){return _q(fn(n,t),fn(n,t+8),fn(n,t+16),fn(n,t+24),e,r)}function Rq(n,t=n.length){if(t>=8){const e=sa.add(t*2),r=fn(n,0).add(sa),a=fn(n,t-8),s=mr(a,37).mul(e).add(r),o=mr(r,25).add(a).mul(e);return Eu(s,o,e)}if(t>=4){const e=sa.add(t*2),r=Q$(n,0);return Eu(r.shl(3).add(t),Q$(n,t-4),e)}if(t>0){const e=n[0],r=n[t>>1],a=n[t-1],s=e+(r<<8),o=t+(a<<2);return rN(sa.mul(s).xor(ZM.mul(o))).mul(sa)}return sa}function Aq(n,t=n.length){const e=sa.add(t*2),r=fn(n,0).mul(Al),a=fn(n,8),s=fn(n,t-8).mul(e),o=fn(n,t-16).mul(sa);return Eu(mr(r.add(a),43).add(mr(s,30)).add(o),r.add(mr(a.add(sa),18)).add(s),e)}function Dq(n,t=n.length){const e=sa.add(t*2),r=fn(n,0).mul(sa),a=fn(n,8),s=fn(n,t-8).mul(e),o=fn(n,t-16).mul(sa),i=mr(r.add(a),43).add(mr(s,30)).add(o),u=Eu(i,r.add(mr(a.add(sa),18)).add(s),e),l=fn(n,16).mul(e),h=fn(n,24),d=i.add(fn(n,t-32)).mul(e),f=u.add(fn(n,t-24)).mul(e);return Eu(mr(l.add(h),43).add(mr(d,30)).add(f),l.add(mr(h.add(r),18)).add(d),e)}function tL(n,t=n.length){const e=Ml.fromNumber(81,!0);if(t<=32)return t<=16?Rq(n,t):Aq(n,t);if(t<=64)return Dq(n,t);let r=e,a=e.mul(Al).add(113),s=rN(a.mul(sa).add(113)).mul(sa),o=[Ml.UZERO,Ml.UZERO],i=[Ml.UZERO,Ml.UZERO];r=r.mul(sa).add(fn(n,0));let u=0;const l=(t-1>>6)*64,h=l+(t-1&63)-63;do r=mr(r.add(a).add(o[0]).add(fn(n,u+8)),37).mul(Al),a=mr(a.add(o[1]).add(fn(n,u+48)),42).mul(Al),r=r.xor(i[1]),a=a.add(o[0]).add(fn(n,u+40)),s=mr(s.add(i[0]),33).mul(Al),o=Oy(n,u,o[1].mul(Al),r.add(i[0])),i=Oy(n,u+32,s.add(i[1]),a.add(fn(n,u+16))),[s,r]=[r,s],u+=64;while(u!==l);const d=Al.add(s.and(255).shl(1));return u=h,i[0]=i[0].add(t-1&63),o[0]=o[0].add(i[0]),i[0]=i[0].add(o[0]),r=mr(r.add(a).add(o[0]).add(fn(n,u+8)),37).mul(d),a=mr(a.add(o[1]).add(fn(n,u+48)),42).mul(d),r=r.xor(i[1].mul(9)),a=a.add(o[0].mul(9).add(fn(n,u+40))),s=mr(s.add(i[0]),33).mul(d),o=Oy(n,u,o[1].mul(d),r.add(i[0])),i=Oy(n,u+32,s.add(i[1]),a.add(fn(n,u+16))),[s,r]=[r,s],Eu(Eu(o[0],i[0],d).add(rN(a).mul(ZM)).add(s),Eu(o[1],i[1],d).add(r),d)}function Fi(n,t){return t==="string"?$o(n):Yu([n],t)}function $q(n,t){return n instanceof Float32Array&&t==="float32"||n instanceof Int32Array&&t==="int32"||n instanceof Uint8Array&&t==="bool"}function Yu(n,t){if(t==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(n)&&(n=Vo(n)),dt().getBool("DEBUG")&&BM(n,t),$q(n,t))return n;if(t==null||t==="float32"||t==="complex64")return new Float32Array(n);if(t==="int32")return new Int32Array(n);if(t==="bool"){const e=new Uint8Array(n.length);for(let r=0;r<e.length;++r)Math.round(n[r])!==0&&(e[r]=1);return e}else throw new Error(`Unknown data type ${t}`)}function ra(){return dt().platform.now()}function Oq(n,t){return dt().platform.fetch(n,t)}function $o(n,t="utf-8"){return t=t||"utf-8",dt().platform.encode(n,t)}function Ii(n,t="utf-8"){return t=t||"utf-8",dt().platform.decode(n,t)}function gr(n){return dt().platform.isTypedArray!=null?dt().platform.isTypedArray(n):XM(n)}function Vo(n,t=[],e=!1){if(t==null&&(t=[]),typeof n=="boolean"||typeof n=="number"||typeof n=="string"||Mu(n)||n==null||gr(n)&&e)t.push(n);else if(Array.isArray(n)||gr(n))for(let r=0;r<n.length;++r)Vo(n[r],t,e);else{let r=-1;for(const a of Object.keys(n))/^([1-9]+[0-9]*|0)$/.test(a)&&(r=Math.max(r,Number(a)));for(let a=0;a<=r;a++)Vo(n[a],t,e)}return t}const Fq=Object.freeze(Object.defineProperty({__proto__:null,arraysEqual:De,arraysEqualWithNull:LM,assert:P,assertNonNegativeIntegerDimensions:Ya,assertNonNull:mc,assertShapesMatch:Br,bytesFromStringArray:PM,bytesPerElement:Hf,checkConversionForErrors:BM,clamp:Ou,computeStrides:oe,convertBackendValuesAndArrayBuffer:WM,createScalarValue:Fi,createShuffledIndices:dq,decodeString:Ii,distSquared:lq,encodeString:$o,fetch:Oq,fingerPrint64:tL,flatten:Vo,getArrayFromDType:On,getTypedArrayFromDType:xr,hasEncodingLoss:_k,hexToLong:Cg,indexToLoc:vc,inferDtype:gc,inferFromImplicitShape:Ik,isBoolean:VM,isFunction:Fu,isInt:Zl,isNumber:$0,isPromise:Mu,isScalarShape:cq,isString:Io,isTypedArray:gr,isValidDtype:zM,locToIndex:eo,makeOnesTypedArray:Ob,makeZerosNestedTypedArray:Rk,makeZerosTypedArray:Mr,nearestDivisor:O0,nearestLargerEven:$b,now:ra,parseAxisParam:_e,randUniform:uq,repeatedTry:eN,rightPad:jl,shuffle:Ek,shuffleCombo:iq,sizeFromShape:xt,sizeToSquarishShape:D0,squeezeShape:Oi,sum:MM,swap:Ni,tanh:hq,toNestedArray:ms,toTypedArray:Yu},Symbol.toStringTag,{value:"Module"}));class Mq{constructor(t,e){this.backendTimer=t,this.logger=e,e==null&&(this.logger=new Bq)}profileKernel(t,e,r){let a;const s=()=>{a=r()};let o;const i=ra();if(this.backendTimer.timerAvailable())o=this.backendTimer.time(s);else{s();for(const l of a)l.dataSync();o=Promise.resolve({kernelMs:ra()-i})}if(dt().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let l=0;l<a.length;l++){const h=a[l];h.data().then(d=>{Lq(d,h.dtype,t)})}return{kernelName:t,outputs:a,inputs:e,timeMs:o.then(l=>l.kernelMs),extraInfo:o.then(l=>l.getExtraProfileInfo!=null?l.getExtraProfileInfo():"")}}logKernelProfile(t){const{kernelName:e,outputs:r,timeMs:a,inputs:s,extraInfo:o}=t;r.forEach(i=>{Promise.all([i.data(),a,o]).then(u=>{this.logger.logKernelProfile(e,i,u[0],u[1],s,u[2])})})}}function Lq(n,t,e){if(t!=="float32")return!1;for(let r=0;r<n.length;r++){const a=n[r];if(isNaN(a)||!isFinite(a))return console.warn(`Found ${a} in the result of '${e}'`),!0}return!1}class Bq{logKernelProfile(t,e,r,a,s,o){const i=typeof a=="number"?jl(`${a}ms`,9):a.error,u=jl(t,25),l=e.rank,h=e.size,d=jl(e.shape.toString(),14);let f="";for(const m in s){const v=s[m];if(v!=null){const y=v.shape||e.shape,b=y.length;f+=`${m}: ${b}D ${b>0?y:""} `}}console.log(`%c${u}	%c${i}	%c${l}D ${d}	%c${h}	%c${f}	%c${o}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}function zq(n,t,e){const r={},a={};for(let u=0;u<t.length;u++)r[t[u].id]=!0;for(let u=0;u<n.length;u++){const l=n[u],h=l.inputs;for(const d in h){const f=h[d];let m=!1;for(let v=0;v<t.length;v++)if(r[f.id]){l.outputs.forEach(y=>r[y.id]=!0),m=!0,a[l.id]=!0;break}if(m)break}}const s={};s[e.id]=!0;const o={};for(let u=n.length-1;u>=0;u--){const l=n[u],h=l.inputs;for(let d=0;d<l.outputs.length;d++)if(s[l.outputs[d].id]){for(const f in h)s[h[f].id]=!0,o[l.id]=!0;break}}const i=[];for(let u=0;u<n.length;u++){const l=n[u];if(a[l.id]&&o[l.id]){const h={};for(const f in l.inputs){const m=l.inputs[f];r[m.id]&&(h[f]=m)}const d=Object.assign({},l);d.inputs=h,d.outputs=l.outputs,i.push(d)}}return i}function Pq(n,t,e,r){for(let a=t.length-1;a>=0;a--){const s=t[a],o=[];if(s.outputs.forEach(u=>{const l=n[u.id];l!=null?o.push(l):o.push(null)}),s.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${s.kernelName}.`);const i=s.gradient(o);for(const u in s.inputs){if(!(u in i))throw new Error(`Cannot backprop through input ${u}. Available gradients found: ${Object.keys(i)}.`);const l=e(()=>i[u]());if(l.dtype!=="float32")throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input ${u} must have 'float32' dtype, but has '${l.dtype}'`);const h=s.inputs[u];if(!De(l.shape,h.shape))throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input '${u}' has shape '${l.shape}', which does not match the shape of the input '${h.shape}'`);if(n[h.id]==null)n[h.id]=l;else{const d=n[h.id];n[h.id]=r(d,l),d.dispose()}}}}const Z$=20,Sf=3,FS=7;function Vq(n,t,e,r){const a=oe(t),s=Uq(n,t,e,a),o=t.length,i=v0(n,t,e,a,s),u=["Tensor"];return r&&(u.push(`  dtype: ${e}`),u.push(`  rank: ${o}`),u.push(`  shape: [${t}]`),u.push("  values:")),u.push(i.map(l=>"    "+l).join(`
`)),u.join(`
`)}function Uq(n,t,e,r){const a=xt(t),s=r[r.length-1],o=new Array(s).fill(0),i=t.length,u=e==="complex64"?Df(n):n;if(i>1)for(let l=0;l<a/s;l++){const h=l*s;for(let d=0;d<s;d++)o[d]=Math.max(o[d],Af(u[h+d],0,e).length)}return o}function Af(n,t,e){let r;return Array.isArray(n)?r=`${parseFloat(n[0].toFixed(FS))} + ${parseFloat(n[1].toFixed(FS))}j`:Io(n)?r=`'${n}'`:e==="bool"?r=eL(n):r=parseFloat(n.toFixed(FS)).toString(),jl(r,t)}function eL(n){return n===0?"false":"true"}function v0(n,t,e,r,a,s=!0){const o=e==="complex64"?2:1,i=t[0],u=t.length;if(u===0){if(e==="complex64"){const y=Df(n);return[Af(y[0],0,e)]}return e==="bool"?[eL(n[0])]:[n[0].toString()]}if(u===1){if(i>Z$){const b=Sf*o;let w=Array.from(n.slice(0,b)),S=Array.from(n.slice((i-Sf)*o,i*o));return e==="complex64"&&(w=Df(w),S=Df(S)),["["+w.map((N,C)=>Af(N,a[C],e)).join(", ")+", ..., "+S.map((N,C)=>Af(N,a[i-Sf+C],e)).join(", ")+"]"]}return["["+(e==="complex64"?Df(n):Array.from(n)).map((b,w)=>Af(b,a[w],e)).join(", ")+"]"]}const l=t.slice(1),h=r.slice(1),d=r[0]*o,f=[];if(i>Z$){for(let y=0;y<Sf;y++){const b=y*d,w=b+d;f.push(...v0(n.slice(b,w),l,e,h,a,!1))}f.push("...");for(let y=i-Sf;y<i;y++){const b=y*d,w=b+d;f.push(...v0(n.slice(b,w),l,e,h,a,y===i-1))}}else for(let y=0;y<i;y++){const b=y*d,w=b+d;f.push(...v0(n.slice(b,w),l,e,h,a,y===i-1))}const m=u===2?",":"";f[0]="["+(i>0?f[0]+m:"");for(let y=1;y<f.length-1;y++)f[y]=" "+f[y]+m;let v=`,
`;for(let y=2;y<u;y++)v+=`
`;return f[f.length-1]=" "+f[f.length-1]+"]"+(s?"":v),f}function Df(n){const t=[];for(let e=0;e<n.length;e+=2)t.push([n[e],n[e+1]]);return t}class Yn{constructor(t,e,r){if(this.dtype=e,this.shape=t.slice(),this.size=xt(t),r!=null){const a=r.length;P(a===this.size,()=>`Length of values '${a}' does not match the size inferred by the shape '${this.size}'.`)}if(e==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=r||On(e,this.size),this.strides=oe(t)}set(t,...e){e.length===0&&(e=[0]),P(e.length===this.rank,()=>`The number of provided coordinates (${e.length}) must match the rank (${this.rank})`);const r=this.locToIndex(e);this.values[r]=t}get(...t){t.length===0&&(t=[0]);let e=0;for(const a of t){if(a<0||a>=this.shape[e]){const s=`Requested out of range element at ${t}.   Buffer shape=${this.shape}`;throw new Error(s)}e++}let r=t[t.length-1];for(let a=0;a<t.length-1;++a)r+=this.strides[a]*t[a];return this.values[r]}locToIndex(t){if(this.rank===0)return 0;if(this.rank===1)return t[0];let e=t[t.length-1];for(let r=0;r<t.length-1;++r)e+=this.strides[r]*t[r];return e}indexToLoc(t){if(this.rank===0)return[];if(this.rank===1)return[t];const e=new Array(this.shape.length);for(let r=0;r<e.length-1;++r)e[r]=Math.floor(t/this.strides[r]),t-=e[r]*this.strides[r];return e[e.length-1]=t,e}get rank(){return this.shape.length}toTensor(){return Ys().makeTensor(this.values,this.shape,this.dtype)}}let Ys=null,Eh=null;function Wq(n){Ys=n}function Gq(n){Eh=n}class Ae{constructor(t,e,r,a){this.kept=!1,this.isDisposedInternal=!1,this.shape=t.slice(),this.dtype=e||"float32",this.size=xt(t),this.strides=oe(t),this.dataId=r,this.id=a,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const t=await this.data();return Eh.buffer(this.shape,this.dtype,t)}bufferSync(){return Eh.buffer(this.shape,this.dtype,this.dataSync())}async array(){const t=await this.data();return ms(this.shape,t,this.dtype==="complex64")}arraySync(){return ms(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();const t=Ys().read(this.dataId);if(this.dtype==="string"){const e=await t;try{return e.map(r=>Ii(r))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return t}dataToGPU(t){return this.throwIfDisposed(),Ys().readToGPU(this.dataId,t)}dataSync(){this.throwIfDisposed();const t=Ys().readSync(this.dataId);if(this.dtype==="string")try{return t.map(e=>Ii(e))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return t}async bytes(){this.throwIfDisposed();const t=await Ys().read(this.dataId);return this.dtype==="string"?t:new Uint8Array(t.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),Ys().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(t=!1){return Eh.print(this,t)}clone(){return this.throwIfDisposed(),Eh.clone(this)}toString(t=!1){const e=this.dataSync();return Vq(e,this.shape,this.dtype,t)}cast(t){return this.throwIfDisposed(),Eh.cast(this,t)}variable(t=!0,e,r){return this.throwIfDisposed(),Ys().makeVariable(this,t,e,r)}}Object.defineProperty(Ae,Symbol.hasInstance,{value:n=>!!n&&n.data!=null&&n.dataSync!=null&&n.throwIfDisposed!=null});function Ct(){return Dk("Tensor",()=>Ae)}Ct();class Qf extends Ae{constructor(t,e,r,a){super(t.shape,t.dtype,t.dataId,a),this.trainable=e,this.name=r}assign(t){if(t.dtype!==this.dtype)throw new Error(`dtype of the new value (${t.dtype}) and previous value (${this.dtype}) must match`);if(!De(t.shape,this.shape))throw new Error(`shape of the new value (${t.shape}) and previous value (${this.shape}) must match`);Ys().disposeTensor(this),this.dataId=t.dataId,Ys().incRef(this,null)}dispose(){Ys().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(Qf,Symbol.hasInstance,{value:n=>n instanceof Ae&&n.assign!=null&&n.assign instanceof Function});var aN;(function(n){n.R0="R0",n.R1="R1",n.R2="R2",n.R3="R3",n.R4="R4",n.R5="R5",n.R6="R6"})(aN||(aN={}));var sN;(function(n){n.float32="float32",n.int32="int32",n.bool="int32",n.complex64="complex64"})(sN||(sN={}));var oN;(function(n){n.float32="float32",n.int32="int32",n.bool="bool",n.complex64="complex64"})(oN||(oN={}));var iN;(function(n){n.float32="float32",n.int32="float32",n.bool="float32",n.complex64="complex64"})(iN||(iN={}));var uN;(function(n){n.float32="complex64",n.int32="complex64",n.bool="complex64",n.complex64="complex64"})(uN||(uN={}));const Hq={float32:iN,int32:sN,bool:oN,complex64:uN};function Sa(n,t){if(n==="string"||t==="string"){if(n==="string"&&t==="string")return"string";throw new Error(`Can not upcast ${n} with ${t}`)}return Hq[n][t]}function Vx(n){return Sa(n,"int32")}function nL(n){return n!=null&&typeof n=="object"&&"texture"in n&&n.texture instanceof WebGLTexture}function rL(n){return typeof GPUBuffer<"u"&&n!=null&&typeof n=="object"&&"buffer"in n&&n.buffer instanceof GPUBuffer}function Rn(n,t){if(n.dtype===t.dtype)return[n,t];const e=Sa(n.dtype,t.dtype);return[n.cast(e),t.cast(e)]}function aL(n,t){P(n.dtype===t.dtype,()=>`The dtypes of the first(${n.dtype}) and second(${t.dtype}) input must match`)}function jq(n,t){return t.some(e=>e.id===n.id)}function Ok(n){const t=[];return sL(n,t,new Set),t}function sL(n,t,e){if(n==null)return;if(n instanceof Ae){t.push(n);return}if(!qq(n))return;const r=n;for(const a in r){const s=r[a];e.has(s)||(e.add(s),sL(s,t,e))}}function qq(n){return Array.isArray(n)||typeof n=="object"}const Kq=Object.freeze(Object.defineProperty({__proto__:null,assertTypesMatch:aL,getTensorsInContainer:Ok,isTensorInList:jq,makeTypesMatch:Rn},Symbol.toStringTag,{value:"Module"}));function MS(n){return n.kernelName!=null}class J${constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(t=>t.name)))}}}dispose(){for(const t in this.registeredVariables)this.registeredVariables[t].dispose()}}class Xh{constructor(t){this.ENV=t,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new J$}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;const t=this.getSortedBackends();for(let e=0;e<t.length;e++){const r=t[e];if(await this.initializeBackend(r).success){await this.setBackend(r);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){const{name:t,asyncInit:e}=this.initializeBackendsAndReturnBest();if(e)throw new Error(`The highest priority backend '${t}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(t)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(t){if(!(t in this.registry))if(t in this.registryFactory){const{asyncInit:e}=this.initializeBackend(t);if(e)return null}else return null;return this.registry[t]}findBackendFactory(t){return t in this.registryFactory?this.registryFactory[t].factory:null}registerBackend(t,e,r=1){return t in this.registryFactory?(is(`${t} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[t]={factory:e,priority:r},!0)}async setBackend(t){if(this.registryFactory[t]==null)throw new Error(`Backend name '${t}' not found in registry`);if(this.backendName=t,this.registry[t]==null){this.backendInstance=null;const{success:e,asyncInit:r}=this.initializeBackend(t);if(!(r?await e:e))return!1}return this.backendInstance=this.registry[t],this.setupRegisteredKernels(),this.profiler=new Mq(this.backendInstance),!0}setupRegisteredKernels(){B0(this.backendName).forEach(e=>{e.setupFunc!=null&&e.setupFunc(this.backendInstance)})}disposeRegisteredKernels(t){B0(t).forEach(r=>{r.disposeFunc!=null&&r.disposeFunc(this.registry[t])})}initializeBackend(t){const e=this.registryFactory[t];if(e==null)throw new Error(`Cannot initialize backend ${t}, no registration found.`);try{const r=e.factory();if(r&&!(r instanceof Db)&&typeof r.then=="function"){const a=++this.pendingBackendInitId,s=r.then(o=>a<this.pendingBackendInitId?!1:(this.registry[t]=o,this.pendingBackendInit=null,!0)).catch(o=>(a<this.pendingBackendInitId||(this.pendingBackendInit=null,is(`Initialization of backend ${t} failed`),is(o.stack||o.message)),!1));return this.pendingBackendInit=s,{success:s,asyncInit:!0}}else return this.registry[t]=r,{success:!0,asyncInit:!1}}catch(r){return is(`Initialization of backend ${t} failed`),is(r.stack||r.message),{success:!1,asyncInit:!1}}}removeBackend(t){if(!(t in this.registryFactory))throw new Error(`${t} backend not found in registry`);this.backendName===t&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,t in this.registry&&(this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t]),delete this.registryFactory[t],this.backendName===t&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((t,e)=>this.registryFactory[e].priority-this.registryFactory[t].priority)}initializeBackendsAndReturnBest(){const t=this.getSortedBackends();for(let e=0;e<t.length;e++){const r=t[e],{success:a,asyncInit:s}=this.initializeBackend(r);if(s||a)return{name:r,asyncInit:s}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(t,e){const r=this.state.tensorInfo.get(e),a=r.backend,s=this.readSync(e),o=a.refCount(e);a.disposeData(e,!0),r.backend=t,t.move(e,s,r.shape,r.dtype,o),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(t,e){let r=null;if(e==null){if(typeof t!="function")throw new Error("Please provide a function to tidy()");e=t}else{if(typeof t!="string"&&!(t instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof e!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=t}let a;return this.scopedRun(()=>this.startScope(r),()=>this.endScope(a),()=>(a=e(),a instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),a))}scopedRun(t,e,r){t();try{const a=r();return e(),a}catch(a){throw e(),a}}nextTensorId(){return Xh.nextTensorId++}nextVariableId(){return Xh.nextVariableId++}clone(t){const e=J.runKernel(Ad,{x:t}),r={x:t},a=o=>({x:()=>{const i="float32",u={x:o},l={dtype:i};return J.runKernel(yd,u,l)}}),s=[];return this.addTapeNode(this.state.activeScope.name,r,[e],a,s,{}),e}runKernel(t,e,r){if(this.backendName==null&&this.backend,!(Yf(t,this.backendName)!=null))throw new Error(`Kernel '${t}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:t,inputs:e,attrs:r})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(t,e,r){const a=this.backend.numDataIds();let s=0;r.forEach(u=>{s+=u.dtype==="complex64"?3:1});const o=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],i=a-e-s-o;if(i>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${i} data ids) after running '${t}'`)}runKernelFunc(t){let e,r=[];const a=this.isTapeOn(),s=this.state.numBytes,o=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let i;this.backendName==null&&this.backend;let u;const l=MS(t)?t.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(MS(t)){const{kernelName:v,inputs:y,attrs:b}=t;this.backendName==null&&this.backend;const w=Yf(v,this.backendName);P(w!=null,()=>`Cannot find registered kernel '${v}' for backend '${this.backendName}'`),i=()=>{const S=this.backend.numDataIds();u=w.kernelFunc({inputs:y,attrs:b,backend:this.backend});const N=Array.isArray(u)?u:[u];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(v,S,N);const C=N.map(T=>T.rank!=null?T:this.makeTensorFromTensorInfo(T));if(a){const T=this.getTensorsForGradient(v,y,C);r=this.saveTensorsForBackwardMode(T)}return C}}else{const{forwardFunc:v}=t,y=b=>{a&&(r=b.map(w=>this.keep(this.clone(w))))};i=()=>{const b=this.backend.numDataIds();u=this.tidy(()=>v(this.backend,y));const w=Array.isArray(u)?u:[u];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(l,b,w),w}}const{inputs:h,attrs:d}=t,f=MS(t)?null:t.backwardsFunc;let m;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?e=i():(m=this.profiler.profileKernel(l,h,()=>i()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(m),e=m.outputs)}),a&&this.addTapeNode(l,h,e,f,r,d),this.state.profiling&&this.state.activeProfile.kernels.push({name:l,bytesAdded:this.state.numBytes-s,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-o,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(h).map(v=>h[v]!=null?h[v].shape:null),outputShapes:e.map(v=>v.shape),kernelTimeMs:m.timeMs,extraInfo:m.extraInfo}),Array.isArray(u)?e:e[0]}saveTensorsForBackwardMode(t){return t.map(r=>this.keep(this.clone(r)))}getTensorsForGradient(t,e,r){const a=nN(t);if(a!=null){const s=a.inputsToSave||[],o=a.outputsToSave||[];let i;a.saveAllInputs?(P(Array.isArray(e),()=>"saveAllInputs is true, expected inputs to be an array."),i=Object.keys(e).map(l=>e[l])):i=s.map(l=>e[l]);const u=r.filter((l,h)=>o[h]);return i.concat(u)}return[]}makeTensor(t,e,r,a){if(t==null)throw new Error("Values passed to engine.makeTensor() are null");r=r||"float32",a=a||this.backend;let s=t;r==="string"&&Io(t[0])&&(s=t.map(u=>$o(u)));const o=a.write(s,e,r),i=new Ae(e,r,o,this.nextTensorId());if(this.trackTensor(i,a),r==="string"){const u=this.state.tensorInfo.get(o),l=PM(s);this.state.numBytes+=l-u.bytes,u.bytes=l}return i}makeTensorFromDataId(t,e,r,a){r=r||"float32";const s={dataId:t,shape:e,dtype:r};return this.makeTensorFromTensorInfo(s,a)}makeTensorFromTensorInfo(t,e){const{dataId:r,shape:a,dtype:s}=t,o=new Ae(a,s,r,this.nextTensorId());return this.trackTensor(o,e),o}makeVariable(t,e=!0,r,a){r=r||this.nextVariableId().toString(),a!=null&&a!==t.dtype&&(t=t.cast(a));const s=new Qf(t,e,r,this.nextTensorId());if(this.state.registeredVariables[s.name]!=null)throw new Error(`Variable with name ${s.name} was already registered`);return this.state.registeredVariables[s.name]=s,this.incRef(s,this.backend),s}trackTensor(t,e){this.state.numTensors++,t.dtype==="string"&&this.state.numStringTensors++;let r=0;t.dtype!=="complex64"&&t.dtype!=="string"&&(r=t.size*Hf(t.dtype)),this.state.numBytes+=r,this.state.tensorInfo.has(t.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(t.dataId,{backend:e||this.backend,dtype:t.dtype,shape:t.shape,bytes:r})),t instanceof Qf||this.track(t)}incRef(t,e){this.trackTensor(t,e),this.backend.incRef(t.dataId)}removeDataId(t,e){this.state.tensorInfo.has(t)&&this.state.tensorInfo.get(t).backend===e&&(this.state.tensorInfo.delete(t),this.state.numDataBuffers--)}disposeTensor(t){if(!this.state.tensorInfo.has(t.dataId))return;const e=this.state.tensorInfo.get(t.dataId);if(this.state.numTensors--,t.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=e.bytes),t.dtype!=="complex64"&&t.dtype!=="string"){const r=t.size*Hf(t.dtype);this.state.numBytes-=r}e.backend.disposeData(t.dataId)&&this.removeDataId(t.dataId,e.backend)}disposeVariables(){for(const t in this.state.registeredVariables){const e=this.state.registeredVariables[t];this.disposeVariable(e)}}disposeVariable(t){this.disposeTensor(t),this.state.registeredVariables[t.name]!=null&&delete this.state.registeredVariables[t.name]}memory(){const t=this.backend.memory();return t.numTensors=this.state.numTensors,t.numDataBuffers=this.state.numDataBuffers,t.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(t.unreliable=!0,t.reasons==null&&(t.reasons=[]),t.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),t}async profile(t){this.state.profiling=!0;const e=this.state.numBytes,r=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await t(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(a=>a.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-e,this.state.activeProfile.newTensors=this.state.numTensors-r;for(const a of this.state.activeProfile.kernels)a.kernelTimeMs=await a.kernelTimeMs,a.extraInfo=await a.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(t,e,r,a,s,o){const i={id:this.state.nextTapeNodeId++,kernelName:t,inputs:e,outputs:r,saved:s},u=nN(t);u!=null&&(a=u.gradFunc),a!=null&&(i.gradient=l=>(l=l.map((h,d)=>{if(h==null){const f=r[d],m=Mr(f.size,f.dtype);return this.makeTensor(m,f.shape,f.dtype)}return h}),a(l.length>1?l:l[0],s,o))),this.state.activeTape.push(i)}keep(t){return t.kept=!0,t}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(t){const e={track:[],name:"unnamed scope",id:this.state.nextScopeId++};t&&(e.name=t),this.state.scopeStack.push(e),this.state.activeScope=e}endScope(t){const e=Ok(t),r=new Set(e.map(s=>s.id));for(let s=0;s<this.state.activeScope.track.length;s++){const o=this.state.activeScope.track[s];!o.kept&&!r.has(o.id)&&o.dispose()}const a=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],e.forEach(s=>{!s.kept&&s.scopeId===a.id&&this.track(s)})}gradients(t,e,r,a=!1){if(P(e.length>0,()=>"gradients() received an empty list of xs."),r!=null&&r.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${r.dtype}'`);const s=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",t));P(s instanceof Ae,()=>"The result y returned by f() must be a tensor.");const o=zq(this.state.activeTape,e,s);if(!a&&o.length===0&&e.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const i={};i[s.id]=r??Xq(s.shape),Pq(i,o,l=>this.tidy(l),Yq);const u=e.map(l=>i[l.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(l=>{for(const h of l.saved)h.dispose()}),this.state.activeTape=null),{value:s,grads:u}})}customGrad(t){return P(Fu(t),()=>"The f passed in customGrad(f) must be a function."),(...e)=>{P(e.every(i=>i instanceof Ae),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let r;const a={};e.forEach((i,u)=>{a[u]=i});const s=(i,u)=>(r=t(...e,u),P(r.value instanceof Ae,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),P(Fu(r.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),r.value),o=(i,u)=>{const l=r.gradFunc(i,u),h=Array.isArray(l)?l:[l];P(h.length===e.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),P(h.every(f=>f instanceof Ae),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const d={};return h.forEach((f,m)=>{d[m]=()=>f}),d};return this.runKernelFunc({forwardFunc:s,backwardsFunc:o,inputs:a})}}readSync(t){return this.state.tensorInfo.get(t).backend.readSync(t)}read(t){return this.state.tensorInfo.get(t).backend.read(t)}readToGPU(t,e){return this.state.tensorInfo.get(t).backend.readToGPU(t,e)}async time(t){const e=ra(),r=await this.backend.time(t);return r.wallMs=ra()-e,r}track(t){return this.state.activeScope!=null&&(t.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(t)),t}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new J$;for(const t in this.registry)this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}Xh.nextTensorId=0;Xh.nextVariableId=0;function Xq(n){const t=Ob(xt(n),"float32");return J.makeTensor(t,n,"float32")}function oL(){const n=HM();if(n._tfengine==null){const t=new GM(n);n._tfengine=new Xh(t)}return gq(n._tfengine.ENV),Wq(()=>n._tfengine),n._tfengine}const J=oL();function Yq(n,t){const e={a:n,b:t};return J.runKernel(yc,e)}function Qq(){return typeof navigator<"u"&&navigator!=null}let lN;function Zq(n){lN=n}function Fk(n){if(lN!==void 0)return lN;if(n||Qq()){if(n||(n=navigator),n.product==="ReactNative")return!0;const t=n.userAgent||n.vendor||(typeof window<"u"?window.opera:"");if(!t){const e=n;return e.userAgentData&&e.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function Mk(){return typeof window<"u"&&window.document!=null||typeof WorkerGlobalScope<"u"}const Jq=Object.freeze(Object.defineProperty({__proto__:null,isBrowser:Mk,isMobile:Fk,mockIsMobile:Zq},Symbol.toStringTag,{value:"Module"}));const Ca=dt();Ca.registerFlag("DEBUG",()=>!1,n=>{n&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});Ca.registerFlag("IS_BROWSER",()=>Mk());Ca.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u");Ca.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));Ca.registerFlag("IS_SAFARI",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor));Ca.registerFlag("PROD",()=>!1);Ca.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>Ca.getBool("DEBUG"));Ca.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);Ca.registerFlag("IS_TEST",()=>!1);Ca.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>Ca.getBool("DEBUG"));Ca.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);Ca.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1);Ca.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);function Uo(n,t){let e=n;if(gr(n))return t==="string"?[]:[n.length];if(nL(n)){const a=n.channels||"RGBA";return[n.height,n.width*a.length]}else if(rL(n))return[n.buffer.size/(t==null?4:Hf(t))];if(!Array.isArray(n))return[];const r=[];for(;Array.isArray(e)||gr(e)&&t!=="string";)r.push(e.length),e=e[0];return Array.isArray(n)&&dt().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&iL(n,r,[]),r}function iL(n,t,e){if(e=e||[],!Array.isArray(n)&&!gr(n)){P(t.length===0,()=>`Element arr[${e.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`);return}P(t.length>0,()=>`Element arr[${e.join("][")}] should be a primitive, but is an array of ${n.length} elements`),P(n.length===t[0],()=>`Element arr[${e.join("][")}] should have ${t[0]} elements, but has ${n.length} elements`);const r=t.slice(1);for(let a=0;a<n.length;++a)iL(n[a],r,e.concat(a))}function tO(n,t,e,r){if(n!=="string_or_numeric"){if(n==null)throw new Error("Expected dtype cannot be null.");if(n!=="numeric"&&n!==t||n==="numeric"&&t==="string")throw new Error(`Argument '${e}' passed to '${r}' must be ${n} tensor, but got ${t} tensor`)}}function V(n,t,e,r="numeric"){if(n instanceof Ct())return tO(r,n.dtype,t,e),n;let a=gc(n);if(a!=="string"&&["bool","int32","float32"].indexOf(r)>=0&&(a=r),tO(r,a,t,e),n==null||!gr(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string"){const u=n==null?"null":n.constructor.name;throw new Error(`Argument '${t}' passed to '${e}' must be a Tensor or TensorLike, but got '${u}'`)}const s=Uo(n,a);!gr(n)&&!Array.isArray(n)&&(n=[n]);const i=a!=="string"?Yu(n,a):Vo(n,[],!0);return J.makeTensor(i,s,a)}function Zf(n,t,e,r="numeric"){if(!Array.isArray(n))throw new Error(`Argument ${t} passed to ${e} must be a \`Tensor[]\` or \`TensorLike[]\``);return n.map((s,o)=>V(s,`${t}[${o}]`,e,r))}const Lk="__op";function tt(n){const t=Object.keys(n);if(t.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let e=t[0];const r=n[e];e.endsWith("_")&&(e=e.substring(0,e.length-1)),e=e+Lk;const a=(...s)=>{J.startScope(e);try{const o=r(...s);return Mu(o)&&console.error("Cannot return a Promise inside of tidy."),J.endScope(o),o}catch(o){throw J.endScope(null),o}};return Object.defineProperty(a,"name",{value:e,configurable:!0}),a}function t8(n,t){const e=V(n,"real","complex"),r=V(t,"imag","complex");Br(e.shape,r.shape,`real and imag shapes, ${e.shape} and ${r.shape}, must match in call to tf.complex().`);const a={real:e,imag:r};return J.runKernel(Vb,a)}const _i=tt({complex_:t8});function Qu(n,t,e,r){if(r==null)r=gc(n);else if(r==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(rL(n)||nL(n)){if(r!=="float32"&&r!=="int32")throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${r}.`);return J.backend.createTensorFromGPUData(n,t||e,r)}if(!gr(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(t!=null){Ya(t);const a=xt(t),s=xt(e);P(a===s,()=>`Based on the provided shape, [${t}], the tensor should have ${a} values but has ${s}`);for(let o=0;o<e.length;++o){const i=e[o],u=o===e.length-1?i!==xt(t.slice(o)):!0;P(e[o]===t[o]||!u,()=>`Error creating a new Tensor. Inferred shape (${e}) does not match the provided shape (${t}). `)}}return!gr(n)&&!Array.isArray(n)&&(n=[n]),t=t||e,n=r!=="string"?Yu(n,r):Vo(n,[],!0),J.makeTensor(n,t,r)}function gs(n,t,e){const r=Uo(n,e);return Qu(n,t,r,e)}const Jl={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};class uo{static join(t){return new uo(t).slice()}constructor(t){if(this.shards=[],this.previousShardIndex=0,t==null||(t instanceof Array||(t=[t]),t=t.map(r=>gr(r)?r.buffer:r),t.length===0))return;this.bufferUniformSize=t[0].byteLength;let e=0;for(let r=0;r<t.length;r++){const a=t[r];r!==t.length-1&&a.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const s=e+a.byteLength;this.shards.push({buffer:a,start:e,end:s}),e=s}this.shards.length===0&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(t=0,e=this.byteLength){if(this.shards.length===0)return new ArrayBuffer(0);if(t=isNaN(Number(t))?0:t,e=isNaN(Number(e))?0:e,t=Math.max(0,t),e=Math.min(this.byteLength,e),e<=t)return new ArrayBuffer(0);const r=this.findShardForByte(t);if(r===-1)throw new Error(`Could not find start shard for byte ${t}`);const a=e-t,s=new ArrayBuffer(a),o=new Uint8Array(s);let i=0;for(let u=r;u<this.shards.length;u++){const l=this.shards[u],d=t+i-l.start,f=i,v=Math.min(e,l.end)-l.start,y=new Uint8Array(l.buffer,d,v-d);if(o.set(y,f),i+=y.length,e<l.end)break}return s}findShardForByte(t){if(this.shards.length===0||t<0||t>=this.byteLength)return-1;if(this.bufferUniformSize!=null)return this.previousShardIndex=Math.floor(t/this.bufferUniformSize),this.previousShardIndex;function e(a){return t<a.start?-1:t>=a.end?1:0}if(e(this.shards[this.previousShardIndex])===0)return this.previousShardIndex;const r=e8(this.shards,e);return r===-1?-1:(this.previousShardIndex=r,this.previousShardIndex)}}function e8(n,t){let e=0,r=n.length;for(;e<=r;){const a=Math.floor((r-e)/2)+e,s=t(n[a]);if(s===0)return a;s<0?r=a:e=a+1}return-1}function n8(){dt().set("PROD",!0)}function r8(){dt().set("DEBUG",!0)}function a8(){dt().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function s8(n){dt().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(n+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}function o8(){J.disposeVariables()}function as(){return J}function cN(){return J.memory()}function i8(n){return J.profile(n)}function ut(n,t){return J.tidy(n,t)}function Ie(n){Ok(n).forEach(e=>e.dispose())}function ar(n){return J.keep(n)}function u8(n){return J.time(n)}function l8(n){return J.setBackend(n)}function c8(){return J.ready()}function Bk(){return J.backendName}function h8(n){J.removeBackend(n)}function d8(n){return J.findBackend(n)}function p8(n){return J.findBackendFactory(n)}function zk(n,t,e=1){return J.registerBackend(n,t,e)}function Ux(){return J.backend}function f8(n,t){dt().setPlatform(n,t)}const Lu=4;async function hN(n,t){const e=[],r=[],a=Array.isArray(n)?n.map(o=>o.name):Object.keys(n);for(let o=0;o<a.length;++o){const i=a[o],u=Array.isArray(n)?n[o].tensor:n[i];if(u.dtype!=="float32"&&u.dtype!=="int32"&&u.dtype!=="bool"&&u.dtype!=="string"&&u.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${i}': ${u.dtype}`);const l={name:i,shape:u.shape,dtype:u.dtype};if(u.dtype==="string"){const h=new Promise(async d=>{const f=await u.bytes(),m=f.reduce((b,w)=>b+w.length,0)+Lu*f.length,v=new Uint8Array(m);let y=0;for(let b=0;b<f.length;b++){const w=f[b],S=new Uint8Array(new Uint32Array([w.length]).buffer);v.set(S,y),y+=Lu,v.set(w,y),y+=w.length}d(v)});r.push(h)}else r.push(u.data());t!=null&&(l.group=t),e.push(l)}const s=await Promise.all(r);return{data:v8(s),specs:e}}function uL(n,t){const e=new uo(n),r={};let a=0;for(const s of t){const o=m8(s,(i,u)=>e.slice(a+i,a+u));r[s.name]=lL(s,e.slice(a,a+o)),a+=o}return r}function m8(n,t){const e=xt(n.shape);let r;if("quantization"in n){const a=n.quantization;r=Jl[a.dtype]}else if(n.dtype==="string"){let a=0;for(let s=0;s<e;s++)a+=Lu+new Uint32Array(t(a,a+Lu))[0];return a}else r=Jl[n.dtype];return e*r}async function g8(n,t){const e=xt(n.shape);let r;if("quantization"in n){const a=n.quantization;r=Jl[a.dtype]}else if(n.dtype==="string"){let a=0;for(let s=0;s<e;s++)a+=Lu+new Uint32Array(await t(a,a+Lu))[0];return a}else r=Jl[n.dtype];return e*r}function lL(n,t){const e=n.name,r=n.dtype,a=n.shape,s=xt(a);let o,i=0;if("quantization"in n){const u=n.quantization;if(u.dtype==="uint8"||u.dtype==="uint16"){if(!("min"in u&&"scale"in u))throw new Error(`Weight ${n.name} with quantization ${u.dtype} doesn't have corresponding metadata min and scale.`)}else if(u.dtype==="float16"){if(r!=="float32")throw new Error(`Weight ${n.name} is quantized with ${u.dtype} which only supports weights of type float32 not ${r}.`)}else throw new Error(`Weight ${n.name} has unknown quantization dtype ${u.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);const l=Jl[u.dtype],h=u.dtype==="uint8"?new Uint8Array(t):new Uint16Array(t);if(r==="float32")if(u.dtype==="uint8"||u.dtype==="uint16"){o=new Float32Array(h.length);for(let d=0;d<h.length;d++){const f=h[d];o[d]=f*u.scale+u.min}}else if(u.dtype==="float16")o=C8()(h);else throw new Error(`Unsupported quantization type ${u.dtype} for weight type float32.`);else if(r==="int32"){if(u.dtype!=="uint8"&&u.dtype!=="uint16")throw new Error(`Unsupported quantization type ${u.dtype} for weight type int32.`);o=new Int32Array(h.length);for(let d=0;d<h.length;d++){const f=h[d];o[d]=Math.round(f*u.scale+u.min)}}else throw new Error(`Unsupported dtype in weight '${e}': ${r}`);i+=s*l}else if(r==="string"){const u=xt(n.shape);o=[];for(let l=0;l<u;l++){const h=new Uint32Array(t.slice(i,i+Lu))[0];i+=Lu;const d=new Uint8Array(t.slice(i,i+h));o.push(d),i+=h}}else{const u=Jl[r];if(r==="float32")o=new Float32Array(t);else if(r==="int32")o=new Int32Array(t);else if(r==="bool")o=new Uint8Array(t);else if(r==="complex64"){o=new Float32Array(t);const l=new Float32Array(o.length/2),h=new Float32Array(o.length/2);for(let v=0;v<l.length;v++)l[v]=o[v*2],h[v]=o[v*2+1];const d=gs(l,a,"float32"),f=gs(h,a,"float32"),m=_i(d,f);return d.dispose(),f.dispose(),m}else throw new Error(`Unsupported dtype in weight '${e}': ${r}`);i+=s*u}return gs(o,a,r)}async function eO(n,t,e){let r=new Uint8Array(t);for(;r.byteLength<e;){const{done:a,value:s}=await n.read();if(a&&s==null){const i=e-r.byteLength;throw new Error(`Reader is done but ${i} bytes are still expected`)}const o=new Uint8Array(r.length+s.byteLength);o.set(r,0),o.set(new Uint8Array(s),r.length),r=o}return r.buffer}async function cL(n,t){const e={},r=n.getReader();let a=new ArrayBuffer(0);for(const s of t){const o=await g8(s,async(l,h)=>(a=await eO(r,a,h),a.slice(l,h)));a=await eO(r,a,o);const i=a.slice(0,o);a=a.slice(o);const u=lL(s,i);if(e[s.name]=u,Bk()==="webgpu"){const l=Ux();"uploadToGPU"in l&&xt(u.shape)>=dt().get("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD")&&l.uploadToGPU(u.dataId)}}return e}function v8(n){if(n===null)throw new Error(`Invalid input value: ${JSON.stringify(n)}`);let t=0;const e=[];n.forEach(s=>{if(t+=s.byteLength,e.push(s.byteLength===s.buffer.byteLength?s:new s.constructor(s)),!(s instanceof Float32Array||s instanceof Int32Array||s instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${s.constructor.name}`)});const r=new Uint8Array(t);let a=0;return e.forEach(s=>{r.set(new Uint8Array(s.buffer),a),a+=s.byteLength}),r.buffer}const Pk=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function nO(n){return Pk?Buffer.byteLength(n,"utf8"):new Blob([n]).size}function y8(n){if(Pk)return Buffer.from(n).toString("base64");const t=new Uint8Array(n);let e="";for(let r=0,a=t.length;r<a;r++)e+=String.fromCharCode(t[r]);return btoa(e)}function b8(n){if(Pk){const r=Buffer.from(n,"base64");return r.buffer.slice(r.byteOffset,r.byteOffset+r.byteLength)}const t=atob(n),e=new Uint8Array(t.length);for(let r=0;r<t.length;++r)e.set([t.charCodeAt(r)],r);return e.buffer}function hL(n){return uo.join(n)}function rO(n){for(n=n.trim();n.endsWith("/");)n=n.slice(0,n.length-1);const e=n.split("/");return e[e.length-1]}function dL(n,t){const e={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy,weightsManifest:t};return n.signature!=null&&(e.signature=n.signature),n.userDefinedMetadata!=null&&(e.userDefinedMetadata=n.userDefinedMetadata),n.modelInitializer!=null&&(e.modelInitializer=n.modelInitializer),n.initializerSignature!=null&&(e.initializerSignature=n.initializerSignature),n.trainingConfig!=null&&(e.trainingConfig=n.trainingConfig),e}function Vk(n,t,e){const r={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy};if(n.trainingConfig!=null&&(r.trainingConfig=n.trainingConfig),n.weightsManifest!=null){if(!t)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!e)throw new Error("modelJSON has weightsManifest but weightData is null");r.weightSpecs=t,r.weightData=e}return n.signature!=null&&(r.signature=n.signature),n.userDefinedMetadata!=null&&(r.userDefinedMetadata=n.userDefinedMetadata),n.modelInitializer!=null&&(r.modelInitializer=n.modelInitializer),n.initializerSignature!=null&&(r.initializerSignature=n.initializerSignature),r}async function Uk(n,t){let e,r;return n.weightsManifest!=null&&([e,r]=await t(n.weightsManifest)),Vk(n,e,r)}function Ng(n){if(n.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:n.modelTopology==null?0:nO(JSON.stringify(n.modelTopology)),weightSpecsBytes:n.weightSpecs==null?0:nO(JSON.stringify(n.weightSpecs)),weightDataBytes:n.weightData==null?0:new uo(n.weightData).byteLength}}function z0(n){const t=[];for(const e of n)t.push(...e.weights);return t}function x8(){const n=e=>{let r=e<<13,a=0;for(;(r&8388608)===0;)a-=8388608,r<<=1;return r&=-8388609,a+=947912704,r|a},t=new Uint32Array(2048);t[0]=0;for(let e=1;e<1024;e++)t[e]=n(e);for(let e=1024;e<2048;e++)t[e]=939524096+(e-1024<<13);return t}function w8(){const n=new Uint32Array(64);n[0]=0,n[31]=1199570944,n[32]=2147483648,n[63]=3347054592;for(let t=1;t<31;t++)n[t]=t<<23;for(let t=33;t<63;t++)n[t]=2147483648+(t-32<<23);return n}function S8(){const n=new Uint32Array(64);for(let t=0;t<64;t++)n[t]=1024;return n[0]=n[32]=0,n}function C8(){const n=x8(),t=w8(),e=S8();return r=>{const a=new ArrayBuffer(4*r.length),s=new Uint32Array(a);for(let o=0;o<r.length;o++){const i=r[o],u=n[e[i>>10]+(i&1023)]+t[i>>10];s[o]=u}return new Float32Array(a)}}class Tn{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return Tn.instance==null&&(Tn.instance=new Tn),Tn.instance}static registerSaveRouter(t){Tn.getInstance().saveRouters.push(t)}static registerLoadRouter(t){Tn.getInstance().loadRouters.push(t)}static getSaveHandlers(t){return Tn.getHandlers(t,"save")}static getLoadHandlers(t,e){return Tn.getHandlers(t,"load",e)}static getHandlers(t,e,r){const a=[];return(e==="load"?Tn.getInstance().loadRouters:Tn.getInstance().saveRouters).forEach(o=>{const i=o(t,r);i!==null&&a.push(i)}),a}}const N8=n=>Tn.registerSaveRouter(n),k8=n=>Tn.registerLoadRouter(n),pL=n=>Tn.getSaveHandlers(n),T8=(n,t)=>Tn.getLoadHandlers(n,t);const dN="tensorflowjs",pN=1,Ul="models_store",Su="model_info_store";function fL(){if(!dt().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const n=typeof window>"u"?self:window,t=n.indexedDB||n.mozIndexedDB||n.webkitIndexedDB||n.msIndexedDB||n.shimIndexedDB;if(t==null)throw new Error("The current browser does not appear to support IndexedDB.");return t}function fN(n){const t=n.result;t.createObjectStore(Ul,{keyPath:"modelPath"}),t.createObjectStore(Su,{keyPath:"modelPath"})}class tc{constructor(t){if(this.indexedDB=fL(),t==null||!t)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=t}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,t)}async load(){return this.databaseAction(this.modelPath)}databaseAction(t,e){return new Promise((r,a)=>{const s=this.indexedDB.open(dN,pN);s.onupgradeneeded=()=>fN(s),s.onsuccess=()=>{const o=s.result;if(e==null){const i=o.transaction(Ul,"readonly"),l=i.objectStore(Ul).get(this.modelPath);l.onsuccess=()=>{if(l.result==null)return o.close(),a(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));r(l.result.modelArtifacts)},l.onerror=h=>(o.close(),a(l.error)),i.oncomplete=()=>o.close()}else{e.weightData=uo.join(e.weightData);const i=Ng(e),u=o.transaction(Su,"readwrite");let l=u.objectStore(Su),h;try{h=l.put({modelPath:this.modelPath,modelArtifactsInfo:i})}catch(f){return a(f)}let d;h.onsuccess=()=>{d=o.transaction(Ul,"readwrite");const f=d.objectStore(Ul);let m;try{m=f.put({modelPath:this.modelPath,modelArtifacts:e,modelArtifactsInfo:i})}catch(v){return a(v)}m.onsuccess=()=>r({modelArtifactsInfo:i}),m.onerror=v=>{l=u.objectStore(Su);const y=l.delete(this.modelPath);y.onsuccess=()=>(o.close(),a(m.error)),y.onerror=b=>(o.close(),a(m.error))}},h.onerror=f=>(o.close(),a(h.error)),u.oncomplete=()=>{d==null?o.close():d.oncomplete=()=>o.close()}}},s.onerror=o=>a(s.error)})}}tc.URL_SCHEME="indexeddb://";const mL=n=>dt().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(tc.URL_SCHEME)?E8(n.slice(tc.URL_SCHEME.length)):null;Tn.registerSaveRouter(mL);Tn.registerLoadRouter(mL);function E8(n){return new tc(n)}function I8(n){return n.startsWith(tc.URL_SCHEME)?n.slice(tc.URL_SCHEME.length):n}class _8{constructor(){this.indexedDB=fL()}async listModels(){return new Promise((t,e)=>{const r=this.indexedDB.open(dN,pN);r.onupgradeneeded=()=>fN(r),r.onsuccess=()=>{const a=r.result,s=a.transaction(Su,"readonly"),i=s.objectStore(Su).getAll();i.onsuccess=()=>{const u={};for(const l of i.result)u[l.modelPath]=l.modelArtifactsInfo;t(u)},i.onerror=u=>(a.close(),e(i.error)),s.oncomplete=()=>a.close()},r.onerror=a=>e(r.error)})}async removeModel(t){return t=I8(t),new Promise((e,r)=>{const a=this.indexedDB.open(dN,pN);a.onupgradeneeded=()=>fN(a),a.onsuccess=()=>{const s=a.result,o=s.transaction(Su,"readwrite"),i=o.objectStore(Su),u=i.get(t);let l;u.onsuccess=()=>{if(u.result==null)return s.close(),r(new Error(`Cannot find model with path '${t}' in IndexedDB.`));{const h=i.delete(t),d=()=>{l=s.transaction(Ul,"readwrite");const m=l.objectStore(Ul).delete(t);m.onsuccess=()=>e(u.result.modelArtifactsInfo),m.onerror=v=>r(u.error)};h.onsuccess=d,h.onerror=f=>(d(),s.close(),r(u.error))}},u.onerror=h=>(s.close(),r(u.error)),o.oncomplete=()=>{l==null?s.close():l.oncomplete=()=>s.close()}},a.onerror=s=>r(a.error)})}}const ki="/",Ih="tensorflowjs_models",gL="info",R8="model_topology",A8="weight_specs",D8="weight_data",$8="model_metadata";function vL(n){return{info:[Ih,n,gL].join(ki),topology:[Ih,n,R8].join(ki),weightSpecs:[Ih,n,A8].join(ki),weightData:[Ih,n,D8].join(ki),modelMetadata:[Ih,n,$8].join(ki)}}function yL(n){for(const t of Object.values(n))window.localStorage.removeItem(t)}function O8(n){const t=n.split(ki);if(t.length<3)throw new Error(`Invalid key format: ${n}`);return t.slice(1,t.length-1).join(ki)}function F8(n){return n.startsWith(ec.URL_SCHEME)?n.slice(ec.URL_SCHEME.length):n}class ec{constructor(t){if(!dt().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,t==null||!t)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=t,this.keys=vL(this.modelPath)}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const e=JSON.stringify(t.modelTopology),r=JSON.stringify(t.weightSpecs),a=Ng(t),s=uo.join(t.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(a)),this.LS.setItem(this.keys.topology,e),this.LS.setItem(this.keys.weightSpecs,r),this.LS.setItem(this.keys.weightData,y8(s));const o={format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,signature:t.signature!=null?t.signature:void 0,userDefinedMetadata:t.userDefinedMetadata!=null?t.userDefinedMetadata:void 0,modelInitializer:t.modelInitializer!=null?t.modelInitializer:void 0,initializerSignature:t.initializerSignature!=null?t.initializerSignature:void 0,trainingConfig:t.trainingConfig!=null?t.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(o)),{modelArtifactsInfo:a}}catch{throw yL(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${a.modelTopologyBytes}, weightSpecsBytes=${a.weightSpecsBytes}, weightDataBytes=${a.weightDataBytes}.`)}}}async load(){const t=JSON.parse(this.LS.getItem(this.keys.info));if(t==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(t.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const e={},r=JSON.parse(this.LS.getItem(this.keys.topology));if(r==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);e.modelTopology=r;const a=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(a==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);e.weightSpecs=a;const s=this.LS.getItem(this.keys.modelMetadata);if(s!=null){const i=JSON.parse(s);e.format=i.format,e.generatedBy=i.generatedBy,e.convertedBy=i.convertedBy,i.signature!=null&&(e.signature=i.signature),i.userDefinedMetadata!=null&&(e.userDefinedMetadata=i.userDefinedMetadata),i.modelInitializer!=null&&(e.modelInitializer=i.modelInitializer),i.initializerSignature!=null&&(e.initializerSignature=i.initializerSignature),i.trainingConfig!=null&&(e.trainingConfig=i.trainingConfig)}const o=this.LS.getItem(this.keys.weightData);if(o==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return e.weightData=b8(o),e}}ec.URL_SCHEME="localstorage://";const bL=n=>dt().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(ec.URL_SCHEME)?M8(n.slice(ec.URL_SCHEME.length)):null;Tn.registerSaveRouter(bL);Tn.registerLoadRouter(bL);function M8(n){return new ec(n)}class L8{constructor(){P(dt().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),P(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const t={},e=Ih+ki,r=ki+gL;for(let a=0;a<this.LS.length;++a){const s=this.LS.key(a);if(s.startsWith(e)&&s.endsWith(r)){const o=O8(s);t[o]=JSON.parse(this.LS.getItem(s))}}return t}async removeModel(t){t=F8(t);const e=vL(t);if(this.LS.getItem(e.info)==null)throw new Error(`Cannot find model at path '${t}'`);const r=JSON.parse(this.LS.getItem(e.info));return yL(e),r}}const Fh="://";class aa{constructor(){this.managers={}}static getInstance(){return aa.instance==null&&(aa.instance=new aa),aa.instance}static registerManager(t,e){P(t!=null,()=>"scheme must not be undefined or null."),t.endsWith(Fh)&&(t=t.slice(0,t.indexOf(Fh))),P(t.length>0,()=>"scheme must not be an empty string.");const r=aa.getInstance();P(r.managers[t]==null,()=>`A model store manager is already registered for scheme '${t}'.`),r.managers[t]=e}static getManager(t){const e=aa.getInstance().managers[t];if(e==null)throw new Error(`Cannot find model manager for scheme '${t}'`);return e}static getSchemes(){return Object.keys(aa.getInstance().managers)}}function y0(n){if(n.indexOf(Fh)===-1)throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${aa.getSchemes().join(",")}`);return{scheme:n.split(Fh)[0],path:n.split(Fh)[1]}}async function xL(n,t,e=!1){P(n!==t,()=>`Old path and new path are the same: '${n}'`);const r=Tn.getLoadHandlers(n);P(r.length>0,()=>`Copying failed because no load handler is found for source URL ${n}.`),P(r.length<2,()=>`Copying failed because more than one (${r.length}) load handlers for source URL ${n}.`);const a=r[0],s=Tn.getSaveHandlers(t);P(s.length>0,()=>`Copying failed because no save handler is found for destination URL ${t}.`),P(s.length<2,()=>`Copying failed because more than one (${r.length}) save handlers for destination URL ${t}.`);const o=s[0],i=y0(n).scheme,u=y0(n).path,l=i===y0(n).scheme,h=await a.load();e&&l&&await aa.getManager(i).removeModel(u);const d=await o.save(h);return e&&!l&&await aa.getManager(i).removeModel(u),d.modelArtifactsInfo}async function B8(){const n=aa.getSchemes(),t={};for(const e of n){const r=await aa.getManager(e).listModels();for(const a in r){const s=e+Fh+a;t[s]=r[a]}}return t}async function z8(n){const t=y0(n);return aa.getManager(t.scheme).removeModel(t.path)}async function P8(n,t){return xL(n,t,!1)}async function V8(n,t){return xL(n,t,!0)}class U8{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(t,e){return fetch(t,e)}now(){return performance.now()}encode(t,e){if(e!=="utf-8"&&e!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${e}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(t)}decode(t,e){return new TextDecoder(e).decode(t)}setTimeoutCustom(t,e){if(typeof window>"u"||!dt().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(t,e);return}this.functionRefs.push(t),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},e),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",r=>{if(r.source===window&&r.data.name===this.messageName){r.stopPropagation();const a=this.functionRefs[r.data.index];a(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}isTypedArray(t){return XM(t)}}if(dt().get("IS_BROWSER")){dt().setPlatform("browser",new U8);try{aa.registerManager(ec.URL_SCHEME,new L8)}catch{}try{aa.registerManager(tc.URL_SCHEME,new _8)}catch{}}const W8={importFetch:()=>require("node-fetch")};let LS;class G8{constructor(){this.util=require("util"),this.textEncoder=new this.util.TextEncoder}fetch(t,e){return dt().global.fetch!=null?dt().global.fetch(t,e):(LS==null&&(LS=W8.importFetch()),LS(t,e))}now(){const t=process.hrtime();return t[0]*1e3+t[1]/1e6}encode(t,e){if(e!=="utf-8"&&e!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${e}`);return this.textEncoder.encode(t)}decode(t,e){return t.length===0?"":new this.util.TextDecoder(e).decode(t)}isTypedArray(t){return this.util.types.isFloat32Array(t)||this.util.types.isInt32Array(t)||this.util.types.isUint8Array(t)||this.util.types.isUint8ClampedArray(t)}}dt().get("IS_NODE")&&!dt().get("IS_BROWSER")&&dt().setPlatform("node",new G8);function we(n,t="float32",e){return t=t||"float32",Ya(n),new Yn(n,t,e)}function H8(n,t){const e=V(n,"x","cast");if(!zM(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if(t==="string"&&e.dtype!=="string"||t!=="string"&&e.dtype==="string")throw new Error("Only strings can be casted to strings");const r={x:e},a={dtype:t};return J.runKernel(yd,r,a)}const Ft=tt({cast_:H8});function j8(n){const e={x:V(n,"x","clone","string_or_numeric")};return J.runKernel(Ad,e)}const Oo=tt({clone_:j8});function Wk(n,t=!1){console.log(n.toString(t))}oL();const q8={buffer:we,cast:Ft,clone:Oo,print:Wk};Gq(q8);function K8(n,t){let e=V(n,"a","add"),r=V(t,"b","add");[e,r]=Rn(e,r);const a={a:e,b:r};return J.runKernel(yc,a)}const It=tt({add_:K8});function X8(n,t){let e=V(n,"a","floorDiv"),r=V(t,"b","floorDiv");[e,r]=Rn(e,r);const a={a:e,b:r};return J.runKernel(_d,a)}const Wx=tt({floorDiv_:X8});function Y8(n,t){let e=V(n,"a","div"),r=V(t,"b","div");if([e,r]=Rn(e,r),e.dtype==="int32"&&r.dtype==="int32")return Wx(e,r);const a={a:e,b:r},s={};return J.runKernel(Cd,a,s)}const Ut=tt({div_:Y8});function Q8(n,t){let e=V(n,"a","mul"),r=V(t,"b","mul");[e,r]=Rn(e,r);const a={a:e,b:r};return J.runKernel(Pd,a)}const et=tt({mul_:Q8});function Z8(n){const t=V(n,"x","abs");if(t.dtype==="complex64"){const e={x:t};return J.runKernel(_m,e)}else{const e={x:t};return J.runKernel(xm,e)}}const Kn=tt({abs_:Z8});function J8(n){const e={x:V(n,"x","acos")};return J.runKernel(hd,e)}const Gk=tt({acos_:J8});function tK(n){const e={x:V(n,"x","acosh")};return J.runKernel(dd,e)}const Hk=tt({acosh_:tK});function eK(n){P(Array.isArray(n),()=>"The argument passed to tf.addN() must be a list of tensors"),P(n.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${n.length}`);const t=n.map((a,s)=>V(a,`tensors${s}`,"addN")),e=t[0];t.forEach(a=>{if(a.dtype!==e.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),t.forEach(a=>{if(!De(a.shape,e.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});const r=t;return J.runKernel(wm,r)}const wL=tt({addN_:eK});function nK(n,t=null,e=!1){const a={x:V(n,"x","all","bool")},s={axis:t,keepDims:e};return J.runKernel(Fb,a,s)}const Gx=tt({all_:nK});function rK(n,t=null,e=!1){const a={x:V(n,"x","any","bool")},s={axis:t,keepDims:e};return J.runKernel(Mb,a,s)}const Jf=tt({any_:rK});function aK(n,t=0){const r={x:V(n,"x","argMax")},a={axis:t};return J.runKernel(Sm,r,a)}const Bu=tt({argMax_:aK});function sK(n,t=0){const r={x:V(n,"x","argMin")},a={axis:t};return J.runKernel(Cm,r,a)}const jk=tt({argMin_:sK});function oK(n){const e={x:V(n,"x","asin")};return J.runKernel(pd,e)}const qk=tt({asin_:oK});function iK(n){const e={x:V(n,"x","asinh")};return J.runKernel(fd,e)}const Kk=tt({asinh_:iK});function uK(n){const e={x:V(n,"x","atan")};return J.runKernel(md,e)}const Xk=tt({atan_:uK});function lK(n,t){let e=V(n,"a","atan2"),r=V(t,"b","atan2");[e,r]=Rn(e,r);const a={a:e,b:r};return J.runKernel(vd,a)}const Yk=tt({atan2_:lK});function cK(n){const e={x:V(n,"x","atanh")};return J.runKernel(gd,e)}const Qk=tt({atanh_:cK});function kg(n,t,e,r,a="NHWC",s){const o=n[3],i=[...t,o],u=Li(a);return Nr(n,i,e,s,r,null,null,u)}function Vs(n,t,e,r,a,s,o="channelsLast"){const[i,u]=tm(t);let l;if(o==="channelsLast")l=[i,u,n[3],n[3]];else if(o==="channelsFirst")l=[i,u,n[1],n[1]];else throw new Error(`Unknown dataFormat ${o}`);return Nr(n,l,e,r,a,s,!1,o)}function Mi(n,t,e,r,a,s,o="NDHWC"){const[i,u,l]=mN(t);let h,d;if(o==="NDHWC")d="channelsLast",h=[i,u,l,n[4],n[4]];else if(o==="NCDHW")d="channelsFirst",h=[i,u,l,n[1],n[1]];else throw new Error(`Unknown dataFormat ${o}`);return Zu(n,h,e,r,a,!1,d,s)}function Nr(n,t,e,r,a,s,o=!1,i="channelsLast"){let[u,l,h,d]=[-1,-1,-1,-1];if(i==="channelsLast")[u,l,h,d]=n;else if(i==="channelsFirst")[u,d,l,h]=n;else throw new Error(`Unknown dataFormat ${i}`);const[f,m,,v]=t,[y,b]=tm(e),[w,S]=tm(r),N=Mh(f,w),C=Mh(m,S),{padInfo:T,outHeight:I,outWidth:_}=pK(a,l,h,y,b,N,C,s,i),$=o?v*d:v;let R;return i==="channelsFirst"?R=[u,$,I,_]:i==="channelsLast"&&(R=[u,I,_,$]),{batchSize:u,dataFormat:i,inHeight:l,inWidth:h,inChannels:d,outHeight:I,outWidth:_,outChannels:$,padInfo:T,strideHeight:y,strideWidth:b,filterHeight:f,filterWidth:m,effectiveFilterHeight:N,effectiveFilterWidth:C,dilationHeight:w,dilationWidth:S,inShape:n,outShape:R,filterShape:t}}function Zu(n,t,e,r,a,s=!1,o="channelsLast",i){let[u,l,h,d,f]=[-1,-1,-1,-1,-1];if(o==="channelsLast")[u,l,h,d,f]=n;else if(o==="channelsFirst")[u,f,l,h,d]=n;else throw new Error(`Unknown dataFormat ${o}`);const[m,v,y,,b]=t,[w,S,N]=mN(e),[C,T,I]=mN(r),_=Mh(m,C),$=Mh(v,T),R=Mh(y,I),{padInfo:D,outDepth:A,outHeight:L,outWidth:H}=fK(a,l,h,d,w,S,N,_,$,R,i),G=s?b*f:b;let q;return o==="channelsFirst"?q=[u,G,A,L,H]:o==="channelsLast"&&(q=[u,A,L,H,G]),{batchSize:u,dataFormat:o,inDepth:l,inHeight:h,inWidth:d,inChannels:f,outDepth:A,outHeight:L,outWidth:H,outChannels:G,padInfo:D,strideDepth:w,strideHeight:S,strideWidth:N,filterDepth:m,filterHeight:v,filterWidth:y,effectiveFilterDepth:_,effectiveFilterHeight:$,effectiveFilterWidth:R,dilationDepth:C,dilationHeight:T,dilationWidth:I,inShape:n,outShape:q,filterShape:t}}function hK(n,t,e,r,a){r==null&&(r=Zk(n,t,e));const s=n[0],o=n[1],i=em((s-t+2*r)/e+1,a),u=em((o-t+2*r)/e+1,a);return[i,u]}function dK(n,t,e,r,a,s){a==null&&(a=Zk(n,t[0],r[0]));const o=[0,0,0,e];for(let i=0;i<3;i++)n[i]+2*a>=t[i]&&(o[i]=em((n[i]-t[i]+2*a)/r[i]+1,s));return o}function Zk(n,t,e,r=1){const a=Mh(t,r);return Math.floor((n[0]*(e-1)-e+a)/2)}function tm(n){return typeof n=="number"?[n,n,n]:n.length===2?[n[0],n[1],1]:n}function mN(n){return typeof n=="number"?[n,n,n]:n}function Mh(n,t){return t<=1?n:n+(n-1)*(t-1)}function pK(n,t,e,r,a,s,o,i,u){let l,h,d;if(typeof n=="number"){l={top:n,bottom:n,left:n,right:n,type:n===0?"VALID":"NUMBER"};const m=hK([t,e],s,r,n,i);h=m[0],d=m[1]}else if(n==="same"){h=Math.ceil(t/r),d=Math.ceil(e/a);const f=Math.max(0,(h-1)*r+s-t),m=Math.max(0,(d-1)*a+o-e),v=Math.floor(f/2),y=f-v,b=Math.floor(m/2),w=m-b;l={top:v,bottom:y,left:b,right:w,type:"SAME"}}else if(n==="valid")l={top:0,bottom:0,left:0,right:0,type:"VALID"},h=Math.ceil((t-s+1)/r),d=Math.ceil((e-o+1)/a);else if(typeof n=="object"){const f=u==="channelsLast"?n[1][0]:n[2][0],m=u==="channelsLast"?n[1][1]:n[2][1],v=u==="channelsLast"?n[2][0]:n[3][0],y=u==="channelsLast"?n[2][1]:n[3][1];l={top:f,bottom:m,left:v,right:y,type:f===0&&m===0&&v===0&&y===0?"VALID":"EXPLICIT"},h=em((t-s+f+m)/r+1,i),d=em((e-o+v+y)/a+1,i)}else throw Error(`Unknown padding parameter: ${n}`);return{padInfo:l,outHeight:h,outWidth:d}}function fK(n,t,e,r,a,s,o,i,u,l,h){let d,f,m,v;if(n==="valid"&&(n=0),typeof n=="number"){d={top:n,bottom:n,left:n,right:n,front:n,back:n,type:n===0?"VALID":"NUMBER"};const b=dK([t,e,r,1],[i,u,l],1,[a,s,o],n,h);f=b[0],m=b[1],v=b[2]}else if(n==="same"){f=Math.ceil(t/a),m=Math.ceil(e/s),v=Math.ceil(r/o);const y=(f-1)*a+i-t,b=(m-1)*s+u-e,w=(v-1)*o+l-r,S=Math.floor(y/2),N=y-S,C=Math.floor(b/2),T=b-C,I=Math.floor(w/2),_=w-I;d={top:C,bottom:T,left:I,right:_,front:S,back:N,type:"SAME"}}else throw Error(`Unknown padding parameter: ${n}`);return{padInfo:d,outDepth:f,outHeight:m,outWidth:v}}function em(n,t){if(!t)return Math.trunc(n);switch(t){case"round":return Math.round(n);case"ceil":return Math.ceil(n);case"floor":return Math.floor(n);default:throw new Error(`Unknown roundingMode ${t}`)}}function zu(n){const[t,e,r]=tm(n);return t===1&&e===1&&r===1}function zr(n,t){return zu(n)||zu(t)}function nc(n){return tm(n).every(t=>t>0)}function Li(n){if(n==="NHWC")return"channelsLast";if(n==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${n}`)}function ma(n,t,e){if(e!=null){if(typeof t=="string")throw Error(`Error in ${n}: pad must be an integer when using dimRoundingMode ${e} but got pad ${t}.`);if(typeof t=="number")P(Zl(t),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${e} but got pad ${t}.`);else if(typeof t=="object")t.forEach(r=>{r.forEach(a=>{P(Zl(a),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${e} but got pad ${a}.`)})});else throw Error(`Error in ${n}: Unknown padding parameter: ${t}`)}}function mK(n,t){const r={x:V(n,"x","reshape","string_or_numeric")},a={shape:t};return J.runKernel(lg,r,a)}const at=tt({reshape_:mK});function gK(n,t,e,r,a){const s=V(n,"x","avgPool","float32"),o=1;P(zr(e,o),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${e} and dilations '${o}'`);let i=s,u=!1;s.rank===3&&(u=!0,i=at(s,[1,s.shape[0],s.shape[1],s.shape[2]])),P(i.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${i.rank}.`),ma("avgPool",r,a);const l={x:i},h={filterSize:t,strides:e,pad:r,dimRoundingMode:a};let d=J.runKernel(Nm,l,h);return d=Ft(d,s.dtype),u?at(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const Tg=tt({avgPool_:gK});function vK(n,t,e,r,a,s="NDHWC"){const o=V(n,"x","avgPool3d","float32");let i=o,u=!1;o.rank===4&&(u=!0,i=at(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),P(i.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${i.rank}.`),P(s==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`),P(typeof e=="number"&&e>0||Array.isArray(e)&&e[0]>0&&e[1]>0&&e[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${e}'`),ma("avgPool3d",r,a);const l={x:i},h={filterSize:t,strides:e,pad:r,dimRoundingMode:a,dataFormat:s};let d=J.runKernel(km,l,h);return d=Ft(d,i.dtype),u?at(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}const Jk=tt({avgPool3d_:vK});function yK(n,t=0){P(n.length>=1,()=>"Pass at least one tensor to concat");const e=Zf(n,"tensors","concat","string_or_numeric");if(e[0].dtype==="complex64"&&e.forEach(s=>{if(s.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${s.dtype}. `)}),e.length===1)return Oo(e[0]);const r=e,a={axis:t};return J.runKernel(Rm,r,a)}const _n=tt({concat_:yK});function bK(n,t,e=!1,r=!1){let a=V(n,"a","matMul"),s=V(t,"b","matMul");[a,s]=Rn(a,s);const o={a,b:s},i={transposeA:e,transposeB:r};return J.runKernel(Tm,o,i)}const xe=tt({matMul_:bK});function xK(n){const e={x:V(n,"x","sigmoid","float32")};return J.runKernel(Qd,e)}const Va=tt({sigmoid_:xK});function wK(n,t,e){const r=V(n,"x","slice","string_or_numeric");if(r.rank===0)throw new Error("Slicing scalar is not possible");const a={x:r},s={begin:t,size:e};return J.runKernel(fg,a,s)}const ue=tt({slice_:wK});function SK(n){const e={x:V(n,"x","tanh","float32")};return J.runKernel(rp,e)}const Pu=tt({tanh_:SK});function CK(n,t,e,r,a,s){const o=V(n,"forgetBias","basicLSTMCell"),i=V(t,"lstmKernel","basicLSTMCell"),u=V(e,"lstmBias","basicLSTMCell"),l=V(r,"data","basicLSTMCell"),h=V(a,"c","basicLSTMCell"),d=V(s,"h","basicLSTMCell"),f=_n([l,d],1),m=xe(f,i),v=It(m,u),y=v.shape[0],b=v.shape[1]/4,w=[y,b],S=ue(v,[0,0],w),N=ue(v,[0,b],w),C=ue(v,[0,b*2],w),T=ue(v,[0,b*3],w),I=It(et(Va(S),Pu(N)),et(h,Va(It(o,C)))),_=et(Pu(I),Va(T));return[I,_]}const SL=tt({basicLSTMCell_:CK});function NK(n,t,e){const r=V(n,"x","batchToSpaceND"),a=t.reduce((i,u)=>i*u);P(r.rank>=1+t.length,()=>`input rank is ${r.rank} but should be > than blockShape.length ${t.length}`),P(e.length===t.length,()=>`crops.length is ${e.length} but should be equal to blockShape.length  ${t.length}`),P(r.shape[0]%a===0,()=>`input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${a}`);const s={x:r},o={blockShape:t,crops:e};return J.runKernel(Em,s,o)}const Eg=tt({batchToSpaceND_:NK});function kK(n){let t;return n.rank===0||n.rank===1?t=at(n,[1,1,1,n.size]):n.rank===2?t=at(n,[1,1,n.shape[0],n.shape[1]]):n.rank===3?t=at(n,[1,n.shape[0],n.shape[1],n.shape[2]]):t=n,t}function TK(n,t,e,r,a,s){s==null&&(s=.001);const o=V(n,"x","batchNorm"),i=V(t,"mean","batchNorm"),u=V(e,"variance","batchNorm");let l;a!=null&&(l=V(a,"scale","batchNorm"));let h;r!=null&&(h=V(r,"offset","batchNorm")),P(i.rank===u.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),P(h==null||i.rank===h.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),P(l==null||i.rank===l.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const f={x:kK(o),scale:l,offset:h,mean:i,variance:u},m={varianceEpsilon:s},v=J.runKernel(zm,f,m);return at(v,o.shape)}const op=tt({batchNorm_:TK});function EK(n,t,e,r,a,s){const o=V(n,"x","batchNorm"),i=V(t,"mean","batchNorm"),u=V(e,"variance","batchNorm");let l;a!=null&&(l=V(a,"scale","batchNorm"));let h;return r!=null&&(h=V(r,"offset","batchNorm")),P(o.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${o.rank}.`),P(i.rank===2||i.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${i.rank}.`),P(u.rank===2||u.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${u.rank}.`),l!=null&&P(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${l.rank}.`),h!=null&&P(h.rank===2||h.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${h.rank}.`),op(o,i,u,h,l,s)}const tT=tt({batchNorm2d_:EK});function IK(n,t,e,r,a,s){const o=V(n,"x","batchNorm"),i=V(t,"mean","batchNorm"),u=V(e,"variance","batchNorm");let l;a!=null&&(l=V(a,"scale","batchNorm"));let h;return r!=null&&(h=V(r,"offset","batchNorm")),P(o.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${o.rank}.`),P(i.rank===3||i.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${i.rank}.`),P(u.rank===3||u.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${u.rank}.`),l!=null&&P(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${l.rank}.`),h!=null&&P(h.rank===3||h.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${h.rank}.`),op(o,i,u,h,l,s)}const eT=tt({batchNorm3d_:IK});function _K(n,t,e,r,a,s){const o=V(n,"x","batchNorm"),i=V(t,"mean","batchNorm"),u=V(e,"variance","batchNorm");let l;a!=null&&(l=V(a,"scale","batchNorm"));let h;return r!=null&&(h=V(r,"offset","batchNorm")),P(o.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${o.rank}.`),P(i.rank===4||i.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${i.rank}.`),P(u.rank===4||u.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${u.rank}.`),l!=null&&P(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${l.rank}.`),h!=null&&P(h.rank===4||h.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${h.rank}.`),op(o,i,u,h,l,s)}const nT=tt({batchNorm4d_:_K});function RK(n,t,e){const r=V(n,"x","bincount"),a=V(t,"weights","bincount");P(r.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${r.dtype}`),P(e>=0,()=>`size must be non-negative, but got ${e}.`),P(a.size===r.size||a.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${a.shape}.`);const s={x:r,weights:a},o={size:e};return J.runKernel(zb,s,o)}const rT=tt({bincount_:RK});function AK(n,t){const e=V(n,"x","bitwiseAnd"),r=V(t,"y","bitwiseAnd");if(!De(e.shape,r.shape))throw new Error(`BitwiseAnd: Tensors must have the same shape. x: ${e.shape}, y: ${r.shape}`);if(e.dtype!=="int32"||r.dtype!=="int32")throw new Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${e.dtype} and type of y: ${r.dtype}`);const a={a:e,b:r};return J.runKernel(Im,a)}const CL=tt({bitwiseAnd_:AK});function DK(n,t){const e=V(n,"s0","broadcastArgs","int32"),r=V(t,"s1","broadcastArgs","int32");if(e.rank!==1)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${e.rank}`);if(r.rank!==1)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${r.rank}`);const a={s0:e,s1:r};return J.runKernel(Pb,a)}const NL=tt({broadcastArgs_:DK});function $K(n,t){let e=V(n,"broadcastTo","x");const r=e.shape;if(Ya(t),t.length<e.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${e.rank}.`);if(t.length>e.rank){const l=e.shape.slice();for(;l.length<t.length;)l.unshift(1);e=at(e,l)}const a=e.shape,s=Array.from(t);for(let l=t.length-1;l>=0;l--)if(a[l]===t[l])s[l]=1;else if(e.shape[l]!==1)throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${t}].`);if(s.map((l,h)=>l>1?h:-1).filter(l=>l>=0).length===0)return Oo(e);const i={x:e},u={reps:s};return J.runKernel(ap,i,u)}const Kl=tt({broadcastTo_:$K});function OK(n){const e={x:V(n,"x","ceil","float32")};return J.runKernel(bd,e)}const aT=tt({ceil_:OK});function bc(n,t,e){Ya(n),e=e||gc(t);const r={shape:n,value:t,dtype:e};return J.runKernel(nx,{},r)}function FK(n,t,e){const r=V(n,"x","clipByValue");if(P(t<=e,()=>`Error in clip: min (${t}) must be less than or equal to max (${e}).`),t===e)return bc(r.shape,t,r.dtype);const a={x:r},s={clipValueMin:t,clipValueMax:e};return J.runKernel(xd,a,s)}const Na=tt({clipByValue_:FK});function MK(n){return _n(n,0)}const sT=tt({concat1d_:MK});function LK(n,t){return _n(n,t)}const Ig=tt({concat2d_:LK});function BK(n,t){return _n(n,t)}const oT=tt({concat3d_:BK});function zK(n,t){return _n(n,t)}const iT=tt({concat4d_:zK});function PK(n,t,e,r,a="NHWC",s=[1,1],o){const i=V(n,"x","conv2d","float32"),u=V(t,"filter","conv2d","float32");let l=i,h=!1;i.rank===3&&(h=!0,l=at(i,[1,i.shape[0],i.shape[1],i.shape[2]])),P(l.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${l.rank}.`),P(u.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${u.rank}.`),ma("conv2d",r,o);const d=a==="NHWC"?l.shape[3]:l.shape[1];P(d===u.shape[2],()=>`Error in conv2d: depth of input (${d}) must match input depth for filter ${u.shape[2]}.`),P(zr(e,s),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${e} and dilations '${s}'`),P(nc(s),()=>"Error in conv2D: Dilated rates should be larger than 0."),P(nc(e),()=>"Error in conv2D: Strides should be larger than 0.");const f={x:l,filter:u},m={strides:e,pad:r,dataFormat:a,dilations:s,dimRoundingMode:o},v=J.runKernel(Am,f,m);return h?at(v,[v.shape[1],v.shape[2],v.shape[3]]):v}const Ri=tt({conv2d_:PK});function VK(n,t,e,r,a="NWC",s=1,o){const i=V(n,"x","conv1d"),u=V(t,"filter","conv1d");let l=i,h=!1;i.rank===2&&(h=!0,l=at(i,[1,i.shape[0],i.shape[1]])),P(l.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${l.rank}.`),P(u.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${u.rank}.`),ma("conv1d",r,o),P(l.shape[2]===u.shape[1],()=>`Error in conv1d: depth of input (${l.shape[2]}) must match input depth for filter ${u.shape[1]}.`),P(zr(e,s),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${e} and dilation '${s}'`),P(nc(s),()=>"Error in conv1D: Dilated rates should be larger than 0."),P(nc(e),()=>"Error in conv1D: Stride should be larger than 0."),P(a==="NWC",()=>`Error in conv1d: got dataFormat of ${a} but only NWC is currently supported.`);const d=at(u,[1,u.shape[0],u.shape[1],u.shape[2]]),f=at(l,[l.shape[0],1,l.shape[1],l.shape[2]]),b=Ri(f,d,[1,e],r,"NHWC",[1,s],o);return h?at(b,[b.shape[2],b.shape[3]]):at(b,[b.shape[0],b.shape[2],b.shape[3]])}const Hx=tt({conv1d_:VK});function UK(n,t,e,r,a,s="NHWC",o){P(n.length===t.rank,()=>`Length of inShape (${n.length}) and rank of dy (${t.rank}) must match`);let i=n,u=t,l=!1;t.rank===3&&(l=!0,u=at(t,[1,t.shape[0],t.shape[1],t.shape[2]]),i=[1,n[0],n[1],n[2]]),P(i.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${i.length}.`),P(u.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${u.rank}`),P(e.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${e.rank}`);const h=s==="NHWC"?i[3]:i[1],d=s==="NHWC"?u.shape[3]:u.shape[1];P(h===e.shape[2],()=>`Error in conv2dDerInput: depth of input (${h}) must match input depth for filter ${e.shape[2]}.`),P(d===e.shape[3],()=>`Error in conv2dDerInput: depth of output (${d}) must match output depth for filter ${e.shape[3]}.`),ma("conv2dDerInput",a,o);const f={dy:u,filter:e},m={strides:r,pad:a,dataFormat:s,dimRoundingMode:o,inputShape:i},v=J.runKernel(Dm,f,m);return l?at(v,[v.shape[1],v.shape[2],v.shape[3]]):v}const uT=tt({conv2DBackpropInput_:UK});function WK(n,t,e,r,a,s){const o=V(n,"x","conv2dTranspose"),i=V(t,"filter","conv2dTranspose");return uT(e,o,i,r,a,"NHWC",s)}const jx=tt({conv2dTranspose_:WK});function GK(n,t,e,r,a="NDHWC",s=[1,1,1]){const o=V(n,"x","conv3d"),i=V(t,"filter","conv3d");let u=o,l=!1;o.rank===4&&(l=!0,u=at(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),P(u.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${u.rank}.`),P(i.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${i.rank}.`),P(u.shape[4]===i.shape[3],()=>`Error in conv3d: depth of input (${u.shape[4]}) must match input depth for filter ${i.shape[3]}.`),P(zr(e,s),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${e} and dilations '${s}'`),P(a==="NDHWC",()=>`Error in conv3d: got dataFormat of ${a} but only NDHWC is currently supported.`),P(nc(s),()=>"Error in conv3D: Dilated rates should be larger than 0."),P(nc(e),()=>"Error in conv3D: Strides should be larger than 0.");const h={x:u,filter:i},d={strides:e,pad:r,dataFormat:a,dilations:s},f=J.runKernel($m,h,d);return l?at(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]]):f}const lT=tt({conv3d_:GK});function HK(n,t,e,r,a){P(n.length===t.rank,()=>`Length of inShape (${n.length}) and rank of dy (${t.rank}) must match`);let s=n,o=t,i=!1;t.rank===4&&(i=!0,o=at(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),s=[1,n[0],n[1],n[2],n[3]]);const u=s[4],l=o.shape[4];P(s.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${s.length}.`),P(o.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${o.rank}`),P(e.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${e.rank}`),P(u===e.shape[3],()=>`Error in conv3dDerInput: depth of input (${u}) must match input depth for filter ${e.shape[3]}.`),P(l===e.shape[4],()=>`Error in conv3dDerInput: depth of output (${l}) must match output depth for filter ${e.shape[4]}.`);const h={dy:o,filter:e},d={pad:a,strides:r,inputShape:s},f=J.runKernel(Gb,h,d);return i?at(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]]):f}const kL=tt({conv3DBackpropInput_:HK});function jK(n,t,e,r,a){const s=V(n,"x","conv3dTranspose"),o=V(t,"filter","conv3dTranspose");return kL(e,s,o,r,a)}const cT=tt({conv3dTranspose_:jK});function qK(n){const e={x:V(n,"x","cos","float32")};return J.runKernel(wd,e)}const _g=tt({cos_:qK});function KK(n){const e={x:V(n,"x","cosh","float32")};return J.runKernel(Sd,e)}const qx=tt({cosh_:KK});function XK(n,t=0,e=!1,r=!1){const s={x:V(n,"x","cumprod")},o={axis:t,exclusive:e,reverse:r};return J.runKernel(Hb,s,o)}const nm=tt({cumprod_:XK});function YK(n,t=0,e=!1,r=!1){const s={x:V(n,"x","cumsum")},o={axis:t,exclusive:e,reverse:r};return J.runKernel(Om,s,o)}const Kx=tt({cumsum_:YK});function QK(n,t,e,r=!1){const a=V(n,"x","denseBincount"),s=V(t,"weights","denseBincount");P(a.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${a.dtype}`),P(a.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${a.rank}.`),P(e>=0,()=>`size must be non-negative, but got ${e}.`),P(s.size===a.size||s.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${a.shape}, weights shape: ${s.shape}.`);const o={x:a,weights:s},i={size:e,binaryOutput:r};return J.runKernel(qb,o,i)}const P0=tt({denseBincount_:QK});function ZK(n,t,e="NHWC"){const r=V(n,"x","depthToSpace","float32"),a=e==="NHWC"?r.shape[1]:r.shape[2],s=e==="NHWC"?r.shape[2]:r.shape[3],o=e==="NHWC"?r.shape[3]:r.shape[1];P(t>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${t}`),P(a*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${a} and ${t}  for depthToSpace with input shape
    ${r.shape}`),P(s*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${s} and ${t} for depthToSpace with input shape
        ${r.shape}`),P(o%(t*t)===0,()=>`Dimension size must be evenly divisible by ${t*t} but is ${o} for depthToSpace with input shape ${r.shape}`);const i={x:r},u={blockSize:t,dataFormat:e};return J.runKernel(Kb,i,u)}const hT=tt({depthToSpace_:ZK});function JK(n,t,e,r,a="NHWC",s=[1,1],o){const i=V(n,"x","depthwiseConv2d","float32"),u=V(t,"filter","depthwiseConv2d","float32");let l=i,h=!1;i.rank===3&&(h=!0,l=at(i,[1,i.shape[0],i.shape[1],i.shape[2]])),P(l.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${l.rank}.`),P(u.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${u.rank}.`);const d=a==="NHWC"?l.shape[3]:l.shape[1];P(d===u.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${d}) must match the inChannels dimension in filter ${u.shape[2]}.`),ma("depthwiseConv2d",r,o);const f={x:l,filter:u},m={strides:e,pad:r,dataFormat:a,dilations:s,dimRoundingMode:o},v=J.runKernel(Fm,f,m);return h?at(v,[v.shape[1],v.shape[2],v.shape[3]]):v}const ip=tt({depthwiseConv2d_:JK});function tX(n){const e={x:V(n,"x","diag")};return J.runKernel(Qb,e)}const TL=tt({diag_:tX});function eX(n,t,e,r,a=[1,1],s="NHWC"){const o=V(n,"x","dilation2d"),i=V(t,"filter","dilation2d");P(o.rank===3||o.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${o.rank}.`),P(i.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${i.rank}.`),P(s==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${s}`);let u=o,l=!1;o.rank===3&&(u=at(o,[1,o.shape[0],o.shape[1],o.shape[2]]),l=!0),P(u.shape[3]===i.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${u.shape[3]} vs ${i.shape[2]}`);const h={x:u,filter:i},d={strides:e,pad:r,dilations:a},f=J.runKernel(Mm,h,d);return l?at(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const dT=tt({dilation2d_:eX});function rc(n,t){const e=n.length,r=[];for(let a=0;a<e;a++){const s=e-1-a,o=n[s]||1;(t[t.length-1-a]||1)>1&&o===1&&r.unshift(s)}return r}function Zn(n,t){const e=[];for(let r=0;r<t.length;r++){const a=n[n.length-r-1],s=t.length-r-1,o=t[s];(a==null||a===1&&o>1)&&e.unshift(s)}return e}function me(n,t){const e=Math.max(n.length,t.length),r=new Array(e);for(let a=0;a<e;a++){let s=n[n.length-a-1];s==null&&(s=1);let o=t[t.length-a-1];if(o==null&&(o=1),s===1)r[e-a-1]=o;else if(o===1)r[e-a-1]=s;else if(s!==o){const i=`Operands could not be broadcast together with shapes ${n} and ${t}.`;throw Error(i)}else r[e-a-1]=s}return r}const nX=Object.freeze(Object.defineProperty({__proto__:null,assertAndGetBroadcastShape:me,getBroadcastDims:rc,getReductionAxes:Zn},Symbol.toStringTag,{value:"Module"}));function rX(n,t){let e=V(n,"a","equal","string_or_numeric"),r=V(t,"b","equal","string_or_numeric");[e,r]=Rn(e,r),me(e.shape,r.shape);const a={a:e,b:r};return J.runKernel(Lm,a)}const Wa=tt({equal_:rX});function aX(n,t,e){const r=V(t,"a","where"),a=V(e,"b","where"),s=V(n,"condition","where","bool"),o=me(me(s.shape,r.shape),a.shape),i=Kl(s,o),u=Kl(r,o),l=Kl(a,o),h={condition:i,t:u,e:l};return J.runKernel(pg,h)}const Or=tt({where_:aX});function sX(n){const e={x:V(n,"x","zerosLike")};return J.runKernel(Sg,e)}const Be=tt({zerosLike_:sX});function oX(n,t){let e=V(n,"a","div"),r=V(t,"b","div");[e,r]=Rn(e,r);const a=Ut(e,r),s=Be(a),o=Wa(r,s);return Or(o,s,a)}const pT=tt({divNoNan_:oX});function iX(n,t){const e=V(n,"t1","dot"),r=V(t,"t2","dot");P((e.rank===1||e.rank===2)&&(r.rank===1||r.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${e.rank} and ${r.rank}.`);const a=e.rank===1?e.size:e.shape[1],s=r.rank===1?r.size:r.shape[0];if(P(a===s,()=>`Error in dot: inner dimensions of inputs must match, but got ${a} and ${s}.`),e.rank===1&&r.rank===1){const o=at(e,[1,-1]),i=at(r,[-1,1]),u=xe(o,i);return at(u,[])}else if(e.rank===1&&r.rank===2){const o=at(e,[1,-1]),i=at(r,[r.shape[0],r.shape[1]]),u=xe(o,i);return at(u,[u.size])}else if(e.rank===2&&r.rank===1){const o=at(r,[-1,1]),i=xe(e,o);return at(i,[i.size])}else{const o=at(r,[r.shape[0],r.shape[1]]);return xe(e,o)}}const fT=tt({dot_:iX});function uX(n,...t){const e=t.map((a,s)=>V(a,`tensors${s}`,"einsum")),r={equation:n};return J.runKernel(Jb,e,r)}const Ll=tt({einsum_:uX});function lX(n){const e={x:V(n,"x","elu","float32")};return J.runKernel(Nd,e)}const up=tt({elu_:lX});function cX(n,t){const e=V(n,"x","ensureShape","string_or_numeric");if(!LM(e.shape,t))throw new Error(`EnsureShape: Shape of tensor ${e.shape} is not compatible with expected shape ${t}`);return n}const EL=tt({ensureShape_:cX});function hX(n){let t=V(n,"x","erf");P(t.dtype==="int32"||t.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),t.dtype==="int32"&&(t=Ft(t,"float32"));const e={x:t};return J.runKernel(kd,e)}const Xx=tt({erf_:hX});function mT(n,t){for(let e=0;e<n.length;++e)if(n[n.length-e-1]!==t-1-e)return!1;return!0}function IL(n,t,e){const r=n.length+t.length,a=[];let s=0,o=0;for(let i=0;i<r;i++)e.indexOf(i)===-1?a.push(n[s++]):a.push(t[o++]);return a}function kr(n,t){const e=[],r=n.length;for(let s=0;s<r;s++)t.indexOf(s)===-1&&e.push(n[s]);const a=t.map(s=>n[s]);return[e,a]}function Vn(n,t){const e=t.map(r=>1);return IL(n,e,t)}function Pr(n,t,e){P(mT(t,e),()=>`${n} supports only inner-most axes for now. Got axes ${t} and rank-${e} input.`)}function An(n,t){if(mT(n,t))return null;const e=[];for(let r=0;r<t;++r)n.indexOf(r)===-1&&e.push(r);return n.forEach(r=>e.push(r)),e}function Ju(n){return n.map((t,e)=>[e,t]).sort((t,e)=>t[1]-e[1]).map(t=>t[0])}function Un(n,t){const e=[];for(let r=t-n;r<t;++r)e.push(r);return e}function dX(n,t=null,e=!1){const a={x:V(n,"x","max")},s={reductionIndices:t,keepDims:e};return J.runKernel(Xm,a,s)}const vs=tt({max_:dX});function pX(n,t=null,e=!1){const a={x:V(n,"x","min")},s={axis:t,keepDims:e};return J.runKernel(Jm,a,s)}const Yh=tt({min_:pX});function fX(n,t){let e=V(n,"base","pow"),r=V(t,"exp","pow");[e,r]=Rn(e,r);const a={a:e,b:r};return J.runKernel(Vd,a)}const Wo=tt({pow_:fX});function Jt(n,t){if((gr(n)&&t!=="string"||Array.isArray(n))&&t!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(t==="string"&&gr(n)&&!(n instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return Qu(n,[],[],t)}function mX(n){const e={x:V(n,"x","sqrt","float32")};return J.runKernel(Jd,e)}const wr=tt({sqrt_:mX});function gX(n){const t=V(n,"x","square"),e={};return J.runKernel("Square",{x:t},e)}const an=tt({square_:gX});function vX(n,t=null,e=!1){let r=V(n,"x","sum");r.dtype==="bool"&&(r=Ft(r,"int32"));const a={x:r},s={axis:t,keepDims:e};return J.runKernel(mg,a,s)}const jt=tt({sum_:vX});function yX(n,t="euclidean",e=null,r=!1){n=V(n,"x","norm");const a=_L(n,t,e);let s=a.shape;if(r){const o=_e(e,n.shape);s=Vn(a.shape,o)}return at(a,s)}function _L(n,t,e=null){if(n.rank===0)return Kn(n);if(n.rank!==1&&e===null)return _L(at(n,[-1]),t,e);if(n.rank===1||typeof e=="number"||Array.isArray(e)&&e.length===1){if(t===1)return jt(Kn(n),e);if(t===1/0)return vs(Kn(n),e);if(t===-1/0)return Yh(Kn(n),e);if(t==="euclidean"||t===2)return wr(jt(Wo(Kn(n),Jt(2,"int32")),e));throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(e)&&e.length===2){if(t===1)return vs(jt(Kn(n),e[0]),e[1]-1);if(t===1/0)return vs(jt(Kn(n),e[1]),e[0]);if(t===-1/0)return Yh(jt(Kn(n),e[1]),e[0]);if(t==="fro"||t==="euclidean")return wr(jt(an(n),e));throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${e}`)}const lp=tt({norm_:yX});function bX(n,t=null,e=!1){return lp(n,"euclidean",t,e)}const gT=tt({euclideanNorm_:bX});function xX(n){const e={x:V(n,"x","exp")};return J.runKernel(Td,e)}const ka=tt({exp_:xX});function wX(n,t=0){const e=V(n,"x","expandDims","string_or_numeric");P(t<=e.rank,()=>"Axis must be <= rank of the tensor");const r={input:e},a={dim:t};return J.runKernel(Bm,r,a)}const Pn=tt({expandDims_:wX});function SX(n){const e={x:V(n,"x","expm1")};return J.runKernel(Ed,e)}const vT=tt({expm1_:SX});function CX(n,t){const e=V(n,"x","tile","string_or_numeric");P(e.rank===t.length,()=>`Error in transpose: rank of input ${e.rank} must match length of reps ${t}.`);const r={x:e},a={reps:t};return J.runKernel(ap,r,a)}const ls=tt({tile_:CX});function NX(n,t,e,r="float32"){t==null&&(t=n);const a=we([n,t],r),s=n<=t?n:t;for(let i=0;i<s;++i)a.set(1,i,i);const o=at(a.toTensor(),[n,t]);if(e==null)return o;if(e.length===1)return ls(Pn(o,0),[e[0],1,1]);if(e.length===2)return ls(Pn(Pn(o,0),0),[e[0],e[1],1,1]);if(e.length===3)return ls(Pn(Pn(Pn(o,0),0),0),[e[0],e[1],e[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${e.length}D.`)}const Yx=tt({eye_:NX});function kX(n){const e={x:V(n,"x","floor","float32")};return J.runKernel(Id,e)}const cp=tt({floor_:kX});function TX(n,t,e=0,r=0){const a=V(n,"x","gather"),s=V(t,"indices","gather","int32"),o={x:a,indices:s},i={axis:e,batchDims:r};return J.runKernel(Pm,o,i)}const hp=tt({gather_:TX});function EX(n,t){let e=V(n,"a","greater","string_or_numeric"),r=V(t,"b","greater","string_or_numeric");[e,r]=Rn(e,r),me(e.shape,r.shape);const a={a:e,b:r};return J.runKernel(Vm,a)}const ga=tt({greater_:EX});function IX(n,t){let e=V(n,"a","greaterEqual","string_or_numeric"),r=V(t,"b","greaterEqual","string_or_numeric");[e,r]=Rn(e,r),me(e.shape,r.shape);const a={a:e,b:r};return J.runKernel(Rd,a)}const Bi=tt({greaterEqual_:IX});function _X(n){const e={input:V(n,"input","imag")};return J.runKernel(ox,e)}const Rg=tt({imag_:_X});function RX(n){const e={x:V(n,"x","isFinite")};return J.runKernel(Dd,e)}const yT=tt({isFinite_:RX});function AX(n){const e={x:V(n,"x","isInf")};return J.runKernel($d,e)}const bT=tt({isInf_:AX});function DX(n){const e={x:V(n,"x","isNaN")};return J.runKernel(Od,e)}const xT=tt({isNaN_:DX});function $X(n,t=.2){const r={x:V(n,"x","leakyRelu")},a={alpha:t};return J.runKernel(Um,r,a)}const Ag=tt({leakyRelu_:$X});function OX(n,t){let e=V(n,"a","less","string_or_numeric"),r=V(t,"b","less","string_or_numeric");[e,r]=Rn(e,r),me(e.shape,r.shape);const a={a:e,b:r};return J.runKernel(Wm,a)}const Qh=tt({less_:OX});function FX(n,t){let e=V(n,"a","lessEqual","string_or_numeric"),r=V(t,"b","lessEqual","string_or_numeric");[e,r]=Rn(e,r),me(e.shape,r.shape);const a={a:e,b:r};return J.runKernel(Gm,a)}const tl=tt({lessEqual_:FX});function RL(n,t,e){if(e<=0)throw new Error("The number of values should be positive.");const r={start:n,stop:t,num:e};return J.runKernel(ix,{},r)}function MX(n,t=5,e=1,r=1,a=.5){const s=V(n,"x","localResponseNormalization");P(s.rank===4||s.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${s.rank}.`),P(Zl(t),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`);let o=s,i=!1;s.rank===3&&(i=!0,o=at(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const u={x:o},l={depthRadius:t,bias:e,alpha:r,beta:a},h=J.runKernel(Km,u,l);return i?at(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const wT=tt({localResponseNormalization_:MX});function LX(n){const e={x:V(n,"x","log","float32")};return J.runKernel(Fd,e)}const Ga=tt({log_:LX});function BX(n){const e={x:V(n,"x","log1p")};return J.runKernel(Md,e)}const Dg=tt({log1p_:BX});function zX(n){return P(Fu(n),()=>"The f passed in grad(f) must be a function"),(t,e)=>{const r=V(t,"x","tf.grad","string_or_numeric"),a=e!=null?V(e,"dy","tf.grad"):null;return J.tidy(()=>{const{value:s,grads:o}=J.gradients(()=>n(r),[r],a);return a!=null&&Br(s.shape,a.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),Qx(o),o[0]})}}function PX(n){return P(Fu(n),()=>"The f passed in grads(f) must be a function"),(t,e)=>{P(Array.isArray(t),()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s");const r=Zf(t,"args","tf.grads","string_or_numeric"),a=e!=null?V(e,"dy","tf.grads"):null;return J.tidy(()=>{const{value:s,grads:o}=J.gradients(()=>n(...r),r,a);return a!=null&&Br(s.shape,a.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),Qx(o),o})}}function VX(n){return P(Fu(n),()=>"The f passed in valueAndGrad(f) must be a function"),(t,e)=>{P(t instanceof Ae,()=>"The x passed in valueAndGrad(f)(x) must be a tensor"),P(e==null||e instanceof Ae,()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor");const{grads:r,value:a}=J.gradients(()=>n(t),[t],e);return Qx(r),{grad:r[0],value:a}}}function UX(n){return P(Fu(n),()=>"The f passed in valueAndGrads(f) must be a function"),(t,e)=>{P(Array.isArray(t)&&t.every(a=>a instanceof Ae),()=>"The args passed in valueAndGrads(f)(args) must be array of tensors"),P(e==null||e instanceof Ae,()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor");const r=J.gradients(()=>n(...t),t,e);return e!=null&&Br(r.value.shape,e.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),Qx(r.grads),r}}function AL(n,t){P(Fu(n),()=>"The f passed in variableGrads(f) must be a function"),P(t==null||Array.isArray(t)&&t.every(l=>l instanceof Qf),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const e=t!=null;if(!e){t=[];for(const l in J.registeredVariables)t.push(J.registeredVariables[l])}const r=e?t.filter(l=>!l.trainable):null,a=t.length;t=t.filter(l=>l.trainable),P(t.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${a} variables is trainable.`);const s=!0,{value:o,grads:i}=J.gradients(n,t,null,s);P(i.some(l=>l!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),P(o.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${o.rank} tensor`);const u={};return t.forEach((l,h)=>{i[h]!=null&&(u[l.name]=i[h])}),r?.forEach(l=>u[l.name]=null),{value:o,grads:u}}function Go(n){return J.customGrad(n)}function Qx(n){if(n.filter(e=>e==null).length>0)throw new Error(`Cannot compute gradient of y=f(x) with respect to x. Make sure that
    the f you passed encloses all operations that lead from x to y.`)}function WX(n){const e={x:V(n,"x","neg")};return J.runKernel(eg,e)}const mn=tt({neg_:WX});function GX(n){const e={x:V(n,"x","softplus")};return J.runKernel(Zd,e)}const xc=tt({softplus_:GX});function HX(n){const t=V(n,"x","logSigmoid");return Go(r=>({value:mn(xc(mn(r))),gradFunc:o=>et(o,Va(mn(r)))}))(t)}const ST=tt({logSigmoid_:HX});function jX(n,t){let e=V(n,"a","sub"),r=V(t,"b","sub");[e,r]=Rn(e,r);const a={a:e,b:r};return J.runKernel(ep,a)}const zt=tt({sub_:jX});function qX(n,t=-1){const e=V(n,"logits","logSoftmax");if(t===-1&&(t=e.rank-1),t!==e.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${e.rank} and axis was ${t}`);return Go((a,s)=>{const i=vs(a,t,!0),u=zt(a,i),l=zt(Ft(u,"float32"),Ga(jt(ka(u),t,!0)));return s([l]),{value:l,gradFunc:(d,f)=>{const[m]=f,v=!0,y=ka(m);return zt(d,et(jt(d,t,v),y))}}})(e)}const Zx=tt({logSoftmax_:qX});function KX(n,t=null,e=!1){const r=V(n,"x","logSumExp"),a=_e(t,r.shape),s=vs(r,a,!0),o=zt(r,s),i=ka(o),u=jt(i,a),l=Ga(u),h=It(at(s,l.shape),l);if(e){const d=Vn(h.shape,a);return at(h,d)}return h}const $g=tt({logSumExp_:KX});function XX(n,t){const e=V(n,"a","logicalAnd","bool"),r=V(t,"b","logicalAnd","bool");me(e.shape,r.shape);const a={a:e,b:r};return J.runKernel(Hm,a)}const ao=tt({logicalAnd_:XX});function YX(n){const e={x:V(n,"x","logicalNot","bool")};return J.runKernel(jm,e)}const Og=tt({logicalNot_:YX});function QX(n,t){const e=V(n,"a","logicalOr","bool"),r=V(t,"b","logicalOr","bool");me(e.shape,r.shape);const a={a:e,b:r};return J.runKernel(qm,a)}const Jx=tt({logicalOr_:QX});function ZX(n,t){const e=V(n,"a","logicalXor","bool"),r=V(t,"b","logicalXor","bool");return me(e.shape,r.shape),ao(Jx(n,t),Og(ao(n,t)))}const CT=tt({logicalXor_:ZX});const Fy=2147483648;function JX(n,t,e="left"){const r=V(n,"sortedSequence","searchSorted"),a=V(t,"values","searchSorted"),s=r.shape[r.shape.length-1],o=a.shape[a.shape.length-1],i=at(r,[-1,s]),u=at(a,[-1,o]);if(i.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(i.shape[0]!==u.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(xt(u.shape)>=Fy)throw new Error(`values tensor size must less than ${Fy}`);if(i.shape[1]>=Fy)throw new Error(`trailing dim_size must less than ${Fy} for int32 output type, was ${i.shape[1]}`);const l={sortedSequence:i,values:u},h={side:e};return J.runKernel(kx,l,h)}const t1=tt({searchSorted_:JX});function DL(n,t){return t1(n,t,"left")}function t7(n,t,e,r,a){const s=V(n,"x","maxPool"),o=1;let i=s,u=!1;s.rank===3&&(u=!0,i=at(s,[1,s.shape[0],s.shape[1],s.shape[2]])),P(i.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${i.rank}.`),P(zr(e,o),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${e} and dilations '${o}'`),ma("maxPool",r,a);const l={x:i},h={filterSize:t,strides:e,pad:r,dimRoundingMode:a},d=J.runKernel(Ym,l,h);return u?at(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const Fg=tt({maxPool_:t7});function e7(n,t=[1,1,1],e,r,a,s="NDHWC"){const o=V(n,"x","maxPool3d");let i=o,u=!1;o.rank===4&&(u=!0,i=at(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),P(i.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${i.rank}.`),P(s==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`),ma("maxPool3d",r,a);const l={x:i},h={filterSize:t,strides:e,pad:r,dimRoundingMode:a,dataFormat:s},d=J.runKernel(Qm,l,h);return u?at(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}const NT=tt({maxPool3d_:e7});function n7(n,t,e,r,a=!1){const o={x:V(n,"x","maxPoolWithArgmax")},i={filterSize:t,strides:e,pad:r,includeBatchInIndex:a},u=J.runKernel(hx,o,i);return{result:u[0],indexes:u[1]}}const $L=tt({maxPoolWithArgmax_:n7});function r7(n,t){let e=V(n,"a","maximum"),r=V(t,"b","maximum");[e,r]=Rn(e,r),e.dtype==="bool"&&(e=Ft(e,"int32"),r=Ft(r,"int32")),me(e.shape,r.shape);const a={a:e,b:r};return J.runKernel(Ld,a)}const Ko=tt({maximum_:r7});function a7(n,t=null,e=!1){const a={x:V(n,"x","mean")},s={axis:t,keepDims:e};return J.runKernel(Zm,a,s)}const En=tt({mean_:a7});function Xn(n,t="float32"){if(Ya(n),t==="complex64"){const r=Xn(n,"float32"),a=Xn(n,"float32");return _i(r,a)}const e=Mr(xt(n),t);return J.makeTensor(e,n,t)}function xa(n,t="float32"){if(Ya(n),t==="complex64"){const r=xa(n,"float32"),a=Xn(n,"float32");return _i(r,a)}const e=Ob(xt(n),t);return J.makeTensor(e,n,t)}function OL(n,t,{indexing:e="xy"}={}){if(e!=="xy"&&e!=="ij")throw new TypeError(`${e} is not a valid third argument to meshgrid`);if(n===void 0)return[];let r=V(n,"x","meshgrid",n instanceof Ae?n.dtype:"float32");if(t===void 0)return[r];let a=V(t,"y","meshgrid",t instanceof Ae?t.dtype:"float32");const s=xt(r.shape),o=xt(a.shape);return e==="xy"?(r=at(r,[1,-1]),a=at(a,[-1,1]),[xe(xa([o,1],r.dtype),r),xe(a,xa([1,s],a.dtype))]):(r=at(r,[-1,1]),a=at(a,[1,-1]),[xe(r,xa([1,o],r.dtype)),xe(xa([s,1],a.dtype),a)])}function s7(n,t){let e=V(n,"a","minimum"),r=V(t,"b","minimum");[e,r]=Rn(e,r),e.dtype==="bool"&&(e=Ft(e,"int32"),r=Ft(r,"int32")),me(e.shape,r.shape);const a={a:e,b:r};return J.runKernel(Bd,a)}const Vu=tt({minimum_:s7});function o7(n,t,e){P(e==="reflect"||e==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${e}.`);const r=V(n,"x","mirrorPad");if(r.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");P(t.length===r.rank,()=>`Padding doesn't match input. Must be ${r.rank}. Got ${t.length}.`);const a=e==="reflect"?1:0;for(let i=0;i<r.rank;i++)P(t[i].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),P(t[i][0]>=0&&t[i][0]<=r.shape[i]-a&&t[i][1]>=0&&t[i][1]<=r.shape[i]-a,()=>`Padding in dimension ${i} cannot be greater than or equal to ${r.shape[i]-a} or less than 0 for input of shape ${r.shape}`);const s={paddings:t,mode:e},o={x:r};return J.runKernel(tg,o,s)}const kT=tt({mirrorPad_:o7});function i7(n,t){let e=V(n,"a","mod"),r=V(t,"b","mod");[e,r]=Rn(e,r);const a={a:e,b:r};return J.runKernel(zd,a)}const TT=tt({mod_:i7});function u7(n,t=null,e=!1){n=V(n,"x","moments");const r=_e(t,n.shape),a=En(n,r,e);let s=a.shape;e||(s=Vn(a.shape,r));const o=an(zt(Ft(n,"float32"),at(a,s))),i=En(o,r,e);return{mean:a,variance:i}}const Mg=tt({moments_:u7});function l7(n,t,e,r){const a=V(t,"data","multiRNNCell"),s=Zf(e,"c","multiRNNCell"),o=Zf(r,"h","multiRNNCell");let i=a;const u=[];for(let d=0;d<n.length;d++){const f=n[d](i,s[d],o[d]);u.push(f[0]),u.push(f[1]),i=f[1]}const l=[],h=[];for(let d=0;d<u.length;d+=2)l.push(u[d]),h.push(u[d+1]);return[l,h]}const FL=tt({multiRNNCell_:l7});function c7(n,t,e,r=!1){const a=V(n,"logits","multinomial"),s=a.size,o=a.rank;if(s<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${s}.`);if(o>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${o}`);e=e||Math.random();const u={logits:o===1?at(a,[1,-1]):a},l={numSamples:t,seed:e,normalized:r},h=J.runKernel(dx,u,l);return o===1?at(h,[h.size]):h}const ML=tt({multinomial_:c7});function h7(n,t){let e=V(n,"a","notEqual","string_or_numeric"),r=V(t,"b","notEqual","string_or_numeric");[e,r]=Rn(e,r),me(e.shape,r.shape);const a={a:e,b:r};return J.runKernel(ng,a)}const ac=tt({notEqual_:h7});function d7(n,t,e=1,r=0,a="int32"){if(t<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);const o={indices:V(n,"indices","oneHot","int32")},i={dtype:a,depth:t,onValue:e,offValue:r};return J.runKernel(ag,o,i)}const sc=tt({oneHot_:d7});function p7(n){const e={x:V(n,"x","onesLike")};return J.runKernel(rg,e)}const Ha=tt({onesLike_:p7});function f7(n,t){const e=V(n,"v1","outerProduct"),r=V(t,"v2","outerProduct");P(e.rank===1&&r.rank===1,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${e.rank} and ${r.rank}.`);const a=at(e,[-1,1]),s=at(r,[1,-1]);return xe(a,s)}const LL=tt({outerProduct_:f7});function m7(n,t,e=0){const r=V(n,"x","pad");if(r.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const a={paddings:t,constantValue:e},s={x:r};return J.runKernel(og,s,a)}const zi=tt({pad_:m7});function g7(n,t,e=0){return P(t.length===2,()=>"Invalid number of paddings. Must be length of 2."),zi(n,[t],e)}const BL=tt({pad1d_:g7});function v7(n,t,e=0){return P(t.length===2&&t[0].length===2&&t[1].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),zi(n,t,e)}const zL=tt({pad2d_:v7});function y7(n,t,e=0){return P(t.length===3&&t[0].length===2&&t[1].length===2&&t[2].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),zi(n,t,e)}const ET=tt({pad3d_:y7});function b7(n,t,e=0){return P(t.length===4&&t[0].length===2&&t[1].length===2&&t[2].length===2&&t[3].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),zi(n,t,e)}const PL=tt({pad4d_:b7});function x7(n,t,e){const r=V(n,"x","spaceToBatchND");P(r.rank>=1+t.length,()=>`input rank ${r.rank} should be > than [blockShape] ${t.length}`),P(e.length===t.length,()=>`paddings.shape[0] ${e.length} must be equal to [blockShape] ${t.length}`),P(r.shape.reduce((o,i,u)=>u>0&&u<=t.length?o&&(i+e[u-1][0]+e[u-1][1])%t[u-1]===0:o,!0),()=>`input spatial dimensions ${r.shape.slice(1)} with paddings ${e.toString()} must be divisible by blockShapes ${t.toString()}`);const a={x:r},s={blockShape:t,paddings:e};return J.runKernel(gg,a,s)}const Lg=tt({spaceToBatchND_:x7});function w7(n,t,e,r,a,s,o){a==null&&(a=[1,1]),s==null&&(s=1),r===0&&(r="valid");const i=V(n,"x","maxPool");let u=i,l=!1;i.rank===3&&(l=!0,u=at(i,[1,i.shape[0],i.shape[1],i.shape[2]])),P(zr(s,a),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${s} and dilations '${a}'`);const h=Vs(u.shape,t,s,a,r),d=[h.dilationHeight,h.dilationWidth];let f;r==="same"?f=C7([h.filterHeight,h.filterWidth],d):f=[[0,0],[0,0]];const m=d[0]===1&&d[1]===1,[v,y]=S7([h.inHeight,h.inWidth],d,f),b=m?r:"valid",w=m?u:Lg(u,d,v),N=(e==="avg"?()=>Tg(w,t,s,b,o):()=>Fg(w,t,s,b,o))(),C=m?N:Eg(N,d,y);return l?at(C,[C.shape[1],C.shape[2],C.shape[3]]):C}function S7(n,t,e){const r=e.map(h=>h[0]),a=e.map(h=>h[1]),s=n.concat(r,a),o=t.map((h,d)=>(h-s[d]%h)%h),i=a.map((h,d)=>h+o[d]),u=t.map((h,d)=>[r[d],i[d]]),l=t.map((h,d)=>[0,o[d]]);return[u,l]}function C7(n,t){const r=n.map((o,i)=>o+(o-1)*(t[i]-1)).map(o=>o-1),a=r.map(o=>Math.floor(o/2)),s=r.map((o,i)=>o-a[i]);return r.map((o,i)=>[a[i],s[i]])}const IT=tt({pool_:w7});function N7(n,t){const e=V(n,"x","prelu"),r=V(t,"alpha","prelu"),a={x:e,alpha:r};return J.runKernel(ig,a)}const Bg=tt({prelu_:N7});function k7(n,t=null,e=!1){let r=V(n,"x","prod");r.dtype==="bool"&&(r=Ft(r,"int32"));const a={x:r},s={axis:t,keepDims:e};return J.runKernel(ug,a,s)}const _T=tt({prod_:k7});function T7(n,t,e,r){const a=n.map((h,d)=>V(h,`tensors${d}`,"raggedGather","int32")),s=V(t,"paramsDenseValues","raggedGather"),o=V(e,"indices","raggedGather","int32"),i={paramsNestedSplits:a,paramsDenseValues:s,indices:o},u={outputRaggedRank:r},l=J.runKernel(gx,i,u);return{outputNestedSplits:l.slice(0,l.length-1),outputDenseValues:l[l.length-1]}}const VL=tt({raggedGather_:T7});function E7(n,t,e){const r=V(n,"starts","raggedRange"),a=V(t,"limits","raggedRange",r.dtype),s=V(e,"deltas","raggedRange",r.dtype),o={starts:r,limits:a,deltas:s},i=J.runKernel(vx,o);return{rtNestedSplits:i[0],rtDenseValues:i[1]}}const UL=tt({raggedRange_:E7});function I7(n,t,e,r,a){const s=V(n,"shape","raggedTensorToTensor","int32"),o=V(t,"values","raggedTensorToTensor"),i=V(e,"defaultValue","raggedTensorToTensor",o.dtype),u=r.map((d,f)=>V(d,`tensors${f}`,"raggedTensorToTensor","int32")),l={shape:s,values:o,defaultValue:i,rowPartitionTensors:u},h={rowPartitionTypes:a};return J.runKernel(yx,l,h)}const WL=tt({raggedTensorToTensor_:I7});function _7(n,t,e){Ya(n);const r=xt(n);let a=null;if(e==null||e==="float32")a=new Float32Array(r);else if(e==="int32")a=new Int32Array(r);else if(e==="bool")a=new Uint8Array(r);else throw new Error(`Unknown data type ${e}`);for(let s=0;s<r;s++)a[s]=t();return J.makeTensor(a,n,e)}const GL=tt({rand_:_7});var b0={exports:{}},R7=b0.exports,aO;function A7(){return aO||(aO=1,(function(n){(function(t,e,r){function a(u){var l=this,h=i();l.next=function(){var d=2091639*l.s0+l.c*23283064365386963e-26;return l.s0=l.s1,l.s1=l.s2,l.s2=d-(l.c=d|0)},l.c=1,l.s0=h(" "),l.s1=h(" "),l.s2=h(" "),l.s0-=h(u),l.s0<0&&(l.s0+=1),l.s1-=h(u),l.s1<0&&(l.s1+=1),l.s2-=h(u),l.s2<0&&(l.s2+=1),h=null}function s(u,l){return l.c=u.c,l.s0=u.s0,l.s1=u.s1,l.s2=u.s2,l}function o(u,l){var h=new a(u),d=l&&l.state,f=h.next;return f.int32=function(){return h.next()*4294967296|0},f.double=function(){return f()+(f()*2097152|0)*11102230246251565e-32},f.quick=f,d&&(typeof d=="object"&&s(d,h),f.state=function(){return s(h,{})}),f}function i(){var u=4022871197,l=function(h){h=String(h);for(var d=0;d<h.length;d++){u+=h.charCodeAt(d);var f=.02519603282416938*u;u=f>>>0,f-=u,f*=u,u=f>>>0,f-=u,u+=f*4294967296}return(u>>>0)*23283064365386963e-26};return l}e&&e.exports?e.exports=o:this.alea=o})(R7,n)})(b0)),b0.exports}var x0={exports:{}},D7=x0.exports,sO;function $7(){return sO||(sO=1,(function(n){(function(t,e,r){function a(i){var u=this,l="";u.x=0,u.y=0,u.z=0,u.w=0,u.next=function(){var d=u.x^u.x<<11;return u.x=u.y,u.y=u.z,u.z=u.w,u.w^=u.w>>>19^d^d>>>8},i===(i|0)?u.x=i:l+=i;for(var h=0;h<l.length+64;h++)u.x^=l.charCodeAt(h)|0,u.next()}function s(i,u){return u.x=i.x,u.y=i.y,u.z=i.z,u.w=i.w,u}function o(i,u){var l=new a(i),h=u&&u.state,d=function(){return(l.next()>>>0)/4294967296};return d.double=function(){do var f=l.next()>>>11,m=(l.next()>>>0)/4294967296,v=(f+m)/(1<<21);while(v===0);return v},d.int32=l.next,d.quick=d,h&&(typeof h=="object"&&s(h,l),d.state=function(){return s(l,{})}),d}e&&e.exports?e.exports=o:this.xor128=o})(D7,n)})(x0)),x0.exports}var w0={exports:{}},O7=w0.exports,oO;function F7(){return oO||(oO=1,(function(n){(function(t,e,r){function a(i){var u=this,l="";u.next=function(){var d=u.x^u.x>>>2;return u.x=u.y,u.y=u.z,u.z=u.w,u.w=u.v,(u.d=u.d+362437|0)+(u.v=u.v^u.v<<4^(d^d<<1))|0},u.x=0,u.y=0,u.z=0,u.w=0,u.v=0,i===(i|0)?u.x=i:l+=i;for(var h=0;h<l.length+64;h++)u.x^=l.charCodeAt(h)|0,h==l.length&&(u.d=u.x<<10^u.x>>>4),u.next()}function s(i,u){return u.x=i.x,u.y=i.y,u.z=i.z,u.w=i.w,u.v=i.v,u.d=i.d,u}function o(i,u){var l=new a(i),h=u&&u.state,d=function(){return(l.next()>>>0)/4294967296};return d.double=function(){do var f=l.next()>>>11,m=(l.next()>>>0)/4294967296,v=(f+m)/(1<<21);while(v===0);return v},d.int32=l.next,d.quick=d,h&&(typeof h=="object"&&s(h,l),d.state=function(){return s(l,{})}),d}e&&e.exports?e.exports=o:this.xorwow=o})(O7,n)})(w0)),w0.exports}var S0={exports:{}},M7=S0.exports,iO;function L7(){return iO||(iO=1,(function(n){(function(t,e,r){function a(i){var u=this;u.next=function(){var h=u.x,d=u.i,f,m;return f=h[d],f^=f>>>7,m=f^f<<24,f=h[d+1&7],m^=f^f>>>10,f=h[d+3&7],m^=f^f>>>3,f=h[d+4&7],m^=f^f<<7,f=h[d+7&7],f=f^f<<13,m^=f^f<<9,h[d]=m,u.i=d+1&7,m};function l(h,d){var f,m=[];if(d===(d|0))m[0]=d;else for(d=""+d,f=0;f<d.length;++f)m[f&7]=m[f&7]<<15^d.charCodeAt(f)+m[f+1&7]<<13;for(;m.length<8;)m.push(0);for(f=0;f<8&&m[f]===0;++f);for(f==8?m[7]=-1:m[f],h.x=m,h.i=0,f=256;f>0;--f)h.next()}l(u,i)}function s(i,u){return u.x=i.x.slice(),u.i=i.i,u}function o(i,u){i==null&&(i=+new Date);var l=new a(i),h=u&&u.state,d=function(){return(l.next()>>>0)/4294967296};return d.double=function(){do var f=l.next()>>>11,m=(l.next()>>>0)/4294967296,v=(f+m)/(1<<21);while(v===0);return v},d.int32=l.next,d.quick=d,h&&(h.x&&s(h,l),d.state=function(){return s(l,{})}),d}e&&e.exports?e.exports=o:this.xorshift7=o})(M7,n)})(S0)),S0.exports}var C0={exports:{}},B7=C0.exports,uO;function z7(){return uO||(uO=1,(function(n){(function(t,e,r){function a(i){var u=this;u.next=function(){var h=u.w,d=u.X,f=u.i,m,v;return u.w=h=h+1640531527|0,v=d[f+34&127],m=d[f=f+1&127],v^=v<<13,m^=m<<17,v^=v>>>15,m^=m>>>12,v=d[f]=v^m,u.i=f,v+(h^h>>>16)|0};function l(h,d){var f,m,v,y,b,w=[],S=128;for(d===(d|0)?(m=d,d=null):(d=d+"\0",m=0,S=Math.max(S,d.length)),v=0,y=-32;y<S;++y)d&&(m^=d.charCodeAt((y+32)%d.length)),y===0&&(b=m),m^=m<<10,m^=m>>>15,m^=m<<4,m^=m>>>13,y>=0&&(b=b+1640531527|0,f=w[y&127]^=m+b,v=f==0?v+1:0);for(v>=128&&(w[(d&&d.length||0)&127]=-1),v=127,y=512;y>0;--y)m=w[v+34&127],f=w[v=v+1&127],m^=m<<13,f^=f<<17,m^=m>>>15,f^=f>>>12,w[v]=m^f;h.w=b,h.X=w,h.i=v}l(u,i)}function s(i,u){return u.i=i.i,u.w=i.w,u.X=i.X.slice(),u}function o(i,u){i==null&&(i=+new Date);var l=new a(i),h=u&&u.state,d=function(){return(l.next()>>>0)/4294967296};return d.double=function(){do var f=l.next()>>>11,m=(l.next()>>>0)/4294967296,v=(f+m)/(1<<21);while(v===0);return v},d.int32=l.next,d.quick=d,h&&(h.X&&s(h,l),d.state=function(){return s(l,{})}),d}e&&e.exports?e.exports=o:this.xor4096=o})(B7,n)})(C0)),C0.exports}var N0={exports:{}},P7=N0.exports,lO;function V7(){return lO||(lO=1,(function(n){(function(t,e,r){function a(i){var u=this,l="";u.next=function(){var d=u.b,f=u.c,m=u.d,v=u.a;return d=d<<25^d>>>7^f,f=f-m|0,m=m<<24^m>>>8^v,v=v-d|0,u.b=d=d<<20^d>>>12^f,u.c=f=f-m|0,u.d=m<<16^f>>>16^v,u.a=v-d|0},u.a=0,u.b=0,u.c=-1640531527,u.d=1367130551,i===Math.floor(i)?(u.a=i/4294967296|0,u.b=i|0):l+=i;for(var h=0;h<l.length+20;h++)u.b^=l.charCodeAt(h)|0,u.next()}function s(i,u){return u.a=i.a,u.b=i.b,u.c=i.c,u.d=i.d,u}function o(i,u){var l=new a(i),h=u&&u.state,d=function(){return(l.next()>>>0)/4294967296};return d.double=function(){do var f=l.next()>>>11,m=(l.next()>>>0)/4294967296,v=(f+m)/(1<<21);while(v===0);return v},d.int32=l.next,d.quick=d,h&&(typeof h=="object"&&s(h,l),d.state=function(){return s(l,{})}),d}e&&e.exports?e.exports=o:this.tychei=o})(P7,n)})(N0)),N0.exports}var k0={exports:{}};const U7={},W7=Object.freeze(Object.defineProperty({__proto__:null,default:U7},Symbol.toStringTag,{value:"Module"})),G7=Ck(W7);var H7=k0.exports,cO;function j7(){return cO||(cO=1,(function(n){(function(t,e,r){var a=256,s=6,o=52,i="random",u=r.pow(a,s),l=r.pow(2,o),h=l*2,d=a-1,f;function m(C,T,I){var _=[];T=T==!0?{entropy:!0}:T||{};var $=w(b(T.entropy?[C,N(e)]:C??S(),3),_),R=new v(_),D=function(){for(var A=R.g(s),L=u,H=0;A<l;)A=(A+H)*a,L*=a,H=R.g(1);for(;A>=h;)A/=2,L/=2,H>>>=1;return(A+H)/L};return D.int32=function(){return R.g(4)|0},D.quick=function(){return R.g(4)/4294967296},D.double=D,w(N(R.S),e),(T.pass||I||function(A,L,H,G){return G&&(G.S&&y(G,R),A.state=function(){return y(R,{})}),H?(r[i]=A,L):A})(D,$,"global"in T?T.global:this==r,T.state)}function v(C){var T,I=C.length,_=this,$=0,R=_.i=_.j=0,D=_.S=[];for(I||(C=[I++]);$<a;)D[$]=$++;for($=0;$<a;$++)D[$]=D[R=d&R+C[$%I]+(T=D[$])],D[R]=T;(_.g=function(A){for(var L,H=0,G=_.i,q=_.j,B=_.S;A--;)L=B[G=d&G+1],H=H*a+B[d&(B[G]=B[q=d&q+L])+(B[q]=L)];return _.i=G,_.j=q,H})(a)}function y(C,T){return T.i=C.i,T.j=C.j,T.S=C.S.slice(),T}function b(C,T){var I=[],_=typeof C,$;if(T&&_=="object")for($ in C)try{I.push(b(C[$],T-1))}catch{}return I.length?I:_=="string"?C:C+"\0"}function w(C,T){for(var I=C+"",_,$=0;$<I.length;)T[d&$]=d&(_^=T[d&$]*19)+I.charCodeAt($++);return N(T)}function S(){try{var C;return f&&(C=f.randomBytes)?C=C(a):(C=new Uint8Array(a),(t.crypto||t.msCrypto).getRandomValues(C)),N(C)}catch{var T=t.navigator,I=T&&T.plugins;return[+new Date,t,I,t.screen,N(e)]}}function N(C){return String.fromCharCode.apply(0,C)}if(w(r.random(),e),n.exports){n.exports=m;try{f=G7}catch{}}else r["seed"+i]=m})(typeof self<"u"?self:H7,[],Math)})(k0)),k0.exports}var BS,hO;function q7(){if(hO)return BS;hO=1;var n=A7(),t=$7(),e=F7(),r=L7(),a=z7(),s=V7(),o=j7();return o.alea=n,o.xor128=t,o.xorwow=e,o.xorshift7=r,o.xor4096=a,o.tychei=s,BS=o,BS}var e1=q7();const K7=.001,HL=.1;function X7(n,t,e){return e==null&&(e=RT()),gN(n,t,(r,a)=>AT(r,a,e))}function RT(){return J.backend.floatPrecision()===32?K7:HL}function gN(n,t,e){let r=!0;if((gr(n)||gr(t))&&(r=!1),gr(n)&&gr(t)&&(r=!0),r){const o=n.constructor.name,i=t.constructor.name;if(o!==i)throw new Error(`Arrays are of different type. Actual: ${o}. Expected: ${i}`)}if(Array.isArray(n)&&Array.isArray(t)){const o=Uo(n),i=Uo(t);if(!De(o,i))throw new Error(`Arrays have different shapes. Actual: [${o}]. Expected: [${i}]`)}const a=gr(n)?n:Vo(n),s=gr(t)?t:Vo(t);if(a.length!==s.length)throw new Error(`Arrays have different lengths actual: ${a.length} vs expected: ${s.length}.
Actual:   ${a}.
Expected: ${s}.`);for(let o=0;o<s.length;++o){const i=a[o],u=s[o];if(!e(i,u))throw new Error(`Arrays differ: actual[${o}] = ${i}, expected[${o}] = ${u}.
Actual:   ${a}.
Expected: ${s}.`)}typeof expect<"u"&&expect().nothing()}function Y7(n,t){n().then(()=>t.fail(),()=>t()),typeof expect<"u"&&expect().nothing()}function Q7(n,t){const e=typeof t=="string"||typeof t=="number"||typeof t=="boolean"?[t]:t;return Io(n)||Io(n[0])||Io(t)||Io(t[0])?gN(n,e,(r,a)=>r==a):gN(n,t,(r,a)=>AT(r,a,0))}function Z7(n,t,e){if(e==null&&(e=RT()),!AT(n,t,e))throw new Error(`Numbers differ: actual === ${n}, expected === ${t}`);typeof expect<"u"&&expect().nothing()}function AT(n,t,e){return!isFinite(n)&&!isFinite(t)?!0:!(isNaN(n)||isNaN(t)||Math.abs(n-t)>e)}function J7(n,t,e){for(let r=0;r<n.length;r++)if(n[r]<t||n[r]>e)throw new Error(`Value out of range:${n[r]} low: ${t}, high: ${e}`)}function t9(n,t){const e=new Float32Array(n),r=new Float32Array(t);if(e.length!==r.length)throw new Error(`Expected ArrayBuffer to be of length ${r.length}, but it was ${e.length}`);for(let a=0;a<r.length;a++)if(e[a]!==r[a])throw new Error(`Expected ArrayBuffer value at ${a} to be ${r[a]} but got ${e[a]} instead`)}function jL(n){for(let t=0;t<n.length;t++){const e=n[t];Array.isArray(e)?jL(e):n[t]=$o(e)}return n}function e9(n){const t=document.createElement("video");return"playsInline"in t&&(t.playsInline=!0),t.muted=!0,t.loop=!0,t.style.position="fixed",t.style.left="0px",t.style.top="0px",t.preload="auto",t.appendChild(n),new Promise(e=>{t.addEventListener("loadeddata",r=>e(t)),t.load()})}async function n9(n){await n.play(),"requestVideoFrameCallback"in n&&await new Promise(t=>{n.requestVideoFrameCallback(t)})}const r9=Object.freeze(Object.defineProperty({__proto__:null,TEST_EPSILON_FLOAT16:HL,createVideoElement:e9,encodeStrings:jL,expectArrayBuffersEqual:t9,expectArraysClose:X7,expectArraysEqual:Q7,expectNumbersClose:Z7,expectPromiseToFail:Y7,expectValuesInRange:J7,play:n9,testEpsilon:RT},Symbol.toStringTag,{value:"Module"}));class DT{constructor(t,e,r,a,s){this.mean=t,this.stdDev=e,this.dtype=r,this.nextVal=NaN,this.truncated=a,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);const o=s||Math.random();this.random=e1.alea(o.toString())}nextValue(){if(!isNaN(this.nextVal)){const a=this.nextVal;return this.nextVal=NaN,a}let t,e,r=!1;for(;!r;){let a,s,o;do a=2*this.random()-1,s=2*this.random()-1,o=a*a+s*s;while(o>=1||o===0);const i=Math.sqrt(-2*Math.log(o)/o);t=this.mean+this.stdDev*a*i,e=this.mean+this.stdDev*s*i,(!this.truncated||this.isValidTruncated(t))&&(r=!0)}return(!this.truncated||this.isValidTruncated(e))&&(this.nextVal=this.convertValue(e)),this.convertValue(t)}convertValue(t){return this.dtype==null||this.dtype==="float32"?t:Math.round(t)}isValidTruncated(t){return t<=this.upper&&t>=this.lower}}class a9{constructor(t,e,r,a){this.alpha=t,this.beta=1/e,this.dtype=r;const s=a||Math.random();this.randu=e1.alea(s.toString()),this.randn=new DT(0,1,r,!1,this.randu()),t<1?this.d=t+2/3:this.d=t-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let t,e,r,a,s,o;for(;;){do a=this.randn.nextValue(),o=1+this.c*a;while(o<=0);if(o*=o*o,t=a*a,e=1-.331*t*t,r=.5*t+this.d*(1-o+Math.log(o)),s=this.randu(),s<e||Math.log(s)<r)break}return o=1/this.beta*this.d*o,this.alpha<1&&(o*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(o)}convertValue(t){return this.dtype==="float32"?t:Math.round(t)}}class s9{constructor(t=0,e=1,r,a){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=t,this.range=e-t,this.dtype=r,a==null&&(a=Math.random()),typeof a=="number"&&(a=a.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${t} - ${e} <= 1 and dtype is not float`);this.random=e1.alea(a)}convertValue(t){return this.canReturnFloat()?t:Math.round(t)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}function o9(n,t,e=1,r="float32",a){if(Ya(n),e==null&&(e=1),r==null&&(r="float32"),r!=="float32"&&r!=="int32")throw new Error(`Unsupported data type ${r}`);const s=new a9(t,e,r,a),o=we(n,r);for(let i=0;i<o.values.length;i++)o.values[i]=s.nextValue();return o.toTensor()}const qL=tt({randomGamma_:o9});function i9(n,t=0,e=1,r,a){if(Ya(n),r!=null&&r==="bool")throw new Error(`Unsupported data type ${r}`);const s=new DT(t,e,r,!1,a),o=we(n,r);for(let i=0;i<o.values.length;i++)o.values[i]=s.nextValue();return o.toTensor()}const n1=tt({randomNormal_:i9});function u9(n,t,e){if(t!=null&&t==="bool")throw new Error(`Unsupported data type ${t}`);return n1(n,0,1,t,e)}const KL=tt({randomStandardNormal_:u9});function l9(n,t=0,e=1,r="float32",a){Ya(n);const s=we(n,r),o=new s9(t,e,null,a);for(let i=0;i<s.values.length;i++)s.values[i]=o.nextValue();return s.toTensor()}const el=tt({randomUniform_:l9});function c9(n,t,e,r){return el(n,t,e,"int32",r)}const XL=tt({randomUniformInt_:c9});function Ai(n,t,e=1,r="float32"){if(e===0)throw new Error("Cannot have a step of zero");const a={start:n,stop:t,step:e,dtype:r};return J.runKernel(bx,{},a)}function h9(n){const e={input:V(n,"input","real")};return J.runKernel(xx,e)}const Zh=tt({real_:h9});function d9(n){const e={x:V(n,"x","reciprocal")};return J.runKernel(Ud,e)}const $T=tt({reciprocal_:d9});function p9(n){const e={x:V(n,"x","relu")};return J.runKernel(Wd,e)}const lo=tt({relu_:p9});function f9(n){const e={x:V(n,"x","relu6")};return J.runKernel(Gd,e)}const r1=tt({relu6_:f9});function m9(n,t){const r={x:V(n,"x","reverse")},a={dims:t};return J.runKernel(dg,r,a)}const bs=tt({reverse_:m9});function g9(n){const t=V(n,"x","reverse");return P(t.rank===1,()=>`Error in reverse1D: x must be rank 1 but got rank ${t.rank}.`),bs(t,0)}const YL=tt({reverse1d_:g9});function v9(n,t){const e=V(n,"x","reverse");return P(e.rank===2,()=>`Error in reverse2D: x must be rank 2 but got rank ${e.rank}.`),bs(e,t)}const QL=tt({reverse2d_:v9});function y9(n,t){const e=V(n,"x","reverse");return P(e.rank===3,()=>`Error in reverse3D: x must be rank 3 but got rank ${e.rank}.`),bs(e,t)}const ZL=tt({reverse3d_:y9});function b9(n,t){const e=V(n,"x","reverse");return P(e.rank===4,()=>`Error in reverse4D: x must be rank 4 but got rank ${e.rank}.`),bs(e,t)}const JL=tt({reverse4d_:b9});function x9(n){const e={x:V(n,"x","round")};return J.runKernel(Hd,e)}const a1=tt({round_:x9});function w9(n){const e={x:V(n,"x","rsqrt","float32")};return J.runKernel(jd,e)}const s1=tt({rsqrt_:w9});function S9(n){const e={x:V(n,"x","selu")};return J.runKernel(qd,e)}const o1=tt({selu_:S9});function C9(n,t,e,r,a,s=[1,1],o="NHWC"){const i=V(n,"x","separableConv2d"),u=V(t,"depthwiseFilter","separableConv2d"),l=V(e,"pointwiseFilter","separableConv2d");let h=i,d=!1;if(i.rank===3&&(d=!0,h=at(i,[1,i.shape[0],i.shape[1],i.shape[2]])),o==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");P(h.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${h.rank}.`),P(u.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${u.rank}.`),P(l.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${u.rank}.`),P(l.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${l.shape[0]}.`),P(l.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${l.shape[1]}.`);const f=u.shape[2],m=u.shape[3];P(l.shape[2]===f*m,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${f*m}, but got ${l.shape[2]}.`);const v=ip(h,u,r,a,o,s),b=Ri(v,l,1,"valid",o);return d?at(b,[b.shape[1],b.shape[2],b.shape[3]]):b}const i1=tt({separableConv2d_:C9});async function N9(n,t){const e=V(n,"x","setdiff1d"),r=V(t,"y","setdiff1d");P(e.dtype===r.dtype,()=>`x and y should have the same dtype, but got x (${e.dtype}) and y (${r.dtype}).`),P(e.rank===1,()=>`x should be 1D tensor, but got x (${e.shape}).`),P(r.rank===1,()=>`y should be 1D tensor, but got y (${r.shape}).`);const a=await e.data(),s=await r.data(),o=new Set(s);let i=0;for(let h=0;h<a.length;h++)o.has(a[h])||i++;const u=new Yn([i],e.dtype),l=new Yn([i],"int32");for(let h=0,d=0;h<a.length;h++)o.has(a[h])||(u.values[d]=a[h],l.values[d]=h,d++);return[u.toTensor(),l.toTensor()]}const t4=N9;function k9(n){const e={x:V(n,"x","sign")};return J.runKernel(Yd,e)}const OT=tt({sign_:k9});function T9(n){const e={x:V(n,"x","sin","float32")};return J.runKernel(Kd,e)}const u1=tt({sin_:T9});function E9(n){const e={x:V(n,"x","sinh")};return J.runKernel(Xd,e)}const l1=tt({sinh_:E9});function I9(n,t,e){const r=V(n,"x","slice1d");return P(r.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`),ue(r,[t],[e])}const zg=tt({slice1d_:I9});function _9(n,t,e){const r=V(n,"x","slice2d");return P(r.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`),ue(r,t,e)}const c1=tt({slice2d_:_9});function R9(n,t,e){const r=V(n,"x","slice3d");return P(r.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`),ue(r,t,e)}const Pg=tt({slice3d_:R9});function A9(n,t,e){const r=V(n,"x","slice4d");return P(r.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`),ue(r,t,e)}const Jh=tt({slice4d_:A9});function D9(n,t=-1){const e=V(n,"logits","softmax","float32");if(t===-1&&(t=e.rank-1),t!==e.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${e.rank} and dim was ${t}`);const r={logits:e},a={dim:t};return J.runKernel(yg,r,a)}const Vg=tt({softmax_:D9});function $9(n){P(n.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${n.dtype}.`);const t={input:n};return J.runKernel(ex,t)}const Ug=tt({fft_:$9});function O9(n){P(n.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${n.dtype}.`);const t={input:n};return J.runKernel(sx,t)}const td=tt({ifft_:O9});function F9(n){const t=n.shape[n.shape.length-1],e=n.size/t;let r;if(t<=2){const a=at(n,[e,t]);r=td(a)}else{const a=[e,2*(t-1)],s=at(Zh(n),[e,t]),o=at(Rg(n),[e,t]),i=bs(ue(s,[0,1],[e,t-2]),1),u=et(bs(ue(o,[0,1],[e,t-2]),1),Jt(-1)),l=_n([s,i],1),h=_n([o,u],1),d=at(_i(l,h),[a[0],a[1]]);r=td(d)}if(r=Zh(r),n.rank===3&&n.shape[0]!==0){const a=r,s=n.shape[0];r=at(r,[s,r.shape[0]/s,r.shape[1]]),a.dispose()}return r}const h1=tt({irfft_:F9});function M9(n,t,e=0){const a={x:V(n,"x","split")},s={numOrSizeSplits:t,axis:e};return J.runKernel(vg,a,s)}const wa=tt({split_:M9});function L9(n,t){P(n.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${n.dtype}`);let e=n.shape[n.shape.length-1];const r=n.size/e;let a;if(t!=null&&t<e){const v=n.shape.map(b=>0),y=n.shape.map(b=>b);y[n.shape.length-1]=t,a=ue(n,v,y),e=t}else if(t!=null&&t>e){const v=n.shape.map(y=>y);v[n.shape.length-1]=t-e,a=_n([n,Xn(v)],n.shape.length-1),e=t}else a=n;const s=Be(a),o=at(_i(a,s),[r,e]),i=Ug(o),u=Math.floor(e/2)+1,l=Zh(i),h=Rg(i),d=wa(l,[u,e-u],l.shape.length-1),f=wa(h,[u,e-u],h.shape.length-1),m=a.shape.slice();return m[a.shape.length-1]=u,at(_i(d[0],f[0]),m)}const Wg=tt({rfft_:L9});function B9(n,t){let e=V(n,"a","squaredDifference"),r=V(t,"b","squaredDifference");[e,r]=Rn(e,r),me(e.shape,r.shape);const a={a:e,b:r},s={};return J.runKernel(tp,a,s)}const d1=tt({squaredDifference_:B9});function z9(n,t){const e=V(n,"x","squeeze","string_or_numeric");return at(e,Oi(e.shape,t).newShape)}const $r=tt({squeeze_:z9});function P9(n,t=0){const e=Zf(n,"tensors","stack","string_or_numeric");P(e.length>=1,()=>"Pass at least one tensor to tf.stack"),e.length>0&&P(t<=e[0].rank,()=>"Axis must be <= rank of the tensor");const r=e,a={axis:t};return J.runKernel(sg,r,a)}const Ta=tt({stack_:P9});function V9(n,t=0){const r={x:V(n,"x","step")},a={alpha:t};return J.runKernel(sp,r,a)}const wc=tt({step_:V9});function U9(n,t,e,r,a=0,s=0,o=0,i=0,u=0){const h={x:V(n,"x","stridedSlice","string_or_numeric")},d={begin:t,end:e,strides:r,beginMask:a,endMask:s,ellipsisMask:o,newAxisMask:i,shrinkAxisMask:u};return J.runKernel(Dx,h,d)}const FT=tt({stridedSlice_:U9});function W9(n){const e={x:V(n,"x","tan","float32")};return J.runKernel(np,e)}const MT=tt({tan_:W9});function sr(n,t){mc(n);const e=Uo(n,t);if(e.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return Qu(n,null,e,t)}function Iu(n,t,e){if(mc(n),t!=null&&t.length!==2)throw new Error("tensor2d() requires shape to have two numbers");const r=Uo(n,e);if(r.length!==2&&r.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(r.length===1&&t==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return Qu(n,t,r,e)}function LT(n,t,e){if(mc(n),t!=null&&t.length!==3)throw new Error("tensor3d() requires shape to have three numbers");const r=Uo(n,e);if(r.length!==3&&r.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(r.length===1&&t==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return Qu(n,t,r,e)}function e4(n,t,e){if(mc(n),t!=null&&t.length!==4)throw new Error("tensor4d() requires shape to have four numbers");const r=Uo(n,e);if(r.length!==4&&r.length!==1)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(r.length===1&&t==null)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return Qu(n,t,r,e)}function n4(n,t,e){if(mc(n),t!=null&&t.length!==5)throw new Error("tensor5d() requires shape to have five numbers");const r=Uo(n,e);if(r.length!==5&&r.length!==1)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(r.length===1&&t==null)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return Qu(n,t,r,e)}function r4(n,t,e){if(mc(n),t!=null&&t.length!==6)throw new Error("tensor6d() requires shape to have six numbers");const r=Uo(n,e);if(r.length!==6&&r.length!==1)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(r.length===1&&t==null)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return t=t||r,Qu(n,t,r,e)}function BT(n,t,e){const r=t.rank>1?t.shape[t.rank-1]:1,a=t.rank>1?t.rank-1:1,s=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${e.shape}, indices.shape: ${t.shape}, shape: ${n}, sliceDim: ${r}, and batchDim: ${a}.`;if(e.rank<a)throw new Error(s+` update.rank < ${a}. `);if(n.length<r+(e.rank-a))throw new Error(s+` Output shape length < ${r+(e.rank-a)}`);if(e.rank!==a+n.length-r)throw new Error(s+` update.rank != ${a+n.length-r}`);for(let o=0;o<a;++o)if(e.shape[o]!==t.shape[o])throw new Error(s+` updates.shape[${o}] (${e.shape[o]}) != indices.shape[${o}] (${t.shape[o]}).`);for(let o=0;o<e.rank-a;++o)if(e.shape[o+a]!==n[o+r])throw new Error(s+` updates.shape[${o+a}] (${e.shape[o+a]}) != shape[${o+a}] (${n[o+a]})`)}function p1(n,t,e){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(n.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${n.rank}.`);if(t.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(e.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${e}`);if(e.length===0){if(t.size===0)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(n.size===0)throw new Error(`Updates specified for empty output. updates shape: ${n.shape}`)}BT(e,t,n)}function nl(n,t,e){const r=t.shape.length,a=r>1?t.shape[r-1]:1,s=e.length;let o=1;for(let d=a;d<s;++d)o*=e[d];const i=a<1?1:a,u=xt(t.shape)/i,l=[...oe(e.slice(0,a)),1],h=xt(e);return{sliceRank:a,numUpdates:u,sliceSize:o,strides:l,outputSize:h}}const G9=Object.freeze(Object.defineProperty({__proto__:null,calculateShapes:nl,validateInput:p1,validateUpdateShape:BT},Symbol.toStringTag,{value:"Module"}));function H9(n,t,e){const r=V(n,"tensor","tensorScatterupdate"),a=V(t,"indices","tensorScatterupdate","int32"),s=V(e,"updates","tensorScatterupdate");if(p1(s,a,r.shape),r.dtype!==s.dtype)throw new Error(`tensor and updates must have the same dtype, instead they are ${r.dtype} and ${s.dtype}.`);const o={tensor:r,indices:a,updates:s},i={};return J.runKernel(Nx,o,i)}const a4=tt({tensorScatterUpdate_:H9});function j9(n,t=1,e=!0){const r=V(n,"x","topk");if(r.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");const a=r.shape[r.shape.length-1];if(t<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${t}`);if(t>a)throw new Error(`'k' passed to topk() must be <= the last dimension (${a}) but got ${t}`);const s={x:r},o={k:t,sorted:e},[i,u]=J.runKernel(Mx,s,o);return{values:i,indices:u}}const zT=tt({topk_:j9});function q9(n,t=0,e=1,r,a){if(Ya(n),r!=null&&r==="bool")throw new Error("Unsupported data type $ { dtype }");const s=new DT(t,e,r,!0,a),o=we(n,r);for(let i=0;i<o.values.length;i++)o.values[i]=s.nextValue();return o.toTensor()}const f1=tt({truncatedNormal_:q9});function K9(n,t=0){const e=V(n,"x","unique","string_or_numeric");P(e.rank>0,()=>"The input tensor must be at least 1D");const r={x:e},a={axis:t},[s,o]=J.runKernel(Bx,r,a);return{values:s,indices:o}}const PT=tt({unique_:K9});function X9(n,t,e){const r=V(n,"x","unsortedSegmentSum"),a=V(t,"segmentIds","unsortedSegmentSum","int32");P(Zl(e),()=>"numSegments must be of dtype int");const s={x:r,segmentIds:a},o={numSegments:e};return J.runKernel(wg,s,o)}const m1=tt({unsortedSegmentSum_:X9});function Y9(n,t=0){const e=V(n,"x","unstack","string_or_numeric");P(t>=-e.shape.length&&t<e.shape.length,()=>`Axis = ${t} is not in [-${e.shape.length}, ${e.shape.length})`);const r={value:e},a={axis:t};return J.runKernel(xg,r,a)}const xs=tt({unstack_:Y9});function s4(n,t){return t1(n,t,"right")}function VT(n,t=!0,e,r){return J.makeVariable(n,t,e,r)}function g1(n,t){const e=[];for(let s=0;s<t.length;s++)t[s]&&e.push(s);const r=we(n,"int32"),a=we([e.length,n.length],"int32");for(let s=0;s<e.length;s++){const o=r.indexToLoc(e[s]),i=s*n.length;a.values.set(o,i)}return a.toTensor()}async function Q9(n){const t=V(n,"condition","whereAsync","bool"),e=await t.data(),r=g1(t.shape,e);return n!==t&&t.dispose(),r}const UT=Q9;async function Z9(n,t,e){const r=V(n,"tensor","boolMask"),a=V(t,"mask","boolMask","bool"),s=e??0,o=a.rank,i=r.shape;P(o>0,()=>"mask cannot be scalar"),Br(i.slice(s,s+o),a.shape,"mask's shape must match the first K dimensions of tensor's shape,");let u=1;for(let y=s;y<s+o;y++)u*=i[y];const l=i.slice(0,s).concat([u],i.slice(s+o)),h=at(r,l),d=at(a,[-1]),f=await UT(d),m=$r(f,[1]),v=hp(h,m,s);return n!==r&&r.dispose(),t!==a&&a.dispose(),m.dispose(),h.dispose(),d.dispose(),f.dispose(),v}const o4=Z9;function J9(n,t,e){const r=V(n,"x","transpose");if(t==null&&(t=r.shape.map((o,i)=>i).reverse()),P(r.rank===t.length,()=>`Error in transpose: rank of input ${r.rank} must match length of perm ${t}.`),t.forEach(o=>{P(o>=0&&o<r.rank,()=>`All entries in 'perm' must be between 0 and ${r.rank-1} but got ${t}`)}),r.rank<=1)return r.clone();const a={x:r},s={perm:t};return r.dtype==="complex64"?ut(()=>{let o=Zh(r),i=Rg(r);return o=J.runKernel(ql,{x:o},s),i=J.runKernel(ql,{x:i},s),e&&(i=mn(i)),_i(o,i)}):J.runKernel(ql,a,s)}const Oe=tt({transpose_:J9});function tY(n,t,e,r,a=!0){const s=V(n,"v","movingAverage"),o=V(t,"x","movingAverage"),i=V(e,"decay","movingAverage");aL(s,o),P(De(s.shape,o.shape),()=>"Shape mismatch in v and x");const u=Jt(1),l=zt(u,i);let h=et(zt(o,s),l);if(a){P(r!=null,()=>"When using zeroDebias: true, step is required.");const d=V(r,"step","movingAverage");h=Ut(h,zt(u,Wo(i,d)))}return It(s,h)}const i4=tt({movingAverage_:tY});function eY(n,t,e){Ya(e);const r=V(n,"indices","scatterND","int32"),a=V(t,"updates","scatterND");p1(a,r,e);const s={indices:r,updates:a},o={shape:e};return J.runKernel(Cx,s,o)}const u4=tt({scatterND_:eY});function nY(n,t,e,r){if(n.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${n.dtype}.`);if(n.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${n.shape}.`);const a=n.rank>0?n.shape[0]:1,s=n.rank>1?n.shape[1]:1;if(e.length!==s)throw new Error(`outputShape has incorrect number of elements:, ${e.length}, should be: ${s}.`);const o=t.size;if(!(t.rank===0||t.rank===1&&o===a))throw new Error(`sparseValues has incorrect shape ${t.shape}, should be [] or [${a}]`);if(t.dtype!==r.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}function rY(n,t,e,r=0){Ya(e);const a=V(n,"sparseIndices","sparseToDense","int32"),s=V(t,"sparseValues","sparseToDense","string_or_numeric"),o=V(r,"defaultValue","sparseToDense",s.dtype);nY(a,s,e,o);const i={sparseIndices:a,sparseValues:s,defaultValue:o},u={outputShape:e};return J.runKernel(Rx,i,u)}const l4=tt({sparseToDense_:rY});function aY(n,t){const e=V(t,"indices","gatherND","int32"),a={params:V(n,"x","gatherND","string_or_numeric"),indices:e};return J.runKernel(ax,a)}const c4=tt({gatherND_:aY});function sY(n,t){if(t==null)return n.shape.slice();if(De(n.shape,t))return t;if(n.shape.length===t.length){const e=[];for(let r=0;r<n.shape.length;r++)t[r]==null&&n.shape[r]!=null?e.push(n.shape[r]):e.push(t[r]);return e}return t}function oY(n,t,e,r){const a=V(n,"x","dropout");if(P(a.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${a.dtype} tensor instead.`),P(t>=0&&t<1,()=>`rate must be a float in the range [0, 1), but got ${t}.`),t===0)return n instanceof Ae?a.clone():a;const s=sY(a,e),o=1-t,i=Ut(cp(It(el(s,0,1,"float32",r),o)),o);return et(a,i)}const WT=tt({dropout_:oY});function GT(n){return Math.floor(Math.pow(2,Math.ceil(Math.log(n)/Math.log(2))))}function v1(n,t,e){const r=1-n%2,a=new Float32Array(n);for(let s=0;s<n;++s){const o=2*Math.PI*s/(n+r-1);a[s]=t-e*Math.cos(o)}return sr(a,"float32")}async function iY(n,t,e=1){const r=V(n,"predictions","inTopK"),a=V(t,"targets","inTopK");P(r.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${r.rank}`),P(r.rank-1===a.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${r.rank} and targets rank ${a.rank}`),Br(r.shape.slice(0,r.shape.length-1),a.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const s=r.shape[r.shape.length-1];P(e>0&&e<=s,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${s}), but got ${e}`);const o=await r.data(),i=await a.data(),[u,l]=[o.length/s,s],h=xr("bool",u);for(let d=0;d<u;d++){const f=d*l,m=o.subarray(f,f+l),v=[];for(let y=0;y<m.length;y++)v.push({value:m[y],index:y});v.sort((y,b)=>b.value-y.value),h[d]=0;for(let y=0;y<e;y++)if(v[y].index===i[d]){h[d]=1;break}}return n!==r&&r.dispose(),t!==a&&a.dispose(),gs(h,a.shape,"bool")}const h4=iY;function uY(n,t,e,r,a,s="NHWC",o){let i=n;n.rank===3&&(i=at(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let u=t;u.rank===3&&(u=at(t,[1,t.shape[0],t.shape[1],t.shape[2]])),P(i.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${i.shape}.`),P(u.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${u.shape}.`),P(e.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${e}.`);const l=s==="NHWC"?i.shape[3]:i.shape[1],h=s==="NHWC"?u.shape[3]:u.shape[1];P(l===e[2],()=>`Error in conv2dDerFilter: depth of input ${l}) must match input depth in filter (${e[2]}.`),P(h===e[3],()=>`Error in conv2dDerFilter: depth of dy (${h}) must match output depth for filter (${e[3]}).`),ma("conv2dDerFilter",a,o);const d={x:i,dy:u},f={strides:r,pad:a,dataFormat:s,dimRoundingMode:o,filterShape:e};return J.runKernel(Ub,d,f)}const HT=tt({conv2DBackpropFilter_:uY});function y1(n,t,e){if(e==null||e==="linear")return n;if(e==="relu")return et(n,wc(t));throw new Error(`Cannot compute gradient for fused activation ${e}.`)}function b1(n,t){let e=t;const r=Zn(n.shape,t.shape);return r.length>0&&(e=jt(e,r)),at(e,n.shape)}function x1(n,t,e,r){if(t==="linear")return n;if(t==="relu")return lo(n);if(t==="elu")return up(n);if(t==="relu6")return r1(n);if(t==="prelu")return Bg(n,e);if(t==="leakyrelu")return Ag(n,r);if(t==="sigmoid")return Va(n);throw new Error(`Unknown fused activation ${t}.`)}const w1=(n,t)=>!(n>0)||t==="linear";function lY({x:n,filter:t,strides:e,pad:r,dataFormat:a="NHWC",dilations:s=[1,1],dimRoundingMode:o,bias:i,activation:u="linear",preluActivationWeights:l,leakyreluAlpha:h}){if(u=u||"linear",w1(J.state.gradientDepth,u)===!1){P(a==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${a} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let I=Ri(n,t,e,r,a,s,o);return i!=null&&(I=It(I,i)),x1(I,u,l,h)}const d=V(n,"x","conv2d","float32"),f=V(t,"filter","conv2d","float32");let m=d,v=!1;d.rank===3&&(v=!0,m=at(d,[1,d.shape[0],d.shape[1],d.shape[2]])),P(m.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${m.rank}.`),P(f.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${f.rank}.`),ma("fused conv2d",r,o);const y=a==="NHWC"?m.shape[3]:m.shape[1];P(f.shape[2]===y,()=>`Error in conv2d: depth of input (${y}) must match input depth for filter ${f.shape[2]}.`),P(zr(e,s),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${e} and dilations '${s}'`);const b=Nr(m.shape,f.shape,e,s,r,o);let w;i!=null&&(w=V(i,"bias","fused conv2d"),[w]=Rn(w,d),a==="NHWC"?me(b.outShape,w.shape):(P(w.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${w.shape.length}.`),P(w.shape.length===0||w.shape[0]===b.outChannels||w.shape[0]===1,()=>`Error in fused conv2d: bias shape (${w.shape}) is not compatible with the number of output channels (${b.outChannels})`)));let S;if(l!=null){const I=l.shape;if(P(I.length<=1||I.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${I.length}.`),I.length===1)P(I[0]===1||I[0]===b.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${I}) is not compatible with the number of output channels (${b.outChannels}).`);else if(I.length===3)try{me(I,b.outShape)}catch{const $=`Error in fused conv2d: PReLU activation weights (${I}) is not compatible with the output shape of the conv2d (${b.outShape}).`;throw Error($)}S=V(l,"prelu weights","fused conv2d")}const N=(I,_)=>{P(a==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${a} but only NHWC is currently supported.`);const[$,R,D,A]=_,L=y1(I,D,u);P(zu(s),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`);const H=uT(R.shape,L,$,e,r),G=HT(R,L,$.shape,e,r),q=[H,G];if(A!=null){const B=b1(A,L);q.push(B)}return q},C={x:m,filter:f,bias:w,preluActivationWeights:S},T={strides:e,pad:r,dataFormat:a,dilations:s,dimRoundingMode:o,activation:u,leakyreluAlpha:h};return i==null?Go((_,$,R)=>{let D=J.runKernel(qf,C,T);return R([$,_,D]),v&&(D=at(D,[D.shape[1],D.shape[2],D.shape[3]])),{value:D,gradFunc:N}})(m,f):Go((_,$,R,D)=>{let A=J.runKernel(qf,C,T);return D([$,_,A,R]),v&&(A=at(A,[A.shape[1],A.shape[2],A.shape[3]])),{value:A,gradFunc:N}})(m,f,w)}const d4=tt({fusedConv2d_:lY});function cY(n,t,e,r,a,s=[1,1],o){let i=n;n.rank===3&&(i=at(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let u=t;u.rank===3&&(u=at(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const l={x:i,dy:u},h={strides:r,pad:a,dimRoundingMode:o,dilations:s,filterShape:e};return J.runKernel(Xb,l,h)}const p4=tt({depthwiseConv2dNativeBackpropFilter_:cY});function hY(n,t,e,r,a,s=[1,1],o){let i=t,u=!1;t.rank===3&&(u=!0,i=at(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const l={dy:i,filter:e},h={strides:r,pad:a,dimRoundingMode:o,dilations:s,inputShape:n},d=J.runKernel(Yb,l,h);return u?at(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const f4=tt({depthwiseConv2dNativeBackpropInput_:hY});function dY({x:n,filter:t,strides:e,pad:r,dataFormat:a="NHWC",dilations:s=[1,1],dimRoundingMode:o,bias:i,activation:u="linear",preluActivationWeights:l,leakyreluAlpha:h}){if(w1(J.state.gradientDepth,u)===!1){let T=ip(n,t,e,r,a,s,o);return i!=null&&(T=It(T,i)),x1(T,u,l,h)}const d=V(n,"x","depthwiseConv2d","float32"),f=V(t,"filter","depthwiseConv2d","float32");let m=d,v=!1;d.rank===3&&(v=!0,m=at(d,[1,d.shape[0],d.shape[1],d.shape[2]])),P(m.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${m.rank}.`),P(f.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${f.rank}.`),P(m.shape[3]===f.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${m.shape[3]}) must match the inChannels dimension in filter ${f.shape[2]}.`),s==null&&(s=[1,1]),P(zr(e,s),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${e} and dilations '${s}'`),ma("fused depthwiseConv2d",r,o);const y=Nr(m.shape,f.shape,e,s,r,o,!0);let b;i!=null&&(b=V(i,"bias","fused conv2d"),[b]=Rn(b,d),me(y.outShape,b.shape));let w;l!=null&&(w=V(l,"prelu weights","fused depthwiseConv2d"));const S=(T,I)=>{P(zu(s),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${s}'`);const[_,$,R,D]=I,A=y1(T,R,u),L=f4($.shape,A,_,e,r,s,o),H=p4($,A,_.shape,e,r,s,o);if(D!=null){const G=b1(b,A);return[L,H,G]}return[L,H]},N={x:m,filter:f,bias:b,preluActivationWeights:w},C={strides:e,pad:r,dataFormat:a,dilations:s,dimRoundingMode:o,activation:u,leakyreluAlpha:h};return i==null?Go((I,_,$)=>{let R=J.runKernel(Kf,N,C);return $([_,I,R]),v&&(R=at(R,[R.shape[1],R.shape[2],R.shape[3]])),{value:R,gradFunc:S}})(m,f):Go((I,_,$,R)=>{let D=J.runKernel(Kf,N,C);return R([_,I,D,$]),v&&(D=at(D,[D.shape[1],D.shape[2],D.shape[3]])),{value:D,gradFunc:S}})(m,f,b)}const pY=tt({fusedDepthwiseConv2d_:dY});function fY({a:n,b:t,transposeA:e=!1,transposeB:r=!1,bias:a,activation:s="linear",preluActivationWeights:o,leakyreluAlpha:i=.2}){if(w1(J.state.gradientDepth,s)===!1){let A=xe(n,t,e,r);return a!=null&&(A=It(A,a)),x1(A,s,o,i)}let u=V(n,"a","fused matMul"),l=V(t,"b","fused matMul");[u,l]=Rn(u,l);const h=e?u.shape[u.rank-2]:u.shape[u.rank-1],d=r?l.shape[l.rank-1]:l.shape[l.rank-2],f=e?u.shape[u.rank-1]:u.shape[u.rank-2],m=r?l.shape[l.rank-2]:l.shape[l.rank-1],v=u.shape.slice(0,-2),y=l.shape.slice(0,-2),b=xt(v),w=xt(y);P(h===d,()=>`Error in fused matMul: inner shapes (${h}) and (${d}) of Tensors with shapes ${u.shape} and ${l.shape} and transposeA=${e} and transposeB=${r} must match.`);const N=me(u.shape.slice(0,-2),l.shape.slice(0,-2)).concat([f,m]),C=e?at(u,[b,h,f]):at(u,[b,f,h]),T=r?at(l,[w,m,d]):at(l,[w,d,m]);let I;a!=null&&(I=V(a,"bias","fused matMul"),[I]=Rn(I,u),me(N,I.shape));let _;o!=null&&(_=V(o,"prelu weights","fused matMul"));const $=(A,L)=>{const[H,G,q,B]=L,j=y1(at(A,q.shape),q,s);let K,z;if(!e&&!r?(K=xe(j,G,!1,!0),z=xe(H,j,!0,!1)):!e&&r?(K=xe(j,G,!1,!1),z=xe(j,H,!0,!1)):e&&!r?(K=xe(G,j,!1,!0),z=xe(H,j,!1,!1)):(K=xe(G,j,!0,!0),z=xe(j,H,!0,!0)),a!=null){const U=b1(B,j);return[K,z,U]}else return[K,z]},R={a:C,b:T,bias:I,preluActivationWeights:_},D={transposeA:e,transposeB:r,activation:s,leakyreluAlpha:i};return a==null?Go((L,H,G)=>{const q=J.runKernel(jf,R,D);return G([L,H,q]),{value:at(q,N),gradFunc:$}})(C,T):Go((L,H,G,q)=>{const B=J.runKernel(jf,R,D);return q([L,H,B,G]),{value:at(B,N),gradFunc:$}})(C,T,I)}const vN=tt({fusedMatMul_:fY});const m4=Object.freeze(Object.defineProperty({__proto__:null,conv2d:d4,depthwiseConv2d:pY,matMul:vN},Symbol.toStringTag,{value:"Module"}));function mY(n){return v1(n,.54,.46)}const gY=tt({hammingWindow_:mY});function vY(n){return v1(n,.5,.5)}const g4=tt({hannWindow_:vY});function yY(n,t,e,r=!1,a=0){let s=0;const o=[];for(;s+t<=n.size;)o.push(ue(n,s,t)),s+=e;if(r)for(;s<n.size;){const i=s+t-n.size,u=_n([ue(n,s,t-i),bc([i],a)]);o.push(u),s+=e}return o.length===0?Iu([],[0,t]):at(_n(o),[o.length,t])}const v4=tt({frame_:yY});function bY(n,t,e,r,a=g4){r==null&&(r=GT(t));const s=v4(n,t,e),o=et(s,a(t));return Wg(o,r)}const xY=tt({stft_:bY});function wY(n,t,e,r,a="bilinear",s=0){const o=V(n,"image","cropAndResize"),i=V(t,"boxes","cropAndResize","float32"),u=V(e,"boxInd","cropAndResize","int32"),l=i.shape[0];P(o.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${o.rank}.`),P(i.rank===2&&i.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${l},4] but had shape ${i.shape}.`),P(u.rank===1&&u.shape[0]===l,()=>`Error in cropAndResize: boxInd must be have size [${l}] but had shape ${i.shape}.`),P(r.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`),P(r[0]>=1&&r[1]>=1,()=>`cropSize must be atleast [1,1], but was ${r}`),P(a==="bilinear"||a==="nearest",()=>`method must be bilinear or nearest, but was ${a}`);const h={image:o,boxes:i,boxInd:u},d={method:a,extrapolationValue:s,cropSize:r};return J.runKernel(jb,h,d)}const SY=tt({cropAndResize_:wY});function CY(n){const t=V(n,"image","flipLeftRight","float32");P(t.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`);const e={image:t};return J.runKernel(rx,e,{})}const NY=tt({flipLeftRight_:CY});function kY(n){const t=V(n,"image","grayscaleToRGB"),e=t.rank-1,r=t.shape[e];P(t.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`),P(r===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${r}.`);const a=new Array(t.rank);return a.fill(1,0,e),a[e]=3,ls(t,a)}const TY=tt({grayscaleToRGB_:kY});function EY(n){const t=V(n,"image","RGBToGrayscale"),e=t.rank-1,r=t.shape[e];P(t.rank>=2,()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${t.rank}.`),P(r===3,()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${r}.`);const a=t.dtype,s=Ft(t,"float32"),o=sr([.2989,.587,.114]);let i;switch(t.rank){case 2:i=Ll("ij,j->i",s,o);break;case 3:i=Ll("ijk,k->ij",s,o);break;case 4:i=Ll("ijkl,l->ijk",s,o);break;case 5:i=Ll("ijklm,m->ijkl",s,o);break;case 6:i=Ll("ijklmn,n->ijklm",s,o);break;default:throw new Error("Not a valid tensor rank.")}return i=Pn(i,-1),Ft(i,a)}const IY=tt({rgbToGrayscale_:EY});function _Y(n,t,e=0,r=.5){const a=V(n,"image","rotateWithOffset","float32");P(a.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${a.rank}.`);const s={image:a},o={radians:t,fillValue:e,center:r};return J.runKernel(zx,s,o)}const RY=tt({rotateWithOffset_:_Y});function dp(n,t,e,r,a,s){r==null&&(r=.5),a==null&&(a=Number.NEGATIVE_INFINITY),s==null&&(s=0);const o=n.shape[0];return e=Math.min(e,o),P(0<=r&&r<=1,()=>`iouThreshold must be in [0, 1], but was '${r}'`),P(n.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${n.rank}'`),P(n.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${n.shape[1]}`),P(t.rank===1,()=>"scores must be a 1D tensor"),P(t.shape[0]===o,()=>`scores has incompatible shape with boxes. Expected ${o}, but was ${t.shape[0]}`),P(0<=s&&s<=1,()=>`softNmsSigma must be in [0, 1], but was '${s}'`),{maxOutputSize:e,iouThreshold:r,scoreThreshold:a,softNmsSigma:s}}function AY(n,t,e,r=.5,a=Number.NEGATIVE_INFINITY){const s=V(n,"boxes","nonMaxSuppression","float32"),o=V(t,"scores","nonMaxSuppression","float32"),i=dp(s,o,e,r,a);e=i.maxOutputSize,r=i.iouThreshold,a=i.scoreThreshold;const u={maxOutputSize:e,iouThreshold:r,scoreThreshold:a};return J.runKernel(px,{boxes:s,scores:o},u)}const DY=tt({nonMaxSuppression_:AY});function $Y(n,t,e){const r=OY(n,t,e),a=r<0?-(r+1):r;n.splice(a,0,t)}function OY(n,t,e){return MY(n,t,e||FY)}function FY(n,t){return n>t?1:n<t?-1:0}function MY(n,t,e){let r=0,a=n.length,s=0,o=!1;for(;r<a;){s=r+(a-r>>>1);const i=e(t,n[s]);i>0?r=s+1:(a=s,o=!i)}return o?r:-r-1}function S1(n,t,e,r,a){return jT(n,t,e,r,a,0)}function C1(n,t,e,r,a,s){return jT(n,t,e,r,a,0,!1,s,!0)}function N1(n,t,e,r,a,s){return jT(n,t,e,r,a,s,!0)}function jT(n,t,e,r,a,s,o=!1,i=!1,u=!1){const l=[];for(let b=0;b<t.length;b++)t[b]>a&&l.push({score:t[b],boxIndex:b,suppressBeginIndex:0});l.sort(dO);const h=s>0?-.5/s:0,d=[],f=[];for(;d.length<e&&l.length>0;){const b=l.pop(),{score:w,boxIndex:S,suppressBeginIndex:N}=b;if(w<a)break;let C=!1;for(let T=d.length-1;T>=N;--T){const I=LY(n,S,d[T]);if(I>=r){C=!0;break}if(b.score=b.score*BY(r,h,I),b.score<=a)break}b.suppressBeginIndex=d.length,C||(b.score===w?(d.push(S),f.push(b.score)):b.score>a&&$Y(l,b,dO))}const m=d.length,v=e-m;i&&v>0&&(d.push(...new Array(v).fill(0)),f.push(...new Array(v).fill(0)));const y={selectedIndices:d};return o&&(y.selectedScores=f),u&&(y.validOutputs=m),y}function LY(n,t,e){const r=n.subarray(t*4,t*4+4),a=n.subarray(e*4,e*4+4),s=Math.min(r[0],r[2]),o=Math.min(r[1],r[3]),i=Math.max(r[0],r[2]),u=Math.max(r[1],r[3]),l=Math.min(a[0],a[2]),h=Math.min(a[1],a[3]),d=Math.max(a[0],a[2]),f=Math.max(a[1],a[3]),m=(i-s)*(u-o),v=(d-l)*(f-h);if(m<=0||v<=0)return 0;const y=Math.max(s,l),b=Math.max(o,h),w=Math.min(i,d),S=Math.min(u,f),N=Math.max(w-y,0)*Math.max(S-b,0);return N/(m+v-N)}function BY(n,t,e){const r=Math.exp(t*e*e);return e<=n?r:0}function dO(n,t){return n.score-t.score||n.score===t.score&&t.boxIndex-n.boxIndex}async function zY(n,t,e,r=.5,a=Number.NEGATIVE_INFINITY){const s=V(n,"boxes","nonMaxSuppressionAsync"),o=V(t,"scores","nonMaxSuppressionAsync"),i=dp(s,o,e,r,a);e=i.maxOutputSize,r=i.iouThreshold,a=i.scoreThreshold;const u=await Promise.all([s.data(),o.data()]),l=u[0],h=u[1],{selectedIndices:d}=S1(l,h,e,r,a);return s!==n&&s.dispose(),o!==t&&o.dispose(),sr(d,"int32")}const PY=zY;function VY(n,t,e,r=.5,a=Number.NEGATIVE_INFINITY,s=0){const o=V(n,"boxes","nonMaxSuppression"),i=V(t,"scores","nonMaxSuppression"),u=dp(o,i,e,r,a,s);e=u.maxOutputSize,r=u.iouThreshold,a=u.scoreThreshold,s=u.softNmsSigma;const l={boxes:o,scores:i},h={maxOutputSize:e,iouThreshold:r,scoreThreshold:a,softNmsSigma:s},d=J.runKernel(mx,l,h);return{selectedIndices:d[0],selectedScores:d[1]}}const UY=tt({nonMaxSuppressionWithScore_:VY});async function WY(n,t,e,r=.5,a=Number.NEGATIVE_INFINITY,s=0){const o=V(n,"boxes","nonMaxSuppressionAsync"),i=V(t,"scores","nonMaxSuppressionAsync"),u=dp(o,i,e,r,a,s);e=u.maxOutputSize,r=u.iouThreshold,a=u.scoreThreshold,s=u.softNmsSigma;const l=await Promise.all([o.data(),i.data()]),h=l[0],d=l[1],{selectedIndices:f,selectedScores:m}=N1(h,d,e,r,a,s);return o!==n&&o.dispose(),i!==t&&i.dispose(),{selectedIndices:sr(f,"int32"),selectedScores:sr(m)}}const GY=WY;function HY(n,t,e,r=.5,a=Number.NEGATIVE_INFINITY,s=!1){const o=V(n,"boxes","nonMaxSuppression"),i=V(t,"scores","nonMaxSuppression"),u=dp(o,i,e,r,a,null),l=u.maxOutputSize,h=u.iouThreshold,d=u.scoreThreshold,f={boxes:o,scores:i},m={maxOutputSize:l,iouThreshold:h,scoreThreshold:d,padToMaxOutputSize:s},v=J.runKernel(fx,f,m);return{selectedIndices:v[0],validOutputs:v[1]}}const jY=tt({nonMaxSuppressionPadded_:HY});async function qY(n,t,e,r=.5,a=Number.NEGATIVE_INFINITY,s=!1){const o=V(n,"boxes","nonMaxSuppressionAsync"),i=V(t,"scores","nonMaxSuppressionAsync"),u=dp(o,i,e,r,a,null),l=u.maxOutputSize,h=u.iouThreshold,d=u.scoreThreshold,[f,m]=await Promise.all([o.data(),i.data()]),{selectedIndices:v,validOutputs:y}=C1(f,m,l,h,d,s);return o!==n&&o.dispose(),i!==t&&i.dispose(),{selectedIndices:sr(v,"int32"),validOutputs:Jt(y,"int32")}}const KY=qY;function XY(n,t,e=!1,r=!1){const a=V(n,"images","resizeBilinear");P(a.rank===3||a.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${a.rank}.`),P(t.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`),P(r===!1||e===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let s=a,o=!1;a.rank===3&&(o=!0,s=at(a,[1,a.shape[0],a.shape[1],a.shape[2]]));const i={images:s},u={alignCorners:e,halfPixelCenters:r,size:t},l=J.runKernel(hg,i,u);return o?at(l,[l.shape[1],l.shape[2],l.shape[3]]):l}const y4=tt({resizeBilinear_:XY});function YY(n,t,e=!1,r=!1){const a=V(n,"images","resizeNearestNeighbor");P(a.rank===3||a.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${a.rank}.`),P(t.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`),P(a.dtype==="float32"||a.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),P(r===!1||e===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let s=a,o=!1;a.rank===3&&(o=!0,s=at(a,[1,a.shape[0],a.shape[1],a.shape[2]]));const i={images:s},u={alignCorners:e,halfPixelCenters:r,size:t},l=J.runKernel(cg,i,u);return o?at(l,[l.shape[1],l.shape[2],l.shape[3]]):l}const b4=tt({resizeNearestNeighbor_:YY});function QY(n,t="binary",e=!1,r=.5){const a=V(n,"image","threshold"),s=.2989,o=.587,i=.114,u=a.shape[0]*a.shape[1];let l=et(sr([r]),255),h,d,f,m;if(P(a.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${a.rank}.`),P(a.shape[2]===3||a.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${a.shape[2]}.`),P(a.dtype==="int32"||a.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${a.dtype}.`),P(t==="otsu"||t==="binary",()=>`Method must be binary or otsu, but was ${t}`),a.shape[2]===3){[h,d,f]=wa(a,[1,1,1],-1);const b=et(h,s),w=et(d,o),S=et(f,i);m=It(It(b,w),S)}else m=n;if(t==="otsu"){const b=rT(Ft(a1(m),"int32"),gs([]),256);l=ZY(b,u)}const v=e?tl(m,l):ga(m,l);return Ft(et(v,255),"int32")}function ZY(n,t){let e=sr([-1]),r=sr([0]),a=sr([0]),s,o,i,u,l,h;for(let d=0;d<n.size-1;d++){s=ue(n,0,d+1),o=ue(n,d+1),l=Ut(jt(s),t),h=Ut(jt(o),t);const f=jt(et(s,Ai(0,s.size)));i=Ut(f,jt(s));const m=bc(o.shape,s.size),v=It(Ai(0,o.size),m),y=et(o,v);u=Ut(jt(y),jt(o));const b=zt(i,u),w=zt(i,u),S=et(l,h);a=et(et(S,b),w);const N=ga(a,r);r=Or(N,a,r),e=Or(N,sr([d]),e)}return e}const JY=tt({threshold_:QY});function tQ(n,t,e="nearest",r="constant",a=0,s){const o=V(n,"image","transform","float32"),i=V(t,"transforms","transform","float32");P(o.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${o.rank}.`),P(i.rank===2&&(i.shape[0]===o.shape[0]||i.shape[0]===1)&&i.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),P(s==null||s.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${s}.`);const u={image:o,transforms:i},l={interpolation:e,fillMode:r,fillValue:a,outputShape:s};return J.runKernel(Lx,u,l)}const eQ=tt({transform_:tQ});function nQ(n,t,e){const r=V(n,"a","bandPart");P(r.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${r.rank}.`);const a=r.shape,[s,o]=r.shape.slice(-2);let i,u;typeof t=="number"?(P(t%1===0,()=>`bandPart(): numLower must be an integer, got ${t}.`),P(t<=s,()=>`bandPart(): numLower (${t}) must not be greater than the number of rows (${s}).`),i=V(t<0?s:t,"numLower","bandPart")):(P(t.dtype==="int32",()=>"bandPart(): numLower's dtype must be an int32."),i=Or(Qh(t,0),s,Vu(t,s))),typeof e=="number"?(P(e%1===0,()=>`bandPart(): numUpper must be an integer, got ${e}.`),P(e<=o,()=>`bandPart(): numUpper (${e}) must not be greater than the number of columns (${o}).`),u=V(e<0?o:e,"numUpper","bandPart")):(P(e.dtype==="int32",()=>"bandPart(): numUpper's dtype must be an int32."),u=Or(Qh(e,0),o,Vu(e,o)));const l=at(Ai(0,s,1,"int32"),[-1,1]),h=Ai(0,o,1,"int32"),d=zt(l,h),f=ao(tl(d,i),Bi(d,mn(u))),m=Xn([s,o],r.dtype);return at(Ta(xs(at(r,[-1,s,o])).map(v=>Or(f,v,m))),a)}const rQ=tt({bandPart_:nQ});function aQ(n){let t;if(Array.isArray(n)){t=!1,P(n!=null&&n.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const a=n[0].shape[0];for(let s=1;s<n.length;++s)P(n[s].shape[0]===a,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${n[s].shape[0]} vs. ${a})`)}else t=!0,n=wa(n,n.shape[0],0).map(a=>$r(a,[0]));P(n.length<=n[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${n.length}) exceeds number of dimensions (${n[0].shape[0]}).`);const e=[],r=n;for(let a=0;a<n.length;++a)e.push(J.tidy(()=>{let s=r[a];if(a>0)for(let o=0;o<a;++o){const i=et(jt(et(e[o],s)),e[o]);s=zt(s,i)}return Ut(s,lp(s,"euclidean"))}));return t?Ta(e,0):e}const sQ=tt({gramSchmidt_:aQ});function oQ(n,t=!1){if(P(n.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${n.rank}`),n.rank===2)return pO(n,t);{const e=n.shape.slice(0,n.shape.length-2).reduce((u,l)=>u*l),r=xs(at(n,[e,n.shape[n.shape.length-2],n.shape[n.shape.length-1]]),0),a=[],s=[];r.forEach(u=>{const[l,h]=pO(u,t);a.push(l),s.push(h)});const o=at(Ta(a,0),n.shape),i=at(Ta(s,0),n.shape);return[o,i]}}function pO(n,t=!1){return J.tidy(()=>{P(n.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${n.shape.length}D Tensor.`);const e=n.shape[0],r=n.shape[1];let a=Yx(e),s=Oo(n);const o=Iu([[1]],[1,1]);let i=Oo(o);const u=e>=r?r:e;for(let l=0;l<u;++l){const h=s,d=i,f=a;[i,s,a]=J.tidy(()=>{const m=ue(s,[l,l],[e-l,1]),v=lp(m),y=ue(s,[l,l],[1,1]),b=Or(ga(y,0),Iu([[-1]]),Iu([[1]])),w=zt(y,et(b,v)),S=Ut(m,w);S.shape[0]===1?i=Oo(o):i=_n([o,ue(S,[1,0],[S.shape[0]-1,S.shape[1]])],0);const N=mn(Ut(xe(b,w),v)),C=ue(s,[l,0],[e-l,r]),T=et(N,i),I=Oe(i);if(l===0)s=zt(C,xe(T,xe(I,C)));else{const R=zt(C,xe(T,xe(I,C)));s=_n([ue(s,[0,0],[l,r]),R],0)}const _=Oe(T),$=ue(a,[0,l],[e,a.shape[1]-l]);if(l===0)a=zt($,xe(xe($,i),_));else{const R=zt($,xe(xe($,i),_));a=_n([ue(a,[0,0],[e,l]),R],1)}return[i,s,a]}),Ie([h,d,f])}return!t&&e>r&&(a=ue(a,[0,0],[e,r]),s=ue(s,[0,0],[r,r])),[a,s]})}const iQ=tt({qr_:oQ});var ia;(function(n){n[n.NONE=0]="NONE",n[n.MEAN=1]="MEAN",n[n.SUM=2]="SUM",n[n.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"})(ia||(ia={}));function uQ(n,t,e=ia.SUM_BY_NONZERO_WEIGHTS){const r=V(n,"losses","computeWeightedLoss");let a=null;t!=null&&(a=V(t,"weights","computeWeightedLoss"));const s=a==null?r:et(r,a);if(e===ia.NONE)return s;if(e===ia.SUM)return jt(s);if(e===ia.MEAN){if(a==null)return En(s);{const o=r.size/a.size,i=Ut(jt(s),jt(a));return o>1?Ut(i,Jt(o)):i}}if(e===ia.SUM_BY_NONZERO_WEIGHTS){if(a==null)return Ut(jt(s),Jt(r.size));{const o=et(a,xa(r.shape)),i=Ft(jt(ac(o,Jt(0))),"float32");return Ut(jt(s),i)}}throw Error(`Unknown reduction: ${e}`)}const Pi=tt({computeWeightedLoss_:uQ});function lQ(n,t,e,r=ia.SUM_BY_NONZERO_WEIGHTS){const a=V(n,"labels","absoluteDifference"),s=V(t,"predictions","absoluteDifference");let o=null;e!=null&&(o=V(e,"weights","absoluteDifference")),Br(a.shape,s.shape,"Error in absoluteDifference: ");const i=Kn(zt(a,s));return Pi(i,o,r)}const cQ=tt({absoluteDifference_:lQ});function hQ(n,t,e,r,a=ia.SUM_BY_NONZERO_WEIGHTS){const s=V(n,"labels","cosineDistance"),o=V(t,"predictions","cosineDistance");let i=null;r!=null&&(i=V(r,"weights","cosineDistance")),Br(s.shape,o.shape,"Error in cosineDistance: ");const u=Jt(1),l=zt(u,jt(et(s,o),e,!0));return Pi(l,i,a)}const dQ=tt({cosineDistance_:hQ});function pQ(n,t,e,r=ia.SUM_BY_NONZERO_WEIGHTS){let a=V(n,"labels","hingeLoss");const s=V(t,"predictions","hingeLoss");let o=null;e!=null&&(o=V(e,"weights","hingeLoss")),Br(a.shape,s.shape,"Error in hingeLoss: ");const i=Jt(1);a=zt(et(Jt(2),a),i);const u=lo(zt(i,et(a,s)));return Pi(u,o,r)}const fQ=tt({hingeLoss_:pQ});function mQ(n,t,e,r=1,a=ia.SUM_BY_NONZERO_WEIGHTS){const s=V(n,"labels","huberLoss"),o=V(t,"predictions","huberLoss");let i=null;e!=null&&(i=V(e,"weights","huberLoss")),Br(s.shape,o.shape,"Error in huberLoss: ");const u=Jt(r),l=Kn(zt(o,s)),h=Vu(l,u),d=zt(l,h),f=It(et(Jt(.5),an(h)),et(u,d));return Pi(f,i,a)}const gQ=tt({huberLoss_:mQ});function vQ(n,t,e,r=1e-7,a=ia.SUM_BY_NONZERO_WEIGHTS){const s=V(n,"labels","logLoss"),o=V(t,"predictions","logLoss");let i=null;e!=null&&(i=V(e,"weights","logLoss")),Br(s.shape,o.shape,"Error in logLoss: ");const u=Jt(1),l=Jt(r),h=mn(et(s,Ga(It(o,l)))),d=et(zt(u,s),Ga(It(zt(u,o),l))),f=zt(h,d);return Pi(f,i,a)}const yQ=tt({logLoss_:vQ});function bQ(n,t,e,r=ia.SUM_BY_NONZERO_WEIGHTS){const a=V(n,"labels","meanSquaredError"),s=V(t,"predictions","meanSquaredError");let o=null;e!=null&&(o=V(e,"weights","meanSquaredError")),Br(a.shape,s.shape,"Error in meanSquaredError: ");const i=d1(a,s);return Pi(i,o,r)}const xQ=tt({meanSquaredError_:bQ});function wQ(n,t){const e=V(n,"labels","sigmoidCrossEntropyWithLogits"),r=V(t,"logits","sigmoidCrossEntropyWithLogits");Br(e.shape,r.shape,"Error in sigmoidCrossEntropyWithLogits: ");const a=lo(r),s=et(r,e),o=Dg(ka(mn(Kn(r))));return It(zt(a,s),o)}function SQ(n,t,e,r=0,a=ia.SUM_BY_NONZERO_WEIGHTS){let s=V(n,"multiClassLabels","sigmoidCrossEntropy");const o=V(t,"logits","sigmoidCrossEntropy");let i=null;if(e!=null&&(i=V(e,"weights","sigmoidCrossEntropy")),Br(s.shape,o.shape,"Error in sigmoidCrossEntropy: "),r>0){const l=Jt(r),h=Jt(1),d=Jt(.5);s=It(et(s,zt(h,l)),et(d,l))}const u=wQ(s,o);return Pi(u,i,a)}const CQ=tt({sigmoidCrossEntropy_:SQ});function NQ(n,t,e=-1){if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${t.rank} and dim was ${e}`);return Go((a,s,o)=>{const u=$g(s,[e],!0),l=zt(Ft(s,"float32"),u);o([a,l]);const h=mn(et(l,a));return{value:jt(h,[e]),gradFunc:(m,v)=>{const[y,b]=v,w=Vn(m.shape,[e]);return[et(at(m,w),zt(Ft(y,"float32"),ka(b))),et(at(m,w),zt(ka(b),Ft(y,"float32")))]}}})(n,t)}function kQ(n,t,e,r=0,a=ia.SUM_BY_NONZERO_WEIGHTS){let s=V(n,"onehotLabels","softmaxCrossEntropy");const o=V(t,"logits","softmaxCrossEntropy");let i=null;if(e!=null&&(i=V(e,"weights","softmaxCrossEntropy")),Br(s.shape,o.shape,"Error in softmaxCrossEntropy: "),r>0){const l=Jt(r),h=Jt(1),d=Jt(s.shape[1]);s=It(et(s,zt(h,l)),Ut(l,d))}const u=NQ(s,o);return Pi(u,i,a)}const TQ=tt({softmaxCrossEntropy_:kQ});function EQ(n,t,e,r){const a=V(n,"indices","sparseFillEmptyRows","int32"),s=V(t,"values","sparseFillEmptyRows"),o=V(e,"denseShape","sparseFillEmptyRows","int32"),i=V(r,"defaultValue","sparseFillEmptyRows",s.dtype);if(a.rank!==2)throw new Error(`Indices should be Tensor2D but received shape
        ${a.shape}`);if(s.rank!==1)throw new Error(`Values should be Tensor1D but received shape ${s.shape}`);if(o.rank!==1)throw new Error(`Dense shape should be Tensor1D but received shape ${o.shape}`);if(i.rank!==0)throw new Error(`Default value should be a scalar but received shape ${i.shape}`);const u={indices:a,values:s,denseShape:o,defaultValue:i},l=J.runKernel(Tx,u);return{outputIndices:l[0],outputValues:l[1],emptyRowIndicator:l[2],reverseIndexMap:l[3]}}const IQ=tt({sparseFillEmptyRows_:EQ});function _Q(n,t,e){const r=V(n,"inputIndices","sparseReshape","int32"),a=V(t,"inputShape","sparseReshape","int32"),s=V(e,"newShape","sparseReshape","int32");if(r.rank!==2)throw new Error(`Input indices should be Tensor2D but received shape
        ${r.shape}`);if(a.rank!==1)throw new Error(`Input shape should be Tensor1D but received shape ${a.shape}`);if(s.rank!==1)throw new Error(`New shape should be Tensor1D but received shape ${s.shape}`);const o={inputIndices:r,inputShape:a,newShape:s},i=J.runKernel(Ex,o);return{outputIndices:i[0],outputShape:i[1]}}const RQ=tt({sparseReshape_:_Q});function AQ(n,t,e){const r=V(n,"data","sparseSegmentMean"),a=V(t,"indices","sparseSegmentMean","int32"),s=V(e,"segmentIds","sparseSegmentMean","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(a.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
          ${a.shape}`);if(s.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
          ${s.shape}`);const o={data:r,indices:a,segmentIds:s};return J.runKernel(Ix,o)}const DQ=tt({sparseSegmentMean_:AQ});function $Q(n,t,e){const r=V(n,"data","sparseSegmentSum"),a=V(t,"indices","sparseSegmentSum","int32"),s=V(e,"segmentIds","sparseSegmentSum","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(a.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
         ${a.shape}`);if(s.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
         ${s.shape}`);const o={data:r,indices:a,segmentIds:s};return J.runKernel(_x,o)}const OQ=tt({sparseSegmentSum_:$Q});function FQ(n,t,e,r,a,s,o,i){const u=V(n,"data","stringNGrams","string");if(u.dtype!=="string")throw new Error("Data must be of datatype string");if(u.shape.length!==1)throw new Error(`Data must be a vector, saw: ${u.shape}`);const l=V(t,"dataSplits","stringNGrams");if(l.dtype!=="int32")throw new Error("Data splits must be of datatype int32");const h={separator:e,nGramWidths:r,leftPad:a,rightPad:s,padWidth:o,preserveShortSequences:i},d={data:u,dataSplits:l},f=J.runKernel($x,d,h);return{nGrams:f[0],nGramsSplits:f[1]}}const MQ=tt({stringNGrams_:FQ});function LQ(n,t,e=!0){const r=V(n,"input","stringSplit","string"),a=V(t,"delimiter","stringSplit","string");if(r.rank!==1)throw new Error(`Input should be Tensor1D but received shape ${r.shape}`);if(a.rank!==0)throw new Error(`Delimiter should be a scalar but received shape ${a.shape}`);const s={skipEmpty:e},o={input:r,delimiter:a},i=J.runKernel(Ox,o,s);return{indices:i[0],values:i[1],shape:i[2]}}const BQ=tt({stringSplit_:LQ});function zQ(n,t){const e=V(n,"input","stringToHashBucketFast","string"),r={numBuckets:t};if(t<=0)throw new Error("Number of buckets must be at least 1");const a={input:e};return J.runKernel(Fx,a,r)}const PQ=tt({stringToHashBucketFast_:zQ});function VQ(n,t,e,r=!0){const a=V(n,"input","staticRegexReplace","string"),s={pattern:t,rewrite:e,replaceGlobal:r};return J.runKernel(bg,{x:a},s)}const UQ=tt({staticRegexReplace_:VQ});const x4={fft:Ug,ifft:td,rfft:Wg,irfft:h1},w4={hammingWindow:gY,hannWindow:g4,frame:v4,stft:xY},ha={flipLeftRight:NY,grayscaleToRGB:TY,resizeNearestNeighbor:b4,resizeBilinear:y4,rgbToGrayscale:IY,rotateWithOffset:RY,cropAndResize:SY,nonMaxSuppression:DY,nonMaxSuppressionAsync:PY,nonMaxSuppressionWithScore:UY,nonMaxSuppressionWithScoreAsync:GY,nonMaxSuppressionPadded:jY,nonMaxSuppressionPaddedAsync:KY,threshold:JY,transform:eQ},qT={bandPart:rQ,gramSchmidt:sQ,qr:iQ},S4={absoluteDifference:cQ,computeWeightedLoss:Pi,cosineDistance:dQ,hingeLoss:fQ,huberLoss:gQ,logLoss:yQ,meanSquaredError:xQ,sigmoidCrossEntropy:CQ,softmaxCrossEntropy:TQ},C4={sparseFillEmptyRows:IQ,sparseReshape:RQ,sparseSegmentMean:DQ,sparseSegmentSum:OQ},N4={stringNGrams:MQ,stringSplit:BQ,stringToHashBucketFast:PQ,staticRegexReplace:UQ};const WQ=new Map,yN=new Map;class Sc{getClassName(){return this.constructor.className}static fromConfig(t,e){return new t(e)}}class us{constructor(){this.classNameMap={}}static getMap(){return us.instance==null&&(us.instance=new us),us.instance}static register(t){us.getMap().classNameMap[t.className]=[t,t.fromConfig]}}function $t(n,t,e){P(n.className!=null,()=>"Class being registered does not have the static className property defined."),P(typeof n.className=="string",()=>"className is required to be a string, but got type "+typeof n.className),P(n.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),typeof t>"u"&&(t="Custom"),typeof e>"u"&&(e=n.className);const r=e,a=t+">"+r;return us.register(n),WQ.set(a,n),yN.set(n,a),n}function GQ(n){return yN.has(n)?yN.get(n):n.className}const HQ=Object.freeze(Object.defineProperty({__proto__:null,Serializable:Sc,SerializationMap:us,getRegisteredName:GQ,registerClass:$t},Symbol.toStringTag,{value:"Module"}));class Vi extends Sc{minimize(t,e=!1,r){const{value:a,grads:s}=this.computeGradients(t,r);if(r!=null){const o=r.map(i=>({name:i.name,tensor:s[i.name]}));this.applyGradients(o)}else this.applyGradients(s);return Ie(s),e?a:(a.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(t,e){return AL(t,e)}dispose(){this.iterations_!=null&&Ie(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:Jt(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(t){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(t){return this.iterations_=(await t[0].tensor.data())[0],t.slice(1)}}Object.defineProperty(Vi,Symbol.hasInstance,{value:n=>n.minimize!=null&&n.computeGradients!=null&&n.applyGradients!=null});class KT extends Vi{static get className(){return"Adadelta"}constructor(t,e,r=null){super(),this.learningRate=t,this.rho=e,this.epsilon=r,this.accumulatedGrads=[],this.accumulatedUpdates=[],r==null&&(this.epsilon=J.backend.epsilon())}applyGradients(t){(Array.isArray(t)?t.map(r=>r.name):Object.keys(t)).forEach((r,a)=>{const s=J.registeredVariables[r],o=!1;this.accumulatedGrads[a]==null&&(this.accumulatedGrads[a]={originalName:`${r}/accum_grad`,variable:ut(()=>Be(s).variable(o))}),this.accumulatedUpdates[a]==null&&(this.accumulatedUpdates[a]={originalName:`${r}/accum_var`,variable:ut(()=>Be(s).variable(o))});const i=Array.isArray(t)?t[a].tensor:t[r];if(i==null)return;const u=this.accumulatedGrads[a].variable,l=this.accumulatedUpdates[a].variable;ut(()=>{const h=It(et(u,this.rho),et(an(i),1-this.rho)),d=et(Ut(wr(It(l,this.epsilon)),wr(It(u,this.epsilon))),i),f=It(et(l,this.rho),et(an(d),1-this.rho));u.assign(h),l.assign(f);const m=It(et(d,-this.learningRate),s);s.assign(m)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(Ie(this.accumulatedGrads.map(t=>t.variable)),Ie(this.accumulatedUpdates.map(t=>t.variable)))}async getWeights(){const t=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(t.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(t){t=await this.extractIterations(t);const e=t.length/2,r=!1;this.accumulatedGrads=t.slice(0,e).map(a=>({originalName:a.name,variable:a.tensor.variable(r)})),this.accumulatedUpdates=t.slice(e,e*2).map(a=>({originalName:a.name,variable:a.tensor.variable(r)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(t,e){return new t(e.learningRate,e.rho,e.epsilon)}}class XT extends Vi{static get className(){return"Adagrad"}constructor(t,e=.1){super(),this.learningRate=t,this.initialAccumulatorValue=e,this.accumulatedGrads=[]}applyGradients(t){(Array.isArray(t)?t.map(r=>r.name):Object.keys(t)).forEach((r,a)=>{const s=J.registeredVariables[r];this.accumulatedGrads[a]==null&&(this.accumulatedGrads[a]={originalName:`${r}/accumulator`,variable:ut(()=>bc(s.shape,this.initialAccumulatorValue).variable(!1))});const o=Array.isArray(t)?t[a].tensor:t[r];if(o==null)return;const i=this.accumulatedGrads[a].variable;ut(()=>{const u=It(i,an(o));i.assign(u);const l=It(et(Ut(o,wr(It(u,J.backend.epsilon()))),-this.learningRate),s);s.assign(l)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&Ie(this.accumulatedGrads.map(t=>t.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(t){t=await this.extractIterations(t);const e=!1;this.accumulatedGrads=t.map(r=>({originalName:r.name,variable:r.tensor.variable(e)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(t,e){return new t(e.learningRate,e.initialAccumulatorValue)}}class YT extends Vi{static get className(){return"Adam"}constructor(t,e,r,a=null){super(),this.learningRate=t,this.beta1=e,this.beta2=r,this.epsilon=a,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],ut(()=>{this.accBeta1=Jt(e).variable(),this.accBeta2=Jt(r).variable()}),a==null&&(this.epsilon=J.backend.epsilon())}applyGradients(t){const e=Array.isArray(t)?t.map(r=>r.name):Object.keys(t);ut(()=>{const r=zt(1,this.accBeta1),a=zt(1,this.accBeta2);e.forEach((s,o)=>{const i=J.registeredVariables[s],u=!1;this.accumulatedFirstMoment[o]==null&&(this.accumulatedFirstMoment[o]={originalName:`${s}/m`,variable:ut(()=>Be(i).variable(u))}),this.accumulatedSecondMoment[o]==null&&(this.accumulatedSecondMoment[o]={originalName:`${s}/v`,variable:ut(()=>Be(i).variable(u))});const l=Array.isArray(t)?t[o].tensor:t[s];if(l==null)return;const h=this.accumulatedFirstMoment[o].variable,d=this.accumulatedSecondMoment[o].variable,f=It(et(h,this.beta1),et(l,1-this.beta1)),m=It(et(d,this.beta2),et(an(l),1-this.beta2)),v=Ut(f,r),y=Ut(m,a);h.assign(f),d.assign(m);const b=It(et(Ut(v,It(wr(y),this.epsilon)),-this.learningRate),i);i.assign(b)}),this.accBeta1.assign(et(this.accBeta1,this.beta1)),this.accBeta2.assign(et(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&Ie(this.accumulatedFirstMoment.map(t=>t.variable)),this.accumulatedSecondMoment!=null&&Ie(this.accumulatedSecondMoment.map(t=>t.variable))}async getWeights(){const t=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(t.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(t){t=await this.extractIterations(t),ut(()=>{this.accBeta1.assign(Wo(this.beta1,this.iterations_+1)),this.accBeta2.assign(Wo(this.beta2,this.iterations_+1))});const e=t.length/2,r=!1;this.accumulatedFirstMoment=t.slice(0,e).map(a=>({originalName:a.name,variable:a.tensor.variable(r)})),this.accumulatedSecondMoment=t.slice(e,e*2).map(a=>({originalName:a.name,variable:a.tensor.variable(r)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon)}}class QT extends Vi{static get className(){return"Adamax"}constructor(t,e,r,a=null,s=0){super(),this.learningRate=t,this.beta1=e,this.beta2=r,this.epsilon=a,this.decay=s,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],ut(()=>{this.iteration=Jt(0).variable(),this.accBeta1=Jt(e).variable()}),a==null&&(this.epsilon=J.backend.epsilon())}applyGradients(t){const e=Array.isArray(t)?t.map(r=>r.name):Object.keys(t);ut(()=>{const r=zt(1,this.accBeta1),a=Ut(-this.learningRate,It(et(this.iteration,this.decay),1));e.forEach((s,o)=>{const i=J.registeredVariables[s],u=!1;this.accumulatedFirstMoment[o]==null&&(this.accumulatedFirstMoment[o]={originalName:`${s}/m`,variable:Be(i).variable(u)}),this.accumulatedWeightedInfNorm[o]==null&&(this.accumulatedWeightedInfNorm[o]={originalName:`${s}/v`,variable:Be(i).variable(u)});const l=Array.isArray(t)?t[o].tensor:t[s];if(l==null)return;const h=this.accumulatedFirstMoment[o].variable,d=this.accumulatedWeightedInfNorm[o].variable,f=It(et(h,this.beta1),et(l,1-this.beta1)),m=et(d,this.beta2),v=Kn(l),y=Ko(m,v);h.assign(f),d.assign(y);const b=It(et(Ut(a,r),Ut(f,It(y,this.epsilon))),i);i.assign(b)}),this.iteration.assign(It(this.iteration,1)),this.accBeta1.assign(et(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&Ie(this.accumulatedFirstMoment.map(t=>t.variable)),this.accumulatedWeightedInfNorm!=null&&Ie(this.accumulatedWeightedInfNorm.map(t=>t.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(t){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon,e.decay)}}class k1 extends Vi{static get className(){return"SGD"}constructor(t){super(),this.learningRate=t,this.setLearningRate(t)}applyGradients(t){(Array.isArray(t)?t.map(r=>r.name):Object.keys(t)).forEach((r,a)=>{const s=Array.isArray(t)?t[a].tensor:t[r];if(s==null)return;const o=J.registeredVariables[r];ut(()=>{const i=It(et(this.c,s),o);o.assign(i)})}),this.incrementIterations()}setLearningRate(t){this.learningRate=t,this.c!=null&&this.c.dispose(),this.c=ar(Jt(-t))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(t){if(t=await this.extractIterations(t),t.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(t,e){return new t(e.learningRate)}}class ZT extends k1{static get className(){return"Momentum"}constructor(t,e,r=!1){super(t),this.learningRate=t,this.momentum=e,this.useNesterov=r,this.accumulations=[],this.m=Jt(this.momentum)}applyGradients(t){(Array.isArray(t)?t.map(r=>r.name):Object.keys(t)).forEach((r,a)=>{const s=J.registeredVariables[r];this.accumulations[a]==null&&(this.accumulations[a]={originalName:`${r}/momentum`,variable:ut(()=>Be(s).variable(!1))});const o=this.accumulations[a].variable,i=Array.isArray(t)?t[a].tensor:t[r];i!=null&&ut(()=>{let u;const l=It(et(this.m,o),i);this.useNesterov?u=It(et(this.c,It(i,et(l,this.m))),s):u=It(et(this.c,l),s),o.assign(l),s.assign(u)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&Ie(this.accumulations.map(t=>t.variable))}setMomentum(t){this.momentum=t}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(t){t=await this.extractIterations(t);const e=!1;this.accumulations=t.map(r=>({originalName:r.name,variable:r.tensor.variable(e)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(t,e){return new t(e.learningRate,e.momentum,e.useNesterov)}}class JT extends Vi{static get className(){return"RMSProp"}constructor(t,e=.9,r=0,a=null,s=!1){if(super(),this.learningRate=t,this.decay=e,this.momentum=r,this.epsilon=a,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=s,a==null&&(this.epsilon=J.backend.epsilon()),t==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(t){(Array.isArray(t)?t.map(r=>r.name):Object.keys(t)).forEach((r,a)=>{const s=J.registeredVariables[r],o=!1;this.accumulatedMeanSquares[a]==null&&(this.accumulatedMeanSquares[a]={originalName:`${r}/rms`,variable:ut(()=>Be(s).variable(o))}),this.accumulatedMoments[a]==null&&(this.accumulatedMoments[a]={originalName:`${r}/momentum`,variable:ut(()=>Be(s).variable(o))}),this.accumulatedMeanGrads[a]==null&&this.centered&&(this.accumulatedMeanGrads[a]={originalName:`${r}/mg`,variable:ut(()=>Be(s).variable(o))});const i=Array.isArray(t)?t[a].tensor:t[r];if(i==null)return;const u=this.accumulatedMeanSquares[a].variable,l=this.accumulatedMoments[a].variable;ut(()=>{const h=It(et(u,this.decay),et(an(i),1-this.decay));if(this.centered){const d=this.accumulatedMeanGrads[a].variable,f=It(et(d,this.decay),et(i,1-this.decay)),m=Ut(et(i,this.learningRate),wr(zt(h,It(an(f),this.epsilon)))),v=It(et(l,this.momentum),m);u.assign(h),d.assign(f),l.assign(v);const y=zt(s,v);s.assign(y)}else{const d=It(et(u,this.decay),et(an(i),1-this.decay)),f=It(et(l,this.momentum),Ut(et(i,this.learningRate),wr(It(d,this.epsilon))));u.assign(d),l.assign(f);const m=zt(s,f);s.assign(m)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&Ie(this.accumulatedMeanSquares.map(t=>t.variable)),this.accumulatedMeanGrads!=null&&this.centered&&Ie(this.accumulatedMeanGrads.map(t=>t.variable)),this.accumulatedMoments!=null&&Ie(this.accumulatedMoments.map(t=>t.variable))}async getWeights(){const t=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&t.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(t.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(t){t=await this.extractIterations(t);const e=this.centered?t.length/3:t.length/2,r=!1;this.accumulatedMeanSquares=t.slice(0,e).map(a=>({originalName:a.name,variable:a.tensor.variable(r)})),this.accumulatedMoments=t.slice(e,e*2).map(a=>({originalName:a.name,variable:a.tensor.variable(r)})),this.centered&&(this.accumulatedMeanGrads=t.slice(e*2,e*3).map(a=>({originalName:a.name,variable:a.tensor.variable(r)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(t,e){return new t(e.learningRate,e.decay,e.momentum,e.epsilon,e.centered)}}const jQ=[KT,XT,YT,QT,ZT,JT,k1];function qQ(){for(const n of jQ)$t(n)}const KQ="model",XQ=".json",YQ=".weights.bin";function fO(n){return new Promise(t=>setTimeout(t)).then(n)}class oc{constructor(t){if(!dt().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");t.startsWith(oc.URL_SCHEME)&&(t=t.slice(oc.URL_SCHEME.length)),(t==null||t.length===0)&&(t=KQ),this.modelJsonFileName=t+XQ,this.weightDataFileName=t+YQ}async save(t){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");const e=uo.join(t.weightData),r=window.URL.createObjectURL(new Blob([e],{type:"application/octet-stream"}));if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const a=[{paths:["./"+this.weightDataFileName],weights:t.weightSpecs}],s=dL(t,a),o=window.URL.createObjectURL(new Blob([JSON.stringify(s)],{type:"application/json"})),i=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(i.download=this.modelJsonFileName,i.href=o,await fO(()=>i.dispatchEvent(new MouseEvent("click"))),t.weightData!=null){const u=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;u.download=this.weightDataFileName,u.href=r,await fO(()=>u.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:Ng(t)}}}}oc.URL_SCHEME="downloads://";class QQ{constructor(t){if(t==null||t.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${t}`);this.jsonFile=t[0],this.weightsFiles=t.slice(1)}async load(){return new Promise((t,e)=>{const r=new FileReader;r.onload=a=>{const s=JSON.parse(a.target.result),o=s.modelTopology;if(o==null){e(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));return}if(s.weightsManifest==null){e(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));return}if(this.weightsFiles.length===0){t({modelTopology:o});return}const u=Uk(s,l=>this.loadWeights(l));t(u)},r.onerror=a=>e(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),r.readAsText(this.jsonFile)})}loadWeights(t){const e=[],r=[];for(const o of t)e.push(...o.weights),r.push(...o.paths);const a=this.checkManifestAndWeightFiles(t),s=r.map(o=>this.loadWeightsFile(o,a[o]));return Promise.all(s).then(o=>[e,o])}loadWeightsFile(t,e){return new Promise((r,a)=>{const s=new FileReader;s.onload=o=>{const i=o.target.result;r(i)},s.onerror=o=>a(`Failed to weights data from file of path '${t}'.`),s.readAsArrayBuffer(e)})}checkManifestAndWeightFiles(t){const e=[],r=this.weightsFiles.map(s=>rO(s.name)),a={};for(const s of t)s.paths.forEach(o=>{const i=rO(o);if(e.indexOf(i)!==-1)throw new Error(`Duplicate file basename found in weights manifest: '${i}'`);if(e.push(i),r.indexOf(i)===-1)throw new Error(`Weight file with basename '${i}' is not provided.`);a[o]=this.weightsFiles[r.indexOf(i)]});if(e.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${e.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return a}}const ZQ=n=>dt().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(oc.URL_SCHEME)?JQ(n.slice(oc.URL_SCHEME.length)):null;Tn.registerSaveRouter(ZQ);function JQ(n="model"){return new oc(n)}function tZ(n){return new QQ(n)}function mO(n,t,e,r){o(n),e=e??0,r=r??1,i(e,r);let a=0;const s=u=>(u.then(l=>{const h=e+ ++a/n.length*(r-e);return t(h),l}),u);function o(u){P(u!=null&&Array.isArray(u)&&u.length>0,()=>"promises must be a none empty array")}function i(u,l){P(u>=0&&u<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${u}`),P(l>=0&&l<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${l}`),P(l>=u,()=>`startFraction must be no more than endFraction, but got startFraction ${u} and endFraction ${l}`)}return Promise.all(n.map(s))}async function k4(n,t){t==null&&(t={});const e=t.fetchFunc==null?dt().platform.fetch:t.fetchFunc,r=n.map(d=>e(d,t.requestInit,{isBinary:!0})),i=(t.onProgress==null?await Promise.all(r):await mO(r,t.onProgress,0,.5)).map(d=>d.arrayBuffer());return t.onProgress==null?await Promise.all(i):await mO(i,t.onProgress,.5,1)}function eZ(n,t){var e;const r=t.fetchFunc==null?dt().platform.fetch:t.fetchFunc;let a=0,s;return(e=t.onProgress)===null||e===void 0||e.call(t,0),new ReadableStream({pull:async o=>{for(var i;a<n.length;){s||(s=(await r(n[a],t.requestInit,{isBinary:!0})).body.getReader());const{done:u,value:l}=await s.read();if(u){a++,s=void 0,(i=t.onProgress)===null||i===void 0||i.call(t,a/n.length);continue}o.enqueue(l);return}o.close()}})}async function nZ(n,t="",e,r){return T4(o=>k4(o,{requestInit:r}))(n,t,e)}function T4(n){return async(t,e="",r)=>{const a=t.map(()=>!1),s={},o=r!=null?r.map(()=>!1):[],i=[];if(t.forEach((m,v)=>{let y=0;m.weights.forEach(b=>{const w="quantization"in b?b.quantization.dtype:b.dtype,S=Jl[w]*xt(b.shape),N=()=>{a[v]=!0,s[v]==null&&(s[v]=[]),s[v].push({manifestEntry:b,groupOffset:y,sizeBytes:S})};r!=null?r.forEach((C,T)=>{C===b.name&&(N(),o[T]=!0)}):N(),i.push(b.name),y+=S})}),!o.every(m=>m)){const m=r.filter((v,y)=>!o[y]);throw new Error(`Could not find weights in manifest with names: ${m.join(", ")}. 
Manifest JSON has weights with names: ${i.join(", ")}.`)}const u=a.reduce((m,v,y)=>(v&&m.push(y),m),[]),l=[];u.forEach(m=>{t[m].paths.forEach(v=>{const y=e+(e.endsWith("/")?"":"/")+v;l.push(y)})});const h=await n(l),d={};let f=0;return u.forEach(m=>{const v=t[m].paths.length,y=new uo(h.slice(f,f+v));s[m].forEach(w=>{const S=y.slice(w.groupOffset,w.groupOffset+w.sizeBytes),N=uL(S,[w.manifestEntry]);for(const C in N)d[C]=N[C]}),f+=v}),d}}const rZ="application/octet-stream",aZ="application/json";class tE{constructor(t,e){if(this.DEFAULT_METHOD="POST",e==null&&(e={}),this.weightPathPrefix=e.weightPathPrefix,this.weightUrlConverter=e.weightUrlConverter,e.fetchFunc!=null?(P(typeof e.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=e.fetchFunc):this.fetch=dt().platform.fetch,P(t!=null&&t.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(t)&&P(t.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${t.length}).`),this.path=t,e.requestInit!=null&&e.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=e.requestInit||{},this.loadOptions=e}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const e=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);e.body=new FormData;const r=[{paths:["./model.weights.bin"],weights:t.weightSpecs}],a=dL(t,r);if(e.body.append("model.json",new Blob([JSON.stringify(a)],{type:aZ}),"model.json"),t.weightData!=null){const o=uo.join(t.weightData);e.body.append("model.weights.bin",new Blob([o],{type:rZ}),"model.weights.bin")}const s=await this.fetch(this.path,e);if(s.ok)return{modelArtifactsInfo:Ng(t),responses:[s]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${s.status}.`)}async loadModelJSON(){const t=await this.fetch(this.path,this.requestInit);if(!t.ok)throw new Error(`Request to ${this.path} failed with status code ${t.status}. Please verify this URL points to the model JSON of the model to load.`);let e;try{e=await t.json()}catch{let o=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?o+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":o+=" Please make sure the server is serving valid JSON for this request.",new Error(o)}const r=e.modelTopology,a=e.weightsManifest;if(r==null&&a==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return e}async load(){if(this.loadOptions.streamWeights)return this.loadStream();const t=await this.loadModelJSON();return Uk(t,e=>this.loadWeights(e))}async loadStream(){const t=await this.loadModelJSON(),e=await this.getWeightUrls(t.weightsManifest),r=z0(t.weightsManifest),a=()=>eZ(e,this.loadOptions);return Object.assign(Object.assign({},t),{weightSpecs:r,getWeightStream:a})}async getWeightUrls(t){const e=Array.isArray(this.path)?this.path[1]:this.path,[r,a]=sZ(e),s=this.weightPathPrefix||r,o=[],i=[];for(const u of t)for(const l of u.paths)this.weightUrlConverter!=null?i.push(this.weightUrlConverter(l)):o.push(s+l+a);return this.weightUrlConverter&&o.push(...await Promise.all(i)),o}async loadWeights(t){const e=await this.getWeightUrls(t),r=z0(t),a=await k4(e,this.loadOptions);return[r,a]}}tE.URL_SCHEME_REGEX=/^https?:\/\//;function sZ(n){const t=n.lastIndexOf("/"),e=n.lastIndexOf("?"),r=n.substring(0,t),a=e>t?n.substring(e):"";return[r+"/",a]}function bN(n){return n.match(tE.URL_SCHEME_REGEX)!=null}const E4=(n,t)=>{if(typeof fetch>"u"&&(t==null||t.fetchFunc==null))return null;{let e=!0;if(Array.isArray(n)?e=n.every(r=>bN(r)):e=bN(n),e)return eE(n,t)}return null};Tn.registerSaveRouter(E4);Tn.registerLoadRouter(E4);function eE(n,t){return new tE(n,t)}function oZ(n,t){return eE(n,t)}class zS{constructor(t){this.modelArtifacts=t}load(){return this.modelArtifacts}}class I4{constructor(t){this.saveHandler=t}save(t){return this.saveHandler(t)}}class iZ{constructor(t){t.load&&(this.load=()=>Promise.resolve(t.load())),t.save&&(this.save=e=>Promise.resolve(t.save(e)))}}function uZ(n,t,e,r){const a=arguments;return new iZ(V0(...a))}function V0(n,t,e,r){return arguments.length===1?n.modelTopology!=null||n.weightSpecs!=null?new zS(n):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new zS({modelTopology:n})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new zS({modelTopology:n,weightSpecs:t,weightData:e,trainingConfig:r}))}function lZ(n){return new I4(n)}function cZ(n){return new I4(n)}const nE=Object.freeze(Object.defineProperty({__proto__:null,CompositeArrayBuffer:uo,browserFiles:tZ,browserHTTPRequest:oZ,concatenateArrayBuffers:hL,copyModel:P8,decodeWeights:uL,decodeWeightsStream:cL,encodeWeights:hN,fromMemory:uZ,fromMemorySync:V0,getLoadHandlers:T8,getModelArtifactsForJSON:Uk,getModelArtifactsForJSONSync:Vk,getModelArtifactsInfoForJSON:Ng,getSaveHandlers:pL,getWeightSpecs:z0,http:eE,isHTTPScheme:bN,listModels:B8,loadWeights:nZ,moveModel:V8,registerLoadRouter:k8,registerSaveRouter:N8,removeModel:z8,weightsLoaderFactory:T4,withSaveHandler:lZ,withSaveHandlerSync:cZ},Symbol.toStringTag,{value:"Module"}));function hZ(n,t,e){const r=V(n,"labels","confusionMatrix"),a=V(t,"predictions","confusionMatrix");P(e==null||e>0&&Number.isInteger(e),()=>`If provided, numClasses must be a positive integer, but got ${e}`),P(r.rank===1,()=>`Expected the rank of labels to be 1, but got ${r.rank}`),P(a.rank===1,()=>`Expected the rank of predictions to be 1, but got ${a.rank}`),P(r.shape[0]===a.shape[0],()=>`Mismatch in the number of examples: ${r.shape[0]} vs. ${a.shape[0]}. Labels and predictions should have the same number of elements.`),P(e>0&&Number.isInteger(e),()=>`numClasses is required to be a positive integer, but got ${e}`);const s=sc(Ft(r,"int32"),e),o=sc(Ft(a,"int32"),e),i=Oe(s),u=xe(i,o);return Ft(u,"int32")}const dZ=tt({confusionMatrix_:hZ});const pZ=Object.freeze(Object.defineProperty({__proto__:null,confusionMatrix:dZ},Symbol.toStringTag,{value:"Module"}));let El,gO=!1;function _4(n,t=3){if(t>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(n==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let e=!1,r=!1,a=!1,s=!1,o=!1,i=!1;if(n.data instanceof Uint8Array)e=!0;else if(typeof ImageData<"u"&&n instanceof ImageData)r=!0;else if(typeof HTMLVideoElement<"u"&&n instanceof HTMLVideoElement)a=!0;else if(typeof HTMLImageElement<"u"&&n instanceof HTMLImageElement)s=!0;else if(n.getContext!=null)o=!0;else if(typeof ImageBitmap<"u"&&n instanceof ImageBitmap)i=!0;else throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${n.constructor.name}`);if(Yf(L0,J.backendName)!=null){const v={pixels:n},y={numChannels:t};return J.runKernel(L0,v,y)}const[l,h]=a?[n.videoWidth,n.videoHeight]:[n.width,n.height];let d;if(o)d=n.getContext("2d").getImageData(0,0,l,h).data;else if(r||e)d=n.data;else if(s||a||i){if(El==null)if(typeof document>"u")if(typeof OffscreenCanvas<"u"&&typeof OffscreenCanvasRenderingContext2D<"u")El=new OffscreenCanvas(1,1).getContext("2d");else throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");else El=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});El.canvas.width=l,El.canvas.height=h,El.drawImage(n,0,0,l,h),d=El.getImageData(0,0,l,h).data}let f;if(t===4)f=new Int32Array(d);else{const v=l*h;f=new Int32Array(v*t);for(let y=0;y<v;y++)for(let b=0;b<t;++b)f[y*t+b]=d[y*4+b]}return LT(f,[h,l,t],"int32")}function fZ(n){return n!=null&&n.data instanceof Uint8Array}function mZ(){return typeof window<"u"&&typeof ImageBitmap<"u"&&window.hasOwnProperty("createImageBitmap")}function gZ(n){return n!=null&&n.width!==0&&n.height!==0}function vZ(n){return mZ()&&!(n instanceof ImageBitmap)&&gZ(n)&&!fZ(n)}async function yZ(n,t=3){let e=null;if(dt().getBool("WRAP_TO_IMAGEBITMAP")&&vZ(n)){let r;try{r=await createImageBitmap(n,{premultiplyAlpha:"none"})}catch{r=null}r!=null&&r.width===n.width&&r.height===n.height?e=r:e=n}else e=n;return _4(e,t)}function R4(n){if(n.rank!==2&&n.rank!==3)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${n.rank}.`);const t=n.rank===2?1:n.shape[2];if(t>4||t===2)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${t}`);if(n.dtype!=="float32"&&n.dtype!=="int32")throw new Error(`Unsupported type for toPixels: ${n.dtype}. Please use float32 or int32 tensors.`)}function bZ(n){const t=n?.alpha||1;if(t>1||t<0)throw new Error(`Alpha value ${t} is suppoed to be in range [0 - 1].`)}async function xZ(n,t){let e=V(n,"img","toPixels");if(!(n instanceof Ae)){const l=e;e=Ft(l,"int32"),l.dispose()}R4(e);const[r,a]=e.shape.slice(0,2),s=e.rank===2?1:e.shape[2],o=await e.data(),i=e.dtype==="float32"?255:1,u=new Uint8ClampedArray(a*r*4);for(let l=0;l<r*a;++l){const h=[0,0,0,255];for(let f=0;f<s;f++){const m=o[l*s+f];if(e.dtype==="float32"){if(m<0||m>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${m}.`)}else if(e.dtype==="int32"&&(m<0||m>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${m}.`);s===1?(h[0]=m*i,h[1]=m*i,h[2]=m*i):h[f]=m*i}const d=l*4;u[d+0]=Math.round(h[0]),u[d+1]=Math.round(h[1]),u[d+2]=Math.round(h[2]),u[d+3]=Math.round(h[3])}if(t!=null){gO||Yf(Zb,J.backendName)!=null&&(console.warn("tf.browser.toPixels is not efficient to draw tensor on canvas. Please try tf.browser.draw instead."),gO=!0),t.width=a,t.height=r;const l=t.getContext("2d"),h=new ImageData(u,a,r);l.putImageData(h,0,0)}return e!==n&&e.dispose(),u}function wZ(n,t,e){let r=V(n,"img","draw");if(!(n instanceof Ae)){const o=r;r=Ft(o,"int32"),o.dispose()}R4(r),bZ(e?.imageOptions);const a={image:r},s={canvas:t,options:e};J.runKernel(Zb,a,s)}const rE=tt({fromPixels_:_4}),SZ=Object.freeze(Object.defineProperty({__proto__:null,draw:wZ,fromPixels:rE,fromPixelsAsync:yZ,toPixels:xZ},Symbol.toStringTag,{value:"Module"}));function T1(n,t){const e=n.shape.length,r=t.shape.length;if(e<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${e}.`);if(r<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);if(t.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[r-1]>e)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[r-1]} vs. ${e}`);if(xt(n.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${n.shape}.`);const a=t.shape,s=a[a.length-1];let o=1;for(let d=0;d<a.length-1;++d)o*=a[d];const i=n.shape,u=a.slice();u.pop();let l=1;for(let d=s;d<e;++d)l*=i[d],u.push(i[d]);const h=[...oe(n.shape).map(d=>d/l),1].slice(0,s);return[u,o,l,h]}const CZ=Object.freeze(Object.defineProperty({__proto__:null,prepareAndValidate:T1},Symbol.toStringTag,{value:"Module"}));const xN=-2,NZ=-1;function aE(n,t,e){const r=n.shape.length;P(r===t.length,()=>`Error in slice${r}D: Length of begin ${t} must match the rank of the array (${r}).`),P(r===e.length,()=>`Error in slice${r}D: Length of size ${e} must match the rank of the array (${r}).`);for(let a=0;a<r;++a)P(t[a]+e[a]<=n.shape[a],()=>`Error in slice${r}D: begin[${a}] + size[${a}] (${t[a]+e[a]}) would overflow input.shape[${a}] (${n.shape[a]})`)}function kZ(n){const t=[];let e=0;for(;n>0;)n&1&&t.push(e),n/=2,e++;return t}function sE(n,t,e){const r=[];for(let a=0;a<n.length;a++)r[a]=Math.ceil((t[a]-n[a])/e[a]);return r}function A4(n,t,e,r){const a=[...n];for(let s=a.length;s<r.length;s++)a.push(1);for(let s=0;s<e;s++)s===0?a[t]=1:(a.splice(t,0,1),a.pop());return a}function D4(n,t,e){return e<=n?e:e-(t-1)}function $4(n,t){const e=[];for(let r=0;r<n;r++)e.push(t+r);return e}function TZ(n,t,e,r,a,s,o,i,u){const l=n.length;let h=new Array(l),d=new Array(l),f=new Array(l);if(t.length&&e>0){const m=t[0],v=e+1;h=O4(o,m,v,r,n),d=F4(i,m,v,a,n),f=A4(s,m,v,n)}else for(let m=0;m<l;m++)h[m]=L4(o,r,s,n,m,u),d[m]=B4(i,a,s,n,m,u),f[m]=M4(s,m,u);return{begin:h,end:d,strides:f}}function O4(n,t,e,r,a){const s=[...a],o=$4(e,t);for(let i=0;i<s.length;i++)if(o.indexOf(i)>-1)s[i]=0;else{const u=D4(t,e,i);let l=r[u];n&1<<u&&(l=0),s[i]=l}return s}function F4(n,t,e,r,a){const s=[...a],o=$4(e,t);for(let i=0;i<s.length;i++)if(o.indexOf(i)>-1)s[i]=Number.MAX_SAFE_INTEGER;else{const u=D4(t,e,i);let l=r[u];n&1<<u&&(l=Number.MAX_SAFE_INTEGER),s[i]=l}for(let i=0;i<s.length;i++){const u=a[i];s[i]<0&&(s[i]+=u),s[i]=Ou(0,s[i],a[i])}return s}function M4(n,t,e){let r=n[t];return(e&1<<t||r==null)&&(r=1),r}function L4(n,t,e,r,a,s){let o=t[a];const i=e[a]||1;(n&1<<a||s&1<<a||o==null)&&(i>0?o=Number.MIN_SAFE_INTEGER:o=Number.MAX_SAFE_INTEGER);const u=r[a];return o<0&&(o+=u),o=Ou(0,o,u-1),o}function B4(n,t,e,r,a,s){let o=t[a];const i=e[a]||1;(n&1<<a||s&1<<a||o==null)&&(i>0?o=Number.MAX_SAFE_INTEGER:o=Number.MIN_SAFE_INTEGER);const u=r[a];return o<0&&(o+=u),i>0?o=Ou(0,o,u):o=Ou(-1,o,u-1),o}function oE(n,t,e){let r=e.length;for(let a=0;a<e.length;a++)if(e[a]>1){r=a;break}for(let a=r+1;a<e.length;a++)if(t[a]>0||e[a]!==n[a])return!1;return!0}function iE(n,t){let e=n.length>0?n[n.length-1]:1;for(let r=0;r<n.length-1;r++)e+=n[r]*t[r];return e}function E1(n,t,e){let r;const a=n.shape.length;typeof t=="number"?r=[t,...new Array(a-1).fill(0)]:t.length<a?r=t.concat(new Array(a-t.length).fill(0)):r=t.slice(),r.forEach(o=>{P(o!==-1,()=>"slice() does not support negative begin indexing.")});let s;return e==null?s=new Array(a).fill(-1):typeof e=="number"?s=[e,...new Array(a-1).fill(-1)]:e.length<a?s=e.concat(new Array(a-e.length).fill(-1)):s=e,s=s.map((o,i)=>o>=0?o:(P(o===-1,()=>`Negative size values should be exactly -1 but got ${o} for the slice() size at index ${i}.`),n.shape[i]-r[i])),[r,s]}function uE(n,t,e,r,a,s,o,i,u){let l;if(r==null?(l=new Array(t.length),l.fill(1)):l=r,o!=null&&(o&o-1)!==0)throw new Error("Multiple ellipses in slice is not allowed.");let h=!1;const d={dims:l.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:e.slice(),strides:l.slice(),beginMask:a,endMask:s,ellipsisMask:o,newAxisMask:i,shrinkAxisMask:u};for(let N=0;N<d.dims;N++)h&&(1<<N&i)!==0&&d.numAddAxisAfterEllipsis++,1<<N&o&&(h=!0);h||(d.ellipsisMask|=1<<d.dims,d.dims++);const f={dims:n.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};EZ(d,f);let m=!0,v=!0,y=!0;const b=[],w=[];for(let N=0;N<n.length;++N){if(f.strides[N]===0)throw Error(`strides[${N}] must be non-zero`);const C=!!(f.shrinkAxisMask&1<<N),T=n[N];if(T===-1){b.push(C?1:-1);continue}const I=[f.beginMask&1<<N,f.endMask&1<<N],_=[f.strides[N]>0?0:-1,f.strides[N]>0?T:T-1];if(C&&f.strides[N]<=0)throw Error("only stride 1 allowed on non-range indexing.");y=y&&f.strides[N]===1;const $=!!(f.beginMask&1<<N&&f.endMask&1<<N);if(f.beginValid&&f.endValid){if(C){const L=f.begin[N]<0?T+f.begin[N]:f.begin[N];if(f.begin[N]=L,f.end[N]=f.begin[N]+1,L<0||L>=T)throw Error(`slice index ${f.begin[N]} of dimension ${N} out of bounds.`)}else f.begin[N]=vO(f.begin[N],0,f.strides[N],T,I,_),f.end[N]=vO(f.end[N],1,f.strides[N],T,I,_);const A=f.strides[N]===1&&f.begin[N]===0&&f.end[N]===T;m=m&&A,v=v&&(N===0&&f.strides[N]===1||A)}else m=m&&f.strides[N]===1&&$,v=v&&(N===0&&f.strides[N]===1||$);let R,D=!1;if(f.beginValid&&f.endValid?(R=f.end[N]-f.begin[N],D=!0):C?(R=1,D=!0):$&&T>=0&&(f.strides[N]<0?R=-T:R=T,D=!0),D){let A;R===0||R<0!=f.strides[N]<0?A=0:A=Math.trunc(R/f.strides[N])+(R%f.strides[N]!==0?1:0),b.push(A)}else b.push(-1)}for(let N=0;N<f.finalShapeGatherIndices.length;++N){const C=f.finalShapeGatherIndices[N];C>=0?w.push(b[C]):C===xN&&w.push(1)}return{finalShapeSparse:w.filter((N,C)=>f.finalShapeGatherIndices[C]!==xN),finalShape:w,isIdentity:m,sliceDim0:v,isSimpleSlice:y,begin:f.begin,end:f.end,strides:f.strides}}function EZ(n,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let e=0;t.beginValid=n.begin!=null,t.endValid=n.end!=null,t.begin=new Array(t.dims),t.end=new Array(t.dims),t.strides=new Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let r=0;r<n.dims;r++)if(1<<r&n.ellipsisMask){const a=Math.min(t.dims-(n.dims-r)+1+n.numAddAxisAfterEllipsis,t.dims);for(;e<a;e++)t.begin[e]=0,t.end[e]=0,t.strides[e]=1,t.beginMask|=1<<e,t.endMask|=1<<e,t.finalShapeGatherIndices.push(e),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[e]=r}else if(1<<r&n.newAxisMask)t.finalShapeGatherIndices.push(xN),t.finalShapeGatherIndicesSparse.push(-1);else{if(e===t.begin.length)throw Error(`Index out of range using input dim ${e}; input has only ${t.dims} dims, ${t.begin.length}.`);n.begin!=null&&(t.begin[e]=n.begin[r]),n.end!=null&&(t.end[e]=n.end[r]),t.strides[e]=n.strides[r],n.beginMask&1<<r&&(t.beginMask|=1<<e),n.endMask&1<<r&&(t.endMask|=1<<e),n.shrinkAxisMask&1<<r?(t.finalShapeGatherIndices.push(NZ),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<e):(t.finalShapeGatherIndices.push(e),t.finalShapeGatherIndicesSparse.push(r)),t.inputShapeGatherIndicesSparse[e]=r,e++}}function vO(n,t,e,r,a,s){if(a[t])return e>0?s[t]:s[t+1&1];{const o=n<0?r+n:n;return o<s[0]?s[0]:o>s[1]?s[1]:o}}const z4=Object.freeze(Object.defineProperty({__proto__:null,assertParamsValid:aE,computeFlatOffset:iE,computeOutShape:sE,getNormalizedAxes:TZ,isSliceContinous:oE,maskToAxes:kZ,parseSliceParams:E1,sliceInfo:uE,startForAxis:L4,startIndicesWithElidedDims:O4,stopForAxis:B4,stopIndicesWithElidedDims:F4,stridesForAxis:M4,stridesWithElidedDims:A4},Symbol.toStringTag,{value:"Module"}));const IZ="4.22.0";class P4{static sgd(t){return new k1(t)}static momentum(t,e,r=!1){return new ZT(t,e,r)}static rmsprop(t,e=.9,r=0,a=null,s=!1){return new JT(t,e,r,a,s)}static adam(t=.001,e=.9,r=.999,a=null){return new YT(t,e,r,a)}static adadelta(t=.001,e=.95,r=null){return new KT(t,e,r)}static adamax(t=.002,e=.9,r=.999,a=null,s=0){return new QT(t,e,r,a,s)}static adagrad(t,e=.1){return new XT(t,e)}}const Dl=P4;const _Z=typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:n=>n();function lE(){return new Promise(n=>_Z(()=>n()))}function cE(n,t){const e=n[0].length;n.forEach((a,s)=>{P(a.length===e,()=>`Error in concat${e}D: rank of tensors[${s}] must be the same as the rank of the rest (${e})`)}),P(t>=0&&t<e,()=>`Error in concat${e}D: axis must be between 0 and ${e-1}.`);const r=n[0];n.forEach((a,s)=>{for(let o=0;o<e;o++)P(o===t||a[o]===r[o],()=>`Error in concat${e}D: Shape of tensors[${s}] (${a}) does not match the shape of the rest (${r}) along the non-concatenated axis ${s}.`)})}function Fo(n,t){const e=n[0].slice();for(let r=1;r<n.length;r++)e[t]+=n[r][t];return e}var Qs;(function(n){n[n.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",n[n.VALUE_ROWIDS=1]="VALUE_ROWIDS",n[n.ROW_LENGTHS=2]="ROW_LENGTHS",n[n.ROW_SPLITS=3]="ROW_SPLITS",n[n.ROW_LIMITS=4]="ROW_LIMITS",n[n.ROW_STARTS=5]="ROW_STARTS"})(Qs||(Qs={}));function V4(n,t,e){let r=new Array;if(e==null&&t==null)return r;if(t==null)for(;r.length<n+e.length;)r.push(-1);else r=t.slice();if(e==null)return r;if(n+e.length!==r.length)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.rank = ${n+e.length}, but shape.rank = ${r.length}`);for(let a=1;a<e.length;++a){const s=e[a],o=r[r.length-e.length+a],i=r[o];if(s>=0)if(i>=0){if(i!==s)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.shape[${a+n}] = ${s} but shape[${a+n}] = ${i}`)}else r[o]=s}return r}function U4(n){const t={FIRST_DIM_SIZE:Qs.FIRST_DIM_SIZE,VALUE_ROWIDS:Qs.VALUE_ROWIDS,ROW_LENGTHS:Qs.ROW_LENGTHS,ROW_SPLITS:Qs.ROW_SPLITS,ROW_LIMITS:Qs.ROW_LIMITS,ROW_STARTS:Qs.ROW_STARTS},e=[];for(const r of n)if(r in t)e.push(t[r]);else break;return e}function W4(n){return n.length===0?0:n[0]===Qs.FIRST_DIM_SIZE?n.length-1:n.length}function G4(n,t){if(n==null||t==null)return;const e=n.length,r=t.length;if(e>=r)throw new Error(`defaultValue.shape=${n} and ragged tensor flatValues.shape=${t}, are incompatible: defaultValue.rank = ${e} must be less than ragged tensor input flatValues.rank = ${r})`);for(let a=0;a<Math.min(e,r-1);++a){const s=n[a],o=t[a+1];if(s>=0&&o>=0&&s!==1&&s!==o)throw new Error(`defaultValue.shape=${n}, and ragged tensor input flatValues.shape=${t} are incompatible: defaultValue.shape[${a-n.length}] = ${s} but ragged tensor input.flatValues.shape[${a-n.length}] = ${o}`)}}const hE=30;function I1(n){return n<=hE?n:O0(n,Math.floor(Math.sqrt(n)))}function dE(n,t,e){const r=e*(typeof n=="number"?n:n[0]),a=t*(typeof n=="number"?n:n[1]);return[r,a]}function Gg(n,t,e,r=!0){let a=[];if(r)a=a.concat(t.slice(0)),a.push(n[0]/e),a=a.concat(n.slice(1));else{a=a.concat(n[0]);const s=t.length;for(let o=0;o<s;++o)a=a.concat([n[o+1]/t[o],t[o]]);a=a.concat(n.slice(s+1))}return a}function Hg(n,t,e=!0){const r=[];if(e){r.push(t);for(let a=t+1;a<n;++a)a<=2*t?(r.push(a),r.push(a-(t+1))):r.push(a)}else{const a=[],s=[];for(let o=1;o<n;++o)o>=t*2+1||o%2===1?s.push(o):a.push(o);r.push(...a),r.push(0),r.push(...s)}return r}function jg(n,t,e,r=!0){const a=[];r?a.push(n[0]/e):a.push(n[0]*e);for(let s=1;s<n.length;++s)s<=t.length?r?a.push(t[s-1]*n[s]):a.push(n[s]/t[s-1]):a.push(n[s]);return a}function pE(n,t){const e=[0];for(let r=0;r<t;++r)e.push(n[r][0]);return e}function fE(n,t,e){const r=n.slice(0,1);for(let a=0;a<e;++a)r.push(n[a+1]-t[a][0]-t[a][1]);return r}const _1=1.7580993408473768,R1=1.0507009873554805;const mE=.3275911,gE=.254829592,vE=-.284496736,yE=1.421413741,bE=-1.453152027,xE=1.061405429;function Di(n,t){if(n.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${n.length}, imag: ${t.length}.`);const e=new Float32Array(n.length*2);for(let r=0;r<e.length;r+=2)e[r]=n[r/2],e[r+1]=t[r/2];return e}function H4(n){const t=new Float32Array(n.length/2),e=new Float32Array(n.length/2);for(let r=0;r<n.length;r+=2)t[r/2]=n[r],e[r/2]=n[r+1];return{real:t,imag:e}}function j4(n){const t=Math.ceil(n.length/4),e=new Float32Array(t),r=new Float32Array(t);for(let a=0;a<n.length;a+=4)e[Math.floor(a/4)]=n[a],r[Math.floor(a/4)]=n[a+1];return{real:e,imag:r}}function q4(n){const t=Math.floor(n.length/4),e=new Float32Array(t),r=new Float32Array(t);for(let a=2;a<n.length;a+=4)e[Math.floor(a/4)]=n[a],r[Math.floor(a/4)]=n[a+1];return{real:e,imag:r}}function wE(n,t){const e=n[t*2],r=n[t*2+1];return{real:e,imag:r}}function K4(n,t,e,r){n[r*2]=t,n[r*2+1]=e}function X4(n,t){const e=new Float32Array(n/2),r=new Float32Array(n/2);for(let a=0;a<Math.ceil(n/2);a++){const s=(t?2:-2)*Math.PI*(a/n);e[a]=Math.cos(s),r[a]=Math.sin(s)}return{real:e,imag:r}}function Y4(n,t,e){const r=(e?2:-2)*Math.PI*(n/t),a=Math.cos(r),s=Math.sin(r);return{real:a,imag:s}}const PS="->",RZ=/->/g,yO=",",bO="...";function SE(n,t){n=n.replace(/\s/g,"");const e=(n.length-n.replace(RZ,"").length)/PS.length;if(e<1)throw new Error("Equations without an arrow are not supported.");if(e>1)throw new Error(`Equation must contain exactly one arrow ("${PS}").`);const[r,a]=n.split(PS);P(r.indexOf(bO)===-1,()=>`The ellipsis notation ("${bO}") is not supported yet.`);const s=r.split(yO),o=s.length;if(t!==o)throw new Error(`Expected ${o} input tensors, received ${t}`);if(o>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const i=[];for(let f=0;f<a.length;++f){const m=a[f];if(!s.some(v=>v.indexOf(m)!==-1))throw new Error(`Output subscripts contain the label ${m} not present in the input subscripts.`);i.indexOf(m)===-1&&i.push(m)}for(let f=0;f<r.length;++f){const m=r[f];i.indexOf(m)===-1&&m!==yO&&i.push(m)}const u=new Array(s.length);for(let f=0;f<o;++f){if(new Set(s[f].split("")).size!==s[f].length)throw new Error(`Found duplicate axes in input component ${s[f]}. Support for duplicate axes in input is not implemented yet.`);u[f]=[];for(let m=0;m<s[f].length;++m)u[f].push(i.indexOf(s[f][m]))}const l=i.length,h=a.length,d=[];for(let f=h;f<l;++f)d.push(f);return{allDims:i,summedDims:d,idDims:u}}function CE(n,t){let e=new Array(n);e.fill(-1);for(let a=0;a<t.length;++a)e[t[a]]=a;const r=[];for(let a=0;a<n;++a)e[a]===-1&&r.push(a);return e=e.filter(a=>a!==-1),{permutationIndices:e,expandDims:r}}function NE(n,t,e){const r=new Array(n);for(let a=0;a<e.length;++a){const s=e[a].shape;for(let o=0;o<t[a].length;++o)r[t[a][o]]===void 0?r[t[a][o]]=s[o]:P(r[t[a][o]]===s[o],()=>`Expected dimension ${r[t[a][o]]} at axis ${o} of input shaped ${JSON.stringify(s)}, but got dimension ${s[o]}`)}}function kE(n,t){const e=n,r=[];let a=0;n.length===0&&e.push(-1),a=n.length+1;for(let o=0;o<a;++o)r.push([]);const s=[];for(let o=0;o<e.length;++o){const i=e[o],u=AZ(t,i);for(const l of u)s.indexOf(l)===-1&&(r[o].push(l),s.push(l))}return{path:e,steps:r}}function TE(n){return n.every((t,e)=>t===e)}function AZ(n,t){const e=[];for(let r=0;r<n.length;++r)(n[r].length===0||n[r].indexOf(t)!==-1||t===-1)&&e.push(r);return e}function EE(n,t,e=0){let r=[];if(typeof t=="number")P(n.shape[e]%t===0,()=>"Number of splits must evenly divide the axis."),r=new Array(t).fill(n.shape[e]/t);else{const a=t.reduce((o,i)=>(i===-1&&(o+=1),o),0);P(a<=1,()=>"There should be only one negative value in split array.");const s=t.indexOf(-1);if(s!==-1){const o=t.reduce((i,u)=>u>0?i+u:i);t[s]=n.shape[e]-o}P(n.shape[e]===t.reduce((o,i)=>o+i),()=>"The sum of sizes must match the size of the axis dimension."),r=t}return r}function Q4(n){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${n}`}function Z4(n,t){return`indices(${n}, 0) is invalid: ${t} < 0`}function J4(n,t,e){return`indices(${n}, 0) is invalid: ${t} >= ${e}`}function tB(n,t){return`only one output dimension may be -1, not both ${n} and ${t}`}function eB(n,t){return`size ${n} must be non-negative, not ${t}`}function nB(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function rB(n,t){const e=xt(n),r=xt(t);return`Input to reshape is a SparseTensor with ${e}
  dense values, but the requested shape requires a multiple of ${r}. inputShape=${n} outputShape= ${t}`}function aB(n,t){const e=xt(n),r=xt(t);return`Input to reshape is a tensor with ${e} dense values, but the requested shape has ${r}. inputShape=${n} outputShape=${t}`}function wN(){return"segment ids must be >= 0"}function sB(){return"segment ids are not increasing"}function oB(n,t){return`Segment id ${n} out of range [0, ${t}), possibly because segmentIds input is not sorted.`}function iB(n,t,e){return`Bad: indices[${n}] == ${t} out of range [0, ${e})`}function uB(n,t){let e=!1,r;for(n<=hE?(r=n,e=!0):r=O0(n,Math.floor(Math.sqrt(n)));!e;)r>t||r===n?e=!0:r=O0(n,r+1);return r}function lB(n,t,e){const r=[],a=n.length;for(let s=0;s<a;s++)s!==t?r.push(n[s]):r.push(e);return r}function IE(n,t,e,r){const a=t.shape.length,s=n.shape.length;if(r!==0&&(r<-a||r>a))throw new Error(`Expect batchDims in the range of [-${a}, ${a}], but got ${r}`);if(r<0&&(r+=a),r>s)throw new Error(`batchDims (${r}) must be less than rank(x) (
    ${s}).`);if(e<r)throw new Error(`batchDims (${r}) must be less than or equal to axis (${e}).`);for(let d=0;d<r;++d)if(n.shape[d]!==t.shape[d])throw new Error(`x.shape[${d}]: ${n.shape[d]} should be equal to indices.shape[${d}]: ${t.shape[d]}.`);const o=n.shape[e],i=[];let u=1,l=1,h=1;for(let d=0;d<r;++d)i.push(n.shape[d]),u*=n.shape[d];for(let d=r;d<e;d++)i.push(n.shape[d]),l*=n.shape[d];for(let d=r;d<a;d++)i.push(t.shape[d]);for(let d=e+1;d<s;d++)i.push(n.shape[d]),h*=n.shape[d];return{batchSize:u,sliceSize:h,outerSize:l,dimSize:o,outputShape:i}}const DZ=Object.freeze(Object.defineProperty({__proto__:null,collectGatherOpShapeInfo:IE,computeOutShape:lB,segOpComputeOptimalWindowSize:uB},Symbol.toStringTag,{value:"Module"}));function $i(n){try{return n.map(t=>Ii(t))}catch(t){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${t}`)}}function cB(n){return n.map(t=>$o(t))}const hB=Object.freeze(Object.defineProperty({__proto__:null,ERF_A1:gE,ERF_A2:vE,ERF_A3:yE,ERF_A4:bE,ERF_A5:xE,ERF_P:mE,PARALLELIZE_THRESHOLD:hE,get RowPartitionType(){return Qs},SELU_SCALE:R1,SELU_SCALEALPHA:_1,applyActivation:x1,assertAndGetBroadcastShape:me,assertAxesAreInnerMostDims:Pr,assertParamsConsistent:cE,assignToTypedArray:K4,axesAreInnerMostDims:mT,calculateShapes:nl,checkEinsumDimSizes:NE,checkPadOnDimRoundingMode:ma,combineLocations:IL,combineRaggedTensorToTensorShapes:V4,complexWithEvenIndex:j4,complexWithOddIndex:q4,computeConv2DInfo:Nr,computeConv3DInfo:Zu,computeDefaultPad:Zk,computeDilation2DInfo:kg,computeOptimalWindowSize:I1,computeOutAndReduceShapes:kr,computeOutShape:Fo,computePool2DInfo:Vs,computePool3DInfo:Mi,convertConv2DDataFormat:Li,decodeEinsumEquation:SE,eitherStridesOrDilationsAreOne:zr,expandShapeToKeepDim:Vn,exponent:Y4,exponents:X4,fromStringArrayToUint8:cB,fromUint8ToStringArray:$i,getAxesPermutation:An,getBroadcastDims:rc,getComplexWithIndex:wE,getEinsumComputePath:kE,getEinsumPermutation:CE,getFusedBiasGradient:b1,getFusedDyActivation:y1,getImageCenter:dE,getInnerMostAxes:Un,getPermuted:Hg,getRaggedRank:W4,getReductionAxes:Zn,getReshaped:Gg,getReshapedPermuted:jg,getRowPartitionTypesHelper:U4,getSliceBeginCoords:pE,getSliceSize:fE,getSparseFillEmptyRowsIndicesDenseShapeMismatch:Q4,getSparseFillEmptyRowsNegativeIndexErrorMessage:Z4,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:J4,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:nB,getSparseReshapeInputOutputMismatchErrorMessage:aB,getSparseReshapeInputOutputMultipleErrorMessage:rB,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:tB,getSparseReshapeNegativeOutputDimErrorMessage:eB,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:iB,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:wN,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:sB,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:oB,getUndoAxesPermutation:Ju,isIdentityPermutation:TE,log:Cq,mergeRealAndImagArrays:Di,prepareAndValidate:T1,prepareSplitSize:EE,segment_util:DZ,shouldFuse:w1,slice_util:z4,splitRealAndImagArrays:H4,stridesOrDilationsArePositive:nc,tupleValuesAreOne:zu,upcastType:Sa,validateDefaultValueShape:G4,validateInput:p1,validateUpdateShape:BT,warn:is},Symbol.toStringTag,{value:"Module"}));const $Z=Object.freeze(Object.defineProperty({__proto__:null,nonMaxSuppressionV3Impl:S1,nonMaxSuppressionV4Impl:C1,nonMaxSuppressionV5Impl:N1,whereImpl:g1},Symbol.toStringTag,{value:"Module"}));qQ();const _E=Object.freeze(Object.defineProperty({__proto__:null,Abs:xm,Acos:hd,Acosh:dd,AdadeltaOptimizer:KT,AdagradOptimizer:XT,AdamOptimizer:YT,AdamaxOptimizer:QT,Add:yc,AddN:wm,All:Fb,Any:Mb,ArgMax:Sm,ArgMin:Cm,Asin:pd,Asinh:fd,Atan:md,Atan2:vd,Atanh:gd,AvgPool:Nm,AvgPool3D:km,AvgPool3DGrad:Bb,AvgPoolGrad:Lb,BatchMatMul:Tm,BatchToSpaceND:Em,Bincount:zb,BitwiseAnd:Im,BroadcastArgs:Pb,BroadcastTo:jM,Cast:yd,Ceil:bd,ClipByValue:xd,Complex:Vb,ComplexAbs:_m,Concat:Rm,Conv2D:Am,Conv2DBackpropFilter:Ub,Conv2DBackpropInput:Dm,Conv3D:$m,Conv3DBackpropFilterV2:Wb,Conv3DBackpropInputV2:Gb,Cos:wd,Cosh:Sd,CropAndResize:jb,Cumprod:Hb,Cumsum:Om,DataStorage:Tk,DenseBincount:qb,DepthToSpace:Kb,DepthwiseConv2dNative:Fm,DepthwiseConv2dNativeBackpropFilter:Xb,DepthwiseConv2dNativeBackpropInput:Yb,Diag:Qb,Dilation2D:Mm,Dilation2DBackpropFilter:M0,Dilation2DBackpropInput:F0,Draw:Zb,get ENV(){return Ak},Einsum:Jb,Elu:Nd,EluGrad:tx,Environment:GM,Equal:Lm,Erf:kd,Exp:Td,ExpandDims:Bm,Expm1:Ed,FFT:ex,Fill:nx,FlipLeftRight:rx,Floor:Id,FloorDiv:_d,FromPixels:L0,FusedBatchNorm:zm,FusedConv2D:qf,FusedDepthwiseConv2D:Kf,GatherNd:ax,GatherV2:Pm,Greater:Vm,GreaterEqual:Rd,IFFT:sx,Identity:Ad,Imag:ox,IsFinite:Dd,IsInf:$d,IsNan:Od,KernelBackend:Db,LRN:Km,LRNGrad:ux,LeakyRelu:Um,Less:Wm,LessEqual:Gm,LinSpace:ix,Log:Fd,Log1p:Md,LogSoftmax:qM,LogicalAnd:Hm,LogicalNot:jm,LogicalOr:qm,LogicalXor:yq,LowerBound:bq,MatrixBandPart:xq,Max:Xm,MaxPool:Ym,MaxPool3D:Qm,MaxPool3DGrad:cx,MaxPoolGrad:lx,MaxPoolWithArgmax:hx,Maximum:Ld,Mean:Zm,Min:Jm,Minimum:Bd,MirrorPad:tg,Mod:zd,MomentumOptimizer:ZT,Multinomial:dx,Multiply:Pd,Neg:eg,NonMaxSuppressionV3:px,NonMaxSuppressionV4:fx,NonMaxSuppressionV5:mx,NotEqual:ng,OP_SCOPE_SUFFIX:Lk,OneHot:ag,OnesLike:rg,Optimizer:Vi,OptimizerConstructors:P4,Pack:sg,PadV2:og,Pool:wq,Pow:Vd,Prelu:ig,Prod:ug,RMSPropOptimizer:JT,RaggedGather:gx,RaggedRange:vx,RaggedTensorToTensor:yx,Range:bx,get Rank(){return aN},Real:xx,RealDiv:Cd,Reciprocal:Ud,get Reduction(){return ia},Relu:Wd,Relu6:Gd,Reshape:lg,ResizeBilinear:hg,ResizeBilinearGrad:Sx,ResizeNearestNeighbor:cg,ResizeNearestNeighborGrad:wx,Reverse:dg,RotateWithOffset:zx,Round:Hd,Rsqrt:jd,SGDOptimizer:k1,ScatterNd:Cx,SearchSorted:kx,Select:pg,Selu:qd,Sigmoid:Qd,Sign:Yd,Sin:Kd,Sinh:Xd,Slice:fg,Softmax:yg,Softplus:Zd,SpaceToBatchND:gg,SparseFillEmptyRows:Tx,SparseReshape:Ex,SparseSegmentMean:Ix,SparseSegmentSum:_x,SparseToDense:Rx,SplitV:vg,Sqrt:Jd,Square:Ax,SquaredDifference:tp,StaticRegexReplace:bg,Step:sp,StridedSlice:Dx,StringNGrams:$x,StringSplit:Ox,StringToHashBucketFast:Fx,Sub:ep,Sum:mg,Tan:np,Tanh:rp,Tensor:Ae,TensorBuffer:Yn,TensorScatterUpdate:Nx,Tile:ap,TopK:Mx,Transform:Lx,Transpose:ql,Unique:Bx,Unpack:xg,UnsortedSegmentSum:wg,UpperBound:Sq,Variable:Qf,ZerosLike:Sg,_FusedMatMul:jf,abs:Kn,acos:Gk,acosh:Hk,add:It,addN:wL,all:Gx,any:Jf,argMax:Bu,argMin:jk,asin:qk,asinh:Kk,atan:Xk,atan2:Yk,atanh:Qk,avgPool:Tg,avgPool3d:Jk,backend:Ux,backend_util:hB,basicLSTMCell:SL,batchNorm:op,batchNorm2d:tT,batchNorm3d:eT,batchNorm4d:nT,batchToSpaceND:Eg,bincount:rT,bitwiseAnd:CL,booleanMaskAsync:o4,broadcastArgs:NL,broadcastTo:Kl,broadcast_util:nX,browser:SZ,buffer:we,cast:Ft,ceil:aT,clipByValue:Na,clone:Oo,complex:_i,concat:_n,concat1d:sT,concat2d:Ig,concat3d:oT,concat4d:iT,conv1d:Hx,conv2d:Ri,conv2dTranspose:jx,conv3d:lT,conv3dTranspose:cT,copyRegisteredKernels:Tq,cos:_g,cosh:qx,cosineWindow:v1,cumprod:nm,cumsum:Kx,customGrad:Go,denseBincount:P0,deprecationWarn:s8,depthToSpace:hT,depthwiseConv2d:ip,device_util:Jq,diag:TL,dilation2d:dT,disableDeprecationWarnings:a8,dispose:Ie,disposeVariables:o8,div:Ut,divNoNan:pT,dot:fT,dropout:WT,einsum:Ll,elu:up,enableDebugMode:r8,enableProdMode:n8,enclosingPowerOfTwo:GT,engine:as,ensureShape:EL,env:dt,equal:Wa,erf:Xx,euclideanNorm:gT,exp:ka,expandDims:Pn,expm1:vT,eye:Yx,fft:Ug,fill:bc,findBackend:d8,findBackendFactory:p8,floor:cp,floorDiv:Wx,fused:m4,gather:hp,gatherND:c4,gather_util:CZ,getBackend:Bk,getGradient:nN,getKernel:Yf,getKernelsForBackend:B0,grad:zX,grads:PX,greater:ga,greaterEqual:Bi,ifft:td,imag:Rg,image:ha,inTopKAsync:h4,io:nE,irfft:h1,isFinite:yT,isInf:bT,isNaN:xT,keep:ar,kernel_impls:$Z,leakyRelu:Ag,less:Qh,lessEqual:tl,linalg:qT,linspace:RL,localResponseNormalization:wT,log:Ga,log1p:Dg,logSigmoid:ST,logSoftmax:Zx,logSumExp:$g,logicalAnd:ao,logicalNot:Og,logicalOr:Jx,logicalXor:CT,losses:S4,lowerBound:DL,matMul:xe,math:pZ,max:vs,maxPool:Fg,maxPool3d:NT,maxPoolWithArgmax:$L,maximum:Ko,mean:En,memory:cN,meshgrid:OL,min:Yh,minimum:Vu,mirrorPad:kT,mod:TT,moments:Mg,movingAverage:i4,mul:et,multiRNNCell:FL,multinomial:ML,neg:mn,nextFrame:lE,norm:lp,notEqual:ac,oneHot:sc,ones:xa,onesLike:Ha,op:tt,outerProduct:LL,pad:zi,pad1d:BL,pad2d:zL,pad3d:ET,pad4d:PL,pool:IT,pow:Wo,prelu:Bg,print:Wk,prod:_T,profile:i8,raggedGather:VL,raggedRange:UL,raggedTensorToTensor:WL,rand:GL,randomGamma:qL,randomNormal:n1,randomStandardNormal:KL,randomUniform:el,randomUniformInt:XL,range:Ai,ready:c8,real:Zh,reciprocal:$T,registerBackend:zk,registerGradient:KM,registerKernel:Px,relu:lo,relu6:r1,removeBackend:h8,reshape:at,reverse:bs,reverse1d:YL,reverse2d:QL,reverse3d:ZL,reverse4d:JL,rfft:Wg,round:a1,rsqrt:s1,scalar:Jt,scatterND:u4,scatter_util:G9,searchSorted:t1,selu:o1,separableConv2d:i1,serialization:HQ,setBackend:l8,setPlatform:f8,setdiff1dAsync:t4,sigmoid:Va,sign:OT,signal:w4,sin:u1,sinh:l1,slice:ue,slice1d:zg,slice2d:c1,slice3d:Pg,slice4d:Jh,slice_util:z4,softmax:Vg,softplus:xc,spaceToBatchND:Lg,sparse:C4,sparseToDense:l4,spectral:x4,split:wa,sqrt:wr,square:an,squaredDifference:d1,squeeze:$r,stack:Ta,step:wc,stridedSlice:FT,string:N4,sub:zt,sum:jt,sumOutType:Vx,tan:MT,tanh:Pu,tensor:gs,tensor1d:sr,tensor2d:Iu,tensor3d:LT,tensor4d:e4,tensor5d:n4,tensor6d:r4,tensorScatterUpdate:a4,tensor_util:Kq,test_util:r9,tidy:ut,tile:ls,time:u8,topk:zT,train:Dl,transpose:Oe,truncatedNormal:f1,unique:PT,unregisterGradient:kq,unregisterKernel:Nq,unsortedSegmentSum:m1,unstack:xs,upcastType:Sa,upperBound:s4,util:Fq,valueAndGrad:VX,valueAndGrads:UX,variable:VT,variableGrads:AL,version_core:IZ,where:Or,whereAsync:UT,zeros:Xn,zerosLike:Be},Symbol.toStringTag,{value:"Module"}));const OZ=dt();OZ.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,n=>{n&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});var Ma;(function(n){n[n.DT_INVALID=0]="DT_INVALID",n[n.DT_FLOAT=1]="DT_FLOAT",n[n.DT_DOUBLE=2]="DT_DOUBLE",n[n.DT_INT32=3]="DT_INT32",n[n.DT_UINT8=4]="DT_UINT8",n[n.DT_INT16=5]="DT_INT16",n[n.DT_INT8=6]="DT_INT8",n[n.DT_STRING=7]="DT_STRING",n[n.DT_COMPLEX64=8]="DT_COMPLEX64",n[n.DT_INT64=9]="DT_INT64",n[n.DT_BOOL=10]="DT_BOOL",n[n.DT_QINT8=11]="DT_QINT8",n[n.DT_QUINT8=12]="DT_QUINT8",n[n.DT_QINT32=13]="DT_QINT32",n[n.DT_BFLOAT16=14]="DT_BFLOAT16",n[n.DT_QINT16=15]="DT_QINT16",n[n.DT_QUINT16=16]="DT_QUINT16",n[n.DT_UINT16=17]="DT_UINT16",n[n.DT_COMPLEX128=18]="DT_COMPLEX128",n[n.DT_HALF=19]="DT_HALF",n[n.DT_RESOURCE=20]="DT_RESOURCE",n[n.DT_VARIANT=21]="DT_VARIANT",n[n.DT_UINT32=22]="DT_UINT32",n[n.DT_UINT64=23]="DT_UINT64",n[n.DT_FLOAT_REF=101]="DT_FLOAT_REF",n[n.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",n[n.DT_INT32_REF=103]="DT_INT32_REF",n[n.DT_UINT8_REF=104]="DT_UINT8_REF",n[n.DT_INT16_REF=105]="DT_INT16_REF",n[n.DT_INT8_REF=106]="DT_INT8_REF",n[n.DT_STRING_REF=107]="DT_STRING_REF",n[n.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",n[n.DT_INT64_REF=109]="DT_INT64_REF",n[n.DT_BOOL_REF=110]="DT_BOOL_REF",n[n.DT_QINT8_REF=111]="DT_QINT8_REF",n[n.DT_QUINT8_REF=112]="DT_QUINT8_REF",n[n.DT_QINT32_REF=113]="DT_QINT32_REF",n[n.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",n[n.DT_QINT16_REF=115]="DT_QINT16_REF",n[n.DT_QUINT16_REF=116]="DT_QUINT16_REF",n[n.DT_UINT16_REF=117]="DT_UINT16_REF",n[n.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",n[n.DT_HALF_REF=119]="DT_HALF_REF",n[n.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",n[n.DT_VARIANT_REF=121]="DT_VARIANT_REF",n[n.DT_UINT32_REF=122]="DT_UINT32_REF",n[n.DT_UINT64_REF=123]="DT_UINT64_REF"})(Ma||(Ma={}));var xO;(function(n){(function(t){t[t.LEGACY=0]="LEGACY",t[t.V1=1]="V1",t[t.V2=2]="V2"})(n.CheckpointFormatVersion||(n.CheckpointFormatVersion={}))})(xO||(xO={}));const RE={};function FZ(n,t){const e={tfOpName:n,category:"custom",inputs:[],attrs:[],customExecutor:t};RE[n]=e}function dB(n){return RE[n]}function MZ(n){delete RE[n]}function O(n,t,e,r,a){const s=t.inputParams[n];if(s&&s.inputIndexStart!==void 0){const i=s.inputIndexStart,u=s.inputIndexEnd===0?void 0:s.inputIndexEnd===void 0?i+1:s.inputIndexEnd,l=i<0?t.inputNames.length+i:i;if(s.type==="tensor")return Ar(t.inputNames[l],e,r,a);if(s.type==="tensors"){const f=t.inputs.slice(i,u);return t.inputNames.slice(i,u).filter((v,y)=>{var b;return((b=f[y])===null||b===void 0?void 0:b.op)!=="NoOp"}).map(v=>Ar(v,e,r,a))}const h=Ar(t.inputNames[l],e,r,a),d=h.dataSync();return s.type==="number"?d[0]:ms(h.shape,d)}const o=t.attrParams[n];return o&&o.value}function Ar(n,t,e,r){const[a,s]=La(n,e);if(r!=null){const i=r.getHashTableHandleByName(a);if(i!=null)return i}const o=e.currentContextIds.find(i=>!!t[U0(a,i)]);return o!==void 0?t[U0(a,o)][s]:void 0}function wO(n,t,e){return t[U0(n,e.currentContextId)]}function wi(n,t){const[e,r,a]=La(n,t);return[U0(e,t&&t.currentContextId),r,a]}function U0(n,t){return t?`${n}-${t}`:n}function La(n,t){if(n==="")return["",0,void 0];const e=t!=null&&t.parseNodeNameCache!=null;if(e){const s=t.parseNodeNameCache.get(n);if(s!=null)return s}const r=n.split(":");let a;if(r.length===1)a=[n,0,void 0];else{const s=r[0],o=r.length===3?r[1]:void 0,i=Number(r[r.length-1]);a=[s,i,o]}return e&&t.parseNodeNameCache.set(n,a),a}function T0(n,t,e){let r=O("pad",n,t,e);if(r==="explicit"){r=O("explicitPaddings",n,t,e);const a=[[0,0],[0,0],[0,0],[0,0]];for(let s=0;s<4;s++)a[s][0]=r[s*2],a[s][1]=r[s*2+1];return a}return r}function Si(n){return n.kept?n:Oo(n)}const LZ=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],BZ=Object.freeze(Object.defineProperty({__proto__:null,json:LZ},Symbol.toStringTag,{value:"Module"}));const zZ=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],PZ=Object.freeze(Object.defineProperty({__proto__:null,json:zZ},Symbol.toStringTag,{value:"Module"}));const VZ=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],UZ=Object.freeze(Object.defineProperty({__proto__:null,json:VZ},Symbol.toStringTag,{value:"Module"}));const WZ=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],GZ=Object.freeze(Object.defineProperty({__proto__:null,json:WZ},Symbol.toStringTag,{value:"Module"}));const HZ=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],jZ=Object.freeze(Object.defineProperty({__proto__:null,json:HZ},Symbol.toStringTag,{value:"Module"}));const qZ=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],KZ=Object.freeze(Object.defineProperty({__proto__:null,json:qZ},Symbol.toStringTag,{value:"Module"}));const XZ=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],YZ=Object.freeze(Object.defineProperty({__proto__:null,json:XZ},Symbol.toStringTag,{value:"Module"}));const QZ=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],ZZ=Object.freeze(Object.defineProperty({__proto__:null,json:QZ},Symbol.toStringTag,{value:"Module"}));const JZ=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],tJ=Object.freeze(Object.defineProperty({__proto__:null,json:JZ},Symbol.toStringTag,{value:"Module"}));const eJ=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],nJ=Object.freeze(Object.defineProperty({__proto__:null,json:eJ},Symbol.toStringTag,{value:"Module"}));const rJ=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}],aJ=Object.freeze(Object.defineProperty({__proto__:null,json:rJ},Symbol.toStringTag,{value:"Module"}));const sJ=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}],oJ=Object.freeze(Object.defineProperty({__proto__:null,json:sJ},Symbol.toStringTag,{value:"Module"}));const iJ=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}],uJ=Object.freeze(Object.defineProperty({__proto__:null,json:iJ},Symbol.toStringTag,{value:"Module"}));const lJ=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],cJ=Object.freeze(Object.defineProperty({__proto__:null,json:lJ},Symbol.toStringTag,{value:"Module"}));const hJ=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],dJ=Object.freeze(Object.defineProperty({__proto__:null,json:hJ},Symbol.toStringTag,{value:"Module"}));const pJ=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],fJ=Object.freeze(Object.defineProperty({__proto__:null,json:pJ},Symbol.toStringTag,{value:"Module"}));const mJ=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],gJ=Object.freeze(Object.defineProperty({__proto__:null,json:mJ},Symbol.toStringTag,{value:"Module"}));const vJ=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],yJ=Object.freeze(Object.defineProperty({__proto__:null,json:vJ},Symbol.toStringTag,{value:"Module"}));const bJ=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}],xJ=Object.freeze(Object.defineProperty({__proto__:null,json:bJ},Symbol.toStringTag,{value:"Module"}));class SO{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const t=[BZ,PZ,UZ,GZ,jZ,KZ,YZ,ZZ,tJ,nJ,aJ,oJ,uJ,cJ,dJ,fJ,gJ,yJ,xJ],e=[].concat(...t.map(r=>r.json));this.opMappers=e.reduce((r,a)=>(r[a.tfOpName]=a,r),{})}transformGraph(t,e={}){const r=t.node,a=[],s=[],o=[],i=r.reduce((y,b)=>(y[b.name]=this.mapNode(b),b.op.startsWith("Placeholder")?a.push(y[b.name]):b.op==="Const"?s.push(y[b.name]):(b.input==null||b.input.length===0)&&o.push(y[b.name]),y),{});let u=[];const l=[];let h={},d={};e!=null&&(h=this.mapSignatureEntries(e.inputs),d=this.mapSignatureEntries(e.outputs));const f=Object.keys(i);f.forEach(y=>{const b=i[y];b.inputNames.forEach((w,S)=>{const[N,,C]=wi(w),T=i[N];if(T.outputs!=null){const I=T.outputs.indexOf(C);if(I!==-1){const _=`${N}:${I}`;b.inputNames[S]=_}}b.inputs.push(T),T.children.push(b)})}),Object.keys(d).length===0?f.forEach(y=>{const b=i[y];b.children.length===0&&l.push(b)}):Object.keys(d).forEach(y=>{const[b]=wi(y),w=i[b];w!=null&&(w.signatureKey=d[y],l.push(w))}),Object.keys(h).length>0?Object.keys(h).forEach(y=>{const[b]=wi(y),w=i[b];w&&(w.signatureKey=h[y],u.push(w))}):u=a;let m={};t.library!=null&&t.library.function!=null&&(m=t.library.function.reduce((y,b)=>(y[b.signature.name]=this.mapFunction(b),y),{}));const v={nodes:i,inputs:u,outputs:l,weights:s,placeholders:a,signature:e,functions:m};return o.length>0&&(v.initNodes=o),v}mapSignatureEntries(t){return Object.keys(t||{}).reduce((e,r)=>(e[t[r].name]=r,e),{})}mapNode(t){const e=dB(t.op)||this.opMappers[t.op]||{};t.attr==null&&(t.attr={});const r={name:t.name,op:t.op,category:e.category,inputNames:(t.input||[]).map(a=>a.startsWith("^")?a.slice(1):a),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:t.attr,outputs:e.outputs};return e.inputs!=null&&(r.inputParams=e.inputs.reduce((a,s)=>(a[s.name]={type:s.type,inputIndexStart:s.start,inputIndexEnd:s.end},a),{})),e.attrs!=null&&(r.attrParams=e.attrs.reduce((a,s)=>{const o=s.type;let i;switch(s.type){case"string":i=SN(t.attr,s.tfName,s.defaultValue),i===void 0&&s.tfDeprecatedName&&(i=SN(t.attr,s.tfDeprecatedName,s.defaultValue));break;case"string[]":i=_N(t.attr,s.tfName,s.defaultValue),i===void 0&&s.tfDeprecatedName&&(i=_N(t.attr,s.tfDeprecatedName,s.defaultValue));break;case"number":i=NN(t.attr,s.tfName,s.defaultValue||0),i===void 0&&s.tfDeprecatedName&&(i=NN(t.attr,s.tfDeprecatedName,s.defaultValue));break;case"number[]":i=IN(t.attr,s.tfName,s.defaultValue),i===void 0&&s.tfDeprecatedName&&(i=IN(t.attr,s.tfDeprecatedName,s.defaultValue));break;case"bool":i=CN(t.attr,s.tfName,s.defaultValue),i===void 0&&s.tfDeprecatedName&&(i=CN(t.attr,s.tfDeprecatedName,s.defaultValue));break;case"bool[]":i=AN(t.attr,s.tfName,s.defaultValue),i===void 0&&s.tfDeprecatedName&&(i=AN(t.attr,s.tfDeprecatedName,s.defaultValue));break;case"shape":i=EN(t.attr,s.tfName,s.defaultValue),i===void 0&&s.tfDeprecatedName&&(i=EN(t.attr,s.tfDeprecatedName,s.defaultValue));break;case"shape[]":i=RN(t.attr,s.tfName,s.defaultValue),i===void 0&&s.tfDeprecatedName&&(i=RN(t.attr,s.tfDeprecatedName,s.defaultValue));break;case"dtype":i=kN(t.attr,s.tfName,s.defaultValue),i===void 0&&s.tfDeprecatedName&&(i=kN(t.attr,s.tfDeprecatedName,s.defaultValue));break;case"dtype[]":i=TN(t.attr,s.tfName,s.defaultValue),i===void 0&&s.tfDeprecatedName&&(i=TN(t.attr,s.tfDeprecatedName,s.defaultValue));break;case"func":i=CO(t.attr,s.tfName,s.defaultValue),i===void 0&&s.tfDeprecatedName&&(i=CO(t.attr,s.tfDeprecatedName,s.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${s.type} for op: ${t.op}`)}return a[s.name]={value:i,type:o},a},{})),r}mapFunction(t){const e=t.nodeDef,r=[],a=[];let s={};e!=null&&(s=e.reduce((d,f)=>(d[f.name]=this.mapNode(f),f.op==="Const"&&a.push(d[f.name]),d),{}));const o=[],i=[];t.signature.inputArg.forEach(d=>{const[f]=wi(d.name),m={name:f,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:AE(d.type),type:"dtype"}},children:[]};m.signatureKey=d.name,o.push(m),s[f]=m}),Object.keys(s).forEach(d=>{const f=s[d];f.inputNames.forEach((m,v)=>{const[y,,b]=wi(m),w=s[y];if(w.outputs!=null){const S=w.outputs.indexOf(b);if(S!==-1){const N=`${y}:${S}`;f.inputNames[v]=N}}f.inputs.push(w),w.children.push(f)})});const l=t.ret;t.signature.outputArg.forEach(d=>{const[f,m]=wi(l[d.name]),v=s[f];v!=null&&(v.defaultOutput=m,i.push(v))});const h=this.mapArgsToSignature(t);return{nodes:s,inputs:o,outputs:i,weights:a,placeholders:r,signature:h}}mapArgsToSignature(t){return{methodName:t.signature.name,inputs:t.signature.inputArg.reduce((e,r)=>(e[r.name]=this.mapArgToTensorInfo(r),e),{}),outputs:t.signature.outputArg.reduce((e,r)=>(e[r.name]=this.mapArgToTensorInfo(r,t.ret),e),{})}}mapArgToTensorInfo(t,e){let r=t.name;return e!=null&&(r=e[r]),{name:r,dtype:t.type}}}function wJ(n){const t=dt().global;if(typeof t.atob<"u")return t.atob(n);if(typeof Buffer<"u")return new Buffer(n,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function pB(n,t){const e=Array.isArray(n)?String.fromCharCode.apply(null,n):wJ(n);return t?e:e.toLowerCase()}function SN(n,t,e,r=!1){const a=n[t];return a!=null?pB(a.s,r):e}function CN(n,t,e){const r=n[t];return r?r.b:e}function NN(n,t,e){const r=n[t]||{},a=r.i!=null?r.i:r.f!=null?r.f:e;return typeof a=="number"?a:parseInt(a,10)}function AE(n){switch(typeof n=="string"&&(n=Ma[n]),n){case Ma.DT_FLOAT:case Ma.DT_HALF:return"float32";case Ma.DT_INT32:case Ma.DT_INT64:case Ma.DT_INT8:case Ma.DT_UINT8:return"int32";case Ma.DT_BOOL:return"bool";case Ma.DT_DOUBLE:return"float32";case Ma.DT_STRING:return"string";case Ma.DT_COMPLEX64:case Ma.DT_COMPLEX128:return"complex64";default:return null}}function CO(n,t,e){const r=n[t];return r&&r.func?r.func.name:e}function kN(n,t,e){const r=n[t];return r&&r.type?AE(r.type):e}function TN(n,t,e){const r=n[t];return r&&r.list&&r.list.type?r.list.type.map(a=>AE(a)):e}function fB(n){if(!n.unknownRank)return n.dim!=null?n.dim.map(t=>typeof t.size=="number"?t.size:parseInt(t.size,10)):[]}function EN(n,t,e){const r=n[t];return r&&r.shape?fB(r.shape):e}function IN(n,t,e){const r=n[t];return r?((r.list.f&&r.list.f.length?r.list.f:r.list.i)||[]).map(a=>typeof a=="number"?a:parseInt(a,10)):e}function _N(n,t,e,r=!1){const a=n[t];return a&&a.list&&a.list.s?a.list.s.map(s=>pB(s,r)):e}function RN(n,t,e){const r=n[t];return r&&r.list&&r.list.shape?r.list.shape.map(a=>fB(a)):e}function AN(n,t,e){const r=n[t];return r&&r.list&&r.list.b?r.list.b:e}class SJ{constructor(t,e,r){this.node=t,this.tensorMap=e,this.context=r,this.inputs=[],this.attrs={},this.inputs=t.inputNames.map(a=>this.getInput(a)),t.rawAttrs!=null&&(this.attrs=Object.keys(t.rawAttrs).reduce((a,s)=>(a[s]=this.getAttr(s),a),{}))}getInput(t){return Ar(t,this.tensorMap,this.context)}getAttr(t,e){const r=this.node.rawAttrs[t];if(r.tensor!=null)return Ar(t,this.tensorMap,this.context);if(r.i!=null||r.f!=null)return NN(this.node.rawAttrs,t,e);if(r.s!=null)return SN(this.node.rawAttrs,t,e);if(r.b!=null)return CN(this.node.rawAttrs,t,e);if(r.shape!=null)return EN(this.node.rawAttrs,t,e);if(r.type!=null)return kN(this.node.rawAttrs,t,e);if(r.list!=null){if(r.list.i!=null||r.list.f!=null)return IN(this.node.rawAttrs,t,e);if(r.list.s!=null)return _N(this.node.rawAttrs,t,e);if(r.list.shape!=null)return RN(this.node.rawAttrs,t,e);if(r.list.b!=null)return AN(this.node.rawAttrs,t,e);if(r.list.type!=null)return TN(this.node.rawAttrs,t,e)}return e}}const Vr=Object.freeze(Object.defineProperty({__proto__:null,OP_SCOPE_SUFFIX:Lk,abs:Kn,acos:Gk,acosh:Hk,add:It,addN:wL,all:Gx,any:Jf,argMax:Bu,argMin:jk,asin:qk,asinh:Kk,atan:Xk,atan2:Yk,atanh:Qk,avgPool:Tg,avgPool3d:Jk,basicLSTMCell:SL,batchNorm:op,batchNorm2d:tT,batchNorm3d:eT,batchNorm4d:nT,batchToSpaceND:Eg,bincount:rT,bitwiseAnd:CL,booleanMaskAsync:o4,broadcastArgs:NL,broadcastTo:Kl,buffer:we,cast:Ft,ceil:aT,clipByValue:Na,clone:Oo,complex:_i,concat:_n,concat1d:sT,concat2d:Ig,concat3d:oT,concat4d:iT,conv1d:Hx,conv2d:Ri,conv2dTranspose:jx,conv3d:lT,conv3dTranspose:cT,cos:_g,cosh:qx,cosineWindow:v1,cumprod:nm,cumsum:Kx,denseBincount:P0,depthToSpace:hT,depthwiseConv2d:ip,diag:TL,dilation2d:dT,div:Ut,divNoNan:pT,dot:fT,dropout:WT,einsum:Ll,elu:up,enclosingPowerOfTwo:GT,ensureShape:EL,equal:Wa,erf:Xx,euclideanNorm:gT,exp:ka,expandDims:Pn,expm1:vT,eye:Yx,fft:Ug,fill:bc,floor:cp,floorDiv:Wx,fused:m4,gather:hp,gatherND:c4,greater:ga,greaterEqual:Bi,ifft:td,imag:Rg,image:ha,inTopKAsync:h4,irfft:h1,isFinite:yT,isInf:bT,isNaN:xT,leakyRelu:Ag,less:Qh,lessEqual:tl,linalg:qT,linspace:RL,localResponseNormalization:wT,log:Ga,log1p:Dg,logSigmoid:ST,logSoftmax:Zx,logSumExp:$g,logicalAnd:ao,logicalNot:Og,logicalOr:Jx,logicalXor:CT,losses:S4,lowerBound:DL,matMul:xe,max:vs,maxPool:Fg,maxPool3d:NT,maxPoolWithArgmax:$L,maximum:Ko,mean:En,meshgrid:OL,min:Yh,minimum:Vu,mirrorPad:kT,mod:TT,moments:Mg,movingAverage:i4,mul:et,multiRNNCell:FL,multinomial:ML,neg:mn,norm:lp,notEqual:ac,oneHot:sc,ones:xa,onesLike:Ha,op:tt,outerProduct:LL,pad:zi,pad1d:BL,pad2d:zL,pad3d:ET,pad4d:PL,pool:IT,pow:Wo,prelu:Bg,print:Wk,prod:_T,raggedGather:VL,raggedRange:UL,raggedTensorToTensor:WL,rand:GL,randomGamma:qL,randomNormal:n1,randomStandardNormal:KL,randomUniform:el,randomUniformInt:XL,range:Ai,real:Zh,reciprocal:$T,relu:lo,relu6:r1,reshape:at,reverse:bs,reverse1d:YL,reverse2d:QL,reverse3d:ZL,reverse4d:JL,rfft:Wg,round:a1,rsqrt:s1,scalar:Jt,scatterND:u4,searchSorted:t1,selu:o1,separableConv2d:i1,setdiff1dAsync:t4,sigmoid:Va,sign:OT,signal:w4,sin:u1,sinh:l1,slice:ue,slice1d:zg,slice2d:c1,slice3d:Pg,slice4d:Jh,softmax:Vg,softplus:xc,spaceToBatchND:Lg,sparse:C4,sparseToDense:l4,spectral:x4,split:wa,sqrt:wr,square:an,squaredDifference:d1,squeeze:$r,stack:Ta,step:wc,stridedSlice:FT,string:N4,sub:zt,sum:jt,tan:MT,tanh:Pu,tensor:gs,tensor1d:sr,tensor2d:Iu,tensor3d:LT,tensor4d:e4,tensor5d:n4,tensor6d:r4,tensorScatterUpdate:a4,tile:ls,topk:zT,transpose:Oe,truncatedNormal:f1,unique:PT,unsortedSegmentSum:m1,unstack:xs,upperBound:s4,variable:VT,where:Or,whereAsync:UT,zeros:Xn,zerosLike:Be},Symbol.toStringTag,{value:"Module"}));const CJ=(n,t,e,r=Vr)=>{switch(n.op){case"BiasAdd":case"AddV2":case"Add":return[r.add(O("a",n,t,e),O("b",n,t,e))];case"AddN":return[r.addN(O("tensors",n,t,e))];case"FloorMod":case"Mod":return[r.mod(O("a",n,t,e),O("b",n,t,e))];case"Mul":return[r.mul(O("a",n,t,e),O("b",n,t,e))];case"RealDiv":case"Div":return[r.div(O("a",n,t,e),O("b",n,t,e))];case"DivNoNan":return[r.divNoNan(O("a",n,t,e),O("b",n,t,e))];case"FloorDiv":return[r.floorDiv(O("a",n,t,e),O("b",n,t,e))];case"Sub":return[r.sub(O("a",n,t,e),O("b",n,t,e))];case"Minimum":return[r.minimum(O("a",n,t,e),O("b",n,t,e))];case"Maximum":return[r.maximum(O("a",n,t,e),O("b",n,t,e))];case"Pow":return[r.pow(O("a",n,t,e),O("b",n,t,e))];case"SquaredDifference":return[r.squaredDifference(O("a",n,t,e),O("b",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};const NJ=(n,t,e,r=Vr)=>{switch(n.op){case"Abs":case"ComplexAbs":return[r.abs(O("x",n,t,e))];case"Acos":return[r.acos(O("x",n,t,e))];case"Acosh":return[r.acosh(O("x",n,t,e))];case"Asin":return[r.asin(O("x",n,t,e))];case"Asinh":return[r.asinh(O("x",n,t,e))];case"Atan":return[r.atan(O("x",n,t,e))];case"Atan2":return[r.atan2(O("x",n,t,e),O("y",n,t,e))];case"Atanh":return[r.atanh(O("x",n,t,e))];case"Ceil":return[r.ceil(O("x",n,t,e))];case"Complex":return[r.complex(O("real",n,t,e),O("imag",n,t,e))];case"Cos":return[r.cos(O("x",n,t,e))];case"Cosh":return[r.cosh(O("x",n,t,e))];case"Elu":return[r.elu(O("x",n,t,e))];case"Erf":return[r.erf(O("x",n,t,e))];case"Exp":return[r.exp(O("x",n,t,e))];case"Expm1":return[r.expm1(O("x",n,t,e))];case"Floor":return[r.floor(O("x",n,t,e))];case"Log":return[r.log(O("x",n,t,e))];case"Log1p":return[r.log1p(O("x",n,t,e))];case"Imag":return[r.imag(O("x",n,t,e))];case"Neg":return[r.neg(O("x",n,t,e))];case"Reciprocal":return[r.reciprocal(O("x",n,t,e))];case"Real":return[r.real(O("x",n,t,e))];case"Relu":return[r.relu(O("x",n,t,e))];case"Round":return[r.round(O("x",n,t,e))];case"Selu":return[r.selu(O("x",n,t,e))];case"Sigmoid":return[r.sigmoid(O("x",n,t,e))];case"Sin":return[r.sin(O("x",n,t,e))];case"Sign":return[r.sign(O("x",n,t,e))];case"Sinh":return[r.sinh(O("x",n,t,e))];case"Softplus":return[r.softplus(O("x",n,t,e))];case"Sqrt":return[r.sqrt(O("x",n,t,e))];case"Square":return[r.square(O("x",n,t,e))];case"Tanh":return[r.tanh(O("x",n,t,e))];case"Tan":return[r.tan(O("x",n,t,e))];case"ClipByValue":return[r.clipByValue(O("x",n,t,e),O("clipValueMin",n,t,e),O("clipValueMax",n,t,e))];case"Relu6":return[r.relu6(O("x",n,t,e))];case"Rsqrt":return[r.rsqrt(Ar(n.inputNames[0],t,e))];case"LeakyRelu":return[r.leakyRelu(O("x",n,t,e),O("alpha",n,t,e))];case"Prelu":return[r.prelu(O("x",n,t,e),O("alpha",n,t,e))];case"IsNan":return[r.isNaN(Ar(n.inputNames[0],t,e))];case"IsInf":return[r.isInf(Ar(n.inputNames[0],t,e))];case"IsFinite":return[r.isFinite(Ar(n.inputNames[0],t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};function Fs(n,t,e=""){if(!(typeof n=="number"||typeof t=="number")){P(n.length===t.length,()=>e+` Shapes ${n} and ${t} must match`);for(let r=0;r<n.length;r++){const a=n[r],s=t[r];P(a<0||s<0||a===s,()=>e+` Shapes ${n} and ${t} must match`)}}}function NO(n){return!(typeof n=="number"||n.some(t=>t<0))}function Cf(n,t,e){let r=DN(n,e);const a=!NO(r);if(a&&t.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${r}`);if(a&&t.forEach(s=>{r=DN(s.shape,r)}),!NO(r))throw new Error(`Non-fully-defined elementShape: ${r}`);return r}function DN(n,t){if(typeof n=="number")return t;if(typeof t=="number")return n;if(n.length!==t.length)throw new Error(`Incompatible ranks during merge: ${n} vs. ${t}`);const e=[];for(let r=0;r<n.length;++r){const a=n[r],s=t[r];if(a>=0&&s>=0&&a!==s)throw new Error(`Incompatible shape during merge: ${n} vs. ${t}`);e[r]=a>=0?a:s}return e}class kJ{constructor(t,e,r,a,s,o,i){this.name=t,this.dtype=e,this.maxSize=r,this.elementShape=a,this.identicalElementShapes=s,this.dynamicSize=o,this.clearAfterRead=i,this.tensors=[],this.closed_=!1,this.idTensor=Jt(0),ar(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(t){this.tensors.forEach(e=>{(t==null||!t.has(e.tensor.id))&&e.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(t<0||t>=this.size())throw new Error(`Tried to read from index ${t}, but array size is: ${this.size()}`);const e=this.tensors[t];if(e.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${t} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(e.cleared=!0),e.read=!0,e.tensor}readMany(t){return t.map(e=>this.read(e))}write(t,e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(t<0||!this.dynamicSize&&t>=this.maxSize)throw new Error(`Tried to write to index ${t}, but array is not resizeable and size is: ${this.maxSize}`);const r=this.tensors[t]||{};if(e.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t},
          because the value dtype is ${e.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=e.shape),Fs(this.elementShape,e.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${t}.`),r.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t}, because it has already been read.`);if(r.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t}, because it has already been written.`);r.tensor=e,ar(e),r.written=!0,this.tensors[t]=r}writeMany(t,e){if(t.length!==e.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${t.length} is not the same as tensors size: ${e.length}.`);t.forEach((r,a)=>this.write(r,e[a]))}gather(t,e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${e}`);if(t)t=t.slice(0,this.size());else{t=[];for(let a=0;a<this.size();a++)t.push(a)}if(t.length===0)return gs([],[0].concat(this.elementShape));const r=this.readMany(t);return Fs(this.elementShape,r[0].shape,"TensorArray shape mismatch: "),Ta(r,0)}concat(t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${t}`);if(this.size()===0)return gs([],[0].concat(this.elementShape));const e=[];for(let a=0;a<this.size();a++)e.push(a);const r=this.readMany(e);return Fs(this.elementShape,r[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${r[0].shape})`),_n(r,0)}scatter(t,e){if(e.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${e.dtype}`);if(t.length!==e.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${e.shape[0]}`);const r=Math.max(...t);if(!this.dynamicSize&&r>=this.maxSize)throw new Error(`Max index must be < array size (${r}  vs. ${this.maxSize})`);this.writeMany(t,xs(e,0))}split(t,e){if(e.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${e.dtype}`);let r=0;const a=t.map(u=>(r+=u,r));if(r!==e.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${r}, and tensor's shape is: ${e.shape}`);if(!this.dynamicSize&&t.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${t.length}), and the TensorArray is not marked as dynamically resizeable`);const s=r===0?0:e.size/r,o=[];ut(()=>{e=at(e,[1,r,s]);for(let u=0;u<t.length;++u){const h=[0,u===0?0:a[u-1],0],d=[1,t[u],s];o[u]=at(ue(e,h,d),this.elementShape)}return o});const i=[];for(let u=0;u<t.length;u++)i[u]=u;this.writeMany(i,o)}}class ic{get id(){return this.idTensor.id}constructor(t,e,r,a=-1){this.tensors=t,this.elementShape=e,this.elementDtype=r,t?.forEach(s=>{if(r!==s.dtype)throw new Error(`Invalid data types; op elements ${r}, but list elements ${s.dtype}`);Fs(e,s.shape,"TensorList shape mismatch: "),ar(s)}),this.idTensor=Jt(0),this.maxNumElements=a,ar(this.idTensor)}copy(){return new ic([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(t){this.tensors.forEach(e=>{(t==null||!t.has(e.id))&&e.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(t,e,r=-1){if(e!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e}, but list elements ${this.elementDtype}`);if(r!==-1&&this.tensors.length!==r)throw new Error(`Operation expected a list with ${r} elements but got a list with ${this.tensors.length} elements.`);Fs(t,this.elementShape,"TensorList shape mismatch: ");const a=Cf(this.elementShape,this.tensors,t);return ut(()=>{const s=this.tensors.map(o=>at(o,a));return Ta(s,0)})}popBack(t,e){if(e!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error("Trying to pop from an empty list.");const r=Cf(this.elementShape,this.tensors,t),a=this.tensors.pop();return a.kept=!1,Fs(a.shape,t,"TensorList shape mismatch: "),at(a,r)}pushBack(t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(Fs(t.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");ar(t),this.tensors.push(t)}resize(t){if(t<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${t}`);if(this.maxNumElements!==-1&&t>this.maxNumElements)throw new Error(`TensorListResize input size ${t} is greater maxNumElement ${this.maxNumElements}.`);const e=new ic([],this.elementShape,this.elementDtype,this.maxNumElements);e.tensors.length=t;for(let r=0;r<Math.min(this.tensors.length,t);++r)e.tensors[r]=this.tensors[r];return e}getItem(t,e,r){if(r!==this.elementDtype)throw new Error(`Invalid data types; op elements ${r}, but list elements ${this.elementDtype}`);if(t<0||t>this.tensors.length)throw new Error(`Trying to access element ${t} in a list with ${this.tensors.length} elements.`);if(this.tensors[t]==null)throw new Error(`element at index ${t} is null.`);Fs(this.tensors[t].shape,e,"TensorList shape mismatch: ");const a=Cf(this.elementShape,this.tensors,e);return at(this.tensors[t],a)}setItem(t,e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(t<0||this.maxNumElements!==-1&&t>=this.maxNumElements)throw new Error(`Trying to set element ${t} in a list with max ${this.maxNumElements} elements.`);Fs(this.elementShape,e.shape,"TensorList shape mismatch: "),ar(e),this.tensors[t]!=null&&(this.tensors[t].kept=!1),this.tensors[t]=e}gather(t,e,r){if(e!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e}, but list elements ${this.elementDtype}`);Fs(this.elementShape,r,"TensorList shape mismatch: "),t=t.slice(0,this.size());const a=Cf(this.elementShape,this.tensors,r);return t.length===0?gs([],[0].concat(a)):ut(()=>{const s=t.map(o=>at(this.tensors[o],a));return Ta(s,0)})}concat(t,e){if(t&&t!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${t}`);Fs(this.elementShape,e,"TensorList shape mismatch: ");const r=Cf(this.elementShape,this.tensors,e);return this.size()===0?gs([],[0].concat(r)):ut(()=>{const a=this.tensors.map(s=>at(s,r));return _n(a,0)})}}function TJ(n,t,e){const r=n.dtype;if(n.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${n.shape}`);if(n.dtype!==e)throw new Error(`Invalid data types; op elements ${n.dtype}, but list elements ${e}`);const a=n.shape.slice(1);Fs(a,t,"TensorList shape mismatch: ");const s=xs(n);return new ic(s,t,r)}function EJ(n,t,e,r){return new ic([],n,t,r)}function IJ(n,t,e,r){if(t.length!==n.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${n.shape[0]}`);const a=Math.max(...t);if(r!=null&&r!==-1&&a>=r)throw new Error(`Max index must be < array size (${a}  vs. ${r})`);const s=new ic([],e,n.dtype,r),o=xs(n,0);return t.forEach((i,u)=>{s.setItem(i,o[u])}),s}function _J(n,t,e){let r=0;const a=t.map(h=>(r+=h,r));if(r!==n.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${r}, and tensor's shape is: ${n.shape}`);const s=n.shape.slice(1),o=DN(s,e),i=r===0?0:n.size/r,u=ut(()=>{const h=[];n=at(n,[1,r,i]);for(let d=0;d<t.length;++d){const m=[0,d===0?0:a[d-1],0],v=[1,t[d],i];h[d]=at(ue(n,m,v),o)}return n.dispose(),h}),l=new ic([],e,n.dtype,t.length);for(let h=0;h<u.length;h++)l.setItem(h,u[h]);return l}const RJ=async(n,t,e)=>{switch(n.op){case"If":case"StatelessIf":{const r=O("thenBranch",n,t,e),a=O("elseBranch",n,t,e),s=O("cond",n,t,e),o=O("args",n,t,e);return(await s.data())[0]?e.functionMap[r].executeFunctionAsync(o,e.tensorArrayMap,e.tensorListMap):e.functionMap[a].executeFunctionAsync(o,e.tensorArrayMap,e.tensorListMap)}case"While":case"StatelessWhile":{const r=O("body",n,t,e),a=O("cond",n,t,e),s=O("args",n,t,e),o=await e.functionMap[a].executeFunctionAsync(s,e.tensorArrayMap,e.tensorListMap),i=s.map(h=>h.id);let u=await o[0].data();o.forEach(h=>{!h.kept&&i.indexOf(h.id)===-1&&h.dispose()});let l=s;for(;u[0];){const h=l;l=await e.functionMap[r].executeFunctionAsync(l,e.tensorArrayMap,e.tensorListMap);const d=l.map(m=>m.id);h.forEach(m=>{!m.kept&&i.indexOf(m.id)===-1&&d.indexOf(m.id)===-1&&m.dispose()});const f=await e.functionMap[a].executeFunctionAsync(l,e.tensorArrayMap,e.tensorListMap);u=await f[0].data(),f.forEach(m=>{!m.kept&&i.indexOf(m.id)===-1&&d.indexOf(m.id)===-1&&m.dispose()})}return l}case"LoopCond":{const r=O("pred",n,t,e);return[Si(r)]}case"Switch":{const r=O("pred",n,t,e);let a=O("data",n,t,e);return a.kept||(a=Si(a)),(await r.data())[0]?[void 0,a]:[a,void 0]}case"Merge":{const r=n.inputNames.find(a=>Ar(a,t,e)!==void 0);if(r){const a=Ar(r,t,e);return[Si(a)]}return}case"Enter":{const r=O("frameName",n,t,e),a=O("tensor",n,t,e);return e.enterFrame(r),[Si(a)]}case"Exit":{const r=O("tensor",n,t,e);return e.exitFrame(),[Si(r)]}case"NextIteration":{const r=O("tensor",n,t,e);return e.nextIteration(),[Si(r)]}case"TensorArrayV3":{const r=O("size",n,t,e),a=O("dtype",n,t,e),s=O("elementShape",n,t,e),o=O("dynamicSize",n,t,e),i=O("clearAfterRead",n,t,e),u=O("identicalElementShapes",n,t,e),l=O("name",n,t,e),h=new kJ(l,a,r,s,u,o,i);return e.addTensorArray(h),[h.idTensor,Jt(1)]}case"TensorArrayWriteV3":{const r=O("tensorArrayId",n,t,e),a=O("index",n,t,e),s=O("tensor",n,t,e),o=e.getTensorArray(r.id);return o.write(a,s),[o.idTensor]}case"TensorArrayReadV3":{const r=O("tensorArrayId",n,t,e),a=O("index",n,t,e);return[e.getTensorArray(r.id).read(a)]}case"TensorArrayGatherV3":{const r=O("tensorArrayId",n,t,e),a=O("indices",n,t,e),s=O("dtype",n,t,e);return[e.getTensorArray(r.id).gather(a,s)]}case"TensorArrayScatterV3":{const r=O("tensorArrayId",n,t,e),a=O("indices",n,t,e),s=O("tensor",n,t,e),o=e.getTensorArray(r.id);return o.scatter(a,s),[o.idTensor]}case"TensorArrayConcatV3":{const r=O("tensorArrayId",n,t,e),a=e.getTensorArray(r.id),s=O("dtype",n,t,e);return[a.concat(s)]}case"TensorArraySplitV3":{const r=O("tensorArrayId",n,t,e),a=O("tensor",n,t,e),s=O("lengths",n,t,e),o=e.getTensorArray(r.id);return o.split(s,a),[o.idTensor]}case"TensorArraySizeV3":{const r=O("tensorArrayId",n,t,e),a=e.getTensorArray(r.id);return[Jt(a.size(),"int32")]}case"TensorArrayCloseV3":{const r=O("tensorArrayId",n,t,e),a=e.getTensorArray(r.id);return a.clearAndClose(),[a.idTensor]}case"TensorListSetItem":{const r=O("tensorListId",n,t,e),a=O("index",n,t,e),s=O("tensor",n,t,e),o=e.getTensorList(r.id);return o.setItem(a,s),[o.idTensor]}case"TensorListGetItem":{const r=O("tensorListId",n,t,e),a=O("index",n,t,e),s=O("elementShape",n,t,e),o=O("elementDType",n,t,e);return[e.getTensorList(r.id).getItem(a,s,o)]}case"TensorListScatterV2":case"TensorListScatter":{const r=O("indices",n,t,e),a=O("tensor",n,t,e),s=O("elementShape",n,t,e),o=O("numElements",n,t,e),i=IJ(a,r,s,o);return e.addTensorList(i),[i.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const r=O("elementShape",n,t,e),a=O("elementDType",n,t,e);let s;n.op==="TensorListReserve"?s="numElements":s="maxNumElements";const o=O(s,n,t,e),i=n.op==="TensorListReserve"?-1:o,u=EJ(r,a,o,i);return e.addTensorList(u),[u.idTensor]}case"TensorListGather":{const r=O("tensorListId",n,t,e),a=O("indices",n,t,e),s=O("elementShape",n,t,e),o=O("elementDType",n,t,e);return[e.getTensorList(r.id).gather(a,o,s)]}case"TensorListStack":{const r=O("tensorListId",n,t,e),a=O("elementShape",n,t,e),s=O("elementDType",n,t,e),o=O("numElements",n,t,e);return[e.getTensorList(r.id).stack(a,s,o)]}case"TensorListFromTensor":{const r=O("tensor",n,t,e),a=O("elementShape",n,t,e),s=O("elementDType",n,t,e),o=TJ(r,a,s);return e.addTensorList(o),[o.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const r=O("tensorListId",n,t,e),a=e.getTensorList(r.id),s=O("dtype",n,t,e),o=O("elementShape",n,t,e);return[a.concat(s,o)]}case"TensorListPushBack":{const r=O("tensorListId",n,t,e),a=O("tensor",n,t,e),s=e.getTensorList(r.id);return s.pushBack(a),[s.idTensor]}case"TensorListPopBack":{const r=O("tensorListId",n,t,e),a=O("elementShape",n,t,e),s=O("elementDType",n,t,e);return[e.getTensorList(r.id).popBack(a,s)]}case"TensorListSplit":{const r=O("tensor",n,t,e),a=O("elementShape",n,t,e),s=O("lengths",n,t,e),o=_J(r,s,a);return e.addTensorList(o),[o.idTensor]}case"TensorListLength":{const r=O("tensorListId",n,t,e),a=e.getTensorList(r.id);return[Jt(a.size(),"int32")]}case"TensorListResize":{const r=O("tensorListId",n,t,e),a=O("size",n,t,e),o=e.getTensorList(r.id).resize(a);return e.addTensorList(o),[o.idTensor]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};function kO(n,t,e){const[r,a]=O("fusedOps",n,t,e),s=r==="biasadd",o=!s,i=a==="prelu",u=r==="fusedbatchnorm",l=O("numArgs",n,t,e);if(s){if(i&&l!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!i&&s&&l!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(u)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const h=O("strides",n,t,e),d=T0(n,t,e),f=O("dataFormat",n,t,e).toUpperCase(),m=O("dilations",n,t,e);let[v,y]=O("args",n,t,e);o&&(y=v,v=void 0);const b=O("leakyreluAlpha",n,t,e);return{stride:h,pad:d,dataFormat:f,dilations:m,biasArg:v,preluArg:y,activationFunc:a,leakyreluAlpha:b}}const AJ=(n,t,e,r=Vr)=>{switch(n.op){case"Conv1D":{const a=O("stride",n,t,e),s=O("pad",n,t,e),o=O("dataFormat",n,t,e).toUpperCase(),i=O("dilation",n,t,e);return[r.conv1d(O("x",n,t,e),O("filter",n,t,e),a,s,o,i)]}case"Conv2D":{const a=O("strides",n,t,e),s=T0(n,t,e),o=O("dataFormat",n,t,e).toUpperCase(),i=O("dilations",n,t,e);return[r.conv2d(O("x",n,t,e),O("filter",n,t,e),[a[1],a[2]],s,o,[i[1],i[2]])]}case"_FusedConv2D":{const{stride:a,pad:s,dataFormat:o,dilations:i,biasArg:u,preluArg:l,activationFunc:h,leakyreluAlpha:d}=kO(n,t,e);return[r.fused.conv2d({x:O("x",n,t,e),filter:O("filter",n,t,e),strides:[a[1],a[2]],pad:s,dataFormat:o,dilations:[i[1],i[2]],bias:u,activation:h,preluActivationWeights:l,leakyreluAlpha:d})]}case"FusedDepthwiseConv2dNative":{const{stride:a,pad:s,dataFormat:o,dilations:i,biasArg:u,preluArg:l,activationFunc:h,leakyreluAlpha:d}=kO(n,t,e);return[r.fused.depthwiseConv2d({x:O("x",n,t,e),filter:O("filter",n,t,e),strides:[a[1],a[2]],pad:s,dataFormat:o,dilations:[i[1],i[2]],bias:u,activation:h,preluActivationWeights:l,leakyreluAlpha:d})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const a=O("outputShape",n,t,e),s=O("strides",n,t,e),o=T0(n,t,e);return[r.conv2dTranspose(O("x",n,t,e),O("filter",n,t,e),a,[s[1],s[2]],o)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const a=O("strides",n,t,e),s=T0(n,t,e),o=O("dilations",n,t,e),i=O("dataFormat",n,t,e).toUpperCase();return[r.depthwiseConv2d(O("input",n,t,e),O("filter",n,t,e),[a[1],a[2]],s,i,[o[1],o[2]])]}case"Conv3D":{const a=O("strides",n,t,e),s=O("pad",n,t,e),o=O("dataFormat",n,t,e).toUpperCase(),i=O("dilations",n,t,e);return[r.conv3d(O("x",n,t,e),O("filter",n,t,e),[a[1],a[2],a[3]],s,o,[i[1],i[2],i[3]])]}case"AvgPool":{const a=O("strides",n,t,e),s=O("pad",n,t,e),o=O("kernelSize",n,t,e);return[r.avgPool(O("x",n,t,e),[o[1],o[2]],[a[1],a[2]],s)]}case"MaxPool":{const a=O("strides",n,t,e),s=O("pad",n,t,e),o=O("kernelSize",n,t,e);return[r.maxPool(O("x",n,t,e),[o[1],o[2]],[a[1],a[2]],s)]}case"MaxPoolWithArgmax":{const a=O("strides",n,t,e),s=O("pad",n,t,e),o=O("kernelSize",n,t,e),i=O("includeBatchInIndex",n,t,e),{result:u,indexes:l}=r.maxPoolWithArgmax(O("x",n,t,e),[o[1],o[2]],[a[1],a[2]],s,i);return[u,l]}case"AvgPool3D":{const a=O("strides",n,t,e),s=O("pad",n,t,e),o=O("kernelSize",n,t,e);return[r.avgPool3d(O("x",n,t,e),[o[1],o[2],o[3]],[a[1],a[2],a[3]],s)]}case"MaxPool3D":{const a=O("strides",n,t,e),s=O("pad",n,t,e),o=O("kernelSize",n,t,e);return[r.maxPool3d(O("x",n,t,e),[o[1],o[2],o[3]],[a[1],a[2],a[3]],s)]}case"Dilation2D":{const a=O("strides",n,t,e),s=O("pad",n,t,e),o=O("dilations",n,t,e),i=a[1],u=a[2],l=o[1],h=o[2];return[r.dilation2d(O("x",n,t,e),O("filter",n,t,e),[i,u],s,[l,h],"NHWC")]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};const DJ=(n,t,e,r=Vr)=>{switch(n.op){case"Fill":{const a=O("shape",n,t,e),s=O("dtype",n,t,e),o=O("value",n,t,e);return[r.fill(a,o,s)]}case"LinSpace":{const a=O("start",n,t,e),s=O("stop",n,t,e),o=O("num",n,t,e);return[r.linspace(a,s,o)]}case"Multinomial":{const a=O("logits",n,t,e),s=O("numSamples",n,t,e),o=O("seed",n,t,e);return[r.multinomial(a,s,o)]}case"OneHot":{const a=O("indices",n,t,e),s=O("depth",n,t,e),o=O("onValue",n,t,e),i=O("offValue",n,t,e),u=O("dtype",n,t,e);return[r.oneHot(a,s,o,i,u)]}case"Ones":return[r.ones(O("shape",n,t,e),O("dtype",n,t,e))];case"OnesLike":return[r.onesLike(O("x",n,t,e))];case"RandomStandardNormal":return[r.randomStandardNormal(O("shape",n,t,e),O("dtype",n,t,e),O("seed",n,t,e))];case"RandomUniform":return[r.randomUniform(O("shape",n,t,e),O("minval",n,t,e),O("maxval",n,t,e),O("dtype",n,t,e))];case"RandomUniformInt":return[r.randomUniformInt(O("shape",n,t,e),O("minval",n,t,e),O("maxval",n,t,e),O("seed",n,t,e))];case"Range":{const a=O("start",n,t,e),s=O("stop",n,t,e),o=O("step",n,t,e);return[r.range(a,s,o,O("dtype",n,t,e))]}case"TruncatedNormal":{const a=O("shape",n,t,e),s=O("mean",n,t,e),o=O("stdDev",n,t,e),i=O("seed",n,t,e);return[r.truncatedNormal(a,s,o,O("dtype",n,t,e),i)]}case"Zeros":return[r.zeros(O("shape",n,t,e),O("dtype",n,t,e))];case"ZerosLike":return[r.zerosLike(O("x",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};function VS(n,t,e){const r=O("boxes",n,t,e),a=O("scores",n,t,e),s=O("maxOutputSize",n,t,e),o=O("iouThreshold",n,t,e),i=O("scoreThreshold",n,t,e),u=O("softNmsSigma",n,t,e);return{boxes:r,scores:a,maxOutputSize:s,iouThreshold:o,scoreThreshold:i,softNmsSigma:u}}const $J=async(n,t,e,r,a=Vr)=>{switch(n.op){case"NonMaxSuppressionV5":{const{boxes:s,scores:o,maxOutputSize:i,iouThreshold:u,scoreThreshold:l,softNmsSigma:h}=VS(n,t,e),d=await a.image.nonMaxSuppressionWithScoreAsync(s,o,i,u,l,h);return[d.selectedIndices,d.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:s,scores:o,maxOutputSize:i,iouThreshold:u,scoreThreshold:l}=VS(n,t,e),h=O("padToMaxOutputSize",n,t,e),d=await a.image.nonMaxSuppressionPaddedAsync(s,o,i,u,l,h);return[d.selectedIndices,d.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:s,scores:o,maxOutputSize:i,iouThreshold:u,scoreThreshold:l}=VS(n,t,e);return[await a.image.nonMaxSuppressionAsync(s,o,i,u,l)]}case"Where":{const s=a.cast(O("condition",n,t,e),"bool"),o=[await a.whereAsync(s)];return s.dispose(),o}case"ListDiff":return a.setdiff1dAsync(O("x",n,t,e),O("y",n,t,e));default:throw TypeError(`Node type ${n.op} is not implemented`)}};const OJ=(n,t,e,r=Vr)=>{switch(n.op){case"LowerBound":{const a=O("sortedSequence",n,t,e),s=O("values",n,t,e);return[r.lowerBound(a,s)]}case"TopKV2":{const a=O("x",n,t,e),s=O("k",n,t,e),o=O("sorted",n,t,e),i=r.topk(a,s,o);return[i.values,i.indices]}case"UpperBound":{const a=O("sortedSequence",n,t,e),s=O("values",n,t,e);return[r.upperBound(a,s)]}case"Unique":{const a=O("x",n,t,e),s=r.unique(a);return[s.values,s.indices]}case"UniqueV2":{const a=O("x",n,t,e),s=O("axis",n,t,e),o=r.unique(a,s);return[o.values,o.indices]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};const FJ=(n,t,e,r=Vr)=>{switch(n.op){case"Const":return t[n.name];case"PlaceholderWithDefault":const a=O("default",n,t,e);return[Ar(n.name,t,e)||a];case"Placeholder":return[Ar(n.name,t,e)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{const h=O("x",n,t,e);return[Si(h)]}case"IdentityN":return O("x",n,t,e).map(h=>Si(h));case"Snapshot":const s=O("x",n,t,e);return[Si(s)];case"Shape":return[r.tensor1d(O("x",n,t,e).shape,"int32")];case"ShapeN":return O("x",n,t,e).map(h=>r.tensor1d(h.shape));case"Size":return[r.scalar(O("x",n,t,e).size,"int32")];case"Rank":return[r.scalar(O("x",n,t,e).rank,"int32")];case"NoOp":return[r.scalar(1)];case"Print":const o=O("x",n,t,e),i=O("data",n,t,e),u=O("message",n,t,e),l=O("summarize",n,t,e);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(u);for(let h=0;h<i.length;h++)console.log(Array.prototype.slice.call(i[h].dataSync()).slice(0,l));return[o];default:throw TypeError(`Node type ${n.op} is not implemented`)}};class MJ{get id(){return this.handle.id}constructor(t,e){this.keyDType=t,this.valueDType=e,this.handle=Jt(0),this.tensorMap=new Map,ar(this.handle)}clearAndClose(){this.tensorMap.forEach(t=>t.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return Jt(this.size(),"int32")}async import(t,e){this.checkKeyAndValueTensor(t,e);const r=await t.data();return this.tensorMap.forEach(a=>a.dispose()),this.tensorMap.clear(),ut(()=>{const a=xs(e),s=r.length,o=a.length;P(s===o,()=>`The number of elements doesn't match, keys has ${s} elements, the values has ${o} elements.`);for(let i=0;i<s;i++){const u=r[i],l=a[i];ar(l),this.tensorMap.set(u,l)}return this.handle})}async find(t,e){this.checkKeyAndValueTensor(t,e);const r=await t.data();return ut(()=>{const a=[];for(let s=0;s<r.length;s++){const o=r[s],i=this.findWithDefault(o,e);a.push(i)}return Ta(a)})}findWithDefault(t,e){const r=this.tensorMap.get(t);return r??e}checkKeyAndValueTensor(t,e){if(t.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${t.dtype}`);if(e.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${e.dtype}`)}}const LJ=async(n,t,e,r)=>{switch(n.op){case"HashTable":case"HashTableV2":{const a=r.getHashTableHandleByName(n.name);if(a!=null)return[a];{const s=O("keyDType",n,t,e),o=O("valueDType",n,t,e),i=new MJ(s,o);return r.addHashTable(n.name,i),[i.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{const a=O("tableHandle",n,t,e,r),s=O("keys",n,t,e),o=O("values",n,t,e);return[await r.getHashTableById(a.id).import(s,o)]}case"LookupTableFind":case"LookupTableFindV2":{const a=O("tableHandle",n,t,e,r),s=O("keys",n,t,e),o=O("defaultValue",n,t,e);return[await r.getHashTableById(a.id).find(s,o)]}case"LookupTableSize":case"LookupTableSizeV2":{const a=O("tableHandle",n,t,e,r);return[r.getHashTableById(a.id).tensorSize()]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};const BJ=(n,t,e,r=Vr)=>{switch(n.op){case"ResizeBilinear":{const a=O("images",n,t,e),s=O("size",n,t,e),o=O("alignCorners",n,t,e),i=O("halfPixelCenters",n,t,e);return[r.image.resizeBilinear(a,[s[0],s[1]],o,i)]}case"ResizeNearestNeighbor":{const a=O("images",n,t,e),s=O("size",n,t,e),o=O("alignCorners",n,t,e),i=O("halfPixelCenters",n,t,e);return[r.image.resizeNearestNeighbor(a,[s[0],s[1]],o,i)]}case"CropAndResize":{const a=O("image",n,t,e),s=O("boxes",n,t,e),o=O("boxInd",n,t,e),i=O("cropSize",n,t,e),u=O("method",n,t,e),l=O("extrapolationValue",n,t,e);return[r.image.cropAndResize(a,s,o,i,u,l)]}case"ImageProjectiveTransformV3":{const a=O("images",n,t,e),s=O("transforms",n,t,e),o=O("outputShape",n,t,e),i=O("fillValue",n,t,e),u=O("interpolation",n,t,e),l=O("fillMode",n,t,e);return[r.image.transform(a,s,u.toLowerCase(),l.toLowerCase(),i,o)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};const zJ=(n,t,e,r=Vr)=>{switch(n.op){case"Equal":return[r.equal(O("a",n,t,e),O("b",n,t,e))];case"NotEqual":return[r.notEqual(O("a",n,t,e),O("b",n,t,e))];case"Greater":return[r.greater(O("a",n,t,e),O("b",n,t,e))];case"GreaterEqual":return[r.greaterEqual(O("a",n,t,e),O("b",n,t,e))];case"Less":return[r.less(O("a",n,t,e),O("b",n,t,e))];case"LessEqual":return[r.lessEqual(O("a",n,t,e),O("b",n,t,e))];case"LogicalAnd":return[r.logicalAnd(O("a",n,t,e),O("b",n,t,e))];case"LogicalNot":return[r.logicalNot(O("a",n,t,e))];case"LogicalOr":return[r.logicalOr(O("a",n,t,e),O("b",n,t,e))];case"Select":case"SelectV2":return[r.where(O("condition",n,t,e),O("a",n,t,e),O("b",n,t,e))];case"BitwiseAnd":return[r.bitwiseAnd(O("a",n,t,e),O("b",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};const PJ=(n,t,e,r=Vr)=>{switch(n.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[r.matMul(O("a",n,t,e),O("b",n,t,e),O("transposeA",n,t,e),O("transposeB",n,t,e))];case"Einsum":return[r.einsum(O("equation",n,t,e),...O("tensors",n,t,e))];case"Transpose":return[r.transpose(O("x",n,t,e),O("perm",n,t,e))];case"_FusedMatMul":const[a,s]=O("fusedOps",n,t,e),o=a==="biasadd",i=s==="prelu",u=O("numArgs",n,t,e),l=O("leakyreluAlpha",n,t,e);if(o){if(i&&u!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!i&&u!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[h,d]=O("args",n,t,e);return[r.fused.matMul({a:O("a",n,t,e),b:O("b",n,t,e),transposeA:O("transposeA",n,t,e),transposeB:O("transposeB",n,t,e),bias:h,activation:s,preluActivationWeights:d,leakyreluAlpha:l})];case"MatrixBandPart":return[r.linalg.bandPart(O("a",n,t,e),O("numLower",n,t,e),O("numUpper",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};const VJ=(n,t,e,r=Vr)=>{switch(n.op){case"EuclideanNorm":return[r.euclideanNorm(O("x",n,t,e),O("axis",n,t,e),O("keepDims",n,t,e))];case"FusedBatchNorm":case"FusedBatchNormV2":return[r.batchNorm(O("x",n,t,e),O("mean",n,t,e),O("variance",n,t,e),O("offset",n,t,e),O("scale",n,t,e),O("epsilon",n,t,e))];case"FusedBatchNormV3":return[r.batchNorm(O("x",n,t,e),O("mean",n,t,e),O("variance",n,t,e),O("offset",n,t,e),O("scale",n,t,e),O("epsilon",n,t,e))];case"LRN":return[r.localResponseNormalization(O("x",n,t,e),O("radius",n,t,e),O("bias",n,t,e),O("alpha",n,t,e),O("beta",n,t,e))];case"Softmax":return[r.softmax(O("x",n,t,e))];case"LogSoftmax":return[r.logSoftmax(O("x",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};const UJ=(n,t,e,r=Vr)=>{switch(n.op){case"RaggedGather":{const{outputNestedSplits:a,outputDenseValues:s}=r.raggedGather(O("paramsNestedSplits",n,t,e),O("paramsDenseValues",n,t,e),O("indices",n,t,e),O("outputRaggedRank",n,t,e));return a.concat(s)}case"RaggedRange":{const{rtNestedSplits:a,rtDenseValues:s}=r.raggedRange(O("starts",n,t,e),O("limits",n,t,e),O("splits",n,t,e));return[a,s]}case"RaggedTensorToTensor":return[r.raggedTensorToTensor(O("shape",n,t,e),O("values",n,t,e),O("defaultValue",n,t,e),O("rowPartitionTensors",n,t,e),O("rowPartitionTypes",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};const WJ=(n,t,e,r=Vr)=>{switch(n.op){case"Max":{const i=O("axis",n,t,e),u=O("keepDims",n,t,e);return[r.max(O("x",n,t,e),i,u)]}case"Mean":{const i=O("axis",n,t,e),u=O("keepDims",n,t,e);return[r.mean(O("x",n,t,e),i,u)]}case"Min":{const i=O("axis",n,t,e),u=O("keepDims",n,t,e);return[r.min(O("x",n,t,e),i,u)]}case"Sum":{const i=O("axis",n,t,e),u=O("keepDims",n,t,e);return[r.sum(O("x",n,t,e),i,u)]}case"All":{const i=O("axis",n,t,e),u=O("keepDims",n,t,e);return[r.all(O("x",n,t,e),i,u)]}case"Any":{const i=O("axis",n,t,e),u=O("keepDims",n,t,e);return[r.any(O("x",n,t,e),i,u)]}case"ArgMax":{const i=O("axis",n,t,e);return[r.argMax(O("x",n,t,e),i)]}case"ArgMin":{const i=O("axis",n,t,e);return[r.argMin(O("x",n,t,e),i)]}case"Prod":{const i=O("axis",n,t,e),u=O("keepDims",n,t,e);return[r.prod(O("x",n,t,e),i,u)]}case"Cumprod":{const i=O("axis",n,t,e),u=O("exclusive",n,t,e),l=O("reverse",n,t,e);return[r.cumprod(O("x",n,t,e),i,u,l)]}case"Cumsum":{const i=O("axis",n,t,e),u=O("exclusive",n,t,e),l=O("reverse",n,t,e);return[r.cumsum(O("x",n,t,e),i,u,l)]}case"Bincount":const a=O("x",n,t,e),s=O("weights",n,t,e),o=O("size",n,t,e);return[r.bincount(a,s,o)];case"DenseBincount":{const i=O("x",n,t,e),u=O("weights",n,t,e),l=O("size",n,t,e),h=O("binaryOutput",n,t,e);return[r.denseBincount(i,u,l,h)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};const GJ=(n,t,e,r=Vr)=>{switch(n.op){case"ConcatV2":case"Concat":{const a=O("n",n,t,e),s=O("axis",n,t,e);let o=O("tensors",n,t,e);return o=o.slice(0,a),[r.concat(o,s)]}case"Gather":{const a=O("x",n,t,e),s=O("indices",n,t,e);return[r.gather(a,r.cast(s,"int32"),0)]}case"GatherV2":{const a=O("axis",n,t,e),s=O("batchDims",n,t,e),o=O("x",n,t,e),i=O("indices",n,t,e);return[r.gather(o,r.cast(i,"int32"),a,s)]}case"Reverse":{const a=O("dims",n,t,e),s=[];for(let i=0;i<a.length;i++)a[i]&&s.push(i);const o=O("x",n,t,e);return[r.reverse(o,s)]}case"ReverseV2":{const a=O("axis",n,t,e),s=O("x",n,t,e);return[r.reverse(s,a)]}case"Slice":{const a=O("begin",n,t,e),s=O("size",n,t,e);return[r.slice(O("x",n,t,e),a,s)]}case"StridedSlice":{const a=O("begin",n,t,e),s=O("end",n,t,e),o=O("strides",n,t,e),i=O("beginMask",n,t,e),u=O("endMask",n,t,e),l=O("ellipsisMask",n,t,e),h=O("newAxisMask",n,t,e),d=O("shrinkAxisMask",n,t,e),f=O("x",n,t,e);return[r.stridedSlice(f,a,s,o,i,u,l,h,d)]}case"Pack":return ut(()=>{const a=O("axis",n,t,e),s=O("tensors",n,t,e),o=s[0].shape,i=r.squeeze(s[0]).shape,u=s.map(l=>{const h=De(l.shape,o);if(!h&&!De(r.squeeze(l).shape,i))throw new Error("the input tensors shape does not match");return h?l:r.reshape(l,o)});return[r.stack(u,a)]});case"Unpack":{const a=O("axis",n,t,e),s=O("tensor",n,t,e);return r.unstack(s,a)}case"Tile":{const a=O("reps",n,t,e);return[r.tile(O("x",n,t,e),a)]}case"Split":case"SplitV":{const a=O("axis",n,t,e),s=O("numOrSizeSplits",n,t,e),o=O("x",n,t,e);return r.split(o,s,a)}case"ScatterNd":{const a=O("indices",n,t,e),s=O("values",n,t,e),o=O("shape",n,t,e);return[r.scatterND(a,s,o)]}case"GatherNd":{const a=O("x",n,t,e),s=O("indices",n,t,e);return[r.gatherND(a,s)]}case"SparseToDense":{const a=O("sparseIndices",n,t,e),s=O("outputShape",n,t,e),o=O("sparseValues",n,t,e),i=O("defaultValue",n,t,e);return[r.sparseToDense(a,o,s,o.dtype===i.dtype?i:r.cast(i,o.dtype))]}case"TensorScatterUpdate":{const a=O("indices",n,t,e),s=O("values",n,t,e),o=O("tensor",n,t,e);return[r.tensorScatterUpdate(o,a,s)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};const HJ=(n,t,e,r=Vr)=>{switch(n.op){case"SparseFillEmptyRows":{const{outputIndices:a,outputValues:s,emptyRowIndicator:o,reverseIndexMap:i}=r.sparse.sparseFillEmptyRows(O("indices",n,t,e),O("values",n,t,e),O("denseShape",n,t,e),O("defaultValue",n,t,e));return[a,s,o,i]}case"SparseReshape":{const{outputIndices:a,outputShape:s}=r.sparse.sparseReshape(O("inputIndices",n,t,e),O("inputShape",n,t,e),O("newShape",n,t,e));return[a,s]}case"SparseSegmentMean":return[r.sparse.sparseSegmentMean(O("data",n,t,e),O("indices",n,t,e),O("segmentIds",n,t,e))];case"SparseSegmentSum":return[r.sparse.sparseSegmentSum(O("data",n,t,e),O("indices",n,t,e),O("segmentIds",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};const jJ=(n,t,e,r=Vr)=>{switch(n.op){case"FFT":return[r.fft(O("x",n,t,e))];case"IFFT":return[r.ifft(O("x",n,t,e))];case"RFFT":return[r.rfft(O("x",n,t,e))];case"IRFFT":return[r.irfft(O("x",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};const qJ=(n,t,e,r=Vr)=>{switch(n.op){case"StaticRegexReplace":return[r.string.staticRegexReplace(O("input",n,t,e),O("pattern",n,t,e),O("rewrite",n,t,e),O("replaceGlobal",n,t,e))];case"StringNGrams":{const{nGrams:a,nGramsSplits:s}=r.string.stringNGrams(O("data",n,t,e),O("dataSplits",n,t,e),O("separator",n,t,e),O("nGramWidths",n,t,e),O("leftPad",n,t,e),O("rightPad",n,t,e),O("padWidth",n,t,e),O("preserveShortSequences",n,t,e));return[a,s]}case"StringSplit":{const{indices:a,values:s,shape:o}=r.string.stringSplit(O("input",n,t,e),O("delimiter",n,t,e),O("skipEmpty",n,t,e));return[a,s,o]}case"StringToHashBucketFast":return[r.string.stringToHashBucketFast(O("input",n,t,e),O("numBuckets",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};const KJ=(n,t,e,r=Vr)=>{switch(n.op){case"Cast":return[r.cast(O("x",n,t,e),O("dtype",n,t,e))];case"ExpandDims":{const a=O("axis",n,t,e);return[r.expandDims(O("x",n,t,e),a)]}case"Squeeze":{const a=O("axis",n,t,e);return[r.squeeze(O("x",n,t,e),a)]}case"Reshape":return[r.reshape(O("x",n,t,e),O("shape",n,t,e))];case"EnsureShape":return[r.ensureShape(O("x",n,t,e),O("shape",n,t,e))];case"MirrorPad":return[r.mirrorPad(O("x",n,t,e),O("padding",n,t,e),O("mode",n,t,e))];case"PadV2":case"Pad":return[r.pad(O("x",n,t,e),O("padding",n,t,e),O("constantValue",n,t,e))];case"SpaceToBatchND":{const a=O("blockShape",n,t,e),s=O("paddings",n,t,e);return[r.spaceToBatchND(O("x",n,t,e),a,s)]}case"BatchToSpaceND":{const a=O("blockShape",n,t,e),s=O("crops",n,t,e);return[r.batchToSpaceND(O("x",n,t,e),a,s)]}case"DepthToSpace":{const a=O("blockSize",n,t,e),s=O("dataFormat",n,t,e).toUpperCase();return[r.depthToSpace(O("x",n,t,e),a,s)]}case"BroadcastTo":return[r.broadcastTo(O("x",n,t,e),O("shape",n,t,e))];case"BroadcastArgs":return[r.broadcastArgs(O("s0",n,t,e),O("s1",n,t,e))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};function TO(n,t,e,r,a=ut){const s=((o,i,u)=>{switch(o.category){case"arithmetic":return a(()=>CJ(o,i,u));case"basic_math":return a(()=>NJ(o,i,u));case"control":return RJ(o,i,u);case"convolution":return a(()=>AJ(o,i,u));case"creation":return a(()=>DJ(o,i,u));case"dynamic":return $J(o,i,u);case"evaluation":return a(()=>OJ(o,i,u));case"image":return a(()=>BJ(o,i,u));case"graph":return a(()=>FJ(o,i,u));case"logical":return a(()=>zJ(o,i,u));case"matrices":return a(()=>PJ(o,i,u));case"normalization":return a(()=>VJ(o,i,u));case"ragged":return a(()=>UJ(o,i,u));case"reduction":return a(()=>WJ(o,i,u));case"slice_join":return a(()=>GJ(o,i,u));case"sparse":return a(()=>HJ(o,i,u));case"spectral":return a(()=>jJ(o,i,u));case"string":return a(()=>qJ(o,i,u));case"transformation":return a(()=>KJ(o,i,u));case"hash_table":return LJ(o,i,u,r);case"custom":const l=dB(o.op);if(l&&l.customExecutor)return l.customExecutor(new SJ(o,i,u));throw TypeError(`Custom op ${o.op} is not registered.`);default:throw TypeError(`Unknown op '${o.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(n,t,e);return Mu(s)?s.then(o=>[].concat(o)):[].concat(s)}class EO{constructor(t={},e={},r={},a={},s){this.weightMap=t,this.tensorArrayMap=e,this.tensorListMap=r,this.functionMap=a,this.parseNodeNameCache=s,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(t,e){return{id:t,frameName:e,iterationId:0}}set currentContext(t){this.contexts!==t&&(this.contexts=t,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const t=[];for(let e=0;e<this.contexts.length-1;e++){const r=this.contexts.slice(0,this.contexts.length-e);t.push(this.contextIdforContexts(r))}t.push(""),this._currentContextIds=t}contextIdforContexts(t){return t?t.map(e=>e.id===0&&e.iterationId===0?"":`${e.frameName}-${e.iterationId}`).join("/"):""}enterFrame(t){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,t)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;const t=Object.assign({},this.contexts[this.contexts.length-1]);t.iterationId+=1,t.id=this.lastId,this.contexts.splice(-1,1,t),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(t){return this.weightMap[t]}addTensorArray(t){this.tensorArrayMap[t.id]=t}getTensorArray(t){return this.tensorArrayMap[t]}addTensorList(t){this.tensorListMap[t.id]=t}getTensorList(t){return this.tensorListMap[t]}dispose(t){for(const e in this.tensorArrayMap)this.tensorArrayMap[e].clearAndClose(t);for(const e in this.tensorListMap)this.tensorListMap[e].clearAndClose(t)}}function IO(n,t,e,r){const a=new Set,s=[];let o=null,i=null;const u=new Set,l=new Set(Object.keys(n).map(f=>La(f)[0]));r=r||[];const h=new Set(r.map(f=>La(f.name)[0])),d=[...t];for(;d.length>0;){const f=d.pop();if((Bl(f)||ntt(f)||rtt(f))&&o==null&&(o=f,i=o.children.map(m=>m.name).filter(m=>a.has(m))),a.add(f.name),e[f.name]==null&&!l.has(f.name)&&!h.has(f.name)){if(f.inputs.length===0){s.push(f.name);continue}f.inputs.forEach(m=>{u.has(m.name)||(u.add(m.name),d.push(m))})}}return{inputs:n,outputs:t,usedNodes:a,missingInputs:s,dynamicNode:o,syncInputs:i}}function XJ(n,t){const{usedNodes:e,inputs:r}=t,a=Object.keys(r).map(b=>La(b)[0]).map(b=>n.nodes[b]),s=n.initNodes||[],o=b=>e.has(typeof b=="string"?b:b.name);function i(b){return[...new Map(b.map(w=>[w.name,w])).values()]}const u=i([...a,...n.weights,...s]).filter(o),l=i([...u,...Object.values(n.nodes)]).filter(o),h=new Map(l.map(b=>[b.name,b])),d={};for(const b of l){d[b.name]=d[b.name]||0;for(const w of b.children)o(w)||(d[w.name]=Number.POSITIVE_INFINITY),d[w.name]=(d[w.name]||0)+1}const f=Object.entries(d).filter(([,b])=>b===0).map(([b])=>b),m=[...f];for(;f.length>0;){const b=f.pop(),w=h.get(b);for(const S of w.children.filter(o))--d[S.name]===0&&(m.push(S.name),f.push(S.name))}const v=m.map(b=>h.get(b)),y=YJ(v,u);return QJ(y,u),y}function YJ(n,t){const e=new Map(n.map(o=>[o.name,o])),r=t.map(o=>o.name),a=new Set(r);for(;r.length>0;){const o=r.pop(),i=e.get(o);for(const u of i.children)!e.has(u.name)||a.has(u.name)||(a.add(u.name),r.push(u.name))}return n.filter(o=>a.has(o.name))}class My extends Error{constructor(t){super(`NodesExecutionOrderError: ${t}`)}}function QJ(n,t){const e=new Map(n.map((i,u)=>[i.name,u])),r=new Set(t.map(i=>i.name)),a=i=>r.has(typeof i=="string"?i:i.name),s=new Set(n.map(i=>i.name)),o=i=>s.has(typeof i=="string"?i:i.name);for(const i of n){for(const u of i.children.filter(o)){if(!e.has(u.name))throw new My(`Child ${u.name} of node ${i.name} is unreachable.`);if(e.get(i.name)>e.get(u.name))throw new My(`Node ${i.name} is scheduled to run after its child ${u.name}.`)}if(!a(i))for(const u of i.inputs){if(!e.has(u.name))throw new My(`Input ${u.name} of node ${i.name} is unreachable.`);if(e.get(u.name)>e.get(i.name))throw new My(`Node ${i.name} is scheduled to run before its input ${u.name}.`)}}}function ZJ(n){const t=new Map(n.map((i,u)=>[i.name,u])),e=Number.MAX_SAFE_INTEGER,r=n.map((i,u)=>Bl(i)?e:u),a=i=>{const u=r[t.get(i.name)];return u??-1},s=n.map((i,u)=>i.children.map(a).reduce((l,h)=>Math.max(l,h),r[u])),o=new Map;for(let i=0;i<n.length;++i){const u=s[i];if(u===e)continue;const l=n[i],h=n[u];o.has(h.name)||o.set(h.name,[]),o.get(h.name).push(l)}return o}const JJ=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),ttt=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),ett=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function Bl(n){return JJ.has(n.op)}function ntt(n){return ttt.has(n.op)}function rtt(n){return ett.has(n.op)}class W0{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(t){const e=Object.keys(t).map(r=>t[r].map(a=>a.id));this._weightIds=[].concat(...e),this._weightMap=t}set resourceManager(t){this._resourceManager=t}get inputs(){return this._inputs.map(t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(t=>t.signatureKey||t.name)}get outputNodes(){return this._outputs.map(t=>{const e=t.signatureKey||t.name;return t.defaultOutput?`${e}:${t.defaultOutput}`:e})}get functions(){return Object.keys(this._functions).reduce((t,e)=>(t[e]=this._functions[e].signature,t),{})}constructor(t,e){this.graph=t,this.parent=e,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=t.outputs,this._inputs=t.inputs,this._initNodes=t.initNodes,this._signature=t.signature,this._functions=t.functions,t.functions!=null&&Object.keys(t.functions).forEach(r=>{this._functionExecutorMap[r]=new W0(t.functions[r],this)})}getCompilationKey(t,e){const r=t.map(s=>s.name).sort(),a=e.map(s=>s.name).sort();return r.join(this.SEPARATOR)+"--"+a.join(this.SEPARATOR)}compile(t,e){const r=IO(t,e,this.weightMap,this._initNodes),{missingInputs:a,dynamicNode:s,syncInputs:o}=r;if(s!=null)throw new Error(`This execution contains the node '${s.name}', which has the dynamic op '${s.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${o}]`);if(a.length>0){const l=e.map(d=>d.name),h=Object.keys(t);throw new Error(`Cannot compute the outputs [${l}] from the provided inputs [${h}]. Missing the following inputs: [${a}]`)}const i=XJ(this.graph,r),u=ZJ(i);return{orderedNodes:i,nodeLiveUntilMap:u}}cloneAndKeepTensor(t){if(t==null)return null;const e=t.clone();return ar(e),e}cloneTensorList(t){return t?t.map(r=>this.cloneAndKeepTensor(r)):null}cloneTensorMap(t){return Object.fromEntries(Object.entries(t).map(([e,r])=>[e,this.cloneTensorList(r)]))}execute(t,e){this.disposeIntermediateTensors(),t=this.mapInputs(t);const r=Object.keys(t).sort();this.checkInputs(t),this.checkInputShapeAndType(t),e=this.mapOutputs(e),this.checkOutputs(e);const a=r.map(f=>this.graph.nodes[La(f)[0]]),s=e.map(f=>La(f)[0]),o=new Set(s);let i=s.map(f=>this.graph.nodes[f]);i.length===0&&(i=this._outputs);const u=this.getCompilationKey(a,i);let l=this.compiledMap.get(u);l==null&&(l=this.compile(t,i),this.compiledMap.set(u,l));try{this.keepIntermediateTensors=dt().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(f){this.keepIntermediateTensors=!1,console.warn(f.message)}const h={},d={};return ut(()=>{const f=new EO(this.weightMap,h,d,this.functionExecutorMap,this.parseNodeNameCache),m=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(t).forEach(w=>{const[S,N]=La(w,f),C=[];C[N]=t[w],m[S]=C,this.keepIntermediateTensors&&(this.clonedTensorsMap[S]=this.cloneTensorList(C))});const v=this.getFrozenTensorIds(m),{orderedNodes:y,nodeLiveUntilMap:b}=l;for(const w of y){if(m[w.name])continue;const S=TO(w,m,f,this._resourceManager);if(Mu(S))throw new Error(`The execution of the op '${w.op}' returned a promise. Please use model.executeAsync() instead.`);m[w.name]=S,this.keepIntermediateTensors&&(this.clonedTensorsMap[w.name]=this.cloneTensorList(S)),this.checkTensorForDisposalWithNodeLiveUntilInfo(w,m,f,v,o,b.get(w.name))}return this.parent==null&&f.dispose(v),e.map(w=>Ar(w,m,f))})}getFrozenTensorIds(t){const e=[].concat.apply([],Object.keys(t).map(r=>t[r]).map(r=>r.map(a=>a.id)));return new Set(e)}checkTensorForDisposal(t,e,r,a,s,o,i){if(!(Bl(e)||o.has(t))){for(const u of r[t])u!=null&&(i[u.id]=(i[u.id]||0)+e.children.length);for(const u of e.inputs){if(Bl(u))continue;const l=wO(u.name,r,a);if(l!=null)for(const h of l){if(!h||h.kept||s.has(h.id))continue;const d=i[h.id];d===1?(h.dispose(),delete i[h.id]):d!=null&&i[h.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(t,e,r,a,s,o){function i(u){return Bl(u)||s.has(u.name)}if(!(Bl(t)||o==null))for(const u of o){if(i(u))continue;const l=wO(u.name,e,r);for(const h of l)!h||h.kept||a.has(h.id)||h.dispose()}}async executeAsync(t,e){return this._executeAsync(t,e)}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach(t=>{for(const e of t)e&&!e.isDisposed&&e.dispose()}),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(t,e,r=!1,a={},s={}){this.disposeIntermediateTensors(),r||(t=this.mapInputs(t),this.checkInputs(t),this.checkInputShapeAndType(t),e=this.mapOutputs(e),this.checkOutputs(e));try{this.keepIntermediateTensors=dt().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(f){this.keepIntermediateTensors=!1,console.warn(f.message)}const o=new EO(this.weightMap,a,s,this.functionExecutorMap,this.parseNodeNameCache);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));const i=await this.executeWithControlFlow(t,o,e,r),u=e.map(f=>Ar(f,i,o)),l=u.map(f=>f.id),h=Object.keys(t).map(f=>t[f].id),d=new Set([...l,...h,...this.weightIds]);return Object.values(i).forEach(f=>{f.forEach(m=>{m&&!m.isDisposed&&!d.has(m.id)&&m.dispose()})}),this.parent==null&&o.dispose(d),u}async executeFunctionAsync(t,e,r){const a=t.reduce((s,o,i)=>(s[this.inputs[i].name]=o,s),{});return this._executeAsync(a,this.outputNodes,!0,e,r)}async executeWithControlFlow(t,e,r,a){const s=Object.keys(t),o=s.map(C=>this.graph.nodes[La(C)[0]]),i=r.map(C=>La(C)[0]),u=new Set(i);let l=i.map(C=>this.graph.nodes[C]);l.length===0&&(l=this._outputs);const{usedNodes:h,missingInputs:d,dynamicNode:f,syncInputs:m}=IO(t,l,this.weightMap,this._initNodes),v=[...o,...this.graph.weights,...this._initNodes||[]].map(C=>({node:C,contexts:e.currentContext})),y=Object.assign({},this.weightMap);Object.keys(t).forEach(C=>{const[T,I]=La(C),_=[];_[I]=t[C],y[T]=_});const b={},w=this.getFrozenTensorIds(y),S={};for(;v.length>0;){const C=this.processStack(o,v,e,y,S,w,u,b,h);await Promise.all(C)}f==null&&!a&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const N=l.filter(C=>!Bl(C)&&!Ar(C.name,y,e)).map(C=>C.name);if(N.length>0){let C="";throw f!=null&&(C=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${m}]`),new Error(`Cannot compute the outputs [${N}] from the provided inputs [${s}]. Consider providing the following inputs: [${d}]. ${C}`)}return y}processStack(t,e,r,a,s,o,i,u,l){const h=[];for(;e.length>0;){const d=e.pop();r.currentContext=d.contexts;let f="";if(d.node.op==="Enter"&&O("isConstant",d.node,a,r)&&([f]=wi(d.node.name,r)),a[d.node.name]==null){const m=TO(d.node,a,r,this._resourceManager);f||([f]=wi(d.node.name,r));const v=r.currentContext;Mu(m)?h.push(m.then(y=>(a[f]=y,this.keepIntermediateTensors&&(this.clonedTensorsMap[f]=this.cloneTensorList(y)),r.currentContext=v,this.checkTensorForDisposal(f,d.node,a,r,o,i,u),this.processChildNodes(d.node,e,r,a,s,l),y))):(a[f]=m,this.keepIntermediateTensors&&(this.clonedTensorsMap[f]=this.cloneTensorList(m)),this.checkTensorForDisposal(f,d.node,a,r,o,i,u),this.processChildNodes(d.node,e,r,a,s,l))}else this.processChildNodes(d.node,e,r,a,s,l)}return h}processChildNodes(t,e,r,a,s,o){t.children.forEach(i=>{const[u]=wi(i.name,r);s[u]||!o.has(i.name)||(i.op==="Merge"?i.inputNames.some(l=>!!Ar(l,a,r))&&(s[u]=!0,e.push({contexts:r.currentContext,node:i})):i.inputNames.every(l=>!!Ar(l,a,r))&&(s[u]=!0,e.push({contexts:r.currentContext,node:i})))})}dispose(){Object.keys(this.weightMap).forEach(t=>this.weightMap[t].forEach(e=>e.dispose()))}checkInputShapeAndType(t){Object.keys(t).forEach(e=>{const r=t[e],[a]=La(e),s=this.graph.nodes[a];if(s.attrParams.shape&&s.attrParams.shape.value){const o=s.attrParams.shape.value,i=o.length===r.shape.length&&r.shape.every((u,l)=>o[l]===-1||o[l]===u);P(i,()=>`The shape of dict['${s.name}'] provided in model.execute(dict) must be [${o}], but was [${r.shape}]`)}s.attrParams.dtype&&s.attrParams.dtype.value&&P(r.dtype===s.attrParams.dtype.value,()=>`The dtype of dict['${s.name}'] provided in model.execute(dict) must be ${s.attrParams.dtype.value}, but was ${r.dtype}`)})}mapInputs(t){var e,r;const a={};for(const s in t){const o=(r=(e=this._signature)===null||e===void 0?void 0:e.inputs)===null||r===void 0?void 0:r[s];o!=null?a[o.name]=t[s]:a[s]=t[s]}return a}checkInputs(t){const e=Object.keys(t).filter(r=>{const[a]=La(r);return this.graph.nodes[a]==null});if(e.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${e}] that are not part of graph`)}mapOutputs(t){return t.map(e=>{var r,a;const s=(a=(r=this._signature)===null||r===void 0?void 0:r.outputs)===null||a===void 0?void 0:a[e];return s!=null?s.name:e},{})}checkOutputs(t){t.forEach(e=>{const[r]=La(e);if(!this.graph.nodes[r])throw new Error(`The output '${e}' is not found in the graph`)})}}class att{constructor(t={},e={}){this.hashTableNameToHandle=t,this.hashTableMap=e}addHashTable(t,e){this.hashTableNameToHandle[t]=e.handle,this.hashTableMap[e.id]=e}getHashTableHandleByName(t){return this.hashTableNameToHandle[t]}getHashTableById(t){return this.hashTableMap[t]}dispose(){for(const t in this.hashTableMap)this.hashTableMap[t].clearAndClose(),delete this.hashTableMap[t];for(const t in this.hashTableNameToHandle)this.hashTableNameToHandle[t].dispose(),delete this.hashTableNameToHandle[t]}}const stt="?tfjs-format=file",ott="model.json";class DE{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(t,e={},r=nE){this.modelUrl=t,this.loadOptions=e,this.version="n/a",this.io=r,e==null&&(this.loadOptions={}),this.resourceManager=new att}findIOHandler(){const t=this.modelUrl;if(t.load!=null)this.handler=t;else if(this.loadOptions.requestInit!=null)this.handler=this.io.browserHTTPRequest(t,this.loadOptions);else{const e=this.io.getLoadHandlers(t,this.loadOptions);if(e.length===0)e.push(this.io.browserHTTPRequest(t,this.loadOptions));else if(e.length>1)throw new Error(`Found more than one (${e.length}) load handlers for URL '${[t]}'`);this.handler=e[0]}}load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const t=this.handler.load();return Mu(t)?t.then(e=>e.getWeightStream==null?this.loadSync(e):this.loadStreaming(e)):this.loadSync(t)}loadSync(t){const e=this.io.decodeWeights(t.weightData,t.weightSpecs);return this.loadWithWeightMap(t,e)}async loadStreaming(t){if(t.getWeightStream==null)throw new Error("Model artifacts missing streamWeights function");const e=await cL(t.getWeightStream(),t.weightSpecs);return this.loadWithWeightMap(t,e)}loadWithWeightMap(t,e){this.artifacts=t;const r=this.artifacts.modelTopology;let a=this.artifacts.signature;if(this.artifacts.userDefinedMetadata!=null){const s=this.artifacts.userDefinedMetadata;s.signature!=null&&(a=s.signature),s.structuredOutputKeys!=null&&(this.structuredOutputKeys=s.structuredOutputKeys)}if(this.signature=a,this.version=`${r.versions.producer}.${r.versions.minConsumer}`,this.executor=new W0(SO.Instance.transformGraph(r,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(e),this.executor.resourceManager=this.resourceManager,t.modelInitializer!=null&&t.modelInitializer.node!=null){const s=SO.Instance.transformGraph(t.modelInitializer);this.initializer=new W0(s),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=t.initializerSignature}return!0}async save(t,e){if(typeof t=="string"){const r=this.io.getSaveHandlers(t);if(r.length===0)throw new Error(`Cannot find any save handlers for URL '${t}'`);if(r.length>1)throw new Error(`Found more than one (${r.length}) save handlers for URL '${t}'`);t=r[0]}if(t.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return t.save(this.artifacts)}addStructuredOutputNames(t){if(this.structuredOutputKeys){const e=t instanceof Ae?[t]:t,r={};return e.forEach((a,s)=>r[this.structuredOutputKeys[s]]=a),r}return t}predict(t,e){const r=this.execute(t,this.outputNodes);return this.addStructuredOutputNames(r)}async predictAsync(t,e){const r=await this.executeAsync(t,this.outputNodes);return this.addStructuredOutputNames(r)}normalizeInputs(t){var e;if(!(t instanceof Ae)&&!Array.isArray(t)){const s=(e=this.signature)===null||e===void 0?void 0:e.inputs;if(s!=null)for(const o in s){const i=s[o];i.resourceId!=null&&(t[o]=this.resourceIdToCapturedInput[i.resourceId])}return t}t=Array.isArray(t)?t:[t];const r=Object.keys(this.resourceIdToCapturedInput).length;if(t.length+r!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-r} non-resource placeholders, while there are ${t.length} input tensors provided.`);let a=0;return this.inputNodes.reduce((s,o)=>{var i,u,l;const h=(l=(u=(i=this.signature)===null||i===void 0?void 0:i.inputs)===null||u===void 0?void 0:u[o])===null||l===void 0?void 0:l.resourceId;return h!=null?s[o]=this.resourceIdToCapturedInput[h]:s[o]=t[a++],s},{})}normalizeOutputs(t){return t=t||this.outputNodes,Array.isArray(t)?t:[t]}executeInitializerGraph(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(t){if(this.resourceIdToCapturedInput={},this.initializerSignature){const e=this.initializerSignature.outputs,r=Object.keys(e);for(let a=0;a<r.length;a++){const s=r[a],o=e[s];this.resourceIdToCapturedInput[o.resourceId]=t[a]}}}execute(t,e){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),t=this.normalizeInputs(t),e=this.normalizeOutputs(e);const r=this.executor.execute(t,e);return r.length>1?r:r[0]}async executeAsync(t,e){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),t=this.normalizeInputs(t),e=this.normalizeOutputs(e);const r=await this.executor.executeAsync(t,e);return r.length>1?r:r[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(t){return Object.keys(t).reduce((e,r)=>(e[r]=[t[r]],e),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&Ie(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}}async function rm(n,t={},e=nE){if(n==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");t==null&&(t={}),t.fromTFHub&&typeof n=="string"&&(n=utt(n));const r=new DE(n,t,e);return await r.load(),r}function itt(n){if(n==null)throw new Error("modelUrl in loadGraphModelSync() cannot be null. Please provide model artifacts or an IOHandler that loads the model");let t;if(n instanceof Array){const[r,a]=n;if(!r)throw new Error("modelJSON must be the first element of the array");if(!a||!(a instanceof ArrayBuffer))throw new Error("An ArrayBuffer of weights must be the second element of the array");if(!("modelTopology"in r))throw new Error("Model JSON is missing 'modelTopology'");if(!("weightsManifest"in r))throw new Error("Model JSON is missing 'weightsManifest'");const s=z0(r.weightsManifest),o=Vk(r,s,a);t=V0(o)}else if("load"in n)t=n;else if("modelTopology"in n&&"weightSpecs"in n&&"weightData"in n)t=V0(n);else throw new Error("Unknown model format");const e=new DE(t);return e.load(),e}function utt(n){return n.endsWith("/")||(n=n+"/"),`${n}${ott}${stt}`}const ltt="4.22.0";const ctt=Object.freeze(Object.defineProperty({__proto__:null,GraphModel:DE,deregisterOp:MZ,loadGraphModel:rm,loadGraphModelSync:itt,registerOp:FZ,version_converter:ltt},Symbol.toStringTag,{value:"Module"}));var $N=function(n,t){return $N=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,r){e.__proto__=r}||function(e,r){for(var a in r)r.hasOwnProperty(a)&&(e[a]=r[a])},$N(n,t)};function mB(n,t){$N(n,t);function e(){this.constructor=n}n.prototype=t===null?Object.create(t):(e.prototype=t.prototype,new e)}var xo=function(){return xo=Object.assign||function(t){for(var e,r=1,a=arguments.length;r<a;r++){e=arguments[r];for(var s in e)Object.prototype.hasOwnProperty.call(e,s)&&(t[s]=e[s])}return t},xo.apply(this,arguments)};function _o(n,t,e,r){function a(s){return s instanceof e?s:new e(function(o){o(s)})}return new(e||(e=Promise))(function(s,o){function i(h){try{l(r.next(h))}catch(d){o(d)}}function u(h){try{l(r.throw(h))}catch(d){o(d)}}function l(h){h.done?s(h.value):a(h.value).then(i,u)}l((r=r.apply(n,[])).next())})}function Ro(n,t){var e={label:0,sent:function(){if(s[0]&1)throw s[1];return s[1]},trys:[],ops:[]},r,a,s,o;return o={next:i(0),throw:i(1),return:i(2)},typeof Symbol=="function"&&(o[Symbol.iterator]=function(){return this}),o;function i(l){return function(h){return u([l,h])}}function u(l){if(r)throw new TypeError("Generator is already executing.");for(;e;)try{if(r=1,a&&(s=l[0]&2?a.return:l[0]?a.throw||((s=a.return)&&s.call(a),0):a.next)&&!(s=s.call(a,l[1])).done)return s;switch(a=0,s&&(l=[l[0]&2,s.value]),l[0]){case 0:case 1:s=l;break;case 4:return e.label++,{value:l[1],done:!1};case 5:e.label++,a=l[1],l=[0];continue;case 7:l=e.ops.pop(),e.trys.pop();continue;default:if(s=e.trys,!(s=s.length>0&&s[s.length-1])&&(l[0]===6||l[0]===2)){e=0;continue}if(l[0]===3&&(!s||l[1]>s[0]&&l[1]<s[3])){e.label=l[1];break}if(l[0]===6&&e.label<s[1]){e.label=s[1],s=l;break}if(s&&e.label<s[2]){e.label=s[2],e.ops.push(l);break}s[2]&&e.ops.pop(),e.trys.pop();continue}l=t.call(n,e)}catch(h){l=[6,h],a=0}finally{r=s=0}if(l[0]&5)throw l[1];return{value:l[0]?l[1]:void 0,done:!0}}}function gB(n){var t=n.shape[2],e=Bu(n,2),r=at(e,[-1]);return sc(r,t)}function htt(n,t){return et(n,t)}function Ly(n,t){return ut(function(){return Ft(ga(n,Jt(t)),"int32")})}function dtt(n,t){var e=t.shape,r=e[0],a=e[1],s=e[2];return ut(function(){var o=gB(t),i=Pn(Ai(0,s,1,"int32"),1),u=Ft(xe(o,i),"int32"),l=at(u,[r,a]),h=It(l,Jt(1,"int32"));return zt(htt(h,n),Jt(1,"int32"))})}function ptt(n){var t=n.shape,e=t[0],r=t[1],a=t[2];return ut(function(){var s=gB(n),o=Pn(Ai(0,a,1,"int32"),1),i=Ft(xe(s,o),"int32");return at(i,[e,r])})}var vB=(function(){function n(t,e){this.model=t,this.outputStride=e;var r=this.model.inputs[0].shape;P(r[1]===-1&&r[2]===-1,function(){return"Input shape [".concat(r[1],", ").concat(r[2],"] ")+"must both be equal to or -1"})}return n.prototype.predict=function(t){var e=this;return ut(function(){var r=e.preprocessInput(Ft(t,"float32")),a=Pn(r,0),s=e.model.predict(a),o=s.map(function(u){return $r(u,[0])}),i=e.nameOutputResults(o);return{heatmapScores:Va(i.heatmap),offsets:i.offsets,displacementFwd:i.displacementFwd,displacementBwd:i.displacementBwd,segmentation:i.segmentation,partHeatmaps:i.partHeatmaps,longOffsets:i.longOffsets,partOffsets:i.partOffsets}})},n.prototype.dispose=function(){this.model.dispose()},n})();var ftt=(function(n){mB(t,n);function t(){return n!==null&&n.apply(this,arguments)||this}return t.prototype.preprocessInput=function(e){return ut(function(){return zt(Ut(e,127.5),1)})},t.prototype.nameOutputResults=function(e){var r=e[0],a=e[1],s=e[2],o=e[3],i=e[4],u=e[5],l=e[6],h=e[7];return{offsets:r,segmentation:a,partHeatmaps:s,longOffsets:o,heatmap:i,displacementFwd:u,displacementBwd:l,partOffsets:h}},t})(vB);var A1=["nose","leftEye","rightEye","leftEar","rightEar","leftShoulder","rightShoulder","leftElbow","rightElbow","leftWrist","rightWrist","leftHip","rightHip","leftKnee","rightKnee","leftAnkle","rightAnkle"],Zs=A1.length,G0=A1.reduce(function(n,t,e){return n[t]=e,n},{}),mtt=[["leftHip","leftShoulder"],["leftElbow","leftShoulder"],["leftElbow","leftWrist"],["leftHip","leftKnee"],["leftKnee","leftAnkle"],["rightHip","rightShoulder"],["rightElbow","rightShoulder"],["rightElbow","rightWrist"],["rightHip","rightKnee"],["rightKnee","rightAnkle"],["leftShoulder","rightShoulder"],["leftHip","rightHip"]],gtt=[["nose","leftEye"],["leftEye","leftEar"],["nose","rightEye"],["rightEye","rightEar"],["nose","leftShoulder"],["leftShoulder","leftElbow"],["leftElbow","leftWrist"],["leftShoulder","leftHip"],["leftHip","leftKnee"],["leftKnee","leftAnkle"],["nose","rightShoulder"],["rightShoulder","rightElbow"],["rightElbow","rightWrist"],["rightShoulder","rightHip"],["rightHip","rightKnee"],["rightKnee","rightAnkle"]];mtt.map(function(n){var t=n[0],e=n[1];return[G0[t],G0[e]]});function $E(n,t,e){var r=n[0],a=n[1],s=t[0],o=t[1],i=e.top,u=e.bottom,l=e.left,h=e.right,d=s/(i+u+r),f=o/(l+h+a);return[f,d]}function yB(n,t,e,r){return{y:r.get(n,t,e),x:r.get(n,t,e+Zs)}}function bB(n,t,e){var r=n.heatmapY,a=n.heatmapX,s=n.id,o=yB(r,a,s,e),i=o.y,u=o.x;return{x:n.heatmapX*t+u,y:n.heatmapY*t+i}}function _O(n,t,e){return n<t?t:n>e?e:n}function vtt(n,t,e,r){var a=e-n,s=r-t;return a*a+s*s}function RO(n,t){return{x:n.x+t.x,y:n.y+t.y}}function ytt(n,t,e){e===void 0&&(e=.3);for(var r=0,a=0,s=0;s<n.length;s++)t.keypoints[s].score>e&&(a+=1,r+=Math.pow(n[s].x-t.keypoints[s].position.x,2)+Math.pow(n[s].y-t.keypoints[s].position.y,2));return a===0?r=1/0:r=r/a,r}function btt(n,t,e,r){var a=t[0],s=t[1],o=e[0],i=e[1],u=Math.round(((a+n.y+1)*i-1)/r),l=Math.round(((s+n.x+1)*o-1)/r);return{x:l,y:u}}function xtt(n,t,e,r,a,s,o){for(var i=o[0],u=o[1],l=e(n),h=l.y*r+l.x,d=a[Zs*(2*h)+t],f=a[Zs*(2*h+1)+t],m=n.y+d,v=n.x+f,y=0;y<s;y++){m=Math.min(m,i-1),v=Math.min(v,u-1);var b=e({x:v,y:m}),w=b.y*r+b.x;d=a[Zs*(2*w)+t],f=a[Zs*(2*w+1)+t],m=m+d,v=v+f}return{x:v,y:m}}function xB(n,t,e,r,a,s,o,i,u,l){for(var h=a[0],d=a[1],f=s[0],m=s[1],v=i[0],y=i[1],b=[],w=function($){return btt($,[h,d],[f,m],u)},S=0;S<r;S++){var N=xtt(n,S,w,o,t,l,[v,y]);b.push(N)}for(var C=-1,T=1/0,I=0;I<e.length;I++){var _=ytt(b,e[I]);_<T&&(C=I,T=_)}return C}function wB(n,t){var e=n[0],r=n[1],a=Math.round((r-1)/t+1),s=Math.round((e-1)/t+1);return[a,s]}function wtt(n,t,e,r,a,s,o,i,u,l){var h=o[0],d=o[1];l===void 0&&(l=5);for(var f=e.map(function($){return new Uint8Array(r*a).fill(0)}),m=i.top,v=i.left,y=$E([r,a],[h,d],i),b=y[0],w=y[1],S=wB([h,d],s)[0],N=0;N<r;N+=1)for(var C=0;C<a;C+=1){var T=N*a+C,I=n[T];if(I===1){var _=xB({x:C,y:N},t,e,l,[m,v],[b,w],S,[r,a],s,u);_>=0&&(f[_][T]=1)}}return f}function Stt(n,t,e,r,a,s,o,i,u,l,h){var d=i[0],f=i[1];h===void 0&&(h=5);for(var m=r.map(function(R){return new Int32Array(a*s).fill(-1)}),v=u.top,y=u.left,b=$E([a,s],[d,f],u),w=b[0],S=b[1],N=wB([d,f],o)[0],C=0;C<a;C+=1)for(var T=0;T<s;T+=1){var I=C*s+T,_=n[I];if(_===1){var $=xB({x:T,y:C},t,r,h,[v,y],[w,S],N,[a,s],o,l);$>=0&&(m[$][I]=e[I])}}return m}function SB(n,t,e,r,a,s,o,i,u,l,h){for(var d=o[0],f=o[1],m=n.shape,v=m[0],y=m[1],b=t.shape.slice(0,2),w=b[0],S=b[1],N=at(t,[w,S,2,Zs]),C=new Float32Array(h*Zs*3).fill(0),T=0;T<e.length;T++)for(var I=T*Zs*3,_=e[T],$=0;$<Zs;$++){var R=_.keypoints[$],D=I+$*3;C[D]=R.score,C[D+1]=R.position.y,C[D+2]=R.position.x}var A=$E([r,a],[d,f],i),L=A[0],H=A[1],G=gs(C,[h,Zs,3]),q=i.top,B=i.left,j={variableNames:["segmentation","longOffsets","poses"],outputShape:[v,y],userCode:`
    int convertToPositionInOutput(int pos, int pad, float scale, int stride) {
      return round(((float(pos + pad) + 1.0) * scale - 1.0) / float(stride));
    }

    float convertToPositionInOutputFloat(
        int pos, int pad, float scale, int stride) {
      return ((float(pos + pad) + 1.0) * scale - 1.0) / float(stride);
    }

    float dist(float x1, float y1, float x2, float y2) {
      return pow(x1 - x2, 2.0) + pow(y1 - y2, 2.0);
    }

    float sampleLongOffsets(float h, float w, int d, int k) {
      float fh = fract(h);
      float fw = fract(w);
      int clH = int(ceil(h));
      int clW = int(ceil(w));
      int flH = int(floor(h));
      int flW = int(floor(w));
      float o11 = getLongOffsets(flH, flW, d, k);
      float o12 = getLongOffsets(flH, clW, d, k);
      float o21 = getLongOffsets(clH, flW, d, k);
      float o22 = getLongOffsets(clH, clW, d, k);
      float o1 = mix(o11, o12, fw);
      float o2 = mix(o21, o22, fw);
      return mix(o1, o2, fh);
    }

    int findNearestPose(int h, int w) {
      float prob = getSegmentation(h, w);
      if (prob < 1.0) {
        return -1;
      }

      // Done(Tyler): convert from output space h/w to strided space.
      float stridedH = convertToPositionInOutputFloat(
        h, `.concat(q,", ").concat(H,", ").concat(s,`);
      float stridedW = convertToPositionInOutputFloat(
        w, `).concat(B,", ").concat(L,", ").concat(s,`);

      float minDist = 1000000.0;
      int iMin = -1;
      for (int i = 0; i < `).concat(h,`; i++) {
        float curDistSum = 0.0;
        int numKpt = 0;
        for (int k = 0; k < `).concat(Zs,`; k++) {
          float dy = sampleLongOffsets(stridedH, stridedW, 0, k);
          float dx = sampleLongOffsets(stridedH, stridedW, 1, k);

          float y = float(h) + dy;
          float x = float(w) + dx;

          for (int s = 0; s < `).concat(u,`; s++) {
            int yRounded = round(min(y, float(`).concat(r-1,`)));
            int xRounded = round(min(x, float(`).concat(a-1,`)));

            float yStrided = convertToPositionInOutputFloat(
              yRounded, `).concat(q,", ").concat(H,", ").concat(s,`);
            float xStrided = convertToPositionInOutputFloat(
              xRounded, `).concat(B,", ").concat(L,", ").concat(s,`);

            float dy = sampleLongOffsets(yStrided, xStrided, 0, k);
            float dx = sampleLongOffsets(yStrided, xStrided, 1, k);

            y = y + dy;
            x = x + dx;
          }

          float poseScore = getPoses(i, k, 0);
          float poseY = getPoses(i, k, 1);
          float poseX = getPoses(i, k, 2);
          if (poseScore > `).concat(l,`) {
            numKpt = numKpt + 1;
            curDistSum = curDistSum + dist(x, y, poseX, poseY);
          }
        }
        if (numKpt > 0 && curDistSum / float(numKpt) < minDist) {
          minDist = curDistSum / float(numKpt);
          iMin = i;
        }
      }
      return iMin;
    }

    void main() {
        ivec2 coords = getOutputCoords();
        int nearestPose = findNearestPose(coords[0], coords[1]);
        setOutput(float(nearestPose));
      }
  `)},K=Ux();return K.compileAndRun(j,[n,N,G])}function Ctt(n,t){return ut(function(){return Ft(Wa(n,Jt(t)),"int32")})}function Ntt(n,t,e){return ut(function(){return zt(et(Ft(Wa(n,Jt(e)),"int32"),It(t,1)),1)})}function CB(){return Bk()==="webgl"}function ktt(n,t,e,r,a,s,o,i,u,l,h,d){var f=o[0],m=o[1];return u===void 0&&(u=.2),l===void 0&&(l=8),h===void 0&&(h=.3),d===void 0&&(d=10),_o(this,void 0,void 0,function(){var v,y,b,w,S;return Ro(this,function(N){switch(N.label){case 0:return v=e.filter(function(C){return C.score>=u}),CB()?(b=ut(function(){var C=SB(n,t,v,r,a,s,[f,m],i,l,h,d),T=as().makeTensorFromDataId(C.dataId,C.shape,C.dtype);return v.map(function(I,_){return Ctt(T,_)})}),[4,Promise.all(b.map(function(C){return C.data()}))]):[3,2];case 1:return y=N.sent(),b.forEach(function(C){return C.dispose()}),[3,5];case 2:return[4,n.data()];case 3:return w=N.sent(),[4,t.data()];case 4:S=N.sent(),y=wtt(w,S,v,r,a,s,[f,m],i,l),N.label=5;case 5:return[2,y.map(function(C,T){return{data:C,pose:v[T],width:a,height:r}})]}})})}function Ttt(n,t,e,r,a,s,o,i,u,l,h,d,f){var m=i[0],v=i[1];return l===void 0&&(l=.2),h===void 0&&(h=8),d===void 0&&(d=.3),f===void 0&&(f=10),_o(this,void 0,void 0,function(){var y,b,w,S,N,C;return Ro(this,function(T){switch(T.label){case 0:return y=r.filter(function(I){return I.score>=l}),CB()?(w=ut(function(){var I=SB(n,t,y,a,s,o,[m,v],u,h,d,f),_=as().makeTensorFromDataId(I.dataId,I.shape,I.dtype);return y.map(function($,R){return Ntt(_,e,R)})}),[4,Promise.all(w.map(function(I){return I.data()}))]):[3,2];case 1:return b=T.sent(),w.forEach(function(I){return I.dispose()}),[3,6];case 2:return[4,n.data()];case 3:return S=T.sent(),[4,t.data()];case 4:return N=T.sent(),[4,e.data()];case 5:C=T.sent(),b=Stt(S,N,C,y,a,s,o,[m,v],u,h),T.label=6;case 6:return[2,b.map(function(I,_){return{pose:y[_],data:I,height:a,width:s}})]}})})}function US(n){return Math.floor(n/2)}var Ett=(function(){function n(t,e){this.priorityQueue=new Array(t),this.numberOfElements=-1,this.getElementValue=e}return n.prototype.enqueue=function(t){this.priorityQueue[++this.numberOfElements]=t,this.swim(this.numberOfElements)},n.prototype.dequeue=function(){var t=this.priorityQueue[0];return this.exchange(0,this.numberOfElements--),this.sink(0),this.priorityQueue[this.numberOfElements+1]=null,t},n.prototype.empty=function(){return this.numberOfElements===-1},n.prototype.size=function(){return this.numberOfElements+1},n.prototype.all=function(){return this.priorityQueue.slice(0,this.numberOfElements+1)},n.prototype.max=function(){return this.priorityQueue[0]},n.prototype.swim=function(t){for(;t>0&&this.less(US(t),t);)this.exchange(t,US(t)),t=US(t)},n.prototype.sink=function(t){for(;2*t<=this.numberOfElements;){var e=2*t;if(e<this.numberOfElements&&this.less(e,e+1)&&e++,!this.less(t,e))break;this.exchange(t,e),t=e}},n.prototype.getValueAt=function(t){return this.getElementValue(this.priorityQueue[t])},n.prototype.less=function(t,e){return this.getValueAt(t)<this.getValueAt(e)},n.prototype.exchange=function(t,e){var r=this.priorityQueue[t];this.priorityQueue[t]=this.priorityQueue[e],this.priorityQueue[e]=r},n})();function Itt(n,t,e,r,a,s){for(var o=s.shape,i=o[0],u=o[1],l=!0,h=Math.max(e-a,0),d=Math.min(e+a+1,i),f=h;f<d;++f){for(var m=Math.max(r-a,0),v=Math.min(r+a+1,u),y=m;y<v;++y)if(s.get(f,y,n)>t){l=!1;break}if(!l)break}return l}function _tt(n,t,e){for(var r=e.shape,a=r[0],s=r[1],o=r[2],i=new Ett(a*s*o,function(f){var m=f.score;return m}),u=0;u<a;++u)for(var l=0;l<s;++l)for(var h=0;h<o;++h){var d=e.get(u,l,h);d<n||Itt(h,d,u,l,t,e)&&i.enqueue({score:d,part:{heatmapY:u,heatmapX:l,id:h}})}return i}var NB=gtt.map(function(n){var t=n[0],e=n[1];return[G0[t],G0[e]]}),WS=NB.map(function(n){var t=n[1];return t}),AO=NB.map(function(n){var t=n[0];return t});function Rtt(n,t,e){var r=e.shape[2]/2;return{y:e.get(t.y,t.x,n),x:e.get(t.y,t.x,r+n)}}function GS(n,t,e,r){return{y:_O(Math.round(n.y/t),0,e-1),x:_O(Math.round(n.x/t),0,r-1)}}function DO(n,t,e,r,a,s,o,i){i===void 0&&(i=2);for(var u=r.shape,l=u[0],h=u[1],d=GS(t.position,s,l,h),f=Rtt(n,d,o),m=RO(t.position,f),v=m,y=0;y<i;y++){var b=GS(v,s,l,h),w=yB(b.y,b.x,e,a);v=RO({x:b.x*s,y:b.y*s},{x:w.x,y:w.y})}var S=GS(v,s,l,h),N=r.get(S.y,S.x,e);return{position:v,part:A1[e],score:N}}function Att(n,t,e,r,a,s){var o=t.shape[2],i=WS.length,u=new Array(o),l=n.part,h=n.score,d=bB(l,r,e);u[l.id]={score:h,part:A1[l.id],position:d};for(var f=i-1;f>=0;--f){var m=WS[f],v=AO[f];u[m]&&!u[v]&&(u[v]=DO(f,u[m],v,t,e,r,s))}for(var f=0;f<i;++f){var m=AO[f],v=WS[f];u[m]&&!u[v]&&(u[v]=DO(f,u[m],v,t,e,r,a))}return u}function kB(n,t,e,r){var a=e.x,s=e.y;return n.some(function(o){var i=o.keypoints,u=i[r].position;return vtt(s,a,u.y,u.x)<=t})}function Dtt(n,t,e){var r=e.reduce(function(a,s,o){var i=s.position,u=s.score;return kB(n,t,i,o)||(a+=u),a},0);return r/=e.length}var $tt=1;function By(n,t,e,r,a,s,o,i){o===void 0&&(o=.5),i===void 0&&(i=20);for(var u=[],l=_tt(o,$tt,n),h=i*i;u.length<s&&!l.empty();){var d=l.dequeue(),f=bB(d.part,a,t);if(!kB(u,h,f,d.part.id)){var m=Att(d,n,t,a,e,r),v=Dtt(u,h,m);u.push({keypoints:m,score:v})}}return u}var Ott=[-123.15,-115.9,-103.06],Ftt=(function(n){mB(t,n);function t(){return n!==null&&n.apply(this,arguments)||this}return t.prototype.preprocessInput=function(e){return It(e,Ott)},t.prototype.nameOutputResults=function(e){var r=e[0],a=e[1],s=e[2],o=e[3],i=e[4],u=e[5],l=e[6],h=e[7];return{offsets:i,segmentation:l,partHeatmaps:u,longOffsets:o,heatmap:s,displacementFwd:a,displacementBwd:r,partOffsets:h}},t})(vB);var $O="https://storage.googleapis.com/tfjs-models/savedmodel/bodypix/resnet50/",OO="https://storage.googleapis.com/tfjs-models/savedmodel/bodypix/mobilenet/";function Mtt(n,t){var e="model-stride".concat(n,".json");return t===4?$O+"float/"+e:$O+"quant".concat(t,"/")+e}function Ltt(n,t,e){var r={1:"100",.75:"075",.5:"050"},a="model-stride".concat(n,".json");return e===4?OO+"float/".concat(r[t],"/")+a:OO+"quant".concat(e,"/").concat(r[t],"/")+a}var bh;function Btt(n){if("offsetHeight"in n&&n.offsetHeight!==0&&"offsetWidth"in n&&n.offsetWidth!==0)return[n.offsetHeight,n.offsetWidth];if(n.height!=null&&n.width!=null)return[n.height,n.width];throw new Error("HTMLImageElement must have height and width attributes set.")}function ztt(n){return n.hasAttribute("height")&&n.hasAttribute("width")?[n.height,n.width]:[n.videoHeight,n.videoWidth]}function $f(n){if(typeof HTMLCanvasElement<"u"&&n instanceof HTMLCanvasElement||typeof OffscreenCanvas<"u"&&n instanceof OffscreenCanvas||typeof HTMLImageElement<"u"&&n instanceof HTMLImageElement)return Btt(n);if(typeof ImageData<"u"&&n instanceof ImageData)return[n.height,n.width];if(typeof HTMLVideoElement<"u"&&n instanceof HTMLVideoElement)return ztt(n);if(n instanceof Ae)return[n.shape[0],n.shape[1]];throw new Error("error: Unknown input type: ".concat(n,"."))}function Ptt(n,t){return(n-1)%t===0}function FO(n,t){return Ptt(n,t)?n:Math.floor(n/t)*t+1}var Of={low:"low",medium:"medium",high:"high",full:"full"},Vtt=(bh={},bh[Of.low]=.25,bh[Of.medium]=.5,bh[Of.high]=.75,bh[Of.full]=1,bh),MO=.1,LO=2;function Utt(n){if(typeof n=="string"){var t=Vtt[n];return P(typeof t=="number",function(){return"string value of inputResolution must be one of ".concat(Object.values(Of).join(",")," but was ").concat(n,".")}),t}else return P(typeof n=="number"&&n<=LO&&n>=MO,function(){return"inputResolution must be a string or number between ".concat(MO," and ").concat(LO,", but ")+"was ".concat(n)}),n}function zy(n,t,e){var r=e[0],a=e[1],s=Utt(n);return[FO(r*s,t),FO(a*s,t)]}function Wtt(n){return n instanceof Ae?n:rE(n)}function xh(n,t,e,r,a){var s=t[0],o=t[1],i=e[0],u=e[1],l=r[0],h=l[0],d=l[1],f=r[1],m=f[0],v=f[1];return ut(function(){var y=ha.resizeBilinear(n,[i,u],!0);return y=Va(y),Gtt(y,[s,o],[[h,d],[m,v]])})}function Gtt(n,t,e){var r=t[0],a=t[1],s=e[0],o=s[0],i=s[1],u=e[1],l=u[0],h=u[1];return ut(function(){var d=Pn(n);return $r(ha.cropAndResize(d,[[o/(r+o+i-1),l/(a+l+h-1),(o+r-1)/(r+o+i-1),(l+a-1)/(a+l+h-1)]],[0],[r,a]),[0])})}function Py(n,t){var e=t[0],r=t[1],a=$f(n),s=a[0],o=a[1],i=r/e,u=o/s,l=[0,0,0,0],h=l[0],d=l[1],f=l[2],m=l[3];u<i?(h=0,d=0,f=Math.round(.5*(i*s-o)),m=Math.round(.5*(i*s-o))):(h=Math.round(.5*(1/i*o-s)),d=Math.round(.5*(1/i*o-s)),f=0,m=0);var v=ut(function(){var y=Wtt(n);return y=ET(y,[[h,d],[f,m],[0,0]]),ha.resizeBilinear(y,[e,r])});return{resized:v,padding:{top:h,left:f,right:m,bottom:d}}}function Vy(n){return _o(this,void 0,void 0,function(){return Ro(this,function(t){return[2,Promise.all(n.map(function(e){return e.buffer()}))]})})}function Htt(n,t,e,r,a){return r===void 0&&(r=0),a===void 0&&(a=0),{score:n.score,keypoints:n.keypoints.map(function(s){var o=s.score,i=s.part,u=s.position;return{score:o,part:i,position:{x:u.x*e+a,y:u.y*t+r}}})}}function jtt(n,t,e,r,a){return r===void 0&&(r=0),a===void 0&&(a=0),e===1&&t===1&&r===0&&a===0?n:n.map(function(s){return Htt(s,t,e,r,a)})}function Uy(n,t,e,r,a){var s=t[0],o=t[1],i=e[0],u=e[1],l=(s+r.top+r.bottom)/i,h=(o+r.left+r.right)/u,d=jtt(n,l,h,-r.top,-r.left);return d}var TB={architecture:"MobileNetV1",outputStride:16,quantBytes:4,multiplier:.75},BO=["MobileNetV1","ResNet50"],zO={MobileNetV1:[8,16,32],ResNet50:[32,16]},PO={MobileNetV1:[.5,.75,1],ResNet50:[1]},VO=[1,2,4];function qtt(n){if(n=n||TB,n.architecture==null&&(n.architecture="MobileNetV1"),BO.indexOf(n.architecture)<0)throw new Error("Invalid architecture ".concat(n.architecture,". ")+"Should be one of ".concat(BO));if(n.outputStride==null&&(n.outputStride=16),zO[n.architecture].indexOf(n.outputStride)<0)throw new Error("Invalid outputStride ".concat(n.outputStride,". ")+"Should be one of ".concat(zO[n.architecture]," ")+"for architecture ".concat(n.architecture,"."));if(n.multiplier==null&&(n.multiplier=1),PO[n.architecture].indexOf(n.multiplier)<0)throw new Error("Invalid multiplier ".concat(n.multiplier,". ")+"Should be one of ".concat(PO[n.architecture]," ")+"for architecture ".concat(n.architecture,"."));if(n.quantBytes==null&&(n.quantBytes=4),VO.indexOf(n.quantBytes)<0)throw new Error("Invalid quantBytes ".concat(n.quantBytes,". ")+"Should be one of ".concat(VO," ")+"for architecture ".concat(n.architecture,"."));return n}var Wy={flipHorizontal:!1,internalResolution:"medium",segmentationThreshold:.7,maxDetections:10,scoreThreshold:.4,nmsRadius:20},Gy={flipHorizontal:!1,internalResolution:"medium",segmentationThreshold:.7,maxDetections:10,scoreThreshold:.4,nmsRadius:20,minKeypointScore:.3,refineSteps:10};function UO(n){var t=n.segmentationThreshold,e=n.maxDetections,r=n.scoreThreshold,a=n.nmsRadius;if(t<0||t>1)throw new Error("segmentationThreshold ".concat(t,". ")+"Should be in range [0.0, 1.0]");if(e<=0)throw new Error("Invalid maxDetections ".concat(e,". ")+"Should be > 0");if(r<0||r>1)throw new Error("Invalid scoreThreshold ".concat(r,". ")+"Should be in range [0.0, 1.0]");if(a<=0)throw new Error("Invalid nmsRadius ".concat(a,"."))}function WO(n){var t=n.segmentationThreshold,e=n.maxDetections,r=n.scoreThreshold,a=n.nmsRadius,s=n.minKeypointScore,o=n.refineSteps;if(t<0||t>1)throw new Error("segmentationThreshold ".concat(t,". ")+"Should be in range [0.0, 1.0]");if(e<=0)throw new Error("Invalid maxDetections ".concat(e,". ")+"Should be > 0");if(r<0||r>1)throw new Error("Invalid scoreThreshold ".concat(r,". ")+"Should be in range [0.0, 1.0]");if(a<=0)throw new Error("Invalid nmsRadius ".concat(a,"."));if(s<0||s>1)throw new Error("Invalid minKeypointScore ".concat(s,".")+"Should be in range [0.0, 1.0]");if(o<=0||o>20)throw new Error("Invalid refineSteps ".concat(o,".")+"Should be in range [1, 20]")}var EB=(function(){function n(t){this.baseModel=t}return n.prototype.predictForPersonSegmentation=function(t){var e=this.baseModel.predict(t),r=e.segmentation,a=e.heatmapScores,s=e.offsets,o=e.displacementFwd,i=e.displacementBwd;return{segmentLogits:r,heatmapScores:a,offsets:s,displacementFwd:o,displacementBwd:i}},n.prototype.predictForPersonSegmentationAndPart=function(t){var e=this.baseModel.predict(t),r=e.segmentation,a=e.partHeatmaps,s=e.heatmapScores,o=e.offsets,i=e.displacementFwd,u=e.displacementBwd;return{segmentLogits:r,partHeatmapLogits:a,heatmapScores:s,offsets:o,displacementFwd:i,displacementBwd:u}},n.prototype.predictForMultiPersonInstanceSegmentationAndPart=function(t){var e=this.baseModel.predict(t),r=e.segmentation,a=e.longOffsets,s=e.heatmapScores,o=e.offsets,i=e.displacementFwd,u=e.displacementBwd,l=e.partHeatmaps;return{segmentLogits:r,longOffsets:a,heatmapScores:s,offsets:o,displacementFwd:i,displacementBwd:u,partHeatmaps:l}},n.prototype.segmentPersonActivation=function(t,e,r){var a=this;r===void 0&&(r=.5);var s=$f(t),o=s[0],i=s[1],u=zy(e,this.baseModel.outputStride,[o,i]),l=Py(t,u),h=l.resized,d=l.padding,f=ut(function(){var S=a.predictForPersonSegmentation(h),N=S.segmentLogits,C=S.heatmapScores,T=S.offsets,I=S.displacementFwd,_=S.displacementBwd,$=h.shape,R=$[0],D=$[1],A=xh(N,[o,i],[R,D],[[d.top,d.bottom],[d.left,d.right]]);return{segmentation:Ly($r(A),r),heatmapScores:C,offsets:T,displacementFwd:I,displacementBwd:_}}),m=f.segmentation,v=f.heatmapScores,y=f.offsets,b=f.displacementFwd,w=f.displacementBwd;return h.dispose(),{segmentation:m,heatmapScores:v,offsets:y,displacementFwd:b,displacementBwd:w,padding:d,internalResolutionHeightAndWidth:u}},n.prototype.segmentPerson=function(t,e){return e===void 0&&(e=Wy),_o(this,void 0,void 0,function(){var r,a,s,o,i,u,l,h,d,f,m,v,y,b,w,S,N,C;return Ro(this,function(T){switch(T.label){case 0:return e=xo(xo({},Wy),e),UO(e),r=this.segmentPersonActivation(t,e.internalResolution,e.segmentationThreshold),a=r.segmentation,s=r.heatmapScores,o=r.offsets,i=r.displacementFwd,u=r.displacementBwd,l=r.padding,h=r.internalResolutionHeightAndWidth,d=a.shape,f=d[0],m=d[1],[4,a.data()];case 1:return v=T.sent(),a.dispose(),[4,Vy([s,o,i,u])];case 2:return y=T.sent(),b=y[0],w=y[1],S=y[2],N=y[3],C=By(b,w,S,N,this.baseModel.outputStride,e.maxDetections,e.scoreThreshold,e.nmsRadius),C=Uy(C,[f,m],h,l),s.dispose(),o.dispose(),i.dispose(),u.dispose(),[2,{height:f,width:m,data:v,allPoses:C}]}})})},n.prototype.segmentMultiPerson=function(t,e){return e===void 0&&(e=Gy),_o(this,void 0,void 0,function(){var r,a,s,o,i,u,l,h,d,f,m,v,y,b,w,S,N,C,T,I,_,$=this;return Ro(this,function(R){switch(R.label){case 0:return e=xo(xo({},Gy),e),WO(e),r=$f(t),a=r[0],s=r[1],o=zy(e.internalResolution,this.baseModel.outputStride,[a,s]),i=Py(t,o),u=i.resized,l=i.padding,h=ut(function(){var D=$.predictForMultiPersonInstanceSegmentationAndPart(u),A=D.segmentLogits,L=D.longOffsets,H=D.heatmapScores,G=D.offsets,q=D.displacementFwd,B=D.displacementBwd,j=xh(A,[a,s],o,[[l.top,l.bottom],[l.left,l.right]]),K;K=L;var z=Ly($r(j),e.segmentationThreshold);return{segmentation:z,longOffsets:K,heatmapScoresRaw:H,offsetsRaw:G,displacementFwdRaw:q,displacementBwdRaw:B}}),d=h.segmentation,f=h.longOffsets,m=h.heatmapScoresRaw,v=h.offsetsRaw,y=h.displacementFwdRaw,b=h.displacementBwdRaw,[4,Vy([m,v,y,b])];case 1:return w=R.sent(),S=w[0],N=w[1],C=w[2],T=w[3],I=By(S,N,C,T,this.baseModel.outputStride,e.maxDetections,e.scoreThreshold,e.nmsRadius),I=Uy(I,[a,s],o,l),[4,ktt(d,f,I,a,s,this.baseModel.outputStride,o,l,e.scoreThreshold,e.refineSteps,e.minKeypointScore,e.maxDetections)];case 2:return _=R.sent(),u.dispose(),d.dispose(),f.dispose(),m.dispose(),v.dispose(),y.dispose(),b.dispose(),[2,_]}})})},n.prototype.segmentPersonPartsActivation=function(t,e,r){var a=this;r===void 0&&(r=.5);var s=$f(t),o=s[0],i=s[1],u=zy(e,this.baseModel.outputStride,[o,i]),l=Py(t,u),h=l.resized,d=l.padding,f=ut(function(){var S=a.predictForPersonSegmentationAndPart(h),N=S.segmentLogits,C=S.partHeatmapLogits,T=S.heatmapScores,I=S.offsets,_=S.displacementFwd,$=S.displacementBwd,R=h.shape,D=R[0],A=R[1],L=xh(N,[o,i],[D,A],[[d.top,d.bottom],[d.left,d.right]]),H=xh(C,[o,i],[D,A],[[d.top,d.bottom],[d.left,d.right]]),G=Ly($r(L),r);return{partSegmentation:dtt(G,H),heatmapScores:T,offsets:I,displacementFwd:_,displacementBwd:$}}),m=f.partSegmentation,v=f.heatmapScores,y=f.offsets,b=f.displacementFwd,w=f.displacementBwd;return h.dispose(),{partSegmentation:m,heatmapScores:v,offsets:y,displacementFwd:b,displacementBwd:w,padding:d,internalResolutionHeightAndWidth:u}},n.prototype.segmentPersonParts=function(t,e){return e===void 0&&(e=Wy),_o(this,void 0,void 0,function(){var r,a,s,o,i,u,l,h,d,f,m,v,y,b,w,S,N,C;return Ro(this,function(T){switch(T.label){case 0:return e=xo(xo({},Wy),e),UO(e),r=this.segmentPersonPartsActivation(t,e.internalResolution,e.segmentationThreshold),a=r.partSegmentation,s=r.heatmapScores,o=r.offsets,i=r.displacementFwd,u=r.displacementBwd,l=r.padding,h=r.internalResolutionHeightAndWidth,d=a.shape,f=d[0],m=d[1],[4,a.data()];case 1:return v=T.sent(),a.dispose(),[4,Vy([s,o,i,u])];case 2:return y=T.sent(),b=y[0],w=y[1],S=y[2],N=y[3],C=By(b,w,S,N,this.baseModel.outputStride,e.maxDetections,e.scoreThreshold,e.nmsRadius),C=Uy(C,[f,m],h,l),s.dispose(),o.dispose(),i.dispose(),u.dispose(),[2,{height:f,width:m,data:v,allPoses:C}]}})})},n.prototype.segmentMultiPersonParts=function(t,e){return e===void 0&&(e=Gy),_o(this,void 0,void 0,function(){var r,a,s,o,i,u,l,h,d,f,m,v,y,b,w,S,N,C,T,I,_,$,R=this;return Ro(this,function(D){switch(D.label){case 0:return e=xo(xo({},Gy),e),WO(e),r=$f(t),a=r[0],s=r[1],o=zy(e.internalResolution,this.baseModel.outputStride,[a,s]),i=Py(t,o),u=i.resized,l=i.padding,h=ut(function(){var A=R.predictForMultiPersonInstanceSegmentationAndPart(u),L=A.segmentLogits,H=A.longOffsets,G=A.heatmapScores,q=A.offsets,B=A.displacementFwd,j=A.displacementBwd,K=A.partHeatmaps,z=xh(L,[a,s],o,[[l.top,l.bottom],[l.left,l.right]]),U=xh(K,[a,s],o,[[l.top,l.bottom],[l.left,l.right]]),M=H,X=Ly($r(z),e.segmentationThreshold),Q=ptt(U);return{segmentation:X,longOffsets:M,heatmapScoresRaw:G,offsetsRaw:q,displacementFwdRaw:B,displacementBwdRaw:j,partSegmentation:Q}}),d=h.segmentation,f=h.longOffsets,m=h.heatmapScoresRaw,v=h.offsetsRaw,y=h.displacementFwdRaw,b=h.displacementBwdRaw,w=h.partSegmentation,[4,Vy([m,v,y,b])];case 1:return S=D.sent(),N=S[0],C=S[1],T=S[2],I=S[3],_=By(N,C,T,I,this.baseModel.outputStride,e.maxDetections,e.scoreThreshold,e.nmsRadius),_=Uy(_,[a,s],o,l),[4,Ttt(d,f,w,_,a,s,this.baseModel.outputStride,o,l,e.scoreThreshold,e.refineSteps,e.minKeypointScore,e.maxDetections)];case 2:return $=D.sent(),u.dispose(),d.dispose(),f.dispose(),m.dispose(),v.dispose(),y.dispose(),b.dispose(),w.dispose(),[2,$]}})})},n.prototype.dispose=function(){this.baseModel.dispose()},n})();function Ktt(n){return _o(this,void 0,void 0,function(){var t,e,r,a,s,o;return Ro(this,function(i){switch(i.label){case 0:if(t=n.outputStride,e=n.quantBytes,r=n.multiplier,_E==null)throw new Error(`Cannot find TensorFlow.js. If you are using a <script> tag, please also include @tensorflow/tfjs on the page before using this
        model.`);return a=Ltt(t,r,e),[4,rm(n.modelUrl||a)];case 1:return s=i.sent(),o=new ftt(s,t),[2,new EB(o)]}})})}function Xtt(n){return _o(this,void 0,void 0,function(){var t,e,r,a,s;return Ro(this,function(o){switch(o.label){case 0:if(t=n.outputStride,e=n.quantBytes,_E==null)throw new Error(`Cannot find TensorFlow.js. If you are using a <script> tag, please also include @tensorflow/tfjs on the page before using this
        model.`);return r=Mtt(t,e),[4,rm(n.modelUrl||r)];case 1:return a=o.sent(),s=new Ftt(a,t),[2,new EB(s)]}})})}function Ytt(n){return n===void 0&&(n=TB),_o(this,void 0,void 0,function(){return Ro(this,function(t){return n=qtt(n),n.architecture==="ResNet50"?[2,Xtt(n)]:n.architecture==="MobileNetV1"?[2,Ktt(n)]:[2,null]})})}var Ff={exports:{}};const Qtt=Ck(ctt),Ztt=Ck(_E);var Jtt=Ff.exports,GO;function tet(){return GO||(GO=1,(function(n,t){(function(e,r){r(t,Qtt,Ztt)})(Jtt,(function(e,r,a){const s={1:{name:"/m/01g317",id:1,displayName:"person"},2:{name:"/m/0199g",id:2,displayName:"bicycle"},3:{name:"/m/0k4j",id:3,displayName:"car"},4:{name:"/m/04_sv",id:4,displayName:"motorcycle"},5:{name:"/m/05czz6l",id:5,displayName:"airplane"},6:{name:"/m/01bjv",id:6,displayName:"bus"},7:{name:"/m/07jdr",id:7,displayName:"train"},8:{name:"/m/07r04",id:8,displayName:"truck"},9:{name:"/m/019jd",id:9,displayName:"boat"},10:{name:"/m/015qff",id:10,displayName:"traffic light"},11:{name:"/m/01pns0",id:11,displayName:"fire hydrant"},13:{name:"/m/02pv19",id:13,displayName:"stop sign"},14:{name:"/m/015qbp",id:14,displayName:"parking meter"},15:{name:"/m/0cvnqh",id:15,displayName:"bench"},16:{name:"/m/015p6",id:16,displayName:"bird"},17:{name:"/m/01yrx",id:17,displayName:"cat"},18:{name:"/m/0bt9lr",id:18,displayName:"dog"},19:{name:"/m/03k3r",id:19,displayName:"horse"},20:{name:"/m/07bgp",id:20,displayName:"sheep"},21:{name:"/m/01xq0k1",id:21,displayName:"cow"},22:{name:"/m/0bwd_0j",id:22,displayName:"elephant"},23:{name:"/m/01dws",id:23,displayName:"bear"},24:{name:"/m/0898b",id:24,displayName:"zebra"},25:{name:"/m/03bk1",id:25,displayName:"giraffe"},27:{name:"/m/01940j",id:27,displayName:"backpack"},28:{name:"/m/0hnnb",id:28,displayName:"umbrella"},31:{name:"/m/080hkjn",id:31,displayName:"handbag"},32:{name:"/m/01rkbr",id:32,displayName:"tie"},33:{name:"/m/01s55n",id:33,displayName:"suitcase"},34:{name:"/m/02wmf",id:34,displayName:"frisbee"},35:{name:"/m/071p9",id:35,displayName:"skis"},36:{name:"/m/06__v",id:36,displayName:"snowboard"},37:{name:"/m/018xm",id:37,displayName:"sports ball"},38:{name:"/m/02zt3",id:38,displayName:"kite"},39:{name:"/m/03g8mr",id:39,displayName:"baseball bat"},40:{name:"/m/03grzl",id:40,displayName:"baseball glove"},41:{name:"/m/06_fw",id:41,displayName:"skateboard"},42:{name:"/m/019w40",id:42,displayName:"surfboard"},43:{name:"/m/0dv9c",id:43,displayName:"tennis racket"},44:{name:"/m/04dr76w",id:44,displayName:"bottle"},46:{name:"/m/09tvcd",id:46,displayName:"wine glass"},47:{name:"/m/08gqpm",id:47,displayName:"cup"},48:{name:"/m/0dt3t",id:48,displayName:"fork"},49:{name:"/m/04ctx",id:49,displayName:"knife"},50:{name:"/m/0cmx8",id:50,displayName:"spoon"},51:{name:"/m/04kkgm",id:51,displayName:"bowl"},52:{name:"/m/09qck",id:52,displayName:"banana"},53:{name:"/m/014j1m",id:53,displayName:"apple"},54:{name:"/m/0l515",id:54,displayName:"sandwich"},55:{name:"/m/0cyhj_",id:55,displayName:"orange"},56:{name:"/m/0hkxq",id:56,displayName:"broccoli"},57:{name:"/m/0fj52s",id:57,displayName:"carrot"},58:{name:"/m/01b9xk",id:58,displayName:"hot dog"},59:{name:"/m/0663v",id:59,displayName:"pizza"},60:{name:"/m/0jy4k",id:60,displayName:"donut"},61:{name:"/m/0fszt",id:61,displayName:"cake"},62:{name:"/m/01mzpv",id:62,displayName:"chair"},63:{name:"/m/02crq1",id:63,displayName:"couch"},64:{name:"/m/03fp41",id:64,displayName:"potted plant"},65:{name:"/m/03ssj5",id:65,displayName:"bed"},67:{name:"/m/04bcr3",id:67,displayName:"dining table"},70:{name:"/m/09g1w",id:70,displayName:"toilet"},72:{name:"/m/07c52",id:72,displayName:"tv"},73:{name:"/m/01c648",id:73,displayName:"laptop"},74:{name:"/m/020lf",id:74,displayName:"mouse"},75:{name:"/m/0qjjc",id:75,displayName:"remote"},76:{name:"/m/01m2v",id:76,displayName:"keyboard"},77:{name:"/m/050k8",id:77,displayName:"cell phone"},78:{name:"/m/0fx9l",id:78,displayName:"microwave"},79:{name:"/m/029bxz",id:79,displayName:"oven"},80:{name:"/m/01k6s3",id:80,displayName:"toaster"},81:{name:"/m/0130jx",id:81,displayName:"sink"},82:{name:"/m/040b_t",id:82,displayName:"refrigerator"},84:{name:"/m/0bt_c3",id:84,displayName:"book"},85:{name:"/m/01x3z",id:85,displayName:"clock"},86:{name:"/m/02s195",id:86,displayName:"vase"},87:{name:"/m/01lsmm",id:87,displayName:"scissors"},88:{name:"/m/0kmg4",id:88,displayName:"teddy bear"},89:{name:"/m/03wvsk",id:89,displayName:"hair drier"},90:{name:"/m/012xff",id:90,displayName:"toothbrush"}};class o{constructor(u,l){this.modelPath=l||`https://storage.googleapis.com/tfjs-models/savedmodel/${this.getPrefix(u)}/model.json`}getPrefix(u){return u==="lite_mobilenet_v2"?`ssd${u}`:`ssd_${u}`}async load(){this.model=await r.loadGraphModel(this.modelPath);const u=a.zeros([1,300,300,3],"int32"),l=await this.model.executeAsync(u);await Promise.all(l.map((h=>h.data()))),l.map((h=>h.dispose())),u.dispose()}async infer(u,l,h){const d=a.tidy((()=>(u instanceof a.Tensor||(u=a.browser.fromPixels(u)),a.expandDims(u)))),f=d.shape[1],m=d.shape[2],v=await this.model.executeAsync(d),y=v[0].dataSync(),b=v[1].dataSync();d.dispose(),a.dispose(v);const[w,S]=this.calculateMaxScores(y,v[0].shape[1],v[0].shape[2]),N=a.getBackend();a.getBackend()==="webgl"&&a.setBackend("cpu");const C=a.tidy((()=>{const I=a.tensor2d(b,[v[1].shape[1],v[1].shape[3]]);return a.image.nonMaxSuppression(I,w,l,h,h)})),T=C.dataSync();return C.dispose(),N!==a.getBackend()&&a.setBackend(N),this.buildDetectedObjects(m,f,b,w,T,S)}buildDetectedObjects(u,l,h,d,f,m){const v=f.length,y=[];for(let b=0;b<v;b++){const w=[];for(let I=0;I<4;I++)w[I]=h[4*f[b]+I];const S=w[0]*l,N=w[1]*u,C=w[2]*l,T=w[3]*u;w[0]=N,w[1]=S,w[2]=T-N,w[3]=C-S,y.push({bbox:w,class:s[m[f[b]]+1].displayName,score:d[f[b]]})}return y}calculateMaxScores(u,l,h){const d=[],f=[];for(let m=0;m<l;m++){let v=Number.MIN_VALUE,y=-1;for(let b=0;b<h;b++)u[m*h+b]>v&&(v=u[m*h+b],y=b);d[m]=v,f[m]=y}return[d,f]}async detect(u,l=20,h=.5){return this.infer(u,l,h)}dispose(){this.model!=null&&this.model.dispose()}}e.ObjectDetection=o,e.load=async function(i={}){if(a==null)throw new Error("Cannot find TensorFlow.js. If you are using a <script> tag, please also include @tensorflow/tfjs on the page before using this model.");const u=i.base||"lite_mobilenet_v2",l=i.modelUrl;if(["mobilenet_v1","mobilenet_v2","lite_mobilenet_v2"].indexOf(u)===-1)throw new Error(`ObjectDetection constructed with invalid base model ${u}. Valid names are 'mobilenet_v1', 'mobilenet_v2' and 'lite_mobilenet_v2'.`);const h=new o(u,l);return await h.load(),h},e.version="2.2.3",Object.defineProperty(e,"__esModule",{value:!0})}))})(Ff,Ff.exports)),Ff.exports}var eet=tet();function _h(n,t,e,r){function a(s){return s instanceof e?s:new e(function(o){o(s)})}return new(e||(e=Promise))(function(s,o){function i(h){try{l(r.next(h))}catch(d){o(d)}}function u(h){try{l(r.throw(h))}catch(d){o(d)}}function l(h){h.done?s(h.value):a(h.value).then(i,u)}l((r=r.apply(n,[])).next())})}function Rh(n,t){var e={label:0,sent:function(){if(s[0]&1)throw s[1];return s[1]},trys:[],ops:[]},r,a,s,o;return o={next:i(0),throw:i(1),return:i(2)},typeof Symbol=="function"&&(o[Symbol.iterator]=function(){return this}),o;function i(l){return function(h){return u([l,h])}}function u(l){if(r)throw new TypeError("Generator is already executing.");for(;e;)try{if(r=1,a&&(s=l[0]&2?a.return:l[0]?a.throw||((s=a.return)&&s.call(a),0):a.next)&&!(s=s.call(a,l[1])).done)return s;switch(a=0,s&&(l=[l[0]&2,s.value]),l[0]){case 0:case 1:s=l;break;case 4:return e.label++,{value:l[1],done:!1};case 5:e.label++,a=l[1],l=[0];continue;case 7:l=e.ops.pop(),e.trys.pop();continue;default:if(s=e.trys,!(s=s.length>0&&s[s.length-1])&&(l[0]===6||l[0]===2)){e=0;continue}if(l[0]===3&&(!s||l[1]>s[0]&&l[1]<s[3])){e.label=l[1];break}if(l[0]===6&&e.label<s[1]){e.label=s[1],s=l;break}if(s&&e.label<s[2]){e.label=s[2],e.ops.push(l);break}s[2]&&e.ops.pop(),e.trys.pop();continue}l=t.call(n,e)}catch(h){l=[6,h],a=0}finally{r=s=0}if(l[0]&5)throw l[1];return{value:l[0]?l[1]:void 0,done:!0}}}var net=function(n){n.startEndTensor.dispose(),n.startPoint.dispose(),n.endPoint.dispose()},ON=function(n){return{startEndTensor:n,startPoint:ue(n,[0,0],[-1,2]),endPoint:ue(n,[0,2],[-1,2])}},ret=function(n,t){var e=et(n.startPoint,t),r=et(n.endPoint,t),a=Ig([e,r],1);return ON(a)};var aet={strides:[8,16],anchors:[2,6]},HO=6;function set(n,t,e){for(var r=[],a=0;a<e.strides.length;a++)for(var s=e.strides[a],o=Math.floor((t+s-1)/s),i=Math.floor((n+s-1)/s),u=e.anchors[a],l=0;l<o;l++)for(var h=s*(l+.5),d=0;d<i;d++)for(var f=s*(d+.5),m=0;m<u;m++)r.push([f,h]);return r}function oet(n,t,e){var r=ue(n,[0,1],[-1,2]),a=It(r,t),s=ue(n,[0,3],[-1,2]),o=Ut(s,e),i=Ut(a,e),u=Ut(o,2),l=zt(i,u),h=It(i,u),d=et(l,e),f=et(h,e),m=1;return Ig([d,f],m)}function iet(n){return n instanceof Ae?[n.shape[0],n.shape[1]]:[n.height,n.width]}function jO(n,t){var e,r,a;if(n.topLeft instanceof Ae&&n.bottomRight instanceof Ae){var s=ut(function(){return[_n([ue(zt(t-1,n.topLeft),0,1),ue(n.topLeft,1,1)]),_n([zt(t-1,ue(n.bottomRight,0,1)),ue(n.bottomRight,1,1)])]}),o=s[0],i=s[1];e=o,r=i,n.landmarks!=null&&(a=ut(function(){var y=zt(sr([t-1,0]),n.landmarks),b=sr([1,-1]),w=et(y,b);return w}))}else{var u=n.topLeft,l=u[0],h=u[1],d=n.bottomRight,f=d[0],m=d[1];e=[t-1-l,h],r=[t-1-f,m],n.landmarks!=null&&(a=n.landmarks.map(function(y){return[t-1-y[0],y[1]]}))}var v={topLeft:e,bottomRight:r};return a!=null&&(v.landmarks=a),n.probability!=null&&(v.probability=n.probability instanceof Ae?n.probability.clone():n.probability),v}function qO(n,t){return ut(function(){var e;return n.hasOwnProperty("box")?e=n.box:e=n,$r(ret(e,t).startEndTensor)})}var uet=(function(){function n(t,e,r,a,s,o){this.blazeFaceModel=t,this.width=e,this.height=r,this.maxFaces=a,this.anchorsData=set(e,r,aet),this.anchors=Iu(this.anchorsData),this.inputSizeData=[e,r],this.inputSize=sr([e,r]),this.iouThreshold=s,this.scoreThreshold=o}return n.prototype.getBoundingBoxes=function(t,e,r){return r===void 0&&(r=!0),_h(this,void 0,void 0,function(){var a,s,o,i,u,l,h,d,f,m,v,y,b,w,S=this;return Rh(this,function(N){switch(N.label){case 0:return a=ut(function(){var C=ha.resizeBilinear(t,[S.width,S.height]),T=et(zt(Ut(C,255),.5),2),I=S.blazeFaceModel.predict(T),_=$r(I),$=oet(_,S.anchors,S.inputSize),R=ue(_,[0,0],[-1,1]),D=$r(Va(R));return[_,$,D]}),s=a[0],o=a[1],i=a[2],u=console.warn,console.warn=function(){},l=ha.nonMaxSuppression(o,i,this.maxFaces,this.iouThreshold,this.scoreThreshold),console.warn=u,[4,l.array()];case 1:return h=N.sent(),l.dispose(),d=h.map(function(C){return ue(o,[C,0],[1,-1])}),e?[3,3]:[4,Promise.all(d.map(function(C){return _h(S,void 0,void 0,function(){var T;return Rh(this,function(I){switch(I.label){case 0:return[4,C.array()];case 1:return T=I.sent(),C.dispose(),[2,T]}})})}))];case 2:d=N.sent(),N.label=3;case 3:for(f=t.shape[1],m=t.shape[2],e?v=Ut([m,f],this.inputSize):v=[m/this.inputSizeData[0],f/this.inputSizeData[1]],y=[],b=function(C){var T=d[C],I=ut(function(){var _=T instanceof Ae?ON(T):ON(Iu(T));if(!r)return _;var $=h[C],R;e?R=ue(S.anchors,[$,0],[1,2]):R=S.anchorsData[$];var D=at($r(ue(s,[$,HO-1],[1,-1])),[HO,-1]),A=ue(i,[$],[1]);return{box:_,landmarks:D,probability:A,anchor:R}});y.push(I)},w=0;w<d.length;w++)b(w);return o.dispose(),i.dispose(),s.dispose(),[2,{boxes:y,scaleFactor:v}]}})})},n.prototype.estimateFaces=function(t,e,r,a){return e===void 0&&(e=!1),r===void 0&&(r=!1),a===void 0&&(a=!0),_h(this,void 0,void 0,function(){var s,o,i,u,l,h,d=this;return Rh(this,function(f){switch(f.label){case 0:return s=iet(t),o=s[1],i=ut(function(){return t instanceof Ae||(t=rE(t)),Pn(Ft(t,"float32"),0)}),[4,this.getBoundingBoxes(i,e,a)];case 1:return u=f.sent(),l=u.boxes,h=u.scaleFactor,i.dispose(),e?[2,l.map(function(m){var v=qO(m,h),y={topLeft:ue(v,[0],[2]),bottomRight:ue(v,[2],[2])};if(a){var b=m,w=b.landmarks,S=b.probability,N=b.anchor,C=et(It(w,N),h);y.landmarks=C,y.probability=S}return r&&(y=jO(y,o)),y})]:[2,Promise.all(l.map(function(m){return _h(d,void 0,void 0,function(){var v,y,S,b,w,S,N,C,T,I,_,$,R=this;return Rh(this,function(D){switch(D.label){case 0:return v=qO(m,h),a?[3,2]:[4,v.array()];case 1:return S=D.sent(),y={topLeft:S.slice(0,2),bottomRight:S.slice(2)},[3,4];case 2:return[4,Promise.all([m.landmarks,v,m.probability].map(function(A){return _h(R,void 0,void 0,function(){return Rh(this,function(L){return[2,A.array()]})})}))];case 3:b=D.sent(),w=b[0],S=b[1],N=b[2],C=m.anchor,T=h,I=T[0],_=T[1],$=w.map(function(A){return[(A[0]+C[0])*I,(A[1]+C[1])*_]}),y={topLeft:S.slice(0,2),bottomRight:S.slice(2),landmarks:$,probability:N},net(m.box),m.landmarks.dispose(),m.probability.dispose(),D.label=4;case 4:return v.dispose(),r&&(y=jO(y,o)),[2,y]}})})}))]}})})},n.prototype.dispose=function(){this.blazeFaceModel.dispose(),this.anchors.dispose(),this.inputSize.dispose()},n})();var cet="https://tfhub.dev/tensorflow/tfjs-model/blazeface/1/default/1";function het(n){var t={},e=t.maxFaces,r=e===void 0?10:e,a=t.inputWidth,s=a===void 0?128:a,o=t.inputHeight,i=o===void 0?128:o,u=t.iouThreshold,l=u===void 0?.3:u,h=t.scoreThreshold,d=h===void 0?.75:h,f=t.modelUrl;return _h(this,void 0,void 0,function(){var m,v;return Rh(this,function(y){switch(y.label){case 0:return f==null?[3,2]:[4,rm(f)];case 1:return m=y.sent(),[3,4];case 2:return[4,rm(cet,{fromTFHub:!0})];case 3:m=y.sent(),y.label=4;case 4:return v=new uet(m,s,i,r,l,d),[2,v]}})})}var IB=function(n,t){return(IB=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,r){e.__proto__=r}||function(e,r){for(var a in r)r.hasOwnProperty(a)&&(e[a]=r[a])})(n,t)};function co(n,t){function e(){this.constructor=n}IB(n,t),n.prototype=t===null?Object.create(t):(e.prototype=t.prototype,new e)}function Yt(n,t,e,r){return new(e||(e=Promise))((function(a,s){function o(l){try{u(r.next(l))}catch(h){s(h)}}function i(l){try{u(r.throw(l))}catch(h){s(h)}}function u(l){l.done?a(l.value):new e((function(h){h(l.value)})).then(o,i)}u((r=r.apply(n,[])).next())}))}function Qt(n,t){var e,r,a,s,o={label:0,sent:function(){if(1&a[0])throw a[1];return a[1]},trys:[],ops:[]};return s={next:i(0),throw:i(1),return:i(2)},typeof Symbol=="function"&&(s[Symbol.iterator]=function(){return this}),s;function i(u){return function(l){return(function(h){if(e)throw new TypeError("Generator is already executing.");for(;o;)try{if(e=1,r&&(a=2&h[0]?r.return:h[0]?r.throw||((a=r.return)&&a.call(r),0):r.next)&&!(a=a.call(r,h[1])).done)return a;switch(r=0,a&&(h=[2&h[0],a.value]),h[0]){case 0:case 1:a=h;break;case 4:return o.label++,{value:h[1],done:!1};case 5:o.label++,r=h[1],h=[0];continue;case 7:h=o.ops.pop(),o.trys.pop();continue;default:if(!(a=(a=o.trys).length>0&&a[a.length-1])&&(h[0]===6||h[0]===2)){o=0;continue}if(h[0]===3&&(!a||h[1]>a[0]&&h[1]<a[3])){o.label=h[1];break}if(h[0]===6&&o.label<a[1]){o.label=a[1],a=h;break}if(a&&o.label<a[2]){o.label=a[2],o.ops.push(h);break}a[2]&&o.ops.pop(),o.trys.pop();continue}h=t.call(n,o)}catch(d){h=[6,d],r=0}finally{e=a=0}if(5&h[0])throw h[1];return{value:h[0]?h[1]:void 0,done:!0}})([u,l])}}}var det=(function(){function n(t){this.global=t,this.flags={},this.flagRegistry={},this.urlFlags={},this.populateURLFlags()}return n.prototype.setPlatform=function(t,e){this.platform!=null&&console.warn("Platform "+this.platformName+" has already been set. Overwriting the platform with "+e+"."),this.platformName=t,this.platform=e},n.prototype.registerFlag=function(t,e,r){if(this.flagRegistry[t]={evaluationFn:e,setHook:r},this.urlFlags[t]!=null){var a=this.urlFlags[t];console.warn("Setting feature override from URL "+t+": "+a+"."),this.set(t,a)}},n.prototype.get=function(t){return t in this.flags?this.flags[t]:(this.flags[t]=this.evaluateFlag(t),this.flags[t])},n.prototype.getNumber=function(t){return this.get(t)},n.prototype.getBool=function(t){return this.get(t)},n.prototype.getFlags=function(){return this.flags},Object.defineProperty(n.prototype,"features",{get:function(){return this.flags},enumerable:!0,configurable:!0}),n.prototype.set=function(t,e){if(this.flagRegistry[t]==null)throw new Error("Cannot set flag "+t+" as it has not been registered.");this.flags[t]=e,this.flagRegistry[t].setHook!=null&&this.flagRegistry[t].setHook(e)},n.prototype.evaluateFlag=function(t){if(this.flagRegistry[t]==null)throw new Error("Cannot evaluate flag '"+t+"': no evaluation function found.");return this.flagRegistry[t].evaluationFn()},n.prototype.setFlags=function(t){this.flags=Object.assign({},t)},n.prototype.reset=function(){this.flags={},this.urlFlags={},this.populateURLFlags()},n.prototype.populateURLFlags=function(){var t=this;if(this.global!==void 0&&this.global.location!==void 0&&this.global.location.search!==void 0){var e,r,a=(e=this.global.location.search,r={},e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(function(s){for(var o=[],i=1;i<arguments.length;i++)o[i-1]=arguments[i];return pet(r,o[0],o[1]),o.join("=")})),r);"tfjsflags"in a&&a.tfjsflags.split(",").forEach((function(s){var o=s.split(":"),i=o[0],u=o[1];t.urlFlags[i]=(function(l,h){if((h=h.toLowerCase())==="true"||h==="false")return h==="true";if(""+ +h===h)return+h;throw new Error("Could not parse value flag value "+h+" for flag "+l+".")})(i,u)}))}},n})();function pet(n,t,e){n[decodeURIComponent(t)]=decodeURIComponent(e||"")}function kt(){return _B}var _B=null,H0=new Map,FN=new Map;function RB(n,t){var e=DB(n,t);return H0.get(e)}function fet(n){return FN.get(n)}function KO(n){for(var t=H0.entries(),e=[];;){var r=t.next(),a=r.done,s=r.value;if(a)break;var o=s[0],i=s[1];o.split("_")[0]===n&&e.push(i)}return e}function AB(n){var t=n.kernelName,e=n.backendName,r=DB(t,e);if(H0.has(r))throw new Error("The kernel '"+t+"' for backend '"+e+"' is already registered");H0.set(r,n)}function met(n){var t=n.kernelName;FN.has(t)&&console.warn("Overriding the gradient for '"+t+"'"),FN.set(t,n)}function DB(n,t){return t+"_"+n}function MN(n,t,e){return Math.max(n,Math.min(t,e))}function $B(n){return n%2==0?n:n+1}function get(n){for(var t=0,e=0;e<n.length;e++)t+=n[e];return t}function Z(n,t){if(!n)throw new Error(typeof t=="string"?t:t())}function Je(n,t,e){e===void 0&&(e=""),Z(Fr(n,t),(function(){return e+" Shapes "+n+" and "+t+" must match"}))}function pp(n){Z(n!=null,(function(){return"The input to the tensor constructor must be a non-null value."}))}function ed(n,t,e){if(t===void 0&&(t=[]),e===void 0&&(e=!1),t==null&&(t=[]),Array.isArray(n)||Mo(n)&&!e)for(var r=0;r<n.length;++r)ed(n[r],t,e);else t.push(n);return t}function ee(n){if(n.length===0)return 1;for(var t=n[0],e=1;e<n.length;e++)t*=n[e];return t}function Fr(n,t){if(n===t)return!0;if(n==null||t==null||n.length!==t.length)return!1;for(var e=0;e<n.length;e++)if(n[e]!==t[e])return!1;return!0}function Qn(n){return n%1==0}function vet(n){if(Math.tanh!=null)return Math.tanh(n);if(n===1/0)return 1;if(n===-1/0)return-1;var t=Math.exp(2*n);return(t-1)/(t+1)}function LN(n){var t=Math.ceil(Math.sqrt(n));return[t,Math.ceil(n/t)]}function Lh(n,t){return t<=n.length?n:n+" ".repeat(t-n.length)}function XO(n,t,e){return t===void 0&&(t=function(r){return 0}),new Promise((function(r,a){var s=0,o=function(){if(n())r();else{s++;var i=t(s);e!=null&&s>=e?a():setTimeout(o,i)}};o()}))}function yet(n,t){for(var e=1,r=-1,a=0;a<n.length;++a)if(n[a]>=0)e*=n[a];else if(n[a]===-1){if(r!==-1)throw Error("Shapes can only have 1 implicit size. Found -1 at dim "+r+" and dim "+a);r=a}else if(n[a]<0)throw Error("Shapes can not be < 0. Found "+n[a]+" at dim "+a);if(r===-1){if(t>0&&t!==e)throw Error("Size("+t+") must match the product of shape "+n);return n}if(e===0)throw Error("Cannot infer the missing size in ["+n+"] when there are 0 elements");if(t%e!=0)throw Error("The implicit shape can't be a fractional number. Got "+t+" / "+e);var s=n.slice();return s[r]=t/e,s}function Tr(n,t){var e=t.length;return Z((n=n==null?t.map((function(r,a){return a})):[].concat(n)).every((function(r){return r>=-e&&r<e})),(function(){return"All values in axis param must be in range [-"+e+", "+e+") but got axis "+n})),Z(n.every((function(r){return Qn(r)})),(function(){return"All values in axis param must be integers but got axis "+n})),n.map((function(r){return r<0?e+r:r}))}function zl(n,t){for(var e=[],r=[],a=t!=null&&Array.isArray(t)&&t.length===0,s=t==null||a?null:Tr(t,n).sort(),o=0,i=0;i<n.length;++i){if(s!=null){if(s[o]===i&&n[i]!==1)throw new Error("Can't squeeze axis "+i+" since its dim '"+n[i]+"' is not 1");(s[o]==null||s[o]>i)&&n[i]===1&&(e.push(n[i]),r.push(i)),s[o]<=i&&o++}n[i]!==1&&(e.push(n[i]),r.push(i))}return{newShape:e,keptDims:r}}function am(n,t){var e=null;if(n==null||n==="float32")e=new Float32Array(t);else if(n==="int32")e=new Int32Array(t);else{if(n!=="bool")throw new Error("Unknown data type "+n);e=new Uint8Array(t)}return e}function j0(n,t){var e=null;if(n==null||n==="float32")e=new Float32Array(t);else if(n==="int32")e=new Int32Array(t);else if(n==="bool")e=new Uint8Array(t);else{if(n!=="string")throw new Error("Unknown data type "+n);e=new Array(t)}return e}function bet(n,t){for(var e=0;e<n.length;e++){var r=n[e];if(isNaN(r)||!isFinite(r))throw Error("A tensor of type "+t+" being uploaded contains "+r+".")}}function xet(n){return n==="bool"||n==="complex64"||n==="float32"||n==="int32"||n==="string"}function wet(n,t){return t!=="complex64"&&(t!=="float32"||n==="complex64")&&(t!=="int32"||n==="float32"||n==="complex64")&&(t!=="bool"||n!=="bool")}function Mo(n){return n instanceof Float32Array||n instanceof Int32Array||n instanceof Uint8Array}function OB(n){if(n==="float32"||n==="int32")return 4;if(n==="complex64")return 8;if(n==="bool")return 1;throw new Error("Unknown dtype "+n)}function Cet(n){if(n==null)return 0;var t=0;return n.forEach((function(e){return t+=e.length})),t}function OE(n){return typeof n=="string"||n instanceof String}function Net(n){return typeof n=="boolean"}function ket(n){return typeof n=="number"}function qg(n){return Array.isArray(n)?qg(n[0]):n instanceof Float32Array?"float32":n instanceof Int32Array||n instanceof Uint8Array?"int32":ket(n)?"float32":OE(n)?"string":Net(n)?"bool":"float32"}function BN(n){return!!(n&&n.constructor&&n.call&&n.apply)}function zN(n,t){for(var e=t;e<n;++e)if(n%e==0)return e;return n}function Lo(n){var t=n.length;if(t<2)return[];var e=new Array(t-1);e[t-2]=n[t-1];for(var r=t-3;r>=0;--r)e[r]=e[r+1]*n[r+1];return e}function FB(n,t,e){if(t==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(n)&&(n=ed(n)),e&&bet(n,t),(function(s,o){return s instanceof Float32Array&&o==="float32"||s instanceof Int32Array&&o==="int32"||s instanceof Uint8Array&&o==="bool"})(n,t))return n;if(t==null||t==="float32"||t==="complex64")return new Float32Array(n);if(t==="int32")return new Int32Array(n);if(t==="bool"){for(var r=new Uint8Array(n.length),a=0;a<r.length;++a)Math.round(n[a])!==0&&(r[a]=1);return r}throw new Error("Unknown data type "+t)}function YO(n,t){if(n.length===0)return t[0];var e=n.reduce((function(r,a){return r*a}));if(e===0)return[];if(e!==t.length)throw new Error("["+n+"] does not match the input size.");return(function r(a,s,o){var i=new Array;if(s.length===1)for(var u=s[0],l=0;l<u;l++)i[l]=o[a+l];else{u=s[0];var h=s.slice(1),d=h.reduce((function(f,m){return f*m}));for(l=0;l<u;l++)i[l]=r(a+l*d,h,o)}return i})(0,n,t)}function MB(n,t){for(var e=Kg(n,t),r=0;r<e.length;r++)e[r]=1;return e}function Kg(n,t){if(t==null||t==="float32"||t==="complex64")return new Float32Array(n);if(t==="int32")return new Int32Array(n);if(t==="bool")return new Uint8Array(n);throw new Error("Unknown data type "+t)}function So(){return kt().platform.now()}function LB(n){n.forEach((function(t){Z(Number.isInteger(t)&&t>=0,(function(){return"Tensor must have a shape comprised of positive integers but got shape ["+n+"]."}))}))}function Tet(n,t){return t===void 0&&(t="utf-8"),t=t||"utf-8",kt().platform.encode(n,t)}function q0(n,t){return t===void 0&&(t="utf-8"),t=t||"utf-8",kt().platform.decode(n,t)}function QO(n,t,e){if(t===0)return 0;if(t===1)return n[0];for(var r=n[n.length-1],a=0;a<n.length-1;++a)r+=e[a]*n[a];return r}function Eet(n,t,e){if(t===0)return[];if(t===1)return[n];for(var r=new Array(t),a=0;a<r.length-1;++a)r[a]=Math.floor(n/e[a]),n-=r[a]*e[a];return r[r.length-1]=n,r}var Iet=(function(){function n(t,e){this.backendTimer=t,this.logger=e,e==null&&(this.logger=new _et)}return n.prototype.profileKernel=function(t,e,r){var a,s=this,o=this.backendTimer.time((function(){a=r()}));return a.forEach((function(i){i.data().then((function(u){(function(l,h,d){if(h!=="float32")return!1;for(var f=0;f<l.length;f++){var m=l[f];if(isNaN(m)||!isFinite(m))return console.warn("Found "+m+" in the result of '"+d+"'"),!0}})(u,i.dtype,t),o.then((function(l){var h="";l.getExtraProfileInfo!=null&&(h=l.getExtraProfileInfo()),s.logger.logKernelProfile(t,i,u,l.kernelMs,e,h)}))}))})),a},n})(),_et=(function(){function n(){}return n.prototype.logKernelProfile=function(t,e,r,a,s,o){var i=typeof a=="number"?Lh(a+"ms",9):a.error,u=Lh(t,25),l=e.rank,h=e.size,d=Lh(e.shape.toString(),14),f="";for(var m in s){var v=s[m].shape||e.shape,y=v.length;f+=m+": "+y+"D "+(y>0?v:"")+" "}console.log("%c"+u+"	%c"+i+"	%c"+l+"D "+d+"	%c"+h+"	%c"+f+"	%c"+o,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")},n})(),ZO=20,Nf=3,HS=7;function Ret(n,t,e,r){var a=Lo(t),s=(function(l,h,d,f){var m=ee(h),v=f[f.length-1],y=new Array(v).fill(0),b=h.length,w=d==="complex64"?Tf(l):l;if(b>1)for(var S=0;S<m/v;S++)for(var N=S*v,C=0;C<v;C++)y[C]=Math.max(y[C],kf(w[N+C],0,d).length);return y})(n,t,e,a),o=t.length,i=(function l(h,d,f,m,v,y){y===void 0&&(y=!0);var b=f==="complex64"?2:1,w=d[0],S=d.length;if(S===0)return f==="complex64"?[kf(Tf(h)[0],0,f)]:f==="bool"?[BB(h[0])]:[h[0].toString()];if(S===1){if(w>ZO){var N=Nf*b,C=Array.from(h.slice(0,N)),T=Array.from(h.slice((w-Nf)*b,w*b));return f==="complex64"&&(C=Tf(C),T=Tf(T)),["["+C.map((function(q,B){return kf(q,v[B],f)})).join(", ")+", ..., "+T.map((function(q,B){return kf(q,v[w-Nf+B],f)})).join(", ")+"]"]}return["["+(f==="complex64"?Tf(h):Array.from(h)).map((function(q,B){return kf(q,v[B],f)})).join(", ")+"]"]}var I=d.slice(1),_=m.slice(1),$=m[0]*b,R=[];if(w>ZO){for(var D=0;D<Nf;D++){var A=(L=D*$)+$;R.push.apply(R,l(h.slice(L,A),I,f,_,v,!1))}for(R.push("..."),D=w-Nf;D<w;D++)A=(L=D*$)+$,R.push.apply(R,l(h.slice(L,A),I,f,_,v,D===w-1))}else for(D=0;D<w;D++){var L;A=(L=D*$)+$,R.push.apply(R,l(h.slice(L,A),I,f,_,v,D===w-1))}var H=S===2?",":"";for(R[0]="["+R[0]+H,D=1;D<R.length-1;D++)R[D]=" "+R[D]+H;var G=`,
`;for(D=2;D<S;D++)G+=`
`;return R[R.length-1]=" "+R[R.length-1]+"]"+(y?"":G),R})(n,t,e,a,s),u=["Tensor"];return r&&(u.push("  dtype: "+e),u.push("  rank: "+o),u.push("  shape: ["+t+"]"),u.push("  values:")),u.push(i.map((function(l){return"    "+l})).join(`
`)),u.join(`
`)}function kf(n,t,e){return Lh(Array.isArray(n)?parseFloat(n[0].toFixed(HS))+" + "+parseFloat(n[1].toFixed(HS))+"j":OE(n)?"'"+n+"'":e==="bool"?BB(n):parseFloat(n.toFixed(HS)).toString(),t)}function BB(n){return n===0?"false":"true"}function Tf(n){for(var t=[],e=0;e<n.length;e+=2)t.push([n[e],n[e+1]]);return t}var sm=(function(){function n(t,e,r){var a=this;if(this.dtype=e,this.shape=t.slice(),this.size=ee(t),r!=null){var s=r.length;Z(s===this.size,(function(){return"Length of values '"+s+"' does not match the size inferred by the shape '"+a.size+"'."}))}if(e==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=r||j0(e,this.size),this.strides=Lo(t)}return n.prototype.set=function(t){for(var e=this,r=[],a=1;a<arguments.length;a++)r[a-1]=arguments[a];r.length===0&&(r=[0]),Z(r.length===this.rank,(function(){return"The number of provided coordinates ("+r.length+") must match the rank ("+e.rank+")"}));var s=this.locToIndex(r);this.values[s]=t},n.prototype.get=function(){for(var t=[],e=0;e<arguments.length;e++)t[e]=arguments[e];t.length===0&&(t=[0]);for(var r=0,a=0,s=t;a<s.length;a++){var o=s[a];if(o<0||o>=this.shape[r]){var i="Requested out of range element at "+t+".   Buffer shape="+this.shape;throw new Error(i)}r++}for(var u=t[t.length-1],l=0;l<t.length-1;++l)u+=this.strides[l]*t[l];return this.values[u]},n.prototype.locToIndex=function(t){if(this.rank===0)return 0;if(this.rank===1)return t[0];for(var e=t[t.length-1],r=0;r<t.length-1;++r)e+=this.strides[r]*t[r];return e},n.prototype.indexToLoc=function(t){if(this.rank===0)return[];if(this.rank===1)return[t];for(var e=new Array(this.shape.length),r=0;r<e.length-1;++r)e[r]=Math.floor(t/this.strides[r]),t-=e[r]*this.strides[r];return e[e.length-1]=t,e},Object.defineProperty(n.prototype,"rank",{get:function(){return this.shape.length},enumerable:!0,configurable:!0}),n.prototype.toTensor=function(){return To().makeTensor(this.values,this.shape,this.dtype)},n})(),To=null,St=null,zB=null,$n=(function(){function n(t,e,r,a){this.kept=!1,this.isDisposedInternal=!1,this.shape=t.slice(),this.dtype=e||"float32",this.size=ee(t),this.strides=Lo(t),this.dataId=r,this.id=a,this.rankType=this.rank<5?this.rank.toString():"higher"}return n.prototype.flatten=function(){return this.throwIfDisposed(),this.as1D()},n.prototype.asScalar=function(){return this.throwIfDisposed(),Z(this.size===1,(function(){return"The array must have only 1 element."})),this.reshape([])},n.prototype.as1D=function(){return this.throwIfDisposed(),this.reshape([this.size])},n.prototype.as2D=function(t,e){return this.throwIfDisposed(),this.reshape([t,e])},n.prototype.as3D=function(t,e,r){return this.throwIfDisposed(),this.reshape([t,e,r])},n.prototype.as4D=function(t,e,r,a){return this.throwIfDisposed(),this.reshape([t,e,r,a])},n.prototype.as5D=function(t,e,r,a,s){return this.throwIfDisposed(),this.reshape([t,e,r,a,s])},n.prototype.asType=function(t){return this.throwIfDisposed(),St.cast(this,t)},Object.defineProperty(n.prototype,"rank",{get:function(){return this.shape.length},enumerable:!0,configurable:!0}),n.prototype.buffer=function(){return Yt(this,void 0,void 0,(function(){var t;return Qt(this,(function(e){switch(e.label){case 0:return[4,this.data()];case 1:return t=e.sent(),[2,St.buffer(this.shape,this.dtype,t)]}}))}))},n.prototype.bufferSync=function(){return St.buffer(this.shape,this.dtype,this.dataSync())},n.prototype.array=function(){return Yt(this,void 0,void 0,(function(){var t;return Qt(this,(function(e){switch(e.label){case 0:return[4,this.data()];case 1:return t=e.sent(),[2,YO(this.shape,t)]}}))}))},n.prototype.arraySync=function(){return YO(this.shape,this.dataSync())},n.prototype.data=function(){return Yt(this,void 0,void 0,(function(){var t,e;return Qt(this,(function(r){switch(r.label){case 0:return this.throwIfDisposed(),t=To().read(this.dataId),this.dtype!=="string"?[3,2]:[4,t];case 1:e=r.sent();try{return[2,e.map((function(a){return q0(a)}))]}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}r.label=2;case 2:return[2,t]}}))}))},n.prototype.dataSync=function(){this.throwIfDisposed();var t=To().readSync(this.dataId);if(this.dtype==="string")try{return t.map((function(e){return q0(e)}))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return t},n.prototype.bytes=function(){return Yt(this,void 0,void 0,(function(){var t;return Qt(this,(function(e){switch(e.label){case 0:return this.throwIfDisposed(),[4,To().read(this.dataId)];case 1:return t=e.sent(),this.dtype==="string"?[2,t]:[2,new Uint8Array(t.buffer)]}}))}))},n.prototype.dispose=function(){this.isDisposed||(To().disposeTensor(this),this.isDisposedInternal=!0)},Object.defineProperty(n.prototype,"isDisposed",{get:function(){return this.isDisposedInternal},enumerable:!0,configurable:!0}),n.prototype.throwIfDisposed=function(){if(this.isDisposed)throw new Error("Tensor is disposed.")},n.prototype.toFloat=function(){return this.asType("float32")},n.prototype.toInt=function(){return this.asType("int32")},n.prototype.toBool=function(){return this.asType("bool")},n.prototype.print=function(t){return t===void 0&&(t=!1),St.print(this,t)},n.prototype.reshape=function(t){return this.throwIfDisposed(),St.reshape(this,t)},n.prototype.reshapeAs=function(t){return this.throwIfDisposed(),this.reshape(t.shape)},n.prototype.expandDims=function(t){return t===void 0&&(t=0),St.expandDims(this,t)},n.prototype.cumsum=function(t,e,r){return t===void 0&&(t=0),e===void 0&&(e=!1),r===void 0&&(r=!1),St.cumsum(this,t,e,r)},n.prototype.squeeze=function(t){return this.throwIfDisposed(),St.squeeze(this,t)},n.prototype.clone=function(){return this.throwIfDisposed(),St.clone(this)},n.prototype.oneHot=function(t,e,r){return this.throwIfDisposed(),St.oneHot(this,t,e,r)},n.prototype.toString=function(t){return t===void 0&&(t=!1),Ret(this.dataSync(),this.shape,this.dtype,t)},n.prototype.tile=function(t){return this.throwIfDisposed(),St.tile(this,t)},n.prototype.gather=function(t,e){return e===void 0&&(e=0),this.throwIfDisposed(),St.gather(this,t,e)},n.prototype.matMul=function(t,e,r){return e===void 0&&(e=!1),r===void 0&&(r=!1),this.throwIfDisposed(),St.matMul(this,t,e,r)},n.prototype.dot=function(t){return this.throwIfDisposed(),St.dot(this,t)},n.prototype.norm=function(t,e,r){return t===void 0&&(t="euclidean"),e===void 0&&(e=null),r===void 0&&(r=!1),this.throwIfDisposed(),St.norm(this,t,e,r)},n.prototype.slice=function(t,e){return this.throwIfDisposed(),St.slice(this,t,e)},n.prototype.reverse=function(t){return this.throwIfDisposed(),St.reverse(this,t)},n.prototype.concat=function(t,e){return e===void 0&&(e=0),this.throwIfDisposed(),t instanceof n&&(t=[t]),St.concat([this].concat(t),e)},n.prototype.split=function(t,e){return e===void 0&&(e=0),this.throwIfDisposed(),St.split(this,t,e)},n.prototype.stack=function(t,e){return e===void 0&&(e=0),St.stack([this,t],e)},n.prototype.unstack=function(t){return t===void 0&&(t=0),St.unstack(this,t)},n.prototype.pad=function(t,e){return e===void 0&&(e=0),St.pad(this,t,e)},n.prototype.batchNormalization=function(t,e,r,a,s){return r===void 0&&(r=.001),zB("tf.batchNormalization() is going away. Use tf.batchNorm() instead, and note the positional argument change of scale, offset, and varianceEpsilon"),this.batchNorm(t,e,s,a,r)},n.prototype.batchNorm=function(t,e,r,a,s){return s===void 0&&(s=.001),this.throwIfDisposed(),St.batchNorm(this,t,e,r,a,s)},n.prototype.all=function(t,e){return t===void 0&&(t=null),e===void 0&&(e=!1),this.throwIfDisposed(),St.all(this,t,e)},n.prototype.any=function(t,e){return t===void 0&&(t=null),e===void 0&&(e=!1),this.throwIfDisposed(),St.any(this,t,e)},n.prototype.logSumExp=function(t,e){return t===void 0&&(t=null),e===void 0&&(e=!1),this.throwIfDisposed(),St.logSumExp(this,t,e)},n.prototype.sum=function(t,e){return t===void 0&&(t=null),e===void 0&&(e=!1),this.throwIfDisposed(),St.sum(this,t,e)},n.prototype.prod=function(t,e){return t===void 0&&(t=null),e===void 0&&(e=!1),this.throwIfDisposed(),St.prod(this,t,e)},n.prototype.mean=function(t,e){return t===void 0&&(t=null),e===void 0&&(e=!1),this.throwIfDisposed(),St.mean(this,t,e)},n.prototype.min=function(t,e){return t===void 0&&(t=null),e===void 0&&(e=!1),this.throwIfDisposed(),St.min(this,t,e)},n.prototype.max=function(t,e){return t===void 0&&(t=null),e===void 0&&(e=!1),this.throwIfDisposed(),St.max(this,t,e)},n.prototype.argMin=function(t){return t===void 0&&(t=null),this.throwIfDisposed(),St.argMin(this,t)},n.prototype.argMax=function(t){return t===void 0&&(t=null),this.throwIfDisposed(),St.argMax(this,t)},n.prototype.cast=function(t){return this.throwIfDisposed(),St.cast(this,t)},n.prototype.add=function(t){return this.throwIfDisposed(),St.add(this,t)},n.prototype.addStrict=function(t){return this.throwIfDisposed(),St.addStrict(this,t)},n.prototype.atan2=function(t){return this.throwIfDisposed(),St.atan2(this,t)},n.prototype.sub=function(t){return this.throwIfDisposed(),St.sub(this,t)},n.prototype.subStrict=function(t){return this.throwIfDisposed(),St.subStrict(this,t)},n.prototype.pow=function(t){return this.throwIfDisposed(),St.pow(this,t)},n.prototype.powStrict=function(t){return this.throwIfDisposed(),St.powStrict(this,t)},n.prototype.mul=function(t){return this.throwIfDisposed(),St.mul(this,t)},n.prototype.mulStrict=function(t){return this.throwIfDisposed(),St.mulStrict(this,t)},n.prototype.div=function(t){return this.throwIfDisposed(),St.div(this,t)},n.prototype.divNoNan=function(t){return this.throwIfDisposed(),St.divNoNan(this,t)},n.prototype.floorDiv=function(t){return this.throwIfDisposed(),St.floorDiv(this,t)},n.prototype.divStrict=function(t){return this.throwIfDisposed(),St.divStrict(this,t)},n.prototype.minimum=function(t){return this.throwIfDisposed(),St.minimum(this,t)},n.prototype.minimumStrict=function(t){return this.throwIfDisposed(),St.minimumStrict(this,t)},n.prototype.maximum=function(t){return this.throwIfDisposed(),St.maximum(this,t)},n.prototype.maximumStrict=function(t){return this.throwIfDisposed(),St.maximumStrict(this,t)},n.prototype.mod=function(t){return this.throwIfDisposed(),St.mod(this,t)},n.prototype.modStrict=function(t){return this.throwIfDisposed(),St.modStrict(this,t)},n.prototype.squaredDifferenceStrict=function(t){return this.throwIfDisposed(),St.squaredDifferenceStrict(this,t)},n.prototype.transpose=function(t){return this.throwIfDisposed(),St.transpose(this,t)},n.prototype.notEqual=function(t){return this.throwIfDisposed(),St.notEqual(this,t)},n.prototype.notEqualStrict=function(t){return this.throwIfDisposed(),St.notEqualStrict(this,t)},n.prototype.less=function(t){return this.throwIfDisposed(),St.less(this,t)},n.prototype.lessStrict=function(t){return this.throwIfDisposed(),St.lessStrict(this,t)},n.prototype.equal=function(t){return this.throwIfDisposed(),St.equal(this,t)},n.prototype.equalStrict=function(t){return this.throwIfDisposed(),St.equalStrict(this,t)},n.prototype.lessEqual=function(t){return this.throwIfDisposed(),St.lessEqual(this,t)},n.prototype.lessEqualStrict=function(t){return this.throwIfDisposed(),St.lessEqualStrict(this,t)},n.prototype.greater=function(t){return this.throwIfDisposed(),St.greater(this,t)},n.prototype.greaterStrict=function(t){return this.throwIfDisposed(),St.greaterStrict(this,t)},n.prototype.greaterEqual=function(t){return this.throwIfDisposed(),St.greaterEqual(this,t)},n.prototype.greaterEqualStrict=function(t){return this.throwIfDisposed(),St.greaterEqualStrict(this,t)},n.prototype.logicalAnd=function(t){return this.throwIfDisposed(),St.logicalAnd(this,t)},n.prototype.logicalOr=function(t){return this.throwIfDisposed(),St.logicalOr(this,t)},n.prototype.logicalNot=function(){return this.throwIfDisposed(),St.logicalNot(this)},n.prototype.logicalXor=function(t){return this.throwIfDisposed(),St.logicalXor(this,t)},n.prototype.where=function(t,e){return this.throwIfDisposed(),St.where(t,this,e)},n.prototype.neg=function(){return this.throwIfDisposed(),St.neg(this)},n.prototype.ceil=function(){return this.throwIfDisposed(),St.ceil(this)},n.prototype.floor=function(){return this.throwIfDisposed(),St.floor(this)},n.prototype.sign=function(){return this.throwIfDisposed(),St.sign(this)},n.prototype.isNaN=function(){return this.throwIfDisposed(),St.isNaN(this)},n.prototype.isInf=function(){return this.throwIfDisposed(),St.isInf(this)},n.prototype.isFinite=function(){return this.throwIfDisposed(),St.isFinite(this)},n.prototype.exp=function(){return this.throwIfDisposed(),St.exp(this)},n.prototype.expm1=function(){return this.throwIfDisposed(),St.expm1(this)},n.prototype.log=function(){return this.throwIfDisposed(),St.log(this)},n.prototype.log1p=function(){return this.throwIfDisposed(),St.log1p(this)},n.prototype.sqrt=function(){return this.throwIfDisposed(),St.sqrt(this)},n.prototype.rsqrt=function(){return this.throwIfDisposed(),St.rsqrt(this)},n.prototype.square=function(){return this.throwIfDisposed(),St.square(this)},n.prototype.reciprocal=function(){return this.throwIfDisposed(),St.reciprocal(this)},n.prototype.abs=function(){return this.throwIfDisposed(),St.abs(this)},n.prototype.clipByValue=function(t,e){return this.throwIfDisposed(),St.clipByValue(this,t,e)},n.prototype.relu=function(){return this.throwIfDisposed(),St.relu(this)},n.prototype.relu6=function(){return this.throwIfDisposed(),St.relu6(this)},n.prototype.elu=function(){return this.throwIfDisposed(),St.elu(this)},n.prototype.selu=function(){return this.throwIfDisposed(),St.selu(this)},n.prototype.leakyRelu=function(t){return t===void 0&&(t=.2),this.throwIfDisposed(),St.leakyRelu(this,t)},n.prototype.prelu=function(t){return this.throwIfDisposed(),St.prelu(this,t)},n.prototype.sigmoid=function(){return this.throwIfDisposed(),St.sigmoid(this)},n.prototype.logSigmoid=function(){return this.throwIfDisposed(),St.logSigmoid(this)},n.prototype.softplus=function(){return this.throwIfDisposed(),St.softplus(this)},n.prototype.zerosLike=function(){return this.throwIfDisposed(),St.zerosLike(this)},n.prototype.onesLike=function(){return this.throwIfDisposed(),St.onesLike(this)},n.prototype.sin=function(){return this.throwIfDisposed(),St.sin(this)},n.prototype.cos=function(){return this.throwIfDisposed(),St.cos(this)},n.prototype.tan=function(){return this.throwIfDisposed(),St.tan(this)},n.prototype.asin=function(){return this.throwIfDisposed(),St.asin(this)},n.prototype.acos=function(){return this.throwIfDisposed(),St.acos(this)},n.prototype.atan=function(){return this.throwIfDisposed(),St.atan(this)},n.prototype.sinh=function(){return this.throwIfDisposed(),St.sinh(this)},n.prototype.cosh=function(){return this.throwIfDisposed(),St.cosh(this)},n.prototype.tanh=function(){return this.throwIfDisposed(),St.tanh(this)},n.prototype.asinh=function(){return this.throwIfDisposed(),St.asinh(this)},n.prototype.acosh=function(){return this.throwIfDisposed(),St.acosh(this)},n.prototype.atanh=function(){return this.throwIfDisposed(),St.atanh(this)},n.prototype.erf=function(){return this.throwIfDisposed(),St.erf(this)},n.prototype.round=function(){return this.throwIfDisposed(),St.round(this)},n.prototype.step=function(t){return t===void 0&&(t=0),this.throwIfDisposed(),St.step(this,t)},n.prototype.softmax=function(t){return t===void 0&&(t=-1),this.throwIfDisposed(),St.softmax(this,t)},n.prototype.logSoftmax=function(t){return t===void 0&&(t=-1),this.throwIfDisposed(),St.logSoftmax(this,t)},n.prototype.resizeBilinear=function(t,e){return e===void 0&&(e=!1),this.throwIfDisposed(),St.image.resizeBilinear(this,t,e)},n.prototype.resizeNearestNeighbor=function(t,e){return e===void 0&&(e=!1),this.throwIfDisposed(),St.image.resizeNearestNeighbor(this,t,e)},n.prototype.conv1d=function(t,e,r,a,s,o){return a===void 0&&(a="NWC"),s===void 0&&(s=1),this.throwIfDisposed(),St.conv1d(this,t,e,r,a,s,o)},n.prototype.conv2d=function(t,e,r,a,s,o){return a===void 0&&(a="NHWC"),s===void 0&&(s=[1,1]),this.throwIfDisposed(),St.conv2d(this,t,e,r,a,s,o)},n.prototype.conv2dTranspose=function(t,e,r,a,s){return this.throwIfDisposed(),St.conv2dTranspose(this,t,e,r,a,s)},n.prototype.depthwiseConv2D=function(t,e,r,a,s,o){return a===void 0&&(a="NHWC"),s===void 0&&(s=[1,1]),this.throwIfDisposed(),St.depthwiseConv2d(this,t,e,r,a,s,o)},n.prototype.separableConv2d=function(t,e,r,a,s,o){return s===void 0&&(s=[1,1]),o===void 0&&(o="NHWC"),this.throwIfDisposed(),St.separableConv2d(this,t,e,r,a,s,o)},n.prototype.avgPool=function(t,e,r,a){return this.throwIfDisposed(),St.avgPool(this,t,e,r,a)},n.prototype.maxPool=function(t,e,r,a){return this.throwIfDisposed(),St.maxPool(this,t,e,r,a)},n.prototype.localResponseNormalization=function(t,e,r,a){return t===void 0&&(t=5),e===void 0&&(e=1),r===void 0&&(r=1),a===void 0&&(a=.5),St.localResponseNormalization(this,t,e,r,a)},n.prototype.pool=function(t,e,r,a,s){return this.throwIfDisposed(),St.pool(this,t,e,r,a,s)},n.prototype.variable=function(t,e,r){return t===void 0&&(t=!0),this.throwIfDisposed(),To().makeVariable(this,t,e,r)},n.prototype.unsortedSegmentSum=function(t,e){return this.throwIfDisposed(),St.unsortedSegmentSum(this,t,e)},n.prototype.batchToSpaceND=function(t,e){return this.throwIfDisposed(),St.batchToSpaceND(this,t,e)},n.prototype.spaceToBatchND=function(t,e){return this.throwIfDisposed(),St.spaceToBatchND(this,t,e)},n.prototype.topk=function(t,e){return t===void 0&&(t=1),e===void 0&&(e=!0),this.throwIfDisposed(),St.topk(this,t,e)},n.prototype.stridedSlice=function(t,e,r,a,s,o,i,u){return a===void 0&&(a=0),s===void 0&&(s=0),o===void 0&&(o=0),i===void 0&&(i=0),u===void 0&&(u=0),this.throwIfDisposed(),St.stridedSlice(this,t,e,r,a,s,o,i,u)},n.prototype.depthToSpace=function(t,e){return this.throwIfDisposed(),St.depthToSpace(this,t,e)},n.prototype.fft=function(){return this.throwIfDisposed(),St.spectral.fft(this)},n.prototype.ifft=function(){return this.throwIfDisposed(),St.spectral.ifft(this)},n.prototype.rfft=function(){return this.throwIfDisposed(),St.spectral.rfft(this)},n.prototype.irfft=function(){return this.throwIfDisposed(),St.spectral.irfft(this)},n})();Object.defineProperty($n,Symbol.hasInstance,{value:function(n){return!!n&&n.dataId!=null&&n.shape!=null&&n.dtype!=null}});var JO,PN,VN,UN,WN,nd=(function(n){function t(e,r,a,s){var o=n.call(this,e.shape,e.dtype,e.dataId,s)||this;return o.trainable=r,o.name=a,o}return co(t,n),t.prototype.assign=function(e){if(e.dtype!==this.dtype)throw new Error("dtype of the new value ("+e.dtype+") and previous value ("+this.dtype+") must match");if(!Fr(e.shape,this.shape))throw new Error("shape of the new value ("+e.shape+") and previous value ("+this.shape+") must match");To().disposeTensor(this),this.dataId=e.dataId,To().incRef(this,null)},t.prototype.dispose=function(){To().disposeVariable(this),this.isDisposedInternal=!0},t})($n);Object.defineProperty(nd,Symbol.hasInstance,{value:function(n){return n instanceof $n&&n.assign!=null&&n.assign instanceof Function}}),(function(n){n.R0="R0",n.R1="R1",n.R2="R2",n.R3="R3",n.R4="R4",n.R5="R5",n.R6="R6"})(JO||(JO={})),(function(n){n.float32="float32",n.int32="int32",n.bool="int32",n.complex64="complex64"})(PN||(PN={})),(function(n){n.float32="float32",n.int32="int32",n.bool="bool",n.complex64="complex64"})(VN||(VN={})),(function(n){n.float32="float32",n.int32="float32",n.bool="float32",n.complex64="complex64"})(UN||(UN={})),(function(n){n.float32="complex64",n.int32="complex64",n.bool="complex64",n.complex64="complex64"})(WN||(WN={}));var Aet={float32:UN,int32:PN,bool:VN,complex64:WN};function Qr(n,t){if(n==="string"||t==="string"){if(n==="string"&&t==="string")return"string";throw new Error("Can not upcast "+n+" with "+t)}return Aet[n][t]}function jS(n){return Qr(n,"int32")}function Mn(n,t){if(n.dtype===t.dtype)return[n,t];var e=Qr(n.dtype,t.dtype);return[n.cast(e),t.cast(e)]}function Det(n,t){Z(n.dtype===t.dtype,(function(){return"The dtypes of the first("+n.dtype+") and second("+t.dtype+") input must match"}))}function PB(n){var t=[];return(function e(r,a,s){if(r!=null){if(r instanceof $n)return void a.push(r);if(o=r,!(!Array.isArray(o)&&typeof o!="object")){var o,i=r;for(var u in i){var l=i[u];s.has(l)||(s.add(l),e(l,a,s))}}}})(n,t,new Set),t}var qS,t3=(function(){function n(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null}}return n.prototype.dispose=function(){for(var t in this.registeredVariables)this.registeredVariables[t].dispose()},n})(),$et=(function(){function n(t){this.ENV=t,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new t3}return n.prototype.ready=function(){return Yt(this,void 0,void 0,(function(){var t,e,r;return Qt(this,(function(a){switch(a.label){case 0:if(this.pendingBackendInit!=null)return[2,this.pendingBackendInit.then((function(){}))];if(this.backendInstance!=null)return[2];t=this.getSortedBackends(),e=0,a.label=1;case 1:return e<t.length?(r=t[e],[4,this.initializeBackend(r).success]):[3,5];case 2:return a.sent()?[4,this.setBackend(r)]:[3,4];case 3:return a.sent(),[2];case 4:return e++,[3,1];case 5:throw new Error("Could not initialize any backends, all backend initializations failed.")}}))}))},Object.defineProperty(n.prototype,"backend",{get:function(){if(this.pendingBackendInit!=null)throw new Error("Backend '"+this.backendName+"' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods");if(this.backendInstance==null){var t=this.initializeBackendsAndReturnBest(),e=t.name;if(t.asyncInit)throw new Error("The highest priority backend '"+e+"' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods");this.setBackend(e)}return this.backendInstance},enumerable:!0,configurable:!0}),n.prototype.backendNames=function(){return Object.keys(this.registryFactory)},n.prototype.findBackend=function(t){return!(t in this.registry)&&(!(t in this.registryFactory)||this.initializeBackend(t).asyncInit)?null:this.registry[t]},n.prototype.findBackendFactory=function(t){return t in this.registryFactory?this.registryFactory[t].factory:null},n.prototype.registerBackend=function(t,e,r){return r===void 0&&(r=1),t in this.registryFactory?(console.warn(t+" backend was already registered. Reusing existing backend factory."),!1):(this.registryFactory[t]={factory:e,priority:r},!0)},n.prototype.setBackend=function(t){return Yt(this,void 0,void 0,(function(){var e,r,a;return Qt(this,(function(s){switch(s.label){case 0:if(this.registryFactory[t]==null)throw new Error("Backend name '"+t+"' not found in registry");return this.backendName=t,this.registry[t]!=null?[3,4]:(this.backendInstance=null,e=this.initializeBackend(t),r=e.success,e.asyncInit?[4,r]:[3,2]);case 1:return a=s.sent(),[3,3];case 2:a=r,s.label=3;case 3:if(!a)return[2,!1];s.label=4;case 4:return this.backendInstance=this.registry[t],this.setupRegisteredKernels(),this.profiler=new Iet(this.backendInstance),[2,!0]}}))}))},n.prototype.setupRegisteredKernels=function(){var t=this;KO(this.backendName).forEach((function(e){e.setupFunc!=null&&e.setupFunc(t.backendInstance)}))},n.prototype.disposeRegisteredKernels=function(t){var e=this;KO(t).forEach((function(r){r.disposeFunc!=null&&r.disposeFunc(e.registry[t])}))},n.prototype.initializeBackend=function(t){var e=this,r=this.registryFactory[t];if(r==null)throw new Error("Cannot initialize backend "+t+", no registration found.");try{var a=r.factory();if(Promise.resolve(a)===a){var s=++this.pendingBackendInitId,o=a.then((function(i){return!(s<e.pendingBackendInitId)&&(e.registry[t]=i,e.pendingBackendInit=null,!0)})).catch((function(i){return!(s<e.pendingBackendInitId)&&(e.pendingBackendInit=null,console.warn("Initialization of backend "+t+" failed"),console.warn(i.stack||i.message),!1)}));return this.pendingBackendInit=o,{success:o,asyncInit:!0}}return this.registry[t]=a,{success:!0,asyncInit:!1}}catch(i){return console.warn("Initialization of backend "+t+" failed"),console.warn(i.stack||i.message),{success:!1,asyncInit:!1}}},n.prototype.removeBackend=function(t){if(!(t in this.registryFactory))throw new Error(t+" backend not found in registry");this.backendName===t&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,t in this.registry&&(this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t]),delete this.registryFactory[t],this.backendName===t&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)},n.prototype.getSortedBackends=function(){var t=this;if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((function(e,r){return t.registryFactory[r].priority-t.registryFactory[e].priority}))},n.prototype.initializeBackendsAndReturnBest=function(){for(var t=this.getSortedBackends(),e=0;e<t.length;e++){var r=t[e],a=this.initializeBackend(r),s=a.success,o=a.asyncInit;if(o||s)return{name:r,asyncInit:o}}throw new Error("Could not initialize any backends, all backend initializations failed.")},n.prototype.moveData=function(t,e){var r=this.state.tensorInfo.get(e),a=r.backend,s=this.readSync(e);a.disposeData(e),r.backend=t,t.move(e,s,r.shape,r.dtype),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++},n.prototype.tidy=function(t,e){var r,a=this,s=null;if(e==null){if(typeof t!="function")throw new Error("Please provide a function to tidy()");e=t}else{if(typeof t!="string"&&!(t instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof e!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");s=t}return this.scopedRun((function(){return a.startScope(s)}),(function(){return a.endScope(r)}),(function(){return(r=e())instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),r}))},n.prototype.scopedRun=function(t,e,r){t();try{var a=r();return e(),a}catch(s){throw e(),s}},n.prototype.nextTensorId=function(){return n.nextTensorId++},n.prototype.nextVariableId=function(){return n.nextVariableId++},n.prototype.clone=function(t){var e=this.makeTensorFromDataId(t.dataId,t.shape,t.dtype),r={x:t};return this.addTapeNode(this.state.activeScope.name,r,[e],(function(a){return{x:function(){return a.toFloat()}}}),[]),e},n.prototype.runKernel=function(t,e,r,a,s){return this.runKernelFunc(null,e,null,t,r,a,s)},n.prototype.shouldCheckForMemLeaks=function(){return this.ENV.getBool("IS_TEST")},n.prototype.checkKernelForMemLeak=function(t,e,r){var a=this.backend.numDataIds(),s=0;r.forEach((function(u){s+=u.dtype==="complex64"?3:1}));var o=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],i=a-e-s-o;if(i>0)throw new Error("Backend '"+this.backendName+"' has an internal memory leak ("+i+" data ids) after running '"+t+"'")},n.prototype.runKernelFunc=function(t,e,r,a,s,o,i){var u,l=this;o===void 0&&(o=[]),i===void 0&&(i=[]);var h=[],d=this.isTapeOn();a==null&&(a=this.state.activeScope!=null?this.state.activeScope.name:"");var f,m=function(S){d&&(h=S.map((function(N){return l.keep(l.clone(N))})))},v=this.state.numBytes,y=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);var b,w=RB(a,this.backendName);return f=w!=null?function(){var S=l.backend.numDataIds();b=w.kernelFunc({inputs:e,attrs:s,backend:l.backend});var N=Array.isArray(b)?b:[b];l.shouldCheckForMemLeaks()&&l.checkKernelForMemLeak(a,S,N);var C=N.map((function(I){var _=I.dataId,$=I.shape,R=I.dtype;return l.makeTensorFromDataId(_,$,R)})),T=C.filter((function(I,_){return i[_]}));return m((o||[]).slice().concat(T)),C}:function(){var S=l.backend.numDataIds();b=l.tidy((function(){return t(l.backend,m)}));var N=Array.isArray(b)?b:[b];return l.shouldCheckForMemLeaks()&&l.checkKernelForMemLeak(a,S,N),N},this.scopedRun((function(){return l.state.kernelDepth++}),(function(){return l.state.kernelDepth--}),(function(){u=l.ENV.getBool("DEBUG")?l.profiler.profileKernel(a,e,(function(){return f()})):f()})),d&&this.addTapeNode(a,e,u,r,h),this.state.profiling&&this.state.activeProfile.kernels.push({name:a,bytesAdded:this.state.numBytes-v,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-y,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(e).map((function(S){return e[S].shape})),outputShapes:u.map((function(S){return S.shape}))}),Array.isArray(b)?u:u[0]},n.prototype.makeTensor=function(t,e,r,a){if(t==null)throw new Error("Values passed to engine.makeTensor() are null");r=r||"float32",a=a||this.backend;var s=t;r==="string"&&OE(t[0])&&(s=t.map((function(h){return Tet(h)})));var o=a.write(s,e,r),i=new $n(e,r,o,this.nextTensorId());if(this.incRef(i,a),r==="string"){var u=this.state.tensorInfo.get(o),l=Cet(s);this.state.numBytes+=l-u.bytes,u.bytes=l}return i},n.prototype.makeTensorFromDataId=function(t,e,r,a){var s=new $n(e,r=r||"float32",t,this.nextTensorId());return this.incRef(s,a),s},n.prototype.makeVariable=function(t,e,r,a){e===void 0&&(e=!0),r=r||this.nextVariableId().toString(),a!=null&&a!==t.dtype&&(t=t.asType(a));var s=new nd(t,e,r,this.nextTensorId());if(this.state.registeredVariables[s.name]!=null)throw new Error("Variable with name "+s.name+" was already registered");return this.state.registeredVariables[s.name]=s,this.incRef(s,this.backend),s},n.prototype.incRef=function(t,e){var r=this.state.tensorInfo.has(t.dataId)?this.state.tensorInfo.get(t.dataId).refCount:0;if(this.state.numTensors++,t.dtype==="string"&&this.state.numStringTensors++,r===0){this.state.numDataBuffers++;var a=0;t.dtype!=="complex64"&&t.dtype!=="string"&&(a=t.size*OB(t.dtype)),this.state.tensorInfo.set(t.dataId,{backend:e||this.backend,dtype:t.dtype,shape:t.shape,bytes:a,refCount:0}),this.state.numBytes+=a}this.state.tensorInfo.get(t.dataId).refCount++,t instanceof nd||this.track(t)},n.prototype.disposeTensor=function(t){if(this.state.tensorInfo.has(t.dataId)){this.state.numTensors--,t.dtype==="string"&&this.state.numStringTensors--;var e=this.state.tensorInfo.get(t.dataId);e.refCount<=1?(t.dtype!=="complex64"&&(this.state.numBytes-=e.bytes),this.state.numDataBuffers--,e.backend.disposeData(t.dataId),this.state.tensorInfo.delete(t.dataId)):this.state.tensorInfo.get(t.dataId).refCount--}},n.prototype.disposeVariables=function(){for(var t in this.state.registeredVariables){var e=this.state.registeredVariables[t];this.disposeVariable(e)}},n.prototype.disposeVariable=function(t){this.disposeTensor(t),this.state.registeredVariables[t.name]!=null&&delete this.state.registeredVariables[t.name]},n.prototype.memory=function(){var t=this.backend.memory();return t.numTensors=this.state.numTensors,t.numDataBuffers=this.state.numDataBuffers,t.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(t.unreliable=!0,t.reasons==null&&(t.reasons=[]),t.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),t},n.prototype.profile=function(t){return Yt(this,void 0,void 0,(function(){var e,r;return Qt(this,(function(a){return this.state.profiling=!0,e=this.state.numBytes,r=this.state.numTensors,this.state.activeProfile.kernels=[],this.state.activeProfile.result=t(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max.apply(Math,this.state.activeProfile.kernels.map((function(s){return s.totalBytesSnapshot}))),this.state.activeProfile.newBytes=this.state.numBytes-e,this.state.activeProfile.newTensors=this.state.numTensors-r,[2,this.state.activeProfile]}))}))},n.prototype.isTapeOn=function(){return this.state.gradientDepth>0&&this.state.kernelDepth===0},n.prototype.addTapeNode=function(t,e,r,a,s){var o=this,i={id:this.state.nextTapeNodeId++,kernelName:t,inputs:e,outputs:r,saved:s},u=fet(t);u!=null&&(a=u.gradFunc),a!=null&&(i.gradient=function(l){return l=l.map((function(h,d){if(h==null){var f=r[d],m=Kg(f.size,f.dtype);return o.makeTensor(m,f.shape,f.dtype)}return h})),a(l.length>1?l:l[0],s)}),this.state.activeTape.push(i)},n.prototype.keep=function(t){return t.kept=!0,t},n.prototype.startTape=function(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++},n.prototype.endTape=function(){this.state.gradientDepth--},n.prototype.startScope=function(t){var e={track:[],name:"unnamed scope",id:this.state.nextScopeId++};t&&(e.name=t),this.state.scopeStack.push(e),this.state.activeScope=e},n.prototype.endScope=function(t){for(var e=this,r=PB(t),a=new Set(r.map((function(u){return u.id}))),s=0;s<this.state.activeScope.track.length;s++){var o=this.state.activeScope.track[s];o.kept||a.has(o.id)||o.dispose()}var i=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],r.forEach((function(u){u.kept||u.scopeId!==i.id||e.track(u)}))},n.prototype.gradients=function(t,e,r,a){var s=this;if(a===void 0&&(a=!1),Z(e.length>0,(function(){return"gradients() received an empty list of xs."})),r!=null&&r.dtype!=="float32")throw new Error("dy must have 'float32' dtype, but has '"+r.dtype+"'");var o=this.scopedRun((function(){return s.startTape()}),(function(){return s.endTape()}),(function(){return s.tidy("forward",t)}));Z(o instanceof $n,(function(){return"The result y returned by f() must be a tensor."}));var i=(function(u,l,h){for(var d={},f={},m=0;m<l.length;m++)d[l[m].id]=!0;for(m=0;m<u.length;m++){var v=(I=u[m]).inputs;for(var y in v){for(var b=v[y],w=!1,S=0;S<l.length;S++)if(d[b.id]){I.outputs.forEach((function(D){return d[D.id]=!0})),w=!0,f[I.id]=!0;break}if(w)break}}var N={};N[h.id]=!0;var C={};for(m=u.length-1;m>=0;m--)for(v=(I=u[m]).inputs,S=0;S<I.outputs.length;S++)if(N[I.outputs[S].id]){for(var y in v)N[v[y].id]=!0,C[I.id]=!0;break}var T=[];for(m=0;m<u.length;m++){var I;if(f[(I=u[m]).id]&&C[I.id]){var _={};for(var y in I.inputs){var $=I.inputs[y];d[$.id]&&(_[y]=$)}var R=Object.assign({},I);R.inputs=_,R.outputs=I.outputs,T.push(R)}}return T})(this.state.activeTape,e,o);if(!a&&i.length===0&&e.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",(function(){var u,l,h={};h[o.id]=r??(u=o.shape,l=MB(ee(u),"float32"),lt.makeTensor(l,u,"float32")),(function(f,m,v){for(var y=function(w){var S=m[w],N=[];if(S.outputs.forEach((function(_){var $=f[_.id];$!=null?N.push($):N.push(null)})),S.gradient==null)throw new Error("Cannot compute gradient: gradient function not found for "+S.kernelName+".");var C=S.gradient(N),T=function(_){if(!(_ in C))throw new Error("Cannot backprop through input "+_+". Available gradients found: "+Object.keys(C)+".");var $=v((function(){return C[_]()}));if($.dtype!=="float32")throw new Error("Error in gradient for op "+S.kernelName+". The gradient of input "+_+" must have 'float32' dtype, but has '"+$.dtype+"'");var R=S.inputs[_];if(!Fr($.shape,R.shape))throw new Error("Error in gradient for op "+S.kernelName+". The gradient of input '"+_+"' has shape '"+$.shape+"', which does not match the shape of the input '"+R.shape+"'");if(f[R.id]==null)f[R.id]=$;else{var D=f[R.id];f[R.id]=D.add($),D.dispose()}};for(var I in S.inputs)T(I)},b=m.length-1;b>=0;b--)y(b)})(h,i,(function(f){return s.tidy(f)}));var d=e.map((function(f){return h[f.id]}));return s.state.gradientDepth===0&&(s.state.activeTape.forEach((function(f){for(var m=0,v=f.saved;m<v.length;m++)v[m].dispose()})),s.state.activeTape=null),{value:o,grads:d}}))},n.prototype.customGrad=function(t){var e=this;return Z(BN(t),(function(){return"The f passed in customGrad(f) must be a function."})),function(){for(var r,a=[],s=0;s<arguments.length;s++)a[s]=arguments[s];Z(a.every((function(i){return i instanceof $n})),(function(){return"The args passed in customGrad(f)(x1, x2,...) must all be tensors"}));var o={};return a.forEach((function(i,u){o[u]=i})),e.runKernelFunc((function(i,u){return Z((r=t.apply(void 0,a.concat([u]))).value instanceof $n,(function(){return"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"})),Z(BN(r.gradFunc),(function(){return"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."})),r.value}),o,(function(i,u){var l=r.gradFunc(i,u),h=Array.isArray(l)?l:[l];Z(h.length===a.length,(function(){return"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."})),Z(h.every((function(f){return f instanceof $n})),(function(){return"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors."}));var d={};return h.forEach((function(f,m){d[m]=function(){return f}})),d}))}},n.prototype.readSync=function(t){return this.state.tensorInfo.get(t).backend.readSync(t)},n.prototype.read=function(t){return this.state.tensorInfo.get(t).backend.read(t)},n.prototype.time=function(t){return Yt(this,void 0,void 0,(function(){var e,r;return Qt(this,(function(a){switch(a.label){case 0:return e=So(),[4,this.backend.time(t)];case 1:return(r=a.sent()).wallMs=So()-e,[2,r]}}))}))},n.prototype.track=function(t){return this.state.activeScope!=null&&(t.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(t)),t},Object.defineProperty(n.prototype,"registeredVariables",{get:function(){return this.state.registeredVariables},enumerable:!0,configurable:!0}),n.prototype.reset=function(){for(var t in this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new t3,this.registry)this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null},n.nextTensorId=0,n.nextVariableId=0,n})(),lt=(function(){var n=(function(){if(qS==null){var e=void 0;if(typeof window<"u")e=window;else if(typeof global<"u")e=global;else if(typeof process<"u")e=process;else{if(typeof self>"u")throw new Error("Could not find a global object");e=self}qS=e}return qS})();if(n._tfengine==null){var t=new det(n);n._tfengine=new $et(t)}return(function(e){_B=e})(n._tfengine.ENV),To=function(){return n._tfengine},n._tfengine})();function VB(){return typeof window<"u"&&window.document!=null||typeof WorkerGlobalScope<"u"}var bi=kt();bi.registerFlag("DEBUG",(function(){return!1}),(function(n){n&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")})),bi.registerFlag("IS_BROWSER",(function(){return VB()})),bi.registerFlag("IS_NODE",(function(){return typeof process<"u"&&process.versions!==void 0&&process.versions.node!==void 0})),bi.registerFlag("IS_CHROME",(function(){return typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor)})),bi.registerFlag("PROD",(function(){return!1})),bi.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",(function(){return bi.getBool("DEBUG")})),bi.registerFlag("DEPRECATION_WARNINGS_ENABLED",(function(){return!0})),bi.registerFlag("IS_TEST",(function(){return!1}));var om,cs,os,$l={},KS={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function Oet(n,t){$l[n]=t}function Xo(n){n in $l||($l[n]=(function(e){if(e!==1&&e!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");var r=(function(a){if(typeof OffscreenCanvas<"u"&&a===2)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")})(e);return r.addEventListener("webglcontextlost",(function(a){a.preventDefault(),delete $l[e]}),!1),e===1?r.getContext("webgl",KS)||r.getContext("experimental-webgl",KS):r.getContext("webgl2",KS)})(n));var t=$l[n];return t.isContextLost()?(delete $l[n],Xo(n)):(t.disable(t.DEPTH_TEST),t.disable(t.STENCIL_TEST),t.disable(t.BLEND),t.disable(t.DITHER),t.disable(t.POLYGON_OFFSET_FILL),t.disable(t.SAMPLE_COVERAGE),t.enable(t.SCISSOR_TEST),t.enable(t.CULL_FACE),t.cullFace(t.BACK),$l[n])}function D1(n,t){return[t,n]}function Pf(n){var t=ee(n);return LN(Math.ceil(t/4))}function Xg(n,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(n/2))]}function FE(n,t){var e,r,a,s,o,i,u,l,h,d=n;return kt().getNumber("WEBGL_VERSION")===2?(e=d.R32F,r=d.R16F,a=d.RGBA16F,s=d.RGBA32F,o=d.RED,i=4,u=1,l=d.HALF_FLOAT,h=d.FLOAT):(e=n.RGBA,r=n.RGBA,a=n.RGBA,s=d.RGBA,o=n.RGBA,i=4,u=4,l=t!=null?t.HALF_FLOAT_OES:null,h=n.FLOAT),{internalFormatFloat:e,internalFormatHalfFloat:r,internalFormatPackedHalfFloat:a,internalFormatPackedFloat:s,textureFormatFloat:o,downloadTextureFormat:n.RGBA,downloadUnpackNumChannels:i,defaultNumChannels:u,textureTypeHalfFloat:l,textureTypeFloat:h}}function ne(n,t,e){var r=e();return t&&(function(a){var s=a.getError();if(s!==a.NO_ERROR)throw new Error("WebGL Error: "+Bet(a,s))})(n),r}(function(n){n[n.DENSE=0]="DENSE",n[n.SHARED_BATCH=1]="SHARED_BATCH"})(om||(om={})),(function(n){n[n.RENDER=0]="RENDER",n[n.UPLOAD=1]="UPLOAD",n[n.PIXELS=2]="PIXELS",n[n.DOWNLOAD=3]="DOWNLOAD"})(cs||(cs={})),(function(n){n[n.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",n[n.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",n[n.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",n[n.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",n[n.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})(os||(os={}));var Fet=596e-10,Met=65504;function Let(n){return!!(kt().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||n===0||Fet<Math.abs(n)&&Math.abs(n)<Met)}function Bet(n,t){switch(t){case n.NO_ERROR:return"NO_ERROR";case n.INVALID_ENUM:return"INVALID_ENUM";case n.INVALID_VALUE:return"INVALID_VALUE";case n.INVALID_OPERATION:return"INVALID_OPERATION";case n.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case n.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case n.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return"Unknown error code "+t}}function Hy(n,t,e){return Ui(n,t,(function(){return n.getExtension(e)}),'Extension "'+e+'" not supported on this browser.')}function zet(n,t,e){var r=Ui(n,t,(function(){return n.createShader(n.VERTEX_SHADER)}),"Unable to create vertex WebGLShader.");if(ne(n,t,(function(){return n.shaderSource(r,e)})),ne(n,t,(function(){return n.compileShader(r)})),n.getShaderParameter(r,n.COMPILE_STATUS)===!1)throw console.log(n.getShaderInfoLog(r)),new Error("Failed to compile vertex shader.");return r}function Pet(n,t,e){var r=Ui(n,t,(function(){return n.createShader(n.FRAGMENT_SHADER)}),"Unable to create fragment WebGLShader.");if(ne(n,t,(function(){return n.shaderSource(r,e)})),ne(n,t,(function(){return n.compileShader(r)})),n.getShaderParameter(r,n.COMPILE_STATUS)===!1)throw(function(a,s){var o=Vet.exec(s);if(o==null)return console.log("Couldn't parse line number in error: "+s),void console.log(a);for(var i=+o[1],u=a.split(`
`),l=u.length.toString().length+2,h=u.map((function(b,w){return Lh((w+1).toString(),l)+b})),d=0,f=0;f<h.length;f++)d=Math.max(h[f].length,d);var m=h.slice(0,i-1),v=h.slice(i-1,i),y=h.slice(i);console.log(m.join(`
`)),console.log(s.split(`
`)[0]),console.log("%c "+Lh(v[0],d),"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(y.join(`
`))})(e,n.getShaderInfoLog(r)),new Error("Failed to compile fragment shader.");return r}var XS,YS,Vet=/ERROR: [0-9]+:([0-9]+):/g;function Uet(n,t){return Ui(n,t,(function(){return n.createProgram()}),"Unable to create WebGLProgram.")}function Wet(n,t,e){if(ne(n,t,(function(){return n.linkProgram(e)})),n.getProgramParameter(e,n.LINK_STATUS)===!1)throw console.log(n.getProgramInfoLog(e)),new Error("Failed to link vertex and fragment shaders.")}function QS(n,t,e){if(ne(n,t,(function(){return n.validateProgram(e)})),n.getProgramParameter(e,n.VALIDATE_STATUS)===!1)throw console.log(n.getProgramInfoLog(e)),new Error("Shader program validation failed.")}function Get(n,t,e){var r=Ui(n,t,(function(){return n.createBuffer()}),"Unable to create WebGLBuffer");return ne(n,t,(function(){return n.bindBuffer(n.ARRAY_BUFFER,r)})),ne(n,t,(function(){return n.bufferData(n.ARRAY_BUFFER,e,n.STATIC_DRAW)})),r}function Het(n,t,e){var r=Ui(n,t,(function(){return n.createBuffer()}),"Unable to create WebGLBuffer");return ne(n,t,(function(){return n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,r)})),ne(n,t,(function(){return n.bufferData(n.ELEMENT_ARRAY_BUFFER,e,n.STATIC_DRAW)})),r}function jet(n,t){return Ui(n,t,(function(){return n.createTexture()}),"Unable to create WebGLTexture.")}function qet(n,t){var e=kt().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(n<=0||t<=0){var r="["+n+"x"+t+"]";throw new Error("Requested texture size "+r+" is invalid.")}if(n>e||t>e)throw r="["+n+"x"+t+"]",new Error("Requested texture size "+r+" greater than WebGL maximum on this browser / GPU "+("["+e+"x"+e+"]")+".")}function Ket(n,t){return Ui(n,t,(function(){return n.createFramebuffer()}),"Unable to create WebGLFramebuffer.")}function e3(n,t,e,r,a,s,o,i){var u=n.getAttribLocation(e,r);return u!==-1&&(ne(n,t,(function(){return n.bindBuffer(n.ARRAY_BUFFER,a)})),ne(n,t,(function(){return n.vertexAttribPointer(u,s,n.FLOAT,!1,o,i)})),ne(n,t,(function(){return n.enableVertexAttribArray(u)})),!0)}function Xet(n,t,e,r){tnt(n,r),ne(n,t,(function(){return n.activeTexture(n.TEXTURE0+r)})),ne(n,t,(function(){return n.bindTexture(n.TEXTURE_2D,e)}))}function Yet(n,t,e,r){return Ui(n,t,(function(){return n.getUniformLocation(e,r)}),'uniform "'+r+'" not present in program.')}function Qet(n,t,e){return n.getUniformLocation(t,e)}function Zet(n,t,e,r,a,s){ne(n,t,(function(){return Xet(n,t,r,s)})),ne(n,t,(function(){return n.uniform1i(a,s)}))}function ZS(n,t,e,r){ne(n,t,(function(){return n.bindFramebuffer(n.FRAMEBUFFER,r)})),ne(n,t,(function(){return n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,e,0)}))}function n3(n,t,e){ne(n,t,(function(){return n.bindFramebuffer(n.FRAMEBUFFER,e)})),ne(n,t,(function(){return n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,null,0)}))}function jy(n){var t=n.checkFramebufferStatus(n.FRAMEBUFFER);if(t!==n.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+Jet(n,t))}function Jet(n,t){switch(t){case n.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case n.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return"unknown error "+t}}function Ui(n,t,e,r){var a=ne(n,t,(function(){return e()}));if(a==null)throw new Error(r);return a}function tnt(n,t){var e=n.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=t+n.TEXTURE0;if(r<n.TEXTURE0||r>e)throw new Error("textureUnit must be in "+("[gl.TEXTURE0, gl.TEXTURE"+e+"]")+".")}function K0(n,t){return t===void 0&&(t=2),ee(n.slice(0,n.length-t))}function X0(n){if(n.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[n.length>1?n[n.length-2]:1,n[n.length-1]]}function JS(n){var t=[1,1,1];return n.length===0||n.length===1&&n[0]===1||(t=[K0(n)].concat(X0(n))),t}function ent(n,t){var e;t===void 0&&(t=!1);var r=kt().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(t&&(r*=2,(n=n.map((function(l,h){return h>=n.length-2?$B(n[h]):n[h]}))).length===1&&(n=[2,n[0]])),n.length!==2){var a=zl(n);n=a.newShape}var s=ee(n);if(n.length<=1&&s<=r)return[1,s];if(n.length===2&&n[0]<=r&&n[1]<=r)return n;if(n.length===3&&n[0]*n[1]<=r&&n[2]<=r)return[n[0]*n[1],n[2]];if(n.length===3&&n[0]<=r&&n[1]*n[2]<=r)return[n[0],n[1]*n[2]];if(n.length===4&&n[0]*n[1]*n[2]<=r&&n[3]<=r)return[n[0]*n[1]*n[2],n[3]];if(n.length===4&&n[0]<=r&&n[1]*n[2]*n[3]<=r)return[n[0],n[1]*n[2]*n[3]];if(t){var o=K0(n),i=2,u=2;return n.length&&(i=(e=X0(n))[0],u=e[1]),LN(s=o*(i/2)*(u/2)).map((function(l){return 2*l}))}return LN(s)}function qy(n){return n%2==0}function Ky(n,t){if(Fr(n=n.slice(-2),t=t.slice(-2))||!n.length||!t.length||n[0]===0||n[1]===0||t[0]===0||t[1]===0)return!0;if(n.length!==t.length){var e=n.slice(-1)[0],r=t.slice(-1)[0];if(e===r||qy(e)&&qy(r)&&(n[0]===1||t[0]===1))return!0}return n[1]===t[1]&&qy(n[0])&&qy(t[0])}function nnt(n){if(XS==null){var t=Xo(n);XS=t.getParameter(t.MAX_TEXTURE_SIZE)}return XS}function rnt(n){if(YS==null){var t=Xo(n);YS=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,YS)}function ant(n){if(n===0)return 0;var t=Xo(n);return Bs(t,"EXT_disjoint_timer_query_webgl2")&&n===2?2:Bs(t,"EXT_disjoint_timer_query")?1:0}function Bs(n,t){return n.getExtension(t)!=null}function r3(n){try{if(Xo(n)!=null)return!0}catch{return!1}return!1}function snt(n){if(n===0)return!1;var t=Xo(n);if(n===1){if(!Bs(t,"OES_texture_float"))return!1}else if(!Bs(t,"EXT_color_buffer_float"))return!1;return GN(t)}function ont(n){if(n===0)return!1;var t=Xo(n);if(n!==1){if(Bs(t,"EXT_color_buffer_float"))return GN(t);if(Bs(t,"EXT_color_buffer_half_float")){var e=t.getExtension("EXT_color_buffer_half_float");return(function(r,a){var s=FE(r,a),o=r.createTexture();r.bindTexture(r.TEXTURE_2D,o),r.texImage2D(r.TEXTURE_2D,0,s.internalFormatHalfFloat,1,1,0,s.textureFormatFloat,s.textureTypeHalfFloat,null);var i=r.createFramebuffer();r.bindFramebuffer(r.FRAMEBUFFER,i),r.framebufferTexture2D(r.FRAMEBUFFER,r.COLOR_ATTACHMENT0,r.TEXTURE_2D,o,0);var u=r.checkFramebufferStatus(r.FRAMEBUFFER)===r.FRAMEBUFFER_COMPLETE;return r.bindTexture(r.TEXTURE_2D,null),r.bindFramebuffer(r.FRAMEBUFFER,null),r.deleteTexture(o),r.deleteFramebuffer(i),u})(t,e)}return!1}return!!Bs(t,"OES_texture_float")&&!!Bs(t,"WEBGL_color_buffer_float")&&GN(t)}function GN(n){var t=FE(n),e=n.createTexture();n.bindTexture(n.TEXTURE_2D,e),n.texImage2D(n.TEXTURE_2D,0,t.internalFormatFloat,1,1,0,t.textureFormatFloat,t.textureTypeFloat,null);var r=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,r),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,e,0);var a=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(e),n.deleteFramebuffer(r),a}function int(n){return n===2&&Xo(n).fenceSync!=null}var de=kt();function UB(n){kt().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(n+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}function Gt(n,t){return lt.tidy(n,t)}function Ua(n){PB(n).forEach((function(t){return t.dispose()}))}function unt(n){return lt.keep(n)}function Y0(){for(var n=[],t=0;t<arguments.length;t++)n[t]=arguments[t];kt().getBool("IS_TEST")||console.warn.apply(console,n)}function rl(n,t){var e=n;if(Mo(n))return t==="string"?[]:[n.length];if(!Array.isArray(n))return[];for(var r=[];Array.isArray(e)||Mo(e)&&t!=="string";)r.push(e.length),e=e[0];return Array.isArray(n)&&kt().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&(function a(s,o,i){if(i=i||[],!Array.isArray(s)&&!Mo(s))return void Z(o.length===0,(function(){return"Element arr["+i.join("][")+"] is a primitive, but should be an array/TypedArray of "+o[0]+" elements"}));Z(o.length>0,(function(){return"Element arr["+i.join("][")+"] should be a primitive, but is an array of "+s.length+" elements"})),Z(s.length===o[0],(function(){return"Element arr["+i.join("][")+"] should have "+o[0]+" elements, but has "+s.length+" elements"}));for(var u=o.slice(1),l=0;l<s.length;++l)a(s[l],u,i.concat(l))})(n,r,[]),r}function a3(n,t,e,r){if(n!=null&&(n!=="numeric"&&n!==t||n==="numeric"&&t==="string"))throw new Error("Argument '"+e+"' passed to '"+r+"' must be "+n+" tensor, but got "+t+" tensor")}function Y(n,t,e,r){if(r===void 0&&(r="numeric"),n instanceof $n)return a3(r,n.dtype,t,e),n;var a=qg(n);if(a!=="string"&&["bool","int32","float32"].indexOf(r)>=0&&(a=r),a3(r,a,t,e),n==null||!Mo(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string"){var s=n==null?"null":n.constructor.name;throw new Error("Argument '"+t+"' passed to '"+e+"' must be a Tensor or TensorLike, but got '"+s+"'")}var o=rl(n,a);Mo(n)||Array.isArray(n)||(n=[n]);var i=a!=="string"?FB(n,a,kt().getBool("DEBUG")):ed(n,[],!0);return lt.makeTensor(i,o,a)}function Q0(n,t,e,r){if(r===void 0&&(r="numeric"),!Array.isArray(n))throw new Error("Argument "+t+" passed to "+e+" must be a `Tensor[]` or `TensorLike[]`");return n.map((function(a,s){return Y(a,t+"["+s+"]",e)}),r)}function WB(n,t){for(var e=0;e<n.length;++e)if(n[n.length-e-1]!==t-1-e)return!1;return!0}function lnt(n,t,e){for(var r=n.length+t.length,a=[],s=0,o=0,i=0;i<r;i++)e.indexOf(i)===-1?a.push(n[s++]):a.push(t[o++]);return a}function na(n,t){for(var e=[],r=n.length,a=0;a<r;a++)t.indexOf(a)===-1&&e.push(n[a]);return[e,t.map((function(s){return n[s]}))]}function ja(n,t){return lnt(n,t.map((function(e){return 1})),t)}function ss(n,t,e){Z(WB(t,e),(function(){return n+" supports only inner-most axes for now. Got axes "+t+" and rank-"+e+" input."}))}function Yo(n,t){if(WB(n,t))return null;for(var e=[],r=0;r<t;++r)n.indexOf(r)===-1&&e.push(r);return n.forEach((function(a){return e.push(a)})),e}function ME(n){return n.map((function(t,e){return[e,t]})).sort((function(t,e){return t[1]-e[1]})).map((function(t){return t[0]}))}function Qo(n,t){for(var e=[],r=t-n;r<t;++r)e.push(r);return e}function cnt(n,t){var e=n[0].length;n.forEach((function(a,s){Z(a.length===e,(function(){return"Error in concat"+e+"D: rank of tensors["+s+"] must be the same as the rank of the rest ("+e+")"}))})),Z(t>=0&&t<e,(function(){return"Error in concat"+e+"D: axis must be between 0 and "+(e-1)+"."}));var r=n[0];n.forEach((function(a,s){for(var o=0;o<e;o++)Z(o===t||a[o]===r[o],(function(){return"Error in concat"+e+"D: Shape of tensors["+s+"] ("+a+") does not match the shape of the rest ("+r+") along the non-concatenated axis "+s+"."}))}))}function rd(n,t){for(var e=n[0].slice(),r=1;r<n.length;r++)e[t]+=n[r][t];return e}function st(n){var t=Object.keys(n);if(t.length!==1)throw new Error("Please provide an object with a single key (operation name) mapping to a function. Got an object with "+t.length+" keys.");var e=t[0],r=n[e];e.endsWith("_")&&(e=e.substring(0,e.length-1));var a=function(){for(var s=[],o=0;o<arguments.length;o++)s[o]=arguments[o];lt.startScope(e);try{var i=r.apply(void 0,s);return i instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),lt.endScope(i),i}catch(u){throw lt.endScope(null),u}};return Object.defineProperty(a,"name",{value:e,configurable:!0}),a}de.registerFlag("HAS_WEBGL",(function(){return de.getNumber("WEBGL_VERSION")>0})),de.registerFlag("WEBGL_VERSION",(function(){return r3(2)?2:r3(1)?1:0})),de.registerFlag("WEBGL_BUFFER_SUPPORTED",(function(){return de.get("WEBGL_VERSION")===2})),de.registerFlag("WEBGL_CPU_FORWARD",(function(){return!0})),de.registerFlag("WEBGL_FORCE_F16_TEXTURES",(function(){return!1})),de.registerFlag("WEBGL_PACK",(function(){return de.getBool("HAS_WEBGL")})),de.registerFlag("WEBGL_PACK_NORMALIZATION",(function(){return de.getBool("WEBGL_PACK")})),de.registerFlag("WEBGL_PACK_CLIP",(function(){return de.getBool("WEBGL_PACK")})),de.registerFlag("WEBGL_PACK_DEPTHWISECONV",(function(){return!1})),de.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",(function(){return de.getBool("WEBGL_PACK")})),de.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",(function(){return de.getBool("WEBGL_PACK")})),de.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",(function(){return de.getBool("WEBGL_PACK")})),de.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",(function(){return de.getBool("WEBGL_PACK")})),de.registerFlag("WEBGL_PACK_REDUCE",(function(){return de.getBool("WEBGL_PACK")})),de.registerFlag("WEBGL_LAZILY_UNPACK",(function(){return de.getBool("WEBGL_PACK")})),de.registerFlag("WEBGL_CONV_IM2COL",(function(){return de.getBool("WEBGL_PACK")})),de.registerFlag("WEBGL_MAX_TEXTURE_SIZE",(function(){return nnt(de.getNumber("WEBGL_VERSION"))})),de.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",(function(){return rnt(de.getNumber("WEBGL_VERSION"))})),de.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",(function(){var n=de.getNumber("WEBGL_VERSION");return n===0?0:ant(n)})),de.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",(function(){return de.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&(n=navigator.userAgent||navigator.vendor||window.opera,!(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(n)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(n.substr(0,4))));var n})),de.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",(function(){return snt(de.getNumber("WEBGL_VERSION"))})),de.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",(function(){return!de.getBool("WEBGL_FORCE_F16_TEXTURES")&&de.getBool("WEBGL_RENDER_FLOAT32_CAPABLE")})),de.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",(function(){return ont(de.getNumber("WEBGL_VERSION"))})),de.registerFlag("WEBGL_FENCE_API_ENABLED",(function(){return int(de.getNumber("WEBGL_VERSION"))})),de.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",(function(){return de.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0})),zB=UB;var Yr=st({complex_:function(n,t){var e=Y(n,"real","complex"),r=Y(t,"imag","complex");return Je(e.shape,r.shape,"real and imag shapes, "+e.shape+" and "+r.shape+", must match in call to tf.complex()."),lt.runKernelFunc((function(a){return a.complex(e,r)}),{$real:e,$imag:r})}}),Ls=st({real_:function(n){var t=Y(n,"input","real");return lt.runKernelFunc((function(e){return e.real(t)}),{$input:t})}}),Eo=st({imag_:function(n){var t=Y(n,"input","imag");return lt.runKernelFunc((function(e){return e.imag(t)}),{$input:t})}});function Zr(n,t,e){return al(n,t,rl(n,e),e)}function al(n,t,e,r){if(r==null&&(r=qg(n)),r==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(!Mo(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(t!=null){LB(t);var a=ee(t),s=ee(e);Z(a===s,(function(){return"Based on the provided shape, ["+t+"], the tensor should have "+a+" values but has "+s}));for(var o=0;o<e.length;++o){var i=e[o],u=o!==e.length-1||i!==ee(t.slice(o));Z(e[o]===t[o]||!u,(function(){return"Error creating a new Tensor. Inferred shape ("+e+") does not match the provided shape ("+t+"). "}))}}return Mo(n)||Array.isArray(n)||(n=[n]),t=t||e,n=r!=="string"?FB(n,r,kt().getBool("DEBUG")):ed(n,[],!0),lt.makeTensor(n,t,r)}function Pt(n,t){if((Mo(n)&&t!=="string"||Array.isArray(n))&&t!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(t==="string"&&Mo(n)&&!(n instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return al(n,[],[],t)}function rr(n,t){pp(n);var e=rl(n,t);if(e.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return al(n,null,e,t)}function _u(n,t,e){if(pp(n),t!=null&&t.length!==2)throw new Error("tensor2d() requires shape to have two numbers");var r=rl(n,e);if(r.length!==2&&r.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(r.length===1&&t==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return al(n,t,r,e)}function LE(n,t,e){if(pp(n),t!=null&&t.length!==3)throw new Error("tensor3d() requires shape to have three numbers");var r=rl(n,e);if(r.length!==3&&r.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(r.length===1&&t==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return al(n,t,r,e)}function Ba(n,t,e){if(pp(n),t!=null&&t.length!==4)throw new Error("tensor4d() requires shape to have four numbers");var r=rl(n,e);if(r.length!==4&&r.length!==1)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(r.length===1&&t==null)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return al(n,t,r,e)}function hnt(n,t,e){if(pp(n),t!=null&&t.length!==5)throw new Error("tensor5d() requires shape to have five numbers");var r=rl(n,e);if(r.length!==5&&r.length!==1)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(r.length===1&&t==null)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return al(n,t,r,e)}function dnt(n,t,e){if(pp(n),t!=null&&t.length!==6)throw new Error("tensor6d() requires shape to have six numbers");var r=rl(n,e);if(r.length!==6&&r.length!==1)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(r.length===1&&t==null)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return al(n,t=t||r,r,e)}function pnt(n,t,e,r){return t===void 0&&(t=!0),lt.makeVariable(n,t,e,r)}function fp(n,t){if(t===void 0&&(t="float32"),t==="complex64"){var e=fp(n,"float32"),r=Sn(n,"float32");return Yr(e,r)}var a=MB(ee(n),t);return lt.makeTensor(a,n,t)}function Sn(n,t){if(t===void 0&&(t="float32"),t==="complex64"){var e=Sn(n,"float32"),r=Sn(n,"float32");return Yr(e,r)}var a=Kg(ee(n),t);return lt.makeTensor(a,n,t)}function Bo(n,t,e){return lt.runKernelFunc((function(r){return r.fill(n,t,e)}),{})}function fnt(n,t,e){if(e<=0)throw new Error("The number of values should be positive.");return lt.runKernelFunc((function(r){return r.linspace(n,t,e)}),{})}function Z0(n,t,e,r){if(e===void 0&&(e=1),r===void 0&&(r="float32"),e===0)throw new Error("Cannot have a step of zero");if(n===t||n<t&&e<0||t<n&&e>1)return Sn([0],r);var a=Kg(Math.abs(Math.ceil((t-n)/e)),r);t<n&&e===1&&(e=-1),a[0]=n;for(var s=1;s<a.length;s++)a[s]=a[s-1]+e;return rr(a,r)}var GB=st({onesLike_:function(n){var t=Y(n,"x","onesLike");if(t.dtype==="complex64"){var e=GB(Ls(t)),r=He(Eo(t));return Yr(e,r)}return lt.runKernelFunc((function(a){return a.onesLike(t)}),{$x:t},(function(a,s){return{$x:function(){return He(a)}}}))}}),He=st({zerosLike_:function(n){var t=Y(n,"x","zerosLike");return lt.runKernelFunc((function(e){return e.zerosLike(t)}),{$x:t},(function(e,r){return{$x:function(){return He(e)}}}))}}),yr=st({concat_:function(n,t){t===void 0&&(t=0),Z(n.length>=1,(function(){return"Pass at least one tensor to concat"}));var e=Q0(n,"tensors","concat");e[0].dtype==="complex64"&&e.forEach((function(i){if(i.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype `+i.dtype+". ")})),t=Tr(t,e[0].shape)[0];var r=rd(e.map((function(i){return i.shape})),t);if(ee(r)===0)return Zr([],r);if((e=e.filter((function(i){return i.size>0}))).length===1)return e[0];var a=e.map((function(i){return i.shape}));cnt(a,t);var s=e,o={axis:t};return lt.runKernelFunc((function(i){return i.concat(e,t)}),s,(function(i){var u=a.map((function(l){return l[t]}));return BE(i,u,t).map((function(l){return function(){return l}}))}),"Concat",o)}}),mnt=st({concat1d_:function(n){return yr(n,0)}}),gnt=st({concat2d_:function(n,t){return yr(n,t)}}),vnt=st({concat3d_:function(n,t){return yr(n,t)}}),ynt=st({concat4d_:function(n,t){return yr(n,t)}}),BE=st({split_:function(n,t,e){e===void 0&&(e=0);var r,a=Y(n,"x","split");return e=Tr(e,a.shape)[0],typeof t=="number"?(Z(a.shape[e]%t==0,(function(){return"Number of splits must evenly divide the axis."})),r=new Array(t).fill(a.shape[e]/t)):(Z(a.shape[e]===t.reduce((function(s,o){return s+o})),(function(){return"The sum of sizes must match the size of the axis dimension."})),r=t),lt.runKernelFunc((function(s){return s.split(a,r,e)}),{$x:a},(function(s){return{$x:function(){return yr(s,e)}}}))}});function Cc(n,t){return n(t={exports:{}},t.exports),t.exports}var bnt=Cc((function(n){(function(t,e,r){function a(i){var u,l=this,h=(u=4022871197,function(d){d=d.toString();for(var f=0;f<d.length;f++){var m=.02519603282416938*(u+=d.charCodeAt(f));m-=u=m>>>0,u=(m*=u)>>>0,u+=4294967296*(m-=u)}return 23283064365386963e-26*(u>>>0)});l.next=function(){var d=2091639*l.s0+23283064365386963e-26*l.c;return l.s0=l.s1,l.s1=l.s2,l.s2=d-(l.c=0|d)},l.c=1,l.s0=h(" "),l.s1=h(" "),l.s2=h(" "),l.s0-=h(i),l.s0<0&&(l.s0+=1),l.s1-=h(i),l.s1<0&&(l.s1+=1),l.s2-=h(i),l.s2<0&&(l.s2+=1),h=null}function s(i,u){return u.c=i.c,u.s0=i.s0,u.s1=i.s1,u.s2=i.s2,u}function o(i,u){var l=new a(i),h=u&&u.state,d=l.next;return d.int32=function(){return 4294967296*l.next()|0},d.double=function(){return d()+11102230246251565e-32*(2097152*d()|0)},d.quick=d,h&&(typeof h=="object"&&s(h,l),d.state=function(){return s(l,{})}),d}e&&e.exports?e.exports=o:this.alea=o})(0,n)})),xnt=Cc((function(n){(function(t,e,r){function a(i){var u=this,l="";u.x=0,u.y=0,u.z=0,u.w=0,u.next=function(){var d=u.x^u.x<<11;return u.x=u.y,u.y=u.z,u.z=u.w,u.w^=u.w>>>19^d^d>>>8},i===(0|i)?u.x=i:l+=i;for(var h=0;h<l.length+64;h++)u.x^=0|l.charCodeAt(h),u.next()}function s(i,u){return u.x=i.x,u.y=i.y,u.z=i.z,u.w=i.w,u}function o(i,u){var l=new a(i),h=u&&u.state,d=function(){return(l.next()>>>0)/4294967296};return d.double=function(){do var f=((l.next()>>>11)+(l.next()>>>0)/4294967296)/2097152;while(f===0);return f},d.int32=l.next,d.quick=d,h&&(typeof h=="object"&&s(h,l),d.state=function(){return s(l,{})}),d}e&&e.exports?e.exports=o:this.xor128=o})(0,n)})),wnt=Cc((function(n){(function(t,e,r){function a(i){var u=this,l="";u.next=function(){var d=u.x^u.x>>>2;return u.x=u.y,u.y=u.z,u.z=u.w,u.w=u.v,(u.d=u.d+362437|0)+(u.v=u.v^u.v<<4^d^d<<1)|0},u.x=0,u.y=0,u.z=0,u.w=0,u.v=0,i===(0|i)?u.x=i:l+=i;for(var h=0;h<l.length+64;h++)u.x^=0|l.charCodeAt(h),h==l.length&&(u.d=u.x<<10^u.x>>>4),u.next()}function s(i,u){return u.x=i.x,u.y=i.y,u.z=i.z,u.w=i.w,u.v=i.v,u.d=i.d,u}function o(i,u){var l=new a(i),h=u&&u.state,d=function(){return(l.next()>>>0)/4294967296};return d.double=function(){do var f=((l.next()>>>11)+(l.next()>>>0)/4294967296)/2097152;while(f===0);return f},d.int32=l.next,d.quick=d,h&&(typeof h=="object"&&s(h,l),d.state=function(){return s(l,{})}),d}e&&e.exports?e.exports=o:this.xorwow=o})(0,n)})),Snt=Cc((function(n){(function(t,e,r){function a(i){var u=this;u.next=function(){var l,h,d=u.x,f=u.i;return l=d[f],h=(l^=l>>>7)^l<<24,h^=(l=d[f+1&7])^l>>>10,h^=(l=d[f+3&7])^l>>>3,h^=(l=d[f+4&7])^l<<7,l=d[f+7&7],h^=(l^=l<<13)^l<<9,d[f]=h,u.i=f+1&7,h},(function(l,h){var d,f=[];if(h===(0|h))f[0]=h;else for(h=""+h,d=0;d<h.length;++d)f[7&d]=f[7&d]<<15^h.charCodeAt(d)+f[d+1&7]<<13;for(;f.length<8;)f.push(0);for(d=0;d<8&&f[d]===0;++d);for(d==8?f[7]=-1:f[d],l.x=f,l.i=0,d=256;d>0;--d)l.next()})(u,i)}function s(i,u){return u.x=i.x.slice(),u.i=i.i,u}function o(i,u){i==null&&(i=+new Date);var l=new a(i),h=u&&u.state,d=function(){return(l.next()>>>0)/4294967296};return d.double=function(){do var f=((l.next()>>>11)+(l.next()>>>0)/4294967296)/2097152;while(f===0);return f},d.int32=l.next,d.quick=d,h&&(h.x&&s(h,l),d.state=function(){return s(l,{})}),d}e&&e.exports?e.exports=o:this.xorshift7=o})(0,n)})),Cnt=Cc((function(n){(function(t,e,r){function a(i){var u=this;u.next=function(){var l,h,d=u.w,f=u.X,m=u.i;return u.w=d=d+1640531527|0,h=f[m+34&127],l=f[m=m+1&127],h^=h<<13,l^=l<<17,h^=h>>>15,l^=l>>>12,h=f[m]=h^l,u.i=m,h+(d^d>>>16)|0},(function(l,h){var d,f,m,v,y,b=[],w=128;for(h===(0|h)?(f=h,h=null):(h+="\0",f=0,w=Math.max(w,h.length)),m=0,v=-32;v<w;++v)h&&(f^=h.charCodeAt((v+32)%h.length)),v===0&&(y=f),f^=f<<10,f^=f>>>15,f^=f<<4,f^=f>>>13,v>=0&&(y=y+1640531527|0,m=(d=b[127&v]^=f+y)==0?m+1:0);for(m>=128&&(b[127&(h&&h.length||0)]=-1),m=127,v=512;v>0;--v)f=b[m+34&127],d=b[m=m+1&127],f^=f<<13,d^=d<<17,f^=f>>>15,d^=d>>>12,b[m]=f^d;l.w=y,l.X=b,l.i=m})(u,i)}function s(i,u){return u.i=i.i,u.w=i.w,u.X=i.X.slice(),u}function o(i,u){i==null&&(i=+new Date);var l=new a(i),h=u&&u.state,d=function(){return(l.next()>>>0)/4294967296};return d.double=function(){do var f=((l.next()>>>11)+(l.next()>>>0)/4294967296)/2097152;while(f===0);return f},d.int32=l.next,d.quick=d,h&&(h.X&&s(h,l),d.state=function(){return s(l,{})}),d}e&&e.exports?e.exports=o:this.xor4096=o})(0,n)})),Nnt=Cc((function(n){(function(t,e,r){function a(i){var u=this,l="";u.next=function(){var d=u.b,f=u.c,m=u.d,v=u.a;return d=d<<25^d>>>7^f,f=f-m|0,m=m<<24^m>>>8^v,v=v-d|0,u.b=d=d<<20^d>>>12^f,u.c=f=f-m|0,u.d=m<<16^f>>>16^v,u.a=v-d|0},u.a=0,u.b=0,u.c=-1640531527,u.d=1367130551,i===Math.floor(i)?(u.a=i/4294967296|0,u.b=0|i):l+=i;for(var h=0;h<l.length+20;h++)u.b^=0|l.charCodeAt(h),u.next()}function s(i,u){return u.a=i.a,u.b=i.b,u.c=i.c,u.d=i.d,u}function o(i,u){var l=new a(i),h=u&&u.state,d=function(){return(l.next()>>>0)/4294967296};return d.double=function(){do var f=((l.next()>>>11)+(l.next()>>>0)/4294967296)/2097152;while(f===0);return f},d.int32=l.next,d.quick=d,h&&(typeof h=="object"&&s(h,l),d.state=function(){return s(l,{})}),d}e&&e.exports?e.exports=o:this.tychei=o})(0,n)})),Ol=Cc((function(n){(function(t,e){var r,a=this,s=256,o=6,i="random",u=e.pow(s,o),l=e.pow(2,52),h=2*l,d=s-1;function f(w,S,N){var C=[],T=y((function $(R,D){var A,L=[],H=typeof R;if(D&&H=="object")for(A in R)try{L.push($(R[A],D-1))}catch{}return L.length?L:H=="string"?R:R+"\0"})((S=S==1?{entropy:!0}:S||{}).entropy?[w,b(t)]:w??(function(){try{var $;return r&&($=r.randomBytes)?$=$(s):($=new Uint8Array(s),(a.crypto||a.msCrypto).getRandomValues($)),b($)}catch{var R=a.navigator,D=R&&R.plugins;return[+new Date,a,D,a.screen,b(t)]}})(),3),C),I=new m(C),_=function(){for(var $=I.g(o),R=u,D=0;$<l;)$=($+D)*s,R*=s,D=I.g(1);for(;$>=h;)$/=2,R/=2,D>>>=1;return($+D)/R};return _.int32=function(){return 0|I.g(4)},_.quick=function(){return I.g(4)/4294967296},_.double=_,y(b(I.S),t),(S.pass||N||function($,R,D,A){return A&&(A.S&&v(A,I),$.state=function(){return v(I,{})}),D?(e[i]=$,R):$})(_,T,"global"in S?S.global:this==e,S.state)}function m(w){var S,N=w.length,C=this,T=0,I=C.i=C.j=0,_=C.S=[];for(N||(w=[N++]);T<s;)_[T]=T++;for(T=0;T<s;T++)_[T]=_[I=d&I+w[T%N]+(S=_[T])],_[I]=S;(C.g=function($){for(var R,D=0,A=C.i,L=C.j,H=C.S;$--;)R=H[A=d&A+1],D=D*s+H[d&(H[A]=H[L=d&L+R])+(H[L]=R)];return C.i=A,C.j=L,D})(s)}function v(w,S){return S.i=w.i,S.j=w.j,S.S=w.S.slice(),S}function y(w,S){for(var N,C=w+"",T=0;T<C.length;)S[d&T]=d&(N^=19*S[d&T])+C.charCodeAt(T++);return b(S)}function b(w){return String.fromCharCode.apply(0,w)}if(e["seed"+i]=f,y(e.random(),t),n.exports){n.exports=f;try{r=require("crypto")}catch{}}})([],Math)}));Ol.alea=bnt,Ol.xor128=xnt,Ol.xorwow=wnt,Ol.xorshift7=Snt,Ol.xor4096=Cnt,Ol.tychei=Nnt;var $1=Ol.alea,zE=(function(){function n(t,e,r,a,s){this.mean=t,this.stdDev=e,this.dtype=r,this.nextVal=NaN,this.truncated=a,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);var o=s||Math.random();this.random=$1(o.toString())}return n.prototype.nextValue=function(){if(!isNaN(this.nextVal)){var t=this.nextVal;return this.nextVal=NaN,t}for(var e,r,a=!1;!a;){var s=void 0,o=void 0,i=void 0;do i=(s=2*this.random()-1)*s+(o=2*this.random()-1)*o;while(i>=1||i===0);var u=Math.sqrt(-2*Math.log(i)/i);e=this.mean+this.stdDev*s*u,r=this.mean+this.stdDev*o*u,this.truncated&&!this.isValidTruncated(e)||(a=!0)}return this.truncated&&!this.isValidTruncated(r)||(this.nextVal=this.convertValue(r)),this.convertValue(e)},n.prototype.convertValue=function(t){return this.dtype==null||this.dtype==="float32"?t:Math.round(t)},n.prototype.isValidTruncated=function(t){return t<=this.upper&&t>=this.lower},n})(),knt=(function(){function n(t,e,r,a){this.alpha=t,this.beta=1/e,this.dtype=r;var s=a||Math.random();this.randu=$1(s.toString()),this.randn=new zE(0,1,r,!1,this.randu()),this.d=t<1?t+2/3:t-1/3,this.c=1/Math.sqrt(9*this.d)}return n.prototype.nextValue=function(){for(var t,e,r,a,s,o;;){do a=this.randn.nextValue(),o=1+this.c*a;while(o<=0);if(o*=o*o,e=1-.331*(t=a*a)*t,r=.5*t+this.d*(1-o+Math.log(o)),(s=this.randu())<e||Math.log(s)<r)break}return o=1/this.beta*this.d*o,this.alpha<1&&(o*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(o)},n.prototype.convertValue=function(t){return this.dtype==="float32"?t:Math.round(t)},n})(),Tnt=(function(){function n(t,e,r,a){var s=this;if(t===void 0&&(t=0),e===void 0&&(e=1),this.canReturnFloat=function(){return s.dtype==null||s.dtype==="float32"},this.min=t,this.range=e-t,this.dtype=r,a==null&&(a=Math.random()),typeof a=="number"&&(a=a.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error("The difference between "+t+" - "+e+" <= 1 and dtype is not float");this.random=$1(a)}return n.prototype.convertValue=function(t){return this.canReturnFloat()?t:Math.round(t)},n.prototype.nextValue=function(){return this.convertValue(this.min+this.range*this.random())},n})();function be(n,t,e){return t===void 0&&(t="float32"),t=t||"float32",LB(n),new sm(n,t,e)}function Ent(n,t){t===void 0&&(t=!1),console.log(n.toString(t))}var HB=st({batchToSpaceND_:function(n,t,e){var r=Y(n,"x","batchToSpaceND"),a=t.reduce((function(s,o){return s*o}));return Z(r.rank>=1+t.length,(function(){return"input rank is "+r.rank+" but should be > than blockShape.length "+t.length})),Z(e.length===t.length,(function(){return"crops.length is "+e.length+" but should be equal to blockShape.length  "+t.length})),Z(r.shape[0]%a==0,(function(){return"input tensor batch is "+r.shape[0]+" but is not divisible by the product of the elements of blockShape "+t.join(" * ")+" === "+a})),lt.runKernelFunc((function(s){return s.batchToSpaceND(r,t,e)}),{$x:r},(function(s){return{$x:function(){return s.spaceToBatchND(t,e)}}}))}}),Int=st({broadcastTo_:function(n,t){var e=Y(n,"broadcastTo","x"),r=e.shape;if(t.some((function(u){return!(u>0)||u%1!=0})))throw new Error("broadcastTo(): Invalid broadcast shape ["+t+"].");if(t.length<e.rank)throw new Error("broadcastTo(): shape.length="+t.length+" < input.rank="+e.rank+".");if(t.length>e.rank){for(var a=e.shape.slice();a.length<t.length;)a.unshift(1);e=e.reshape(a)}for(var s=Array.from(t),o=t.length-1;o>=0;o--)if(e.shape[o]===t[o])s[o]=1;else if(e.shape[o]!==1)throw new Error("broadcastTo(): ["+r+"] cannot be broadcast to ["+t+"].");var i=s.map((function(u,l){return u>1?l:-1})).filter((function(u){return u>=0}));return i.length===0?e.clone():lt.runKernelFunc((function(u){return u.tile(e,s)}),{input:e},(function(u){return{input:function(){return u.sum(i,!0)}}}))}}),_nt=st({cast_:function(n,t){var e=Y(n,"x","cast");if(!xet(t))throw new Error("Failed to cast to unknown dtype "+t);if(t==="string"&&e.dtype!=="string"||t!=="string"&&e.dtype==="string")throw new Error("Only strings can be casted to strings");var r={dtype:t};return lt.runKernelFunc((function(a){return a.cast(e,t)}),{x:e},(function(a){return{x:function(){return a.clone()}}}),"Cast",r)}}),Rnt=st({clone_:function(n){var t=Y(n,"x","clone",null);return lt.runKernelFunc((function(){return lt.makeTensorFromDataId(t.dataId,t.shape,t.dtype)}),{$x:t},(function(e){return{$x:function(){return e.toFloat()}}}))}}),Ant=st({cumsum_:function(n,t,e,r){t===void 0&&(t=0),e===void 0&&(e=!1),r===void 0&&(r=!1);var a=Y(n,"x","cumsum"),s=Yo([t|=0],a.rank),o=a;s!=null&&(o=a.transpose(s));var i=Qo(1,a.rank)[0],u=lt.runKernelFunc((function(l){return l.cumsum(o,i,e,r)}),{permutedX:o},(function(l){return{permutedX:function(){return l.cumsum(t,e,!r)}}}));return s!=null&&(u=u.transpose(s)),u}}),Dnt=st({depthToSpace_:function(n,t,e){e===void 0&&(e="NHWC");var r=Y(n,"x","depthToSpace"),a=e==="NHWC"?r.shape[1]:r.shape[2],s=e==="NHWC"?r.shape[2]:r.shape[3],o=e==="NHWC"?r.shape[3]:r.shape[1];return Z(a*t>=0,(function(){return`Negative dimension size caused by overflow when multiplying
      `+a+" and "+t+`  for depthToSpace with input shape
      `+r.shape})),Z(s*t>=0,(function(){return`Negative dimension size caused by overflow when multiplying
      `+s+" and "+t+` for depthToSpace with input shape
          `+r.shape})),Z(o%(t*t)==0,(function(){return"Dimension size must be evenly divisible by "+t*t+" but is "+o+" for depthToSpace with input shape "+r.shape})),lt.runKernelFunc((function(i){return i.depthToSpace(r,t,e)}),{$x:r})}}),Ms=st({expandDims_:function(n,t){t===void 0&&(t=0);var e=Y(n,"x","expandDims",null);Z(t<=e.rank,(function(){return"Axis must be <= rank of the tensor"}));var r=e.shape.slice();return t<0&&(Z(-(e.rank+1)<=t,(function(){return"Axis must be in the interval ["+-(e.rank+1)+", "+e.rank+"]"})),t=e.rank+t+1),r.splice(t,0,1),to(e,r)}}),jB=st({eye_:function(n,t,e,r){r===void 0&&(r="float32"),t==null&&(t=n);for(var a=be([n,t],r),s=n<=t?n:t,o=0;o<s;++o)a.set(1,o,o);var i=a.toTensor().as2D(n,t);if(e==null)return i;if(e.length===1)return Bh(Ms(i,0),[e[0],1,1]);if(e.length===2)return Bh(Ms(Ms(i,0),0),[e[0],e[1],1,1]);if(e.length===3)return Bh(Ms(Ms(Ms(i,0),0),0),[e[0],e[1],e[2],1,1]);throw new Error("eye() currently supports only 1D and 2D batchShapes, but received "+e.length+"D.")}}),$nt=st({multinomial_:function(n,t,e,r){r===void 0&&(r=!1);var a=Y(n,"logits","multinomial"),s=a.size,o=a.rank;if(s<2)throw new Error("Error in multinomial: you need at least 2 outcomes, but got "+s+".");if(o>2)throw new Error("Rank of probabilities must be 1 or 2, but is "+o);e=e||Math.random();var i=o===1?a.as2D(1,-1):a,u=lt.runKernelFunc((function(l){return l.multinomial(i,r,t,e)}),{logits2D:i});return o===1?u.as1D():u}}),HN=st({oneHot_:function(n,t,e,r){if(e===void 0&&(e=1),r===void 0&&(r=0),t<2)throw new Error("Error in oneHot: depth must be >=2, but it is "+t);var a=Y(n,"indices","oneHot","int32"),s=a.shape.concat([t]);return a=a.flatten(),lt.runKernelFunc((function(o){return o.oneHot(a,t,e,r)}),{$indices:a},(function(o){return{$indices:function(){return Sn(a.shape,"float32")}}})).reshape(s)}}),Nc=st({pad_:function(n,t,e){e===void 0&&(e=0);var r=Y(n,"x","pad");if(r.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");var a={paddings:t,constantValue:e};return lt.runKernelFunc((function(s){return s.pad(r,t,e)}),{x:r},(function(s){var o=t.map((function(i){return i[0]}));return{x:function(){return s.slice(o,r.shape)}}}),"PadV2",a)}}),Ont=st({pad1d_:function(n,t,e){return e===void 0&&(e=0),Z(t.length===2,(function(){return"Invalid number of paddings. Must be length of 2."})),Nc(n,[t],e)}}),Fnt=st({pad2d_:function(n,t,e){return e===void 0&&(e=0),Z(t.length===2&&t[0].length===2&&t[1].length===2,(function(){return"Invalid number of paddings. Must be length of 2 each."})),Nc(n,t,e)}}),Mnt=st({pad3d_:function(n,t,e){return e===void 0&&(e=0),Z(t.length===3&&t[0].length===2&&t[1].length===2&&t[2].length===2,(function(){return"Invalid number of paddings. Must be length of 2 each."})),Nc(n,t,e)}}),Lnt=st({pad4d_:function(n,t,e){return e===void 0&&(e=0),Z(t.length===4&&t[0].length===2&&t[1].length===2&&t[2].length===2&&t[3].length===2,(function(){return"Invalid number of paddings. Must be length of 2 each."})),Nc(n,t,e)}}),Bnt=st({rand_:function(n,t,e){var r=ee(n),a=null;if(e==null||e==="float32")a=new Float32Array(r);else if(e==="int32")a=new Int32Array(r);else{if(e!=="bool")throw new Error("Unknown data type "+e);a=new Uint8Array(r)}for(var s=0;s<r;s++)a[s]=t();return lt.makeTensor(a,n,e)}}),znt=st({randomNormal_:function(n,t,e,r,a){if(t===void 0&&(t=0),e===void 0&&(e=1),r!=null&&r==="bool")throw new Error("Unsupported data type "+r);for(var s=new zE(t,e,r,!1,a),o=be(n,r),i=0;i<o.values.length;i++)o.values[i]=s.nextValue();return o.toTensor()}}),Pnt=st({randomGamma_:function(n,t,e,r,a){if(e===void 0&&(e=1),r===void 0&&(r="float32"),e==null&&(e=1),r==null&&(r="float32"),r!=="float32"&&r!=="int32")throw new Error("Unsupported data type "+r);for(var s=new knt(t,e,r,a),o=be(n,r),i=0;i<o.values.length;i++)o.values[i]=s.nextValue();return o.toTensor()}}),qB=st({randomUniform_:function(n,t,e,r,a){t===void 0&&(t=0),e===void 0&&(e=1),r===void 0&&(r="float32");for(var s=be(n,r),o=new Tnt(t,e,null,a),i=0;i<s.values.length;i++)s.values[i]=o.nextValue();return s.toTensor()}}),to=st({reshape_:function(n,t){var e=Y(n,"x","reshape",null);t=yet(t,e.size),Z(e.size===ee(t),(function(){return"new shape and old shape must have the same number of elements."}));var r={shape:t};return lt.runKernelFunc((function(a){return a.reshape(e,t)}),{x:e},(function(a){return{x:function(){return a.reshape(e.shape)}}}),"Reshape",r)}}),KB=st({spaceToBatchND_:function(n,t,e){var r=Y(n,"x","spaceToBatchND");return Z(r.rank>=1+t.length,(function(){return"input rank "+r.rank+" should be > than [blockShape] "+t.length})),Z(e.length===t.length,(function(){return"paddings.shape[0] "+e.length+" must be equal to [blockShape] "+t.length})),Z(r.shape.reduce((function(a,s,o){return o>0&&o<=t.length?a&&(s+e[o-1][0]+e[o-1][1])%t[o-1]==0:a}),!0),(function(){return"input spatial dimensions "+r.shape.slice(1)+" with paddings "+e.toString()+" must be divisible by blockShapes "+t.toString()})),lt.runKernelFunc((function(a){return a.spaceToBatchND(r,t,e)}),{$x:r},(function(a){return{$x:function(){return a.batchToSpaceND(t,e)}}}))}}),XB=st({squeeze_:function(n,t){var e=Y(n,"x","squeeze");return to(e,zl(e.shape,t).newShape)}}),ys=st({stack_:function(n,t){t===void 0&&(t=0);var e=Q0(n,"tensors","stack");if(Z(e.length>=1,(function(){return"Pass at least one tensor to tf.stack"})),e.length===1)return e[0].expandDims(t);var r=e[0].rank,a=e[0].shape,s=e[0].dtype;Z(t<=r,(function(){return"Axis must be <= rank of the tensor"})),e.forEach((function(i){Je(a,i.shape,"All tensors passed to stack must have matching shapes")})),e.forEach((function(i){Z(s===i.dtype,(function(){return"All tensors passed to stack must have matching dtypes"}))}));var o=e.map((function(i){return i.expandDims(t)}));return yr(o,t)}}),Bh=st({tile_:function(n,t){var e=Y(n,"x","tile",null);Z(e.rank===t.length,(function(){return"Error in transpose: rank of input "+e.rank+" must match length of reps "+t+"."}));var r=[e],a={reps:t};return lt.runKernelFunc((function(s,o){var i=s.tile(e,t);return o([e]),i}),{x:e},(function(s,o){var i=o[0];return{x:function(){var u=He(i);if(i.rank===1)for(var l=0;l<t[0];++l)u=u.add(s.slice([l*i.shape[0]],[i.shape[0]]));else if(i.rank===2)for(l=0;l<t[0];++l)for(var h=0;h<t[1];++h)u=u.add(s.slice([l*i.shape[0],h*i.shape[1]],[i.shape[0],i.shape[1]]));else if(i.rank===3)for(l=0;l<t[0];++l)for(h=0;h<t[1];++h)for(var d=0;d<t[2];++d)u=u.add(s.slice([l*i.shape[0],h*i.shape[1],d*i.shape[2]],[i.shape[0],i.shape[1],i.shape[2]]));else{if(i.rank!==4)throw new Error("Gradient for tile operation is not implemented for rank-"+i.rank+" tensors yet.");for(l=0;l<t[0];++l)for(h=0;h<t[1];++h)for(d=0;d<t[2];++d)for(var f=0;f<t[3];++f)u=u.add(s.slice([l*i.shape[0],h*i.shape[1],d*i.shape[2],f*i.shape[3]],[i.shape[0],i.shape[1],i.shape[2],i.shape[3]]))}return u}}}),"Tile",a,r)}}),Vnt=st({truncatedNormal_:function(n,t,e,r,a){if(t===void 0&&(t=0),e===void 0&&(e=1),r!=null&&r==="bool")throw new Error("Unsupported data type "+r);for(var s=new zE(t,e,r,!0,a),o=be(n,r),i=0;i<o.values.length;i++)o.values[i]=s.nextValue();return o.toTensor()}}),br=st({unstack_:function(n,t){t===void 0&&(t=0),t=t||0;var e=Y(n,"x","unstack");Z(t>=-e.shape.length&&t<e.shape.length,(function(){return"Axis = "+t+" is not in [-"+e.shape.length+", "+e.shape.length+")"})),t<0&&(t+=e.shape.length);var r={axis:t};return lt.runKernelFunc((function(a){return a.unstack(e,t)}),{x:e},(function(a){return{x:function(){return ys(a,t)}}}),"Unpack",r)}}),Unt=function(n,t){return Yt(this,void 0,void 0,(function(){var e,r,a,s,o,i,u,l,h,d;return Qt(this,(function(f){switch(f.label){case 0:return e=Y(n,"x","setdiff1d"),r=Y(t,"y","setdiff1d"),Z(e.dtype===r.dtype,(function(){return"x and y should have the same dtype, but got x ("+e.dtype+") and y ("+r.dtype+")."})),Z(e.rank===1,(function(){return"x should be 1D tensor, but got x ("+e.shape+")."})),Z(r.rank===1,(function(){return"y should be 1D tensor, but got y ("+r.shape+")."})),[4,e.data()];case 1:return a=f.sent(),[4,r.data()];case 2:for(s=f.sent(),o=new Set(s),i=0,h=0;h<a.length;h++)o.has(a[h])||i++;for(u=new sm([i],e.dtype),l=new sm([i],"int32"),h=0,d=0;h<a.length;h++)o.has(a[h])||(u.values[d]=a[h],l.values[d]=h,d++);return[2,[u.toTensor(),l.toTensor()]]}}))}))};function J0(n,t,e,r){r===void 0&&(r=!0);var a=[];if(r)(a=a.concat(t.slice(0))).push(n[0]/e),a=a.concat(n.slice(1));else{a=a.concat(n[0]);for(var s=t.length,o=0;o<s;++o)a=a.concat([n[o+1]/t[o],t[o]]);a=a.concat(n.slice(s+1))}return a}function tb(n,t,e){e===void 0&&(e=!0);var r=[];if(e){r.push(t);for(var a=t+1;a<n;++a)a<=2*t?(r.push(a),r.push(a-(t+1))):r.push(a)}else{var s=[],o=[];for(a=1;a<n;++a)a>=2*t+1||a%2==1?o.push(a):s.push(a);r.push.apply(r,s),r.push(0),r.push.apply(r,o)}return r}function eb(n,t,e,r){r===void 0&&(r=!0);var a=[];r?a.push(n[0]/e):a.push(n[0]*e);for(var s=1;s<n.length;++s)s<=t.length?r?a.push(t[s-1]*n[s]):a.push(n[s]/t[s-1]):a.push(n[s]);return a}function YB(n,t){for(var e=[0],r=0;r<t;++r)e.push(n[r][0]);return e}function QB(n,t,e){for(var r=n.slice(0,1),a=0;a<e;++a)r.push(n[a+1]-t[a][0]-t[a][1]);return r}function ZB(n,t){if(n.rank<1)throw new Error("tf.gatherND() expects the input to be rank 1 or higher, but the rank was "+n.rank+".");if(t.rank<1)throw new Error("tf.gatherND() expects the indices to be rank 1 or higher, but the rank was "+t.rank+".");if(t.dtype!=="int32")throw new Error("tf.gatherND() expects the indices to be int32 type, but the dtype was "+t.dtype+".");if(t.shape[t.rank-1]>n.rank)throw new Error("index innermost dimension length must be <= tensor rank; saw: "+t.shape[t.rank-1]+" vs. "+n.rank);if(n.size===0)throw new Error("Requested more than 0 entries, but input is empty. Input shape: "+n.shape+".");for(var e=t.shape,r=e[e.length-1],a=1,s=0;s<e.length-1;++s)a*=e[s];var o=n.shape,i=e.slice();i.pop();var u=1;for(s=r;s<n.rank;++s)u*=o[s],i.push(o[s]);var l=Lo(n.shape).map((function(h){return h/u})).concat([1]).slice(0,r);return[i,a,u,l]}var JB=30;function tC(n){return n<=JB?n:zN(n,Math.floor(Math.sqrt(n)))}function Wnt(n,t,e){var r=t.rank>1?t.shape[t.rank-1]:1,a=t.rank>1?t.rank-1:1,s="Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: "+e.shape+", indices.shape: "+t.shape+", shape: "+n+", sliceDim: "+r+", and batchDim: "+a+".";if(e.rank<a)throw new Error(s+" update.rank < "+a+". ");if(n.length<r+(e.rank-a))throw new Error(s+" Output shape length < "+(r+(e.rank-a)));if(e.rank!==a+n.length-r)throw new Error(s+" update.rank != "+(a+n.length-r));for(var o=0;o<a;++o)if(e.shape[o]!==t.shape[o])throw new Error(s+" updates.shape["+o+"] ("+e.shape[o]+") != indices.shape["+o+"] ("+t.shape[o]+").");for(o=0;o<e.rank-a;++o)if(e.shape[o+a]!==n[o+r])throw new Error(s+" updates.shape["+(o+a)+"] ("+e.shape[o+a]+") != shape["+(o+a)+"] ("+n[o+a]+")")}function Gnt(n,t,e){if(t.rank<1)throw new Error("tf.scatterND() expects the indices to be rank 1 or higher, but the rank was "+t.rank+".");if(n.rank<1)throw new Error("tf.scatterND() expects the updates to be rank 1 or higher, but the rank was "+n.rank+".");if(t.dtype!=="int32")throw new Error("The dtype of 'indices' should be int32, but got dtype: "+t.dtype);if(e.length<1)throw new Error("Output rank must be greater or equal to 1, but got shape: "+e);if(e.length===0){if(t.size===0)throw new Error("Indices specified for empty output. indices shape: "+t.shape);if(n.size===0)throw new Error("Updates specified for empty output. updates shape: "+n.shape)}Wnt(e,t,n)}function nb(n,t,e){for(var r=t.shape.length,a=r>1?t.shape[r-1]:1,s=e.length,o=1,i=a;i<s;++i)o*=e[i];var u=a<1?1:a;return{sliceRank:a,numUpdates:ee(t.shape)/u,sliceSize:o,strides:Lo(e.slice(0,a)).concat([1]),outputSize:ee(e)}}function Hnt(n,t,e){Z(n.rank===t.length,(function(){return"Error in slice"+n.rank+"D: Length of begin "+t+" must match the rank of the array ("+n.rank+")."})),Z(n.rank===e.length,(function(){return"Error in slice"+n.rank+"D: Length of size "+e+" must match the rank of the array ("+n.rank+")."}));for(var r=function(s){Z(t[s]+e[s]<=n.shape[s],(function(){return"Error in slice"+n.rank+"D: begin["+s+"] + size["+s+"] ("+(t[s]+e[s])+") would overflow input.shape["+s+"] ("+n.shape[s]+")"}))},a=0;a<n.rank;++a)r(a)}function s3(n){for(var t=[],e=0;n>0;)1&n&&t.push(e),n/=2,e++;return t}function PE(n,t,e){for(var r=[],a=0;a<n.length;a++)r[a]=Math.ceil((t[a]-n[a])/e[a]);return r}function jnt(n,t,e,r,a){var s=t[a],o=e[a]||1;(n&1<<a||s==null)&&(s=o>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);var i=r[a];return s<0&&(s+=i),s=MN(0,s,i-1)}function qnt(n,t,e,r,a){var s=t[a],o=e[a]||1;(n&1<<a||s==null)&&(s=o>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);var i=r[a];return s<0&&(s+=i),s=o>0?MN(0,s,i):MN(-1,s,i-1)}function tz(n,t,e){for(var r=e.length,a=0;a<e.length;a++)if(e[a]>1){r=a;break}for(a=r+1;a<e.length;a++)if(t[a]>0||e[a]!==n[a])return!1;return!0}function ez(n,t){for(var e=n.length>0?n[n.length-1]:1,r=0;r<n.length-1;r++)e+=n[r]*t[r];return e}function Knt(n,t){Z(BN(n),(function(){return"The f passed in variableGrads(f) must be a function"})),Z(t==null||Array.isArray(t)&&t.every((function(h){return h instanceof nd})),(function(){return"The varList passed in variableGrads(f, varList) must be an array of variables"}));var e=t!=null;if(!e)for(var r in t=[],lt.registeredVariables)t.push(lt.registeredVariables[r]);var a=e?t.filter((function(h){return!h.trainable})):null,s=t.length;Z((t=t.filter((function(h){return h.trainable}))).length>0,(function(){return"variableGrads() expects at least one of the input variables to be trainable, but none of the "+s+" variables is trainable."}));var o=lt.gradients(n,t,null,!0),i=o.value,u=o.grads;Z(u.some((function(h){return h!=null})),(function(){return"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."})),Z(i.rank===0,(function(){return"The f passed in variableGrads(f) must return a scalar, but it returned a rank-"+i.rank+" tensor"}));var l={};return t.forEach((function(h,d){u[d]!=null&&(l[h.name]=u[d])})),a?.forEach((function(h){return l[h.name]=null})),{value:i,grads:l}}function O1(n){return lt.customGrad(n)}var Wi=st({softmax_:function(n,t){t===void 0&&(t=-1);var e=Y(n,"logits","softmax","float32");if(t===-1&&(t=e.rank-1),t!==e.rank-1)throw Error("Softmax along a non-last dimension is not yet supported. Logits was rank "+e.rank+" and dim was "+t);return lt.runKernelFunc((function(r,a){var s=r.softmax(e,t);return a([s]),s}),{logits:e},(function(r,a){var s=a[0],o=r.mul(s);return{logits:function(){return o.sub(o.sum([t],!0).mul(s))}}}),"Softmax",{dim:t},[],[!0])}}),Xnt=st({logSoftmax_:function(n,t){t===void 0&&(t=-1);var e=Y(n,"logits","logSoftmax");if(t===-1&&(t=e.rank-1),t!==e.rank-1)throw Error("Log Softmax along a non-last dimension is not yet supported. Logits was rank "+e.rank+" and axis was "+t);return O1((function(r,a){var s=r.max(t,!0),o=r.sub(s),i=o.toFloat().sub(o.exp().sum(t,!0).log());return a([i]),{value:i,gradFunc:function(u,l){var h=l[0].exp();return u.sub(u.sum(t,!0).mul(h))}}}))(e)}}),nz=(function(){function n(t,e){this.backend=t,this.dataMover=e,this.data=new WeakMap,this.dataIdsCount=0}return n.prototype.get=function(t){return this.data.has(t)||this.dataMover.moveData(this.backend,t),this.data.get(t)},n.prototype.set=function(t,e){this.dataIdsCount++,this.data.set(t,e)},n.prototype.has=function(t){return this.data.has(t)},n.prototype.delete=function(t){return this.dataIdsCount--,this.data.delete(t)},n.prototype.numDataIds=function(){return this.dataIdsCount},n})(),rz=(function(){function n(){}return n.prototype.time=function(t){return bt("time")},n.prototype.read=function(t){return bt("read")},n.prototype.readSync=function(t){return bt("readSync")},n.prototype.numDataIds=function(){return bt("numDataIds")},n.prototype.disposeData=function(t){return bt("disposeData")},n.prototype.write=function(t,e,r){return bt("write")},n.prototype.move=function(t,e,r,a){return bt("move")},n.prototype.memory=function(){return bt("memory")},n.prototype.floatPrecision=function(){return bt("floatPrecision")},n.prototype.epsilon=function(){return this.floatPrecision()===32?1e-7:1e-4},n.prototype.batchMatMul=function(t,e,r,a){return bt("batchMatMul")},n.prototype.fusedBatchMatMul=function(t){return t.a,t.b,t.transposeA,t.transposeB,t.bias,t.activation,t.preluActivationWeights,bt("fusedBatchMatMul")},n.prototype.slice=function(t,e,r){return bt("slice")},n.prototype.stridedSlice=function(t,e,r,a){return bt("stridedSlice")},n.prototype.unstack=function(t,e){return bt("unstack")},n.prototype.reverse=function(t,e){return bt("reverse")},n.prototype.concat=function(t,e){return bt("concat")},n.prototype.neg=function(t){return bt("neg")},n.prototype.add=function(t,e){return bt("add")},n.prototype.addN=function(t){return bt("addN")},n.prototype.subtract=function(t,e){return bt("subtract")},n.prototype.multiply=function(t,e){return bt("multiply")},n.prototype.realDivide=function(t,e){return bt("realDivide")},n.prototype.floorDiv=function(t,e){return bt("floorDiv")},n.prototype.sum=function(t,e){return bt("sum")},n.prototype.prod=function(t,e){return bt("prod")},n.prototype.unsortedSegmentSum=function(t,e,r){return bt("unsortedSegmentSum")},n.prototype.argMin=function(t,e){return bt("argMin")},n.prototype.argMax=function(t,e){return bt("argMax")},n.prototype.equal=function(t,e){return bt("equal")},n.prototype.notEqual=function(t,e){return bt("notEqual")},n.prototype.less=function(t,e){return bt("less")},n.prototype.lessEqual=function(t,e){return bt("lessEqual")},n.prototype.greater=function(t,e){return bt("greater")},n.prototype.greaterEqual=function(t,e){return bt("greaterEqual")},n.prototype.logicalNot=function(t){return bt("logicalNot")},n.prototype.logicalAnd=function(t,e){return bt("logicalAnd")},n.prototype.logicalOr=function(t,e){return bt("logicalOr")},n.prototype.where=function(t){return bt("where")},n.prototype.select=function(t,e,r){return bt("select")},n.prototype.topk=function(t,e,r){return bt("topk")},n.prototype.min=function(t,e){return bt("min")},n.prototype.minimum=function(t,e){return bt("minimum")},n.prototype.mod=function(t,e){return bt("mod")},n.prototype.max=function(t,e){return bt("max")},n.prototype.maximum=function(t,e){return bt("maximum")},n.prototype.all=function(t,e){return bt("all")},n.prototype.any=function(t,e){return bt("any")},n.prototype.squaredDifference=function(t,e){return bt("squaredDifference")},n.prototype.ceil=function(t){return bt("ceil")},n.prototype.floor=function(t){return bt("floor")},n.prototype.round=function(t){return bt("round")},n.prototype.sign=function(t){return bt("sign")},n.prototype.isNaN=function(t){return bt("isNaN")},n.prototype.isInf=function(t){return bt("isInf")},n.prototype.isFinite=function(t){return bt("isFinite")},n.prototype.pow=function(t,e){return bt("pow")},n.prototype.exp=function(t){return bt("exp")},n.prototype.expm1=function(t){return bt("expm1")},n.prototype.softmax=function(t,e){return bt("softmax")},n.prototype.log=function(t){return bt("log")},n.prototype.log1p=function(t){return bt("log1p")},n.prototype.sqrt=function(t){return bt("sqrt")},n.prototype.rsqrt=function(t){return bt("rsqrt")},n.prototype.square=function(t){return bt("square")},n.prototype.reciprocal=function(t){return bt("reciprocal")},n.prototype.relu=function(t){return bt("relu")},n.prototype.relu6=function(t){return bt("relu6")},n.prototype.prelu=function(t,e){return bt("prelu")},n.prototype.elu=function(t){return bt("elu")},n.prototype.eluDer=function(t,e){return bt("eluDer")},n.prototype.selu=function(t){return bt("selu")},n.prototype.int=function(t){return bt("int")},n.prototype.clip=function(t,e,r){return bt("clip")},n.prototype.abs=function(t){return bt("abs")},n.prototype.complexAbs=function(t){return bt("complexAbs")},n.prototype.sigmoid=function(t){return bt("sigmoid")},n.prototype.softplus=function(t){return bt("softplus")},n.prototype.sin=function(t){return bt("sin")},n.prototype.cos=function(t){return bt("cos")},n.prototype.tan=function(t){return bt("tan")},n.prototype.asin=function(t){return bt("asin")},n.prototype.acos=function(t){return bt("acos")},n.prototype.atan=function(t){return bt("atan")},n.prototype.atan2=function(t,e){return bt("atan2")},n.prototype.sinh=function(t){return bt("sinh")},n.prototype.cosh=function(t){return bt("cosh")},n.prototype.tanh=function(t){return bt("tanh")},n.prototype.asinh=function(t){return bt("asinh")},n.prototype.acosh=function(t){return bt("acosh")},n.prototype.atanh=function(t){return bt("atanh")},n.prototype.erf=function(t){return bt("erf")},n.prototype.step=function(t,e){return bt("step")},n.prototype.fusedConv2d=function(t){return t.input,t.filter,t.convInfo,t.bias,t.activation,t.preluActivationWeights,bt("fusedConv2d")},n.prototype.conv2d=function(t,e,r){return bt("conv2d")},n.prototype.conv2dDerInput=function(t,e,r){return bt("conv2dDerInput")},n.prototype.conv2dDerFilter=function(t,e,r){return bt("conv2dDerFilter")},n.prototype.fusedDepthwiseConv2D=function(t){return t.input,t.filter,t.convInfo,t.bias,t.activation,t.preluActivationWeights,bt("fusedDepthwiseConv2D")},n.prototype.depthwiseConv2D=function(t,e,r){return bt("depthwiseConv2D")},n.prototype.depthwiseConv2DDerInput=function(t,e,r){return bt("depthwiseConv2DDerInput")},n.prototype.depthwiseConv2DDerFilter=function(t,e,r){return bt("depthwiseConv2DDerFilter")},n.prototype.conv3d=function(t,e,r){return bt("conv3d")},n.prototype.conv3dDerInput=function(t,e,r){return bt("conv3dDerInput")},n.prototype.conv3dDerFilter=function(t,e,r){return bt("conv3dDerFilter")},n.prototype.maxPool=function(t,e){return bt("maxPool")},n.prototype.maxPoolBackprop=function(t,e,r,a){return bt("maxPoolBackprop")},n.prototype.avgPool=function(t,e){return bt("avgPool")},n.prototype.avgPoolBackprop=function(t,e,r){return bt("avgPoolBackprop")},n.prototype.avgPool3d=function(t,e){return bt("avgPool3d")},n.prototype.avgPool3dBackprop=function(t,e,r){return bt("avgPool3dBackprop")},n.prototype.maxPool3d=function(t,e){return bt("maxPool3d")},n.prototype.maxPool3dBackprop=function(t,e,r,a){return bt("maxPool3dBackprop")},n.prototype.reshape=function(t,e){return bt("reshape")},n.prototype.cast=function(t,e){return bt("cast")},n.prototype.tile=function(t,e){return bt("tile")},n.prototype.pad=function(t,e,r){return bt("pad")},n.prototype.transpose=function(t,e){return bt("transpose")},n.prototype.gather=function(t,e,r){return bt("gather")},n.prototype.gatherND=function(t,e){return bt("gatherND")},n.prototype.scatterND=function(t,e,r){return bt("scatterND")},n.prototype.batchToSpaceND=function(t,e,r){return bt("batchToSpaceND")},n.prototype.spaceToBatchND=function(t,e,r){return bt("spaceToBatchND")},n.prototype.resizeBilinear=function(t,e,r,a){return bt("resizeBilinear")},n.prototype.resizeBilinearBackprop=function(t,e,r){return bt("resizeBilinearBackprop")},n.prototype.resizeNearestNeighbor=function(t,e,r,a){return bt("resizeNearestNeighbor")},n.prototype.resizeNearestNeighborBackprop=function(t,e,r){return bt("resizeNearestNeighborBackprop")},n.prototype.batchNormalization=function(t,e,r,a,s,o){return bt("batchNormalization")},n.prototype.localResponseNormalization4D=function(t,e,r,a,s){return bt("localResponseNormalization4D")},n.prototype.LRNGrad=function(t,e,r,a,s,o,i){return bt("LRNGrad")},n.prototype.multinomial=function(t,e,r,a){return bt("multinomial")},n.prototype.oneHot=function(t,e,r,a){return bt("oneHot")},n.prototype.cumsum=function(t,e,r,a){return bt("cumsum")},n.prototype.nonMaxSuppression=function(t,e,r,a,s){return bt("nonMaxSuppression")},n.prototype.fft=function(t){return bt("fft")},n.prototype.ifft=function(t){return bt("ifft")},n.prototype.complex=function(t,e){return bt("complex")},n.prototype.real=function(t){return bt("real")},n.prototype.imag=function(t){return bt("imag")},n.prototype.cropAndResize=function(t,e,r,a,s,o){return bt("cropAndResize")},n.prototype.depthToSpace=function(t,e,r){return bt("depthToSpace")},n.prototype.split=function(t,e,r){return bt("split")},n.prototype.sparseToDense=function(t,e,r,a){return bt("sparseToDense")},n.prototype.diag=function(t){return bt("diag")},n.prototype.fill=function(t,e,r){return bt("fill")},n.prototype.onesLike=function(t){return bt("onesLike")},n.prototype.zerosLike=function(t){return bt("zerosLike")},n.prototype.linspace=function(t,e,r){return bt("linspace")},n.prototype.dispose=function(){return bt("dispose")},n})();function bt(n){throw new Error("'"+n+"' not yet implemented or not found in the registry. Did you forget to import the kernel?")}function Cu(n,t){for(var e=n.length,r=[],a=0;a<e;a++){var s=e-1-a,o=n[s]||1;(t[t.length-1-a]||1)>1&&o===1&&r.unshift(s)}return r}function Sr(n,t){for(var e=[],r=0;r<t.length;r++){var a=n[n.length-r-1],s=t.length-r-1,o=t[s];(a==null||a===1&&o>1)&&e.unshift(s)}return e}function Le(n,t){for(var e=[],r=Math.max(n.length,t.length),a=0;a<r;a++){var s=n[n.length-a-1];s==null&&(s=1);var o=t[t.length-a-1];if(o==null&&(o=1),s===1)e.unshift(o);else if(o===1)e.unshift(s);else{if(s!==o)throw Error("Operands could not be broadcast together with shapes "+n+" and "+t+".");e.unshift(s)}}return e}function im(n,t,e,r,a,s,o){o===void 0&&(o="channelsLast");var i,u=sb(t),l=u[0],h=u[1];if(o==="channelsLast")i=[l,h,n[3],n[3]];else{if(o!=="channelsFirst")throw new Error("Unknown dataFormat "+o);i=[l,h,n[1],n[1]]}return kc(n,i,e,r,a,s,!1,o)}function rb(n,t,e,r,a,s,o){o===void 0&&(o="NDHWC");var i,u,l=jN(t),h=l[0],d=l[1],f=l[2];if(o==="NDHWC")u="channelsLast",i=[h,d,f,n[4],n[4]];else{if(o!=="NCDHW")throw new Error("Unknown dataFormat "+o);u="channelsFirst",i=[h,d,f,n[1],n[1]]}return ab(n,i,e,r,a,!1,u,s)}function kc(n,t,e,r,a,s,o,i){o===void 0&&(o=!1),i===void 0&&(i="channelsLast");var u=[-1,-1,-1,-1],l=u[0],h=u[1],d=u[2],f=u[3];if(i==="channelsLast")l=n[0],h=n[1],d=n[2],f=n[3];else{if(i!=="channelsFirst")throw new Error("Unknown dataFormat "+i);l=n[0],f=n[1],h=n[2],d=n[3]}var m,v=t[0],y=t[1],b=t[3],w=sb(e),S=w[0],N=w[1],C=sb(r),T=C[0],I=C[1],_=zh(v,T),$=zh(y,I),R=(function(G,q,B,j,K,z,U,M){var X,Q,rt;if(typeof G=="number"){X={top:G,bottom:G,left:G,right:G,type:G===0?"VALID":"NUMBER"};var ct=(function(At,Lt,Mt,Wt,se){Wt==null&&(Wt=az(At,Lt,Mt));var Xt=At[0],Se=At[1],pe=Vf((Xt-Lt+2*Wt)/Mt+1,se);Z(Qn(pe),(function(){return"The output # of rows ("+pe+") must be an integer. Change the stride and/or zero pad parameters"}));var Xe=Vf((Se-Lt+2*Wt)/Mt+1,se);return Z(Qn(Xe),(function(){return"The output # of columns ("+Xe+") must be an integer. Change the stride and/or zero pad parameters"})),[pe,Xe]})([q,B],z,j,G,M);Q=ct[0],rt=ct[1]}else if(G==="same"){Q=Math.ceil(q/j),rt=Math.ceil(B/K);var pt=Math.max(0,(Q-1)*j+z-q),yt=Math.max(0,(rt-1)*K+U-B),Tt=Math.floor(pt/2),gt=pt-Tt,Rt=Math.floor(yt/2);X={top:Tt,bottom:gt,left:Rt,right:yt-Rt,type:"SAME"}}else{if(G!=="valid")throw Error("Unknown padding parameter: "+G);X={top:0,bottom:0,left:0,right:0,type:"VALID"},Q=Math.ceil((q-z+1)/j),rt=Math.ceil((B-U+1)/K)}return{padInfo:X,outHeight:Q,outWidth:rt}})(a,h,d,S,N,_,$,s),D=R.padInfo,A=R.outHeight,L=R.outWidth,H=o?b*f:b;return i==="channelsFirst"?m=[l,H,A,L]:i==="channelsLast"&&(m=[l,A,L,H]),{batchSize:l,dataFormat:i,inHeight:h,inWidth:d,inChannels:f,outHeight:A,outWidth:L,outChannels:H,padInfo:D,strideHeight:S,strideWidth:N,filterHeight:v,filterWidth:y,effectiveFilterHeight:_,effectiveFilterWidth:$,dilationHeight:T,dilationWidth:I,inShape:n,outShape:m,filterShape:t}}function ab(n,t,e,r,a,s,o,i){s===void 0&&(s=!1),o===void 0&&(o="channelsLast");var u=[-1,-1,-1,-1,-1],l=u[0],h=u[1],d=u[2],f=u[3],m=u[4];if(o==="channelsLast")l=n[0],h=n[1],d=n[2],f=n[3],m=n[4];else{if(o!=="channelsFirst")throw new Error("Unknown dataFormat "+o);l=n[0],m=n[1],h=n[2],d=n[3],f=n[4]}var v,y=t[0],b=t[1],w=t[2],S=t[4],N=jN(e),C=N[0],T=N[1],I=N[2],_=jN(r),$=_[0],R=_[1],D=_[2],A=zh(y,$),L=zh(b,R),H=zh(w,D),G=(function(U,M,X,Q,rt,ct,pt,yt,Tt,gt,Rt){var At,Lt,Mt,Wt;if(typeof U=="number"){At={top:U,bottom:U,left:U,right:U,front:U,back:U,type:U===0?"VALID":"NUMBER"};var se=(function(Ge,Ot,Ht,Ce,ge,en){ge==null&&(ge=az(Ge,Ot,Ce));var hr=Ge[0],Wr=Ge[1],ti=Ge[2],Er=Vf((hr-Ot+2*ge)/Ce+1,en);Z(Qn(Er),(function(){return"The output # of depths ("+Er+") must be an integer. Change the stride and/or zero pad parameters"}));var Dn=Vf((Wr-Ot+2*ge)/Ce+1,en);Z(Qn(Dn),(function(){return"The output # of rows ("+Dn+") must be an integer. Change the stride and/or zero pad parameters"}));var dr=Vf((ti-Ot+2*ge)/Ce+1,en);return Z(Qn(dr),(function(){return"The output # of columns ("+dr+") must be an integer. Change the stride and/or zero pad parameters"})),[Er,Dn,dr,Ht]})([M,X,Q,1],yt,1,rt,U,Rt);Lt=se[0],Mt=se[1],Wt=se[2]}else if(U==="same"){Lt=Math.ceil(M/rt),Mt=Math.ceil(X/ct),Wt=Math.ceil(Q/pt);var Xt=(Lt-1)*rt+yt-M,Se=(Mt-1)*ct+Tt-X,pe=(Wt-1)*pt+gt-Q,Xe=Math.floor(Xt/2),We=Xt-Xe,hn=Math.floor(Se/2),vn=Se-hn,Hn=Math.floor(pe/2);At={top:hn,bottom:vn,left:Hn,right:pe-Hn,front:Xe,back:We,type:"SAME"}}else{if(U!=="valid")throw Error("Unknown padding parameter: "+U);At={top:0,bottom:0,left:0,right:0,front:0,back:0,type:"VALID"},Lt=Math.ceil((M-yt+1)/rt),Mt=Math.ceil((X-Tt+1)/ct),Wt=Math.ceil((Q-gt+1)/pt)}return{padInfo:At,outDepth:Lt,outHeight:Mt,outWidth:Wt}})(a,h,d,f,C,T,I,A,L,H,i),q=G.padInfo,B=G.outDepth,j=G.outHeight,K=G.outWidth,z=s?S*m:S;return o==="channelsFirst"?v=[l,z,B,j,K]:o==="channelsLast"&&(v=[l,B,j,K,z]),{batchSize:l,dataFormat:o,inDepth:h,inHeight:d,inWidth:f,inChannels:m,outDepth:B,outHeight:j,outWidth:K,outChannels:z,padInfo:q,strideDepth:C,strideHeight:T,strideWidth:I,filterDepth:y,filterHeight:b,filterWidth:w,effectiveFilterDepth:A,effectiveFilterHeight:L,effectiveFilterWidth:H,dilationDepth:$,dilationHeight:R,dilationWidth:D,inShape:n,outShape:v,filterShape:t}}function az(n,t,e,r){r===void 0&&(r=1);var a=zh(t,r);return Math.floor((n[0]*(e-1)-e+a)/2)}function sb(n){return typeof n=="number"?[n,n,n]:n.length===2?[n[0],n[1],1]:n}function jN(n){return typeof n=="number"?[n,n,n]:n}function zh(n,t){return t<=1?n:n+(n-1)*(t-1)}function Vf(n,t){if(!t)return n;switch(t){case"round":return Math.round(n);case"ceil":return Math.ceil(n);case"floor":return Math.floor(n);default:throw new Error("Unknown roundingMode "+t)}}function ad(n){var t=sb(n),e=t[0],r=t[1],a=t[2];return e===1&&r===1&&a===1}function qa(n,t){return ad(n)||ad(t)}function VE(n){if(n==="NHWC")return"channelsLast";if(n==="NCHW")return"channelsFirst";throw new Error("Unknown dataFormat "+n)}function sz(n,t,e){if(t==="complex64"){if(n.dtype==="complex64")return n.clone();var r=Sn(n.shape),a=n.toFloat(),s=e.complex(a,r);return r.dispose(),a.dispose(),s}if(!wet(n.dtype,t))return lt.makeTensorFromDataId(n.dataId,n.shape,t);if(n.dtype==="complex64"){var o=e.real(n);return s=o.cast(t),o.dispose(),s}if(t==="int32")return e.int(n);if(t==="bool"){var i=Pt(0,n.dtype);return s=e.notEqual(n,i),i.dispose(),s}throw new Error("Error in Cast: failed to cast "+n.dtype+" to "+t)}function qN(n,t){return lt.makeTensorFromDataId(n.dataId,t,n.dtype)}function oz(n,t,e){var r=(t-n)/(e-1),a=Kg(e,"float32");a[0]=n;for(var s=1;s<a.length;s++)a[s]=a[s-1]+r;return rr(a,"float32")}function KN(n,t){if(n.length!==t.length)throw new Error("Cannot merge real and imag arrays of different lengths. real:"+n.length+", imag: "+t.length+".");for(var e=new Float32Array(2*n.length),r=0;r<e.length;r+=2)e[r]=n[r/2],e[r+1]=t[r/2];return e}function o3(n,t){return{real:n[2*t],imag:n[2*t+1]}}function Ynt(n,t,e,r){n[2*r]=t,n[2*r+1]=e}function Qnt(n,t,e){var r=(e?2:-2)*Math.PI*(n/t);return{real:Math.cos(r),imag:Math.sin(r)}}function Znt(n,t,e){var r=(function(s,o,i){return(function(u,l,h){for(var d=0,f=u.length,m=0,v=!1;d<f;){var y=h(l,u[m=d+(f-d>>>1)]);y>0?d=m+1:(f=m,v=!y)}return v?d:-d-1})(s,o,i||Jnt)})(n,t,e),a=r<0?-(r+1):r;n.splice(a,0,t)}function Jnt(n,t){return n>t?1:n<t?-1:0}function UE(n,t,e,r,a){return iz(n,t,e,r,a,0).selectedIndices}function WE(n,t,e,r,a,s){var o=iz(n,t,e,r,a,s);return o.numValidOutputs.dispose(),{selectedIndices:o.selectedIndices,selectedScores:o.selectedScores}}function iz(n,t,e,r,a,s,o,i){i===void 0&&(i=!1);for(var u=Array.from(t).map((function(C,T){return{score:C,boxIndex:T,suppressBeginIndex:0}})).filter((function(C){return C.score>a})).sort(i3),l=s>0?-.5/s:0,h=[],d=[];h.length<e&&u.length>0;){var f=u.pop(),m=f.score,v=f.boxIndex,y=f.suppressBeginIndex;if(m<a)break;for(var b=!1,w=h.length-1;w>=y;--w){var S=trt(n,v,h[w]);if(S>=r){b=!0;break}if(f.score=f.score*ert(r,l,S),f.score<=a)break}f.suppressBeginIndex=h.length,b||(f.score===m?(h.push(v),d.push(f.score)):f.score>a&&Znt(u,f,i3))}var N=h.length;return i&&(h.fill(0,N),d.fill(0,N)),{selectedIndices:rr(h,"int32"),selectedScores:rr(d,"float32"),numValidOutputs:Pt(N,"int32")}}function trt(n,t,e){var r=n.subarray(4*t,4*t+4),a=n.subarray(4*e,4*e+4),s=Math.min(r[0],r[2]),o=Math.min(r[1],r[3]),i=Math.max(r[0],r[2]),u=Math.max(r[1],r[3]),l=Math.min(a[0],a[2]),h=Math.min(a[1],a[3]),d=Math.max(a[0],a[2]),f=Math.max(a[1],a[3]),m=(i-s)*(u-o),v=(d-l)*(f-h);if(m<=0||v<=0)return 0;var y=Math.max(s,l),b=Math.max(o,h),w=Math.min(i,d),S=Math.min(u,f),N=Math.max(w-y,0)*Math.max(S-b,0);return N/(m+v-N)}function ert(n,t,e){var r=Math.exp(t*e*e);return e<=n?r:0}function i3(n,t){return n.score-t.score||n.score===t.score&&t.boxIndex-n.boxIndex}function uz(n,t,e){var r=new Array(n.rank).fill(0),a=n.shape.slice();return t.map((function(s){a[e]=s;var o=n.slice(r,a);return r[e]+=s,o}))}function lz(n,t){for(var e=new Array(n.rank),r=0;r<e.length;r++)e[r]=n.shape[r]*t[r];var a=be(e,n.dtype);for(r=0;r<a.values.length;++r){for(var s=a.indexToLoc(r),o=new Array(n.rank),i=0;i<o.length;i++)o[i]=s[i]%n.shape[i];var u=n.locToIndex(o);a.values[r]=n.values[u]}return a.toTensor()}function cz(n,t,e,r,a){for(var s=t[t.length-1],o=[n.length/s,s],i=o[0],u=o[1],l=am(e,i*r),h=am("int32",i*r),d=0;d<i;d++){for(var f=d*u,m=n.subarray(f,f+u),v=[],y=0;y<m.length;y++)v.push({value:m[y],index:y});v.sort((function(C,T){return T.value-C.value}));var b=d*r,w=l.subarray(b,b+r),S=h.subarray(b,b+r);for(y=0;y<r;y++)w[y]=v[y].value,S[y]=v[y].index}var N=t.slice();return N[N.length-1]=r,[Zr(l,N,e),Zr(h,N,"int32")]}function GE(n,t){for(var e=[],r=0;r<t.length;r++)t[r]&&e.push(r);var a=be(n,"int32"),s=be([e.length,n.length],"int32");for(r=0;r<e.length;r++){var o=a.indexToLoc(e[r]),i=r*n.length;s.values.set(o,i)}return s.toTensor()}var nrt=function(n,t){this.outputShape=[],this.outputShape=n,this.variableNames=t.map((function(a,s){return"T"+s}));var e=[];this.variableNames.forEach((function(a){e.push("float v"+a+" = get"+a+"AtOutCoords();")}));var r=this.variableNames.map((function(a){return"v"+a})).join(" + ");this.userCode=`
      void main() {
        `+e.join(`
        `)+`

        float result = `+r+`;
        setOutput(result);
      }
    `},rrt=function(n,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.variableNames=t.map((function(a,s){return"T"+s}));var e=[];this.variableNames.forEach((function(a){e.push("vec4 v"+a+" = get"+a+"AtOutCoords();")}));var r=this.variableNames.map((function(a){return"v"+a})).join(" + ");this.userCode=`
      void main() {
        `+e.join(`
        `)+`

        vec4 result = `+r+`;
        setOutput(result);
      }
    `},art=function(n,t,e){this.variableNames=["A"];var r=n.windowSize,a=n.batchSize,s=n.inSize,o=Math.ceil(s/r);e||this.variableNames.push("bestIndicesA"),this.outputShape=[a,o];var i=t==="max"?">":"<",u=e?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * `+r+`;

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < `+r+`; i++) {
          int inIdx = `+u+`;
          float candidate = getA(batch, inIdx);
          if (candidate `+i+` bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `};function hz(n,t){return["x","y","z","w","u","v"].slice(0,t).map((function(e){return n+"."+e}))}function za(n,t){return t===1?[n]:hz(n,t)}function ua(){var n,t,e,r,a,s,o,i,u,l;return kt().getNumber("WEBGL_VERSION")===2?(n="#version 300 es",t="in",e="out",r="in",a="texture",s="outputColor",o="out vec4 outputColor;",i=`
      bool isnan_custom(float val) {
        return (val > 0.0 || val < 0.0) ? false : val != 0.0;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `,u="",l=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(n="",t="attribute",e="varying",r="varying",a="texture2D",s="gl_FragColor",o="",i=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,u=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,l=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:n,attribute:t,varyingVs:e,varyingFs:r,texture2D:a,output:s,defineOutput:o,defineSpecialNaN:i,defineSpecialInf:u,defineRound:l}}function Wl(n,t,e){e===void 0&&(e="index");var r=Lo(t);return r.map((function(a,s){return"int "+n[s]+" = "+e+" / "+a+"; "+(s===r.length-1?"int "+n[s+1]+" = "+e+" - "+n[s]+" * "+a:"index -= "+n[s]+" * "+a)+";"})).join("")}function HE(n){var t=Lo(n).map((function(e){return e.toString()}));return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * `+t[0]+" + coords.y * "+t[1]+` + coords.z;
  }
`}var dz=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;function srt(n,t,e,r){var a=[];n.forEach((function(m){var v=ee(m.shapeInfo.logicalShape);m.shapeInfo.isUniform?a.push("uniform float "+m.name+(v>1?"["+v+"]":"")+";"):(a.push("uniform sampler2D "+m.name+";"),a.push("uniform int offset"+m.name+";"))}));var s,o,i=a.join(`
`),u=n.map((function(m){return(function(v,y,b){b===void 0&&(b=!1);var w="";w+=b?pz(v):Ah(v);var S=v.shapeInfo.logicalShape,N=y.logicalShape;return S.length<=N.length&&(w+=b?(function(C,T){var I,_=C.name,$=_.charAt(0).toUpperCase()+_.slice(1),R="get"+$+"AtOutCoords",D=C.shapeInfo.logicalShape.length,A=T.logicalShape.length,L=Cu(C.shapeInfo.logicalShape,T.logicalShape),H=yn(A),G=A-D,q=["x","y","z","w","u","v"];I=D===0?"":A<2&&L.length>=1?"coords = 0;":L.map((function(X){return"coords."+q[X+G]+" = 0;"})).join(`
`);var B="";B=A<2&&D>0?"coords":C.shapeInfo.logicalShape.map((function(X,Q){return"coords."+q[Q+G]})).join(", ");var j="return outputValue;",K=ee(C.shapeInfo.logicalShape)===1,z=ee(T.logicalShape)===1;if(D!==1||K||z){if(K&&!z)j=A===1?`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:`
        return vec4(outputValue.x);
      `;else if(L.length){var U=D-2,M=D-1;L.indexOf(U)>-1&&L.indexOf(M)>-1?j="return vec4(outputValue.x);":L.indexOf(U)>-1?j="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":L.indexOf(M)>-1&&(j="return vec4(outputValue.xx, outputValue.zz);")}}else j=`
      return vec4(outputValue.xy, outputValue.xy);
    `;return`
    vec4 `+R+`() {
      `+H+` coords = getOutputCoords();
      `+I+`
      vec4 outputValue = get`+$+"("+B+`);
      `+j+`
    }
  `})(v,y):(function(C,T){var I=C.name,_=I.charAt(0).toUpperCase()+I.slice(1),$="get"+_+"AtOutCoords",R=T.texShape,D=C.shapeInfo.texShape,A=C.shapeInfo.logicalShape.length,L=T.logicalShape.length;if(!C.shapeInfo.isUniform&&A===L&&C.shapeInfo.flatOffset==null&&Fr(D,R))return`
      float `+$+`() {
        return sampleTexture(`+I+`, resultUV);
      }
    `;var H,G=yn(L),q=Cu(C.shapeInfo.logicalShape,T.logicalShape),B=L-A,j=["x","y","z","w","u","v"];H=A===0?"":L<2&&q.length>=1?"coords = 0;":q.map((function(z){return"coords."+j[z+B]+" = 0;"})).join(`
`);var K="";return K=L<2&&A>0?"coords":C.shapeInfo.logicalShape.map((function(z,U){return"coords."+j[U+B]})).join(", "),`
    float `+$+`() {
      `+G+` coords = getOutputCoords();
      `+H+`
      return get`+_+"("+K+`);
    }
  `})(v,y)),w})(m,t,r)})).join(`
`),l=t.texShape,h=ua(),d=(function(m){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return `+m.texture2D+`(textureSampler, uv).r;
    }
  `})(h),f=(function(m){return m.version+`
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    `+m.varyingFs+` vec2 resultUV;
    `+m.defineOutput+`
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    `+m.defineSpecialNaN+`
    `+m.defineSpecialInf+`
    `+m.defineRound+`

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    `+ort+`
    `+irt+`
    `+urt+`
  `})(h);return t.isPacked?(s=(function(m,v){switch(m.length){case 0:return`
    int getOutputCoords() {
      return 0;
    }
  `;case 1:return(function(C,T){var I=[Math.ceil(T[0]/2),Math.ceil(T[1]/2)];return I[0]===1?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * `+I[1]+`.0);
      }
    `:I[1]===1?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * `+I[0]+`.0);
      }
    `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(`+I[0]+", "+I[1]+`));
      return 2 * (resTexRC.x * `+I[1]+` + resTexRC.y);
    }
  `})(0,v);case 2:return(function(C,T){var I=[Math.ceil(T[0]/2),Math.ceil(T[1]/2)];if(Fr(C,T))return`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(`+I[0]+", "+I[1]+`));
      }
    `;var _=Math.ceil(C[1]/2);return`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(`+I[0]+", "+I[1]+`));

      int index = resTexRC.x * `+I[1]+` + resTexRC.y;
      int r = 2 * (index / `+_+`);
      int c = imod(index, `+_+`) * 2;

      return ivec2(r, c);
    }
  `})(m,v);case 3:return y=m,b=v,w=[Math.ceil(b[0]/2),Math.ceil(b[1]/2)],S=Math.ceil(y[2]/2),N=S*Math.ceil(y[1]/2),`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(`+w[0]+", "+w[1]+`));
      int index = resTexRC.x * `+w[1]+` + resTexRC.y;

      int b = index / `+N+`;
      index -= b * `+N+`;

      int r = 2 * (index / `+S+`);
      int c = imod(index, `+S+`) * 2;

      return ivec3(b, r, c);
    }
  `;default:return(function(C,T){for(var I=[Math.ceil(T[0]/2),Math.ceil(T[1]/2)],_=Math.ceil(C[C.length-1]/2),$=_*Math.ceil(C[C.length-2]/2),R=$,D="",A="b, r, c",L=2;L<C.length-1;L++)R*=C[C.length-L-1],D=`
      int b`+L+" = index / "+R+`;
      index -= b`+L+" * "+R+`;
    `+D,A="b"+L+", "+A;return`
    ivec`+C.length+` getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(`+I[0]+", "+I[1]+`));
      int index = resTexRC.x * `+I[1]+` + resTexRC.y;

      `+D+`

      int b = index / `+$+`;
      index -= b * `+$+`;

      int r = 2 * (index / `+_+`);
      int c = imod(index, `+_+`) * 2;

      return ivec`+C.length+"("+A+`);
    }
  `})(m,v)}var y,b,w,S,N})(t.logicalShape,l),o=(function(m){return`
    void setOutput(vec4 val) {
      `+m.output+` = val;
    }
  `})(h)):(s=(function(m,v){switch(m.length){case 0:return`
    int getOutputCoords() {
      return 0;
    }
  `;case 1:return(function(w,S){return S[0]===1?`
      int getOutputCoords() {
        return int(resultUV.x * `+S[1]+`.0);
      }
    `:S[1]===1?`
      int getOutputCoords() {
        return int(resultUV.y * `+S[0]+`.0);
      }
    `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(`+S[0]+", "+S[1]+`));
      return resTexRC.x * `+S[1]+` + resTexRC.y;
    }
  `})(0,v);case 2:return(function(w,S){return Fr(w,S)?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(`+S[0]+", "+S[1]+`));
      }
    `:w[1]===1?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(`+S[0]+", "+S[1]+`));
        int index = resTexRC.x * `+S[1]+` + resTexRC.y;
        return ivec2(index, 0);
      }
    `:w[0]===1?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(`+S[0]+", "+S[1]+`));
        int index = resTexRC.x * `+S[1]+` + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(`+S[0]+", "+S[1]+`));
      int index = resTexRC.x * `+S[1]+` + resTexRC.y;
      int r = index / `+w[1]+`;
      int c = index - r * `+w[1]+`;
      return ivec2(r, c);
    }
  `})(m,v);case 3:return y=v,b=Wl(["r","c","d"],m),`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(`+y[0]+", "+y[1]+`));
      int index = resTexRC.x * `+y[1]+` + resTexRC.y;
      `+b+`
      return ivec3(r, c, d);
    }
  `;case 4:return(function(w,S){var N=Wl(["r","c","d","d2"],w);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(`+S[0]+", "+S[1]+`));
      int index = resTexRC.x * `+S[1]+` + resTexRC.y;
      `+N+`
      return ivec4(r, c, d, d2);
    }
  `})(m,v);case 5:return(function(w,S){var N=Wl(["r","c","d","d2","d3"],w);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(`+S[0]+`,
                             `+S[1]+`));

      int index = resTexRC.x * `+S[1]+` + resTexRC.y;

      `+N+`

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `})(m,v);case 6:return(function(w,S){var N=Wl(["r","c","d","d2","d3","d4"],w);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(`+S[0]+", "+S[1]+`));
      int index = resTexRC.x * `+S[1]+` + resTexRC.y;

      `+N+`

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `})(m,v);default:throw new Error(m.length+"-D output sampling is not yet supported")}var y,b})(t.logicalShape,l),o=(function(m){return`
    void setOutput(float val) {
      `+m.output+` = vec4(val, 0, 0, 0);
    }
  `})(h)),r&&(f+=lrt),[f,d,o,i,s,u,e].join(`
`)}function Ah(n){var t=n.shapeInfo.logicalShape;switch(t.length){case 0:return(function(e){var r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1);if(e.shapeInfo.isUniform)return"float "+a+"() {return "+r+";}";var s=e.shapeInfo.texShape,o=s[0],i=s[1];if(o===1&&i===1)return`
      float `+a+`() {
        return sampleTexture(`+r+`, halfCR);
      }
    `;var u=e.shapeInfo.texShape,l=u[0],h=u[1],d=Il(r);return`
    float `+a+`() {
      vec2 uv = uvFromFlat(`+l+", "+h+", "+d+`);
      return sampleTexture(`+r+`, uv);
    }
  `})(n);case 1:return(function(e){var r=e.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1);if(e.shapeInfo.isUniform)return`
      float `+a+`(int index) {
        `+wh(e)+`
      }
    `;var s=e.shapeInfo.texShape,o=s[0],i=s[1];if(i===1&&o===1)return`
      float `+a+`(int index) {
        return sampleTexture(`+r+`, halfCR);
      }
    `;var u=Il(r);return i===1?`
      float `+a+`(int index) {
        vec2 uv = vec2(0.5, (float(index + `+u+") + 0.5) / "+o+`.0);
        return sampleTexture(`+r+`, uv);
      }
    `:o===1?`
      float `+a+`(int index) {
        vec2 uv = vec2((float(index + `+u+") + 0.5) / "+i+`.0, 0.5);
        return sampleTexture(`+r+`, uv);
      }
    `:`
    float `+a+`(int index) {
      vec2 uv = uvFromFlat(`+o+", "+i+", index + "+u+`);
      return sampleTexture(`+r+`, uv);
    }
  `})(n);case 2:return(function(e){var r=e.shapeInfo.logicalShape,a=e.name,s="get"+a.charAt(0).toUpperCase()+a.slice(1),o=e.shapeInfo.texShape;if(o!=null&&Fr(r,o)){var i=o[0],u=o[1];return`
    float `+s+`(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(`+u+".0, "+i+`.0);
      return sampleTexture(`+a+`, uv);
    }
  `}var l=zl(r),h=l.newShape,d=l.keptDims,f=h;if(f.length<r.length){var m=Dh(e,f);return`
      `+Ah(m)+`
      float `+s+`(int row, int col) {
        return `+s+"("+$h(["row","col"],d)+`);
      }
    `}if(e.shapeInfo.isUniform)return`
      float `+s+`(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(`+r[1]+`, 1)));
        `+wh(e)+`
      }
    `;var v=o[0],y=o[1],b=Il(a);return y===1?`
    float `+s+`(int row, int col) {
      float index = dot(vec3(row, col, `+b+"), vec3("+r[1]+`, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / `+v+`.0);
      return sampleTexture(`+a+`, uv);
    }
  `:v===1?`
    float `+s+`(int row, int col) {
      float index = dot(vec3(row, col, `+b+"), vec3("+r[1]+`, 1, 1));
      vec2 uv = vec2((index + 0.5) / `+y+`.0, 0.5);
      return sampleTexture(`+a+`, uv);
    }
  `:`
  float `+s+`(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * `+r[1]+" + col + "+b+`;
    vec2 uv = uvFromFlat(`+v+", "+y+`, index);
    return sampleTexture(`+a+`, uv);
  }
`})(n);case 3:return(function(e){var r=e.shapeInfo.logicalShape,a=e.name,s="get"+a.charAt(0).toUpperCase()+a.slice(1),o=r[1]*r[2],i=r[2],u=zl(r),l=u.newShape,h=u.keptDims,d=l;if(d.length<r.length){var f=Dh(e,d);return`
        `+Ah(f)+`
        float `+s+`(int row, int col, int depth) {
          return `+s+"("+$h(["row","col","depth"],h)+`);
        }
      `}if(e.shapeInfo.isUniform)return`
      float `+s+`(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(`+o+", "+i+`, 1)));
        `+wh(e)+`
      }
    `;var m=e.shapeInfo.texShape,v=m[0],y=m[1],b=e.shapeInfo.flatOffset;if(y===o&&b==null)return`
        float `+s+`(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(`+i+`, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(`+y+".0, "+v+`.0);
          return sampleTexture(`+a+`, uv);
        }
      `;if(y===i&&b==null)return`
    float `+s+`(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(`+r[1]+`, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(`+y+".0, "+v+`.0);
      return sampleTexture(`+a+`, uv);
    }
  `;var w=Il(a);return`
      float `+s+`(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * `+o+" + col * "+i+" + depth + "+w+`;
        vec2 uv = uvFromFlat(`+v+", "+y+`, index);
        return sampleTexture(`+a+`, uv);
      }
  `})(n);case 4:return(function(e){var r=e.shapeInfo.logicalShape,a=e.name,s="get"+a.charAt(0).toUpperCase()+a.slice(1),o=r[3],i=r[2]*o,u=r[1]*i,l=zl(r),h=l.newShape,d=l.keptDims;if(h.length<r.length){var f=Dh(e,h);return`
      `+Ah(f)+`
      float `+s+`(int row, int col, int depth, int depth2) {
        return `+s+"("+$h(["row","col","depth","depth2"],d)+`);
      }
    `}if(e.shapeInfo.isUniform)return`
      float `+s+`(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(`+u+", "+i+", "+o+`, 1)));
        `+wh(e)+`
      }
    `;var m=e.shapeInfo.flatOffset,v=e.shapeInfo.texShape,y=v[0],b=v[1];if(b===u&&m==null)return`
      float `+s+`(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(`+i+", "+o+`, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(`+b+".0, "+y+`.0);
        return sampleTexture(`+a+`, uv);
      }
    `;if(b===o&&m==null)return`
      float `+s+`(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(`+r[1]*r[2]+", "+r[2]+`, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(`+b+".0, "+y+`.0);
        return sampleTexture(`+a+`, uv);
      }
    `;var w=Il(a);return`
    float `+s+`(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * `+u+" + col * "+i+` +
          depth * `+o+` + depth2;
      vec2 uv = uvFromFlat(`+y+", "+b+", index + "+w+`);
      return sampleTexture(`+a+`, uv);
    }
  `})(n);case 5:return(function(e){var r=e.shapeInfo.logicalShape,a=e.name,s="get"+a.charAt(0).toUpperCase()+a.slice(1),o=r[4],i=r[3]*o,u=r[2]*i,l=r[1]*u,h=zl(r),d=h.newShape,f=h.keptDims;if(d.length<r.length){var m=Dh(e,d);return`
      `+Ah(m)+`
      float `+s+`(int row, int col, int depth, int depth2, int depth3) {
        return `+s+"("+$h(["row","col","depth","depth2","depth3"],f)+`);
      }
    `}if(e.shapeInfo.isUniform)return`
      float `+s+`(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(`+l+", "+u+", "+i+", "+o+`)) +
          depth3;
        `+wh(e)+`
      }
    `;var v=e.shapeInfo.flatOffset,y=e.shapeInfo.texShape,b=y[0],w=y[1];if(w===l&&v==null)return`
      float `+s+`(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(`+u+", "+i+", "+o+`, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(`+w+".0, "+b+`.0);
        return sampleTexture(`+a+`, uv);
      }
    `;if(w===o&&v==null)return`
      float `+s+`(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(`+r[1]*r[2]*r[3]+`,
               `+r[2]*r[3]+", "+r[3]+`, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(`+w+".0, "+b+`.0);
        return sampleTexture(`+a+`, uv);
      }
    `;var S=Il(a);return`
    float `+s+`(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * `+l+" + col * "+u+" + depth * "+i+` +
          depth2 * `+o+" + depth3 + "+S+`;
      vec2 uv = uvFromFlat(`+b+", "+w+`, index);
      return sampleTexture(`+a+`, uv);
    }
  `})(n);case 6:return(function(e){var r=e.shapeInfo.logicalShape,a=e.name,s="get"+a.charAt(0).toUpperCase()+a.slice(1),o=zl(r),i=o.newShape,u=o.keptDims;if(i.length<r.length){var l=Dh(e,i);return`
      `+Ah(l)+`
      float `+s+`(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return `+s+"("+$h(["row","col","depth","depth2","depth3","depth4"],u)+`);
      }
    `}var h=r[5],d=r[4]*h,f=r[3]*d,m=r[2]*f,v=r[1]*m;if(e.shapeInfo.isUniform)return`
      float `+s+`(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(`+v+", "+m+", "+f+", "+d+`)) +
          dot(
            vec2(depth3, depth4),
            vec2(`+h+`, 1)));
        `+wh(e)+`
      }
    `;var y=e.shapeInfo.flatOffset,b=e.shapeInfo.texShape,w=b[0],S=b[1];if(S===v&&y==null)return`
      float `+s+`(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(`+m+", "+f+", "+d+", "+h+`)) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(`+S+".0, "+w+`.0);
        return sampleTexture(`+a+`, uv);
      }
    `;if(S===h&&y==null)return`
      float `+s+`(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(`+r[1]*r[2]*r[3]*r[4]+`,
               `+r[2]*r[3]*r[4]+`,
               `+r[3]*r[4]+`,
               `+r[4]+`)) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(`+S+".0, "+w+`.0);
        return sampleTexture(`+a+`, uv);
      }
    `;var N=Il(a);return`
    float `+s+`(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * `+v+" + col * "+m+" + depth * "+f+` +
          depth2 * `+d+" + depth3 * "+h+" + depth4 + "+N+`;
      vec2 uv = uvFromFlat(`+w+", "+S+`, index);
      return sampleTexture(`+a+`, uv);
    }
  `})(n);default:throw new Error(t.length+"-D input sampling is not yet supported")}}function pz(n){var t,e,r;switch(n.shapeInfo.logicalShape.length){case 0:return t=n.name,e="get"+t.charAt(0).toUpperCase()+t.slice(1),r=ua(),`
    vec4 `+e+`() {
      return `+r.texture2D+"("+t+`, halfCR);
    }
  `;case 1:return(function(a){var s=a.name,o="get"+s.charAt(0).toUpperCase()+s.slice(1),i=a.shapeInfo.texShape,u=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)],l=ua();return`
    vec4 `+o+`(int index) {
      vec2 uv = packedUVfrom1D(
        `+u[0]+", "+u[1]+`, index);
      return `+l.texture2D+"("+s+`, uv);
    }
  `})(n);case 2:return(function(a){var s=a.shapeInfo.logicalShape,o=a.name,i="get"+o.charAt(0).toUpperCase()+o.slice(1),u=a.shapeInfo.texShape,l=u[0],h=u[1],d=ua();if(u!=null&&Fr(s,u))return`
      vec4 `+i+`(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(`+h+".0, "+l+`.0);

        return `+d.texture2D+"("+o+`, uv);
      }
    `;var f=[Math.ceil(u[0]/2),Math.ceil(u[1]/2)],m=Math.ceil(s[1]/2);return`
    vec4 `+i+`(int row, int col) {
      vec2 uv = packedUVfrom2D(`+m+", "+f[0]+", "+f[1]+`, row, col);
      return `+d.texture2D+"("+o+`, uv);
    }
  `})(n);case 3:return(function(a){var s=a.shapeInfo.logicalShape,o=a.name,i="get"+o.charAt(0).toUpperCase()+o.slice(1),u=a.shapeInfo.texShape,l=[Math.ceil(u[0]/2),Math.ceil(u[1]/2)];if(s[0]===1){var h=s.slice(1),d=Dh(a,h);return`
        `+pz(d)+`
        vec4 `+i+`(int b, int row, int col) {
          return `+i+"("+$h(["b","row","col"],[1,2])+`);
        }
      `}var f=l[0],m=l[1],v=Math.ceil(s[2]/2),y=v*Math.ceil(s[1]/2),b=ua();return`
    vec4 `+i+`(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        `+f+", "+m+", "+y+", "+v+`, b, row, col);
      return `+b.texture2D+"("+o+`, uv);
    }
  `})(n);default:return(function(a){for(var s=a.shapeInfo.logicalShape,o=s.length,i=a.name,u="get"+i.charAt(0).toUpperCase()+i.slice(1),l=a.shapeInfo.texShape,h=[Math.ceil(l[0]/2),Math.ceil(l[1]/2)],d=h[0],f=h[1],m=Math.ceil(s[o-1]/2),v=m*Math.ceil(s[o-2]/2),y="int b, int row, int col",b="b * "+v+" + (row / 2) * "+m+" + (col / 2)",w=2;w<o-1;w++)y="int b"+w+", "+y,v*=s[o-w-1],b="b"+w+" * "+v+" + "+b;var S=ua();return`
    vec4 `+u+"("+y+`) {
      int index = `+b+`;
      int texR = index / `+f+`;
      int texC = index - texR * `+f+`;
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(`+f+", "+d+`);
      return `+S.texture2D+"("+i+`, uv);
    }
  `})(n)}}var ort=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,irt=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,urt=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,lrt=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function Il(n){return"offset"+n}function wh(n){var t=n.name,e=ee(n.shapeInfo.logicalShape);return e<2?"return "+t+";":`
    for (int i = 0; i < `+e+`; i++) {
      if (i == index) {
        return `+t+`[i];
      }
    }
  `}function yn(n){if(n<=1)return"int";if(n===2)return"ivec2";if(n===3)return"ivec3";if(n===4)return"ivec4";if(n===5)return"ivec5";if(n===6)return"ivec6";throw Error("GPU for rank "+n+" is not yet supported")}function Dh(n,t){var e=JSON.parse(JSON.stringify(n));return e.shapeInfo.logicalShape=t,e}function $h(n,t){return t.map((function(e){return n[e]})).join(", ")}var crt=function(n,t,e,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,Z(n.length>2,(function(){return"Packed arg"+(e.charAt(0).toUpperCase()+e.slice(1))+" supports only inputs with rank above 2."}));var a=n[n.length-1],s=Math.ceil(a/t);this.outputShape=n.slice(0,-1),s>1&&this.outputShape.push(s),r||this.variableNames.push("bestIndicesA");var o,i,u=this.outputShape,l=u.length,h=yn(l),d=za("coords",l);if(s===1){var f=yn(i=l+1);o=`
        `+f+" sourceLocR = "+f+"("+d.join()+`, 0);
        ++`+d[l-1]+`;
        `+f+" sourceLocG = "+f+"("+d.join()+`, 0);
        ++`+d[l-2]+`;
        `+f+" sourceLocA = "+f+"("+d.join()+`, 0);
        --`+d[l-1]+`;
        `+f+" sourceLocB = "+f+"("+d.join()+`, 0);
        --`+d[l-2]+";"}else i=l,o=`
        `+h+` sourceLocR = coords;
        ++`+d[l-1]+`;
        `+h+` sourceLocG = coords;
        ++`+d[l-2]+`;
        `+h+` sourceLocA = coords;
        --`+d[l-1]+`;
        `+h+` sourceLocB = coords;
        --`+d[l-2]+";";var m=["x","y","z","w","u","v"].slice(0,i),v="."+m[i-1],y=m.map((function($){return"int "+$})),b=za("sourceLocR",i-1).concat("inIdx.r"),w=za("sourceLocG",i-1).concat("inIdx.g"),S=za("sourceLocB",i-1).concat("inIdx.b"),N=za("sourceLocA",i-1).concat("inIdx.a"),C=e==="max"?"greaterThan":"lessThan",T=r?"":`
          inIdx = round(vec4(getBestIndicesAChannel(`+b.join()+`),
                             getBestIndicesAChannel(`+w.join()+`),
                             getBestIndicesAChannel(`+S.join()+`),
                             getBestIndicesAChannel(`+N.join()+")));",I=`vec4(
            getAChannel(`+b.join()+`),
            hasNextCol ? getAChannel(`+w.join()+`) : 0.,
            hasNextRow ? getAChannel(`+S.join()+`) : 0.,
            hasNextRow && hasNextCol ? getAChannel(`+N.join()+") : 0.)",_=r?"":`
      float getBestIndicesAChannel(`+y.join()+`) {
        return getChannel(getBestIndicesA(`+m.join()+`),
                                          vec2(`+m.slice(-2).join()+`));
      }`;this.userCode=`
      float getAChannel(`+y.join()+`) {
        return getChannel(getA(`+m.join()+`),
                               vec2(`+m.slice(-2).join()+`));
      }
      `+_+`
      void main() {
        `+h+` coords = getOutputCoords();
        bool hasNextCol = `+d[l-1]+" < "+(u[l-1]-1)+`;
        bool hasNextRow = `+d[l-2]+" < "+(u[l-2]-1)+`;
        `+o+`
        ivec4 srcIdx = ivec4(sourceLocR`+v+", sourceLocG"+v+`,
          sourceLocB`+v+", sourceLocA"+v+") * "+t+`;
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = `+I+`;

        for (int i = 0; i < `+t+`; i++) {
          inIdx = srcIdx;
          `+T+`
          vec4 candidate = `+I+`;
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(`+C+`(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `},hrt=function(n){this.variableNames=["dy"],this.outputShape=n.inShape;var t=n.filterHeight,e=n.filterWidth,r=n.strideHeight,a=n.strideWidth,s=n.dilationHeight,o=n.dilationWidth,i=n.effectiveFilterHeight,u=n.effectiveFilterWidth,l=i-1-n.padInfo.top,h=u-1-n.padInfo.left,d=1/(t*e);this.userCode=`
      const ivec2 pads = ivec2(`+l+", "+h+`);
      const float avgMultiplier = float(`+d+`);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < `+i+`;
            wR += `+s+`) {
          float dyR = float(dyRCorner + wR) / `+r+`.0;

          if (dyR < 0.0 || dyR >= `+n.outHeight+`.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < `+u+`;
            wC+= `+o+`) {
            float dyC = float(dyCCorner + wC) / `+a+`.0;

            if (dyC < 0.0 || dyC >= `+n.outWidth+`.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `},drt=function(n){this.variableNames=["dy"],this.outputShape=n.inShape;var t=n.filterDepth,e=n.filterHeight,r=n.filterWidth,a=n.strideDepth,s=n.strideHeight,o=n.strideWidth,i=n.dilationDepth,u=n.dilationHeight,l=n.dilationWidth,h=n.effectiveFilterDepth,d=n.effectiveFilterHeight,f=n.effectiveFilterWidth,m=h-1-n.padInfo.front,v=d-1-n.padInfo.top,y=f-1-n.padInfo.left,b=1/(t*e*r);this.userCode=`
      const ivec3 pads = ivec3(`+m+", "+v+", "+y+`);
      const float avgMultiplier = float(`+b+`);

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < `+h+`;
            wD += `+i+`) {
          float dyD = float(dyDCorner + wD) / `+a+`.0;

          if (dyD < 0.0 || dyD >= `+n.outDepth+`.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < `+d+`;
              wR += `+u+`) {
            float dyR = float(dyRCorner + wR) / `+s+`.0;

            if (dyR < 0.0 || dyR >= `+n.outHeight+`.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < `+f+`;
                wC += `+l+`) {
              float dyC = float(dyCCorner + wC) / `+o+`.0;

              if (dyC < 0.0 || dyC >= `+n.outWidth+`.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `},prt=function(n,t,e,r,a,s){this.outputShape=[],this.variableNames=["x","mean","variance"],Le(n,t),Le(n,e);var o="0.0";r!=null&&(Le(n,r),this.variableNames.push("offset"),o="getOffsetAtOutCoords()");var i="1.0";a!=null&&(Le(n,a),this.variableNames.push("scale"),i="getScaleAtOutCoords()"),this.outputShape=n,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = `+o+`;
        float scale = `+i+`;
        float inv = scale * inversesqrt(variance + float(`+s+`));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `},frt=function(n,t,e,r,a,s){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],Le(n,t),Le(n,e);var o="vec4(0.0)";r!=null&&(Le(n,r),this.variableNames.push("offset"),o="getOffsetAtOutCoords()");var i="vec4(1.0)";a!=null&&(Le(n,a),this.variableNames.push("scale"),i="getScaleAtOutCoords()"),this.outputShape=n,this.userCode=`
      void main() {
        vec4 offset = `+o+`;
        vec4 scale = `+i+`;

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(`+s+`));

        setOutput((x - mean) * inv + offset);
      }
    `},mrt="return areal * breal - aimag * bimag;",grt="return areal * bimag + aimag * breal;",u3=function(n,t,e){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=Le(t,e),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        `+n+`
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `},eC="return a + b;",nC="return a - b;",l3="return a * b;",fz="return (a < 0.) ? b * a : a;",zn=function(n,t,e){this.variableNames=["A","B"],this.outputShape=Le(t,e),this.userCode=`
      float binaryOperation(float a, float b) {
        `+n+`
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `},mz=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`,xi=function(n,t,e,r){r===void 0&&(r=!1),this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=Le(t,e);var a=this.outputShape.length,s="";if(r)if(a===0||ee(this.outputShape)===1)s=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(s=`
          `+yn(a)+` coords = getOutputCoords();
        `,a===1)s+=`
            result.y = (coords + 1) >= `+this.outputShape[0]+` ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{var o=za("coords",a);s+=`
            bool nextRowOutOfBounds =
              (`+o[a-2]+" + 1) >= "+this.outputShape[a-2]+`;
            bool nextColOutOfBounds =
              (`+o[a-1]+" + 1) >= "+this.outputShape[a-1]+`;
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        `+n+`
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        `+s+`

        setOutput(result);
      }
    `},vrt=(function(){function n(t){this.variableNames=["A"],this.outputShape=t,this.userCode=`
      uniform float minVal;
      uniform float maxVal;

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}return n.prototype.getCustomSetupFunc=function(t,e){var r=this;return function(a,s){r.minLoc==null&&(r.minLoc=a.getUniformLocationNoThrow(s,"minVal"),r.maxLoc=a.getUniformLocationNoThrow(s,"maxVal")),a.gl.uniform1f(r.minLoc,t),a.gl.uniform1f(r.maxLoc,e)}},n})(),yrt=(function(){function n(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.userCode=`
      uniform float minVal;
      uniform float maxVal;

      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}return n.prototype.getCustomSetupFunc=function(t,e){var r=this;return function(a,s){r.minLoc==null&&(r.minLoc=a.getUniformLocationNoThrow(s,"minVal"),r.maxLoc=a.getUniformLocationNoThrow(s,"maxVal")),a.gl.uniform1f(r.minLoc,t),a.gl.uniform1f(r.maxLoc,e)}},n})(),brt=function(n){this.variableNames=["real","imag"],this.outputShape=n,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `},xrt=function(n){this.outputShape=[],this.outputShape=rd(n,1),this.variableNames=n.map((function(i,u){return"T"+u}));var t=new Array(n.length-1);t[0]=n[0][1];for(var e=1;e<t.length;e++)t[e]=t[e-1]+n[e][1];var r=["if (yC < "+t[0]+") setOutput(getT0(yR, yC));"];for(e=1;e<t.length;e++){var a=t[e-1];r.push("else if (yC < "+t[e]+") setOutput(getT"+e+"(yR, yC-"+a+"));")}var s=t.length,o=t[t.length-1];r.push("else setOutput(getT"+s+"(yR, yC-"+o+"));"),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        `+r.join(`
        `)+`
      }
    `},wrt=function(n,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=rd(n,t);var e=this.outputShape,r=e.length,a=yn(r),s=za("coords",r),o=["x","y","z","w","u","v"].slice(0,r);this.variableNames=n.map((function(b,w){return"T"+w}));var i=new Array(n.length-1);i[0]=n[0][t];for(var u=1;u<i.length;u++)i[u]=i[u-1]+n[u][t];var l=o[t],h=o.slice(-2),d=o.join(),f="if ("+l+" < "+i[0]+`) {
        return getChannel(
            getT0(`+d+"), vec2("+h.join()+`));
        }`;for(u=1;u<i.length;u++){var m=i[u-1];f+=`
        if (`+l+" < "+i[u]+"  && "+l+" >= "+i[u-1]+`) {
          return getChannel(
            getT`+u+"("+Xy(o,l,m)+`),
            vec2(`+Xy(h,l,m)+`));
        }`}var v=i.length,y=i[i.length-1];f+=`
        return getChannel(
          getT`+v+"("+Xy(o,l,y)+`),
          vec2(`+Xy(h,l,y)+"));",this.userCode=`
      float getValue(`+o.map((function(b){return"int "+b}))+`) {
        `+f+`
      }

      void main() {
        `+a+` coords = getOutputCoords();
        vec4 result = vec4(getValue(`+s+`), 0., 0., 0.);

        `+s[r-1]+" = "+s[r-1]+` + 1;
        if (`+s[r-1]+" < "+e[r-1]+`) {
          result.g = getValue(`+s+`);
        }

        `+s[r-2]+" = "+s[r-2]+` + 1;
        if (`+s[r-2]+" < "+e[r-2]+`) {
          result.a = getValue(`+s+`);
        }

        `+s[r-1]+" = "+s[r-1]+` - 1;
        if (`+s[r-2]+" < "+e[r-2]+` &&
            `+s[r-1]+" < "+e[r-1]+`) {
          result.b = getValue(`+s+`);
        }
        setOutput(result);
      }
    `};function Xy(n,t,e){var r=n.indexOf(t);return n.map((function(a,s){return s===r?a+" - "+e:a})).join()}var Srt=function(n){this.variableNames=["x","dy"],this.outputShape=n.filterShape;var t=n.strideHeight,e=n.strideWidth,r=n.padInfo.top,a=n.padInfo.left,s=n.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < `+n.batchSize+`; b++) {
          for (int yR = 0; yR < `+n.outHeight+`; yR++) {
            int xR = wR + yR * `+t+" - "+r+`;

            if (xR < 0 || xR >= `+n.inHeight+`) {
              continue;
            }

            for (int yC = 0; yC < `+n.outWidth+`; yC++) {
              int xC = wC + yC * `+e+" - "+a+`;

              if (xC < 0 || xC >= `+n.inWidth+`) {
                continue;
              }

              if (`+s+`) {
                float dyValue = getDy(b, yR, yC, d2);
                float xValue = getX(b, xR, xC, d1);
                dotProd += (xValue * dyValue);
              } else {
                float dyValue = getDy(b, d2, yR, yC);
                float xValue = getX(b, d1, xR, xC);
                dotProd += (xValue * dyValue);
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `},Crt=function(n){this.variableNames=["dy","W"],this.outputShape=n.inShape;var t=n.filterHeight,e=n.filterWidth,r=n.strideHeight,a=n.strideWidth,s=n.dataFormat==="channelsLast",o=t-1-n.padInfo.top,i=e-1-n.padInfo.left,u=s?1:2,l=s?2:3,h=s?3:1;this.userCode=`
      const ivec2 pads = ivec2(`+o+", "+i+`);

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[`+h+`];

        ivec2 dyCorner = ivec2(coords[`+u+"], coords["+l+`]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < `+t+`; wR++) {
          float dyR = float(dyRCorner + wR) / `+r+`.0;

          if (dyR < 0.0 || dyR >= `+n.outHeight+`.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = `+t+` - 1 - wR;

          for (int wC = 0; wC < `+e+`; wC++) {
            float dyC = float(dyCCorner + wC) / `+a+`.0;

            if (dyC < 0.0 || dyC >= `+n.outWidth+`.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = `+e+` - 1 - wC;

            for (int d2 = 0; d2 < `+n.outChannels+`; d2++) {

              if (`+s+`) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `},Nrt=function(n){this.variableNames=["x","dy"],this.outputShape=n.filterShape;var t=n.strideDepth,e=n.strideHeight,r=n.strideWidth,a=n.padInfo.front,s=n.padInfo.top,o=n.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < `+n.batchSize+`; b++) {
          for (int yF = 0; yF < `+n.outDepth+`; yF++) {
            int xF = wF + yF * `+t+" - "+a+`;

            if (xF < 0 || xF >= `+n.inDepth+`) {
              continue;
            }

            for (int yR = 0; yR < `+n.outHeight+`; yR++) {
              int xR = wR + yR * `+e+" - "+s+`;

              if (xR < 0 || xR >= `+n.inHeight+`) {
                continue;
              }

              for (int yC = 0; yC < `+n.outWidth+`; yC++) {
                int xC = wC + yC * `+r+" - "+o+`;

                if (xC < 0 || xC >= `+n.inWidth+`) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `},krt=function(n){this.variableNames=["dy","W"],this.outputShape=n.inShape;var t=n.filterDepth,e=n.filterHeight,r=n.filterWidth,a=n.strideDepth,s=n.strideHeight,o=n.strideWidth,i=t-1-n.padInfo.front,u=e-1-n.padInfo.top,l=r-1-n.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(`+i+", "+u+", "+l+`);

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < `+t+`; wF++) {
          float dyF = float(dyFCorner + wF) / `+a+`.0;

          if (dyF < 0.0 || dyF >= `+n.outDepth+`.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = `+t+` - 1 - wF;

          for (int wR = 0; wR < `+e+`; wR++) {
            float dyR = float(dyRCorner + wR) / `+s+`.0;

            if (dyR < 0.0 || dyR >= `+n.outHeight+`.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = `+e+` - 1 - wR;

            for (int wC = 0; wC < `+r+`; wC++) {
              float dyC = float(dyCCorner + wC) / `+o+`.0;

              if (dyC < 0.0 || dyC >= `+n.outWidth+`.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = `+r+` - 1 - wC;

              for (int d2 = 0; d2 < `+n.outChannels+`; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `},Trt=function(n){this.variableNames=["x","dy"],this.outputShape=n.filterShape;var t=n.strideHeight,e=n.strideWidth,r=n.padInfo.top,a=n.padInfo.left,s=n.outChannels/n.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * `+s+` + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < `+n.batchSize+`; b++) {
          for (int yR = 0; yR < `+n.outHeight+`; yR++) {
            int xR = wR + yR * `+t+" - "+r+`;

            if (xR < 0 || xR >= `+n.inHeight+`) {
              continue;
            }

            for (int yC = 0; yC < `+n.outWidth+`; yC++) {
              int xC = wC + yC * `+e+" - "+a+`;

              if (xC < 0 || xC >= `+n.inWidth+`) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `},Ert=function(n){this.variableNames=["dy","W"],this.outputShape=n.inShape;var t=n.filterHeight,e=n.filterWidth,r=n.strideHeight,a=n.strideWidth,s=t-1-n.padInfo.top,o=e-1-n.padInfo.left,i=n.outChannels/n.inChannels;this.userCode=`
      const ivec2 pads = ivec2(`+s+", "+o+`);

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < `+t+`; wR++) {
          float dyR = float(dyRCorner + wR) / `+r+`.0;

          if (dyR < 0.0 || dyR >= `+n.outHeight+`.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = `+t+` - 1 - wR;

          for (int wC = 0; wC < `+e+`; wC++) {
            float dyC = float(dyCCorner + wC) / `+a+`.0;

            if (dyC < 0.0 || dyC >= `+n.outWidth+`.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = `+e+` - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < `+i+`; dm++) {
              int d2 = d1 * `+i+` + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `},c3=function(n,t,e,r){t===void 0&&(t=!1),e===void 0&&(e=null),r===void 0&&(r=!1),this.variableNames=["x","W"],this.outputShape=n.outShape;var a=n.padInfo.top,s=n.padInfo.left,o=n.strideHeight,i=n.strideWidth,u=n.dilationHeight,l=n.dilationWidth,h=n.filterHeight,d=n.filterWidth,f=4*Math.floor(n.inChannels/4),m=n.inChannels%4,v=n.dataFormat==="channelsLast",y=v?1:2,b=v?2:3,w=v?3:1,S="",N="";e&&(S=r?`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          `+e+`
        }`:`
          float activation(float x) {
            `+e+`
          }
        `,N="result = activation(result);");var C=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),this.userCode=`
      `+S+`

      const ivec2 strides = ivec2(`+o+", "+i+`);
      const ivec2 pads = ivec2(`+a+", "+s+`);

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[`+w+`];

        ivec2 xRCCorner =
            ivec2(coords[`+y+"], coords["+b+`]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < `+h+`; wR++) {
          int xR = xRCorner + wR * `+u+`;

          if (xR < 0 || xR >= `+n.inHeight+`) {
            continue;
          }

          for (int wC = 0; wC < `+d+`; wC++) {
            int xC = xCCorner + wC * `+l+`;

            if (xC < 0 || xC >= `+n.inWidth+`) {
              continue;
            }

            for (int d1 = 0; d1 < `+f+`; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (`+v+`) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (`+(m===1)+`) {

              if (`+v+`) {
                dotProd +=
                    getX(batch, xR, xC, `+f+`) *
                    getW(wR, wC, `+f+`, d2);
              } else {
                dotProd +=
                    getX(batch, `+f+`, xR, xC) *
                    getW(wR, wC, `+f+`, d2);
              }

            } else if (`+(m===2)+`) {
              vec2 wValues = vec2(
                getW(wR, wC, `+f+`, d2),
                getW(wR, wC, `+f+` + 1, d2)
              );

              if (`+v+`) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, `+f+`),
                  getX(batch, xR, xC, `+f+` + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, `+f+`, xR, xC),
                  getX(batch, `+f+` + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (`+(m===3)+`) {
              vec3 wValues = vec3(
                getW(wR, wC, `+f+`, d2),
                getW(wR, wC, `+f+` + 1, d2),
                getW(wR, wC, `+f+` + 2, d2)
              );

              if (`+v+`) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, `+f+`),
                  getX(batch, xR, xC, `+f+` + 1),
                  getX(batch, xR, xC, `+f+` + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, `+f+`, xR, xC),
                  getX(batch, `+f+` + 1, xR, xC),
                  getX(batch, `+f+` + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        `+C+`
        `+N+`
        setOutput(result);
      }
    `},Irt=function(n){this.variableNames=["x","W"],this.outputShape=n.outShape;var t=n.padInfo.front,e=n.padInfo.top,r=n.padInfo.left,a=n.strideDepth,s=n.strideHeight,o=n.strideWidth,i=n.dilationDepth,u=n.dilationHeight,l=n.dilationWidth,h=n.filterDepth,d=n.filterHeight,f=n.filterWidth,m=4*Math.floor(n.inChannels/4),v=n.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(`+a+", "+s+", "+o+`);
      const ivec3 pads = ivec3(`+t+", "+e+", "+r+`);

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < `+h+`; wF++) {
          int xF = xFCorner + wF * `+i+`;

          if (xF < 0 || xF >= `+n.inDepth+`) {
            continue;
          }

          for (int wR = 0; wR < `+d+`; wR++) {
            int xR = xRCorner + wR * `+u+`;

            if (xR < 0 || xR >= `+n.inHeight+`) {
              continue;
            }

            for (int wC = 0; wC < `+f+`; wC++) {
              int xC = xCCorner + wC * `+l+`;

              if (xC < 0 || xC >= `+n.inWidth+`) {
                continue;
              }

              for (int d1 = 0; d1 < `+m+`; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (`+(v===1)+`) {
                dotProd +=
                  getX(batch, xF, xR, xC, `+m+`) *
                  getW(wF, wR, wC, `+m+`, d2);
              } else if (`+(v===2)+`) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, `+m+`),
                  getX(batch, xF, xR, xC, `+m+` + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, `+m+`, d2),
                  getW(wF, wR, wC, `+m+` + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (`+(v===3)+`) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, `+m+`),
                  getX(batch, xF, xR, xC, `+m+` + 1),
                  getX(batch, xF, xR, xC, `+m+` + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, `+m+`, d2),
                  getW(wF, wR, wC, `+m+` + 1, d2),
                  getW(wF, wR, wC, `+m+` + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `},h3=function(n,t,e,r){t===void 0&&(t=!1),e===void 0&&(e=null),r===void 0&&(r=!1),this.variableNames=["x","W"],this.outputShape=n.outShape;var a=n.inHeight,s=n.inWidth,o=n.padInfo.top,i=n.padInfo.left,u=n.strideHeight,l=n.strideWidth,h=n.dilationHeight,d=n.dilationWidth,f=n.filterHeight,m=n.filterWidth,v=n.outChannels/n.inChannels,y="",b="";e&&(y=r?`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          `+e+`
        }`:`
          float activation(float x) {
            `+e+`
          }
        `,b="result = activation(result);");var w=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),this.userCode=`
      `+y+`

      const ivec2 strides = ivec2(`+u+", "+l+`);
      const ivec2 pads = ivec2(`+o+", "+i+`);

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / `+v+`;
        int q = d2 - d1 * `+v+`;

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < `+f+`; wR++) {
          int xR = xRCorner + wR * `+h+`;

          if (xR < 0 || xR >= `+a+`) {
            continue;
          }

          for (int wC = 0; wC < `+m+`; wC++) {
            int xC = xCCorner + wC * `+d+`;

            if (xC < 0 || xC >= `+s+`) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        `+w+`
        `+b+`
        setOutput(result);
      }
    `},d3=function(n,t,e,r){t===void 0&&(t=!1),e===void 0&&(e=null),r===void 0&&(r=!1),this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n.outShape;for(var a=n.inHeight,s=n.inWidth,o=n.padInfo.top,i=n.padInfo.left,u=n.strideHeight,l=n.strideWidth,h=n.dilationHeight,d=n.dilationWidth,f=n.filterHeight,m=n.filterWidth,v=m,y="int xR; int xC; int xCOffset;",b=0;b<f;b++)for(var w=0;w<m;w++)y+=`
          vec4 xTexelR`+b+"C"+2*w+` = vec4(0.);
          vec4 wR`+b+"C"+w+` = vec4(0.);
          vec4 xR`+b+"C"+w+" = vec4(0.);";for(b=0;b<f;b++)for(var S=0;S<v;S++){if(y+=`
          xR = xRCorner + `+b*h+`;
          xC = xCCorner + `+(w=2*S)*d+`;
        `,l===1){if(w<m&&(y+=i%2==1?`
                xCOffset = xC + 1;
                if(xR >= 0 && xR < `+a+" && xCOffset >= 0 && xCOffset < "+s+`) {
                  xTexelR`+b+"C"+w+` = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if(xCOffset + 1 >= `+s+`) {
                    xTexelR`+b+"C"+w+`.zw = vec2(0.);
                  }
                } else {
                  xTexelR`+b+"C"+w+` = vec4(0.);
                }

                xCOffset = xC + 1 - 2;
                if(xR >= 0 && xR < `+a+" && xCOffset >= 0 && xCOffset < "+s+`) {
                  vec4 previous = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if(xCOffset + 1 >= `+s+`) {
                    previous.zw = vec2(0.);
                  }

                  xR`+b+"C"+w+" = vec4(previous.zw, xTexelR"+b+"C"+w+`.xy);
                } else {
                  xR`+b+"C"+w+" = vec4(0, 0, xTexelR"+b+"C"+w+`.xy);
                }
              `:`
                if(xR >= 0 && xR < `+a+" && xC >= 0 && xC < "+s+`) {
                  xTexelR`+b+"C"+w+` = getX(batch, xR, xC, d1);
                } else {
                  xTexelR`+b+"C"+w+` = vec4(0.);
                }

                xR`+b+"C"+w+" = xTexelR"+b+"C"+w+`;
              `,w+1<m)){var N=i%2==0?$B(d):d;d%2==0&&i%2==1||d%2!=0&&i%2!=1?(y+=`
                  xCOffset = xC + `+i%2+" + "+N+`;

                  if(xR >= 0 && xR < `+a+` &&
                    xCOffset >= 0 && xCOffset < `+s+`) {
                    xTexelR`+b+"C"+(w+2)+` = getX(batch, xR, xCOffset, d1);
                  }
                `,d>1&&(y+=`
                    xCOffset -= 2;
                    if(xR >= 0 && xR < `+a+` &&
                      xCOffset >= 0 && xCOffset < `+s+`) {
                      xTexelR`+b+"C"+w+` = getX(batch, xR, xCOffset, d1);
                    } else {
                      xTexelR`+b+"C"+w+` = vec4(0.);
                    }
                  `),y+=`
                  xR`+b+"C"+(w+1)+` = vec4(
                    xTexelR`+b+"C"+w+".zw, xTexelR"+b+"C"+(w+2)+`.xy);
                `):y+=`
                  xCOffset = xC + `+N+`;

                  if(xR >= 0 && xR < `+a+` &&
                    xCOffset >= 0 && xCOffset < `+s+`) {
                    xTexelR`+b+"C"+(w+2)+` = getX(batch, xR, xCOffset, d1);
                  }

                  xR`+b+"C"+(w+1)+" = xTexelR"+b+"C"+(w+2)+`;
                `}}else w<m&&(y+=`
              if(xR >= 0 && xR < `+a+`) {
            `,i%2==1?(y+=`
                xCOffset = xC + 1 - `+l+`;
                if(xCOffset >= 0 && xCOffset < `+s+`) {
                  xTexelR`+b+"C"+w+` = getX(batch, xR, xCOffset, d1);
                } else {
                  xTexelR`+b+"C"+w+` = vec4(0.);
                }

                if(xC + 1 >= 0 && xC + 1 < `+s+`) {
                  xTexelR`+b+"C"+(w+2)+` = getX(batch, xR, xC + 1, d1);
                } else {
                  xTexelR`+b+"C"+(w+2)+` = vec4(0.);
                }

                xR`+b+"C"+w+` = vec4(
                  xTexelR`+b+"C"+w+".zw, xTexelR"+b+"C"+(w+2)+`.zw);
              `,w+1<m&&(y+=`
                  vec4 final = vec4(0.);
                  xCOffset = xC + 1 + `+l+`;
                  if(xCOffset >= 0 && xCOffset < `+s+`) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xR`+b+"C"+(w+1)+" = vec4(xTexelR"+b+"C"+(w+2)+`.xy, final.xy);
                `)):(y+=`
                if(xC >= 0 && xC < `+s+`) {
                  xTexelR`+b+"C"+w+` = getX(batch, xR, xC, d1);
                } else {
                  xTexelR`+b+"C"+w+` = vec4(0.);
                }

                xCOffset = xC + `+l+`;
                if(xCOffset >= 0 && xCOffset < `+s+`) {
                  xTexelR`+b+"C"+(w+2)+` = getX(batch, xR, xCOffset, d1);
                } else {
                  xTexelR`+b+"C"+(w+2)+` = vec4(0.);
                }

                xR`+b+"C"+w+` = vec4(
                  xTexelR`+b+"C"+w+".xy, xTexelR"+b+"C"+(w+2)+`.xy);
              `,w+1<m&&(y+=`
                  xR`+b+"C"+(w+1)+` = vec4(
                    xTexelR`+b+"C"+w+".zw, xTexelR"+b+"C"+(w+2)+`.zw);
                `)),y+="}");w<m&&(y+=`
            vec4 wTexelR`+b+"C"+w+" = getW("+b+", "+w+`, d1, q);
            wR`+b+"C"+w+" = vec4(wTexelR"+b+"C"+w+".xz, wTexelR"+b+"C"+w+`.xz);
          `,w+1<m&&(y+=`
              vec4 wTexelR`+b+"C"+(w+1)+" = getW("+b+", "+(w+1)+`, d1, q);
              wR`+b+"C"+(w+1)+` =
                vec4(wTexelR`+b+"C"+(w+1)+".xz, wTexelR"+b+"C"+(w+1)+".xz);"))}for(b=0;b<f;b++)for(w=0;w<m;w++)y+="dotProd += xR"+b+"C"+w+" * wR"+b+"C"+w+";";var C="",T="";e&&(C=r?`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          `+e+`
        }`:`vec4 activation(vec4 x) {
          `+e+`
        }`,T="result = activation(result);");var I=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),this.userCode=`
      `+C+`

      const ivec2 strides = ivec2(`+u+", "+l+`);
      const ivec2 pads = ivec2(`+o+", "+i+`);

      void main() {

        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2;
        int q = 0;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        vec4 dotProd = vec4(0.);

        `+y+`

        vec4 result = dotProd;
        `+I+`
        `+T+`
        setOutput(result);
      }
    `},_rt=function(n,t,e,r,a){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];var s=n[0],o=n[1],i=n[2],u=n[3],l=t[0],h=e[0],d=e[1];this.outputShape=[l,h,d,u];var f=r==="bilinear"?1:0,m=[o-1+".0",i-1+".0"],v=m[0],y=m[1],b=h>1?[""+(o-1)/(h-1),"(y2-y1) * height_ratio","y1*"+v+" + float(y)*(height_scale)"]:["0.0","0.0","0.5 * (y1+y2) * "+v],w=b[0],S=b[1],N=b[2],C=d>1?[""+(i-1)/(d-1),"(x2-x1) * width_ratio","x1*"+y+" + float(x)*(width_scale)"]:["0.0","0.0","0.5 * (x1+x2) * "+y],T=C[0],I=C[1],_=C[2];this.userCode=`
      const float height_ratio = float(`+w+`);
      const float width_ratio = float(`+T+`);
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= `+s+`) {
          return;
        }

        float height_scale = `+S+`;
        float width_scale = `+I+`;

        float in_y = `+N+`;
        if( in_y < 0.0 || in_y > `+v+` ) {
          setOutput(float(`+a+`));
          return;
        }
        float in_x = `+_+`;
        if( in_x < 0.0 || in_x > `+y+` ) {
          setOutput(float(`+a+`));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(`+f+` == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `},Rrt=function(n,t,e){this.variableNames=["x"],this.outputShape=n;var r=n.length,a=n[n.length-1],s=e?"<":">";this.userCode=`
      int getIndex(int i) {
        `+(e?"return "+a+" -i - 1;":"return i;")+`
      }

      void main() {
        `+yn(r)+` coords = getOutputCoords();
        int end = `+p3(r,"coords")+`;
        float val = 0.0;
        for (int i = `+a+` - 1; i >= 0; i -= 1) {
          int idx = getIndex(i);
          if (idx `+s+` end) {
            continue;
          }
          if (idx == end && `+t+`) {
            continue;
          }
          `+p3(r,"coords")+` = idx;
          val += getX(`+(function(o,i){if(o===1)return""+i;if(o===2)return i+".x, "+i+".y";if(o===3)return i+".x, "+i+".y, "+i+".z";if(o===4)return i+".x, "+i+".y, "+i+".z, "+i+".w";throw Error("Cumulative sum for rank "+o+" is not yet supported")})(r,"coords")+`);
        }
        setOutput(val);
      }
    `};function p3(n,t){if(n===1)return""+t;if(n===2)return t+".y";if(n===3)return t+".z";if(n===4)return t+".w";throw Error("Cumulative sum for rank "+n+" is not yet supported")}var Art=function(n){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=om.DENSE;var t=Pf(n),e=ua();this.outputShape=n,this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        `+Wl(["r","c","d"],n)+`
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx *
          vec2(`+t[0]+", "+t[1]+`));
        int index = 4 * (resTexRC.x * `+t[1]+` + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        `+e.output+` = result;
      }
    `},Drt=function(n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=om.DENSE;var t=Pf(n),e=ua();this.outputShape=n,this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        `+Wl(["r","c","d"],n)+`
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx *
          vec2(`+t[0]+", "+t[1]+`));
        int index = 4 * (resTexRC.x * `+t[1]+` + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        `+e.output+` = result;
      }
    `},$rt=(function(){function n(t,e,r){this.variableNames=["x"],this.outputShape=[],this.outputShape=t,this.blockSize=e,this.dataFormat=r,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = `+this.getHeightCoordString()+`;
      int w = `+this.getWidthCoordString()+`;
      int d = `+this.getDepthCoordString()+`;

      int in_h = h / `+e+`;
      int offset_h = imod(h, `+e+`);
      int in_w = w / `+e+`;
      int offset_w = imod(w, `+e+`);
      int offset_d = (offset_h * `+e+` + offset_w) *
        `+this.getOutputDepthSize()+`;
      int in_d = d + offset_d;

      float result = `+this.getInputSamplingString()+`;
      setOutput(result);
    }
  `}return n.prototype.getHeightCoordString=function(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"},n.prototype.getWidthCoordString=function(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"},n.prototype.getDepthCoordString=function(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"},n.prototype.getOutputDepthSize=function(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]},n.prototype.getInputSamplingString=function(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"},n})(),Ort=function(n){this.variableNames=["X"],this.outputShape=[n,n],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `},Frt=function(n){this.variableNames=["A"],this.outTexUsage=cs.DOWNLOAD;var t=ua();this.outputShape=n,this.userCode=`
      `+dz+`

      void main() {
        float x = getAAtOutCoords();
        `+t.output+` = encode_float(x);
      }
    `},Mrt=function(n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=cs.DOWNLOAD;var t=ua();this.outputShape=n,this.userCode=`
      `+dz+`

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        `+t.output+` = encode_float(x);
      }
    `},Lrt=function(n,t,e){e===void 0&&(e=!1),this.variableNames=["A"];var r=ua(),a=t[0],s=t[1];this.outputShape=n;var o="result";e&&(o="floor(result * 255. + 0.5)"),this.userCode=`
      `+HE(n)+`

      void main() {
        ivec3 coords = getOutputCoords();

        int flatIndex = getFlatIndex(coords);
        int offset = imod(flatIndex, 4);

        flatIndex = idiv(flatIndex, 4, 1.);
        
        int r = flatIndex / `+s+`;
        int c = imod(flatIndex, `+s+`);
        vec2 uv = (vec2(c, r) + halfCR) / vec2(`+s+".0, "+a+`.0);
        vec4 values = `+r.texture2D+`(A, uv);

        float result;

        if(offset == 0) {
          result = values[0];
        } else if(offset == 1) {
          result = values[1];
        } else if(offset == 2) {
          result = values[2];
        } else {
          result = values[3];
        }

        `+r.output+" = vec4("+o+`, 0., 0., 0.);
      }
    `},Brt=function(n,t,e){e===void 0&&(e=!1),this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;var r=ua(),a=t[0],s=t[1];this.outputShape=n;var o="",i="result";e&&(i="floor(result * 255. + 0.5)");for(var u=0;u<=1;u++)for(var l=0;l<=1;l++){var h=2*u+l;o+=`
          localCoords = coords;
          if(localCoords[2] + `+l+" < "+n[2]+`) {
            localCoords[2] += `+l+`;
            if(localCoords[1] + `+u+" < "+n[1]+`) {
              localCoords[1] += `+u+`;

              flatIndex = getFlatIndex(localCoords);
              offset = imod(flatIndex, 4);

              flatIndex = idiv(flatIndex, 4, 1.);

              r = flatIndex / `+s+`;
              c = imod(flatIndex, `+s+`);
              uv = (vec2(c, r) + halfCR) / vec2(`+s+".0, "+a+`.0);
              values = `+r.texture2D+`(A, uv);

              if(offset == 0) {
                result[`+h+`] = values[0];
              } else if(offset == 1) {
                result[`+h+`] = values[1];
              } else if(offset == 2) {
                result[`+h+`] = values[2];
              } else {
                result[`+h+`] = values[3];
              }
            }
          }
        `}this.userCode=`
      `+HE(n)+`

      void main() {
        ivec3 coords = getOutputCoords();

        vec4 result = vec4(0.);
        int flatIndex, r, c, offset;
        ivec3 localCoords;
        vec2 uv;
        vec4 values;

        `+o+`

        `+r.output+" = "+i+`;
      }
    `},zrt="return real * expR - imag * expI;",Prt="return real * expI + imag * expR;",f3=function(n,t,e){this.variableNames=["real","imag"];var r=t[1];this.outputShape=t;var a=e?"2.0 * "+Math.PI:"-2.0 * "+Math.PI,s=e?r+".0":"1.0";this.userCode=`
      const float exponentMultiplier = `+a+`;

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        `+n+`
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(`+r+`);
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < `+r+`; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / `+s+`;
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `},Vrt=(function(){function n(t,e){this.outputShape=[],this.variableNames=["x"],this.outputShape=t,this.userCode=`
      uniform float value;
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}return n.prototype.getCustomSetupFunc=function(t){var e=this;return function(r,a){e.valueLoc==null&&(e.valueLoc=r.getUniformLocationNoThrow(a,"value")),r.gl.uniform1f(e.valueLoc,t)}},n})(),Urt=function(n,t,e){this.variableNames=["A","indices"];var r=n.slice();r[e]=t,this.outputShape=r,this.rank=r.length;var a=yn(this.rank),s=(function(o,i){var u=o.length;if(u>4)throw Error("Gather for rank "+u+" is not yet supported");if(u===1)return"int(getIndices(resRC))";for(var l=["resRC.x","resRC.y","resRC.z","resRC.w"],h=[],d=0;d<o.length;d++)d===i?h.push("int(getIndices("+l[d]+"))"):h.push(""+l[d]);return h.join()})(n,e);this.userCode=`
      void main() {
        `+a+` resRC = getOutputCoords();
        setOutput(getA(`+s+`));
      }
    `},Wrt=function(n,t,e){this.sliceDim=n,this.strides=t,this.variableNames=["x","indices"],this.outputShape=e;var r=yn(t.length),a=yn(e.length),s=this.sliceDim>1?"strides[j]":"strides";this.userCode=`
        `+r+" strides = "+r+"("+this.strides+`);
         void main() {
          `+a+` coords = getOutputCoords();
          int flattenIndex = 0;
          for (int j = 0; j < `+this.sliceDim+`; j++) {
            int index = round(getIndices(coords[0], j));
            flattenIndex += index * `+s+`;
          }
          setOutput(getX(flattenIndex, coords[1]));
        }
      `};function Grt(n,t){var e=ua();return zet(n,t,e.version+`
    precision highp float;
    `+e.attribute+` vec3 clipSpacePos;
    `+e.attribute+` vec2 uv;
    `+e.varyingVs+` vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`)}function Hrt(n,t){return Get(n,t,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}function jrt(n,t){return Het(n,t,new Uint16Array([0,1,2,2,1,3]))}function Yg(n,t,e,r,a,s,o){qet(e,r);var i=jet(n,t),u=n.TEXTURE_2D;return ne(n,t,(function(){return n.bindTexture(u,i)})),ne(n,t,(function(){return n.texParameteri(u,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE)})),ne(n,t,(function(){return n.texParameteri(u,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE)})),ne(n,t,(function(){return n.texParameteri(u,n.TEXTURE_MIN_FILTER,n.NEAREST)})),ne(n,t,(function(){return n.texParameteri(u,n.TEXTURE_MAG_FILTER,n.NEAREST)})),ne(n,t,(function(){return n.texImage2D(u,0,a,e,r,0,s,o,null)})),ne(n,t,(function(){return n.bindTexture(n.TEXTURE_2D,null)})),i}function qrt(n,t,e,r,a){var s=D1(e,r);return Yg(n,t,s[0],s[1],a.internalFormatFloat,a.textureFormatFloat,n.FLOAT)}function Krt(n,t,e,r,a){var s=D1(e,r);return Yg(n,t,s[0],s[1],a.internalFormatHalfFloat,a.textureFormatFloat,a.textureTypeHalfFloat)}function Xrt(n,t,e,r,a){var s=D1(e,r);return Yg(n,t,s[0],s[1],n.RGBA,n.RGBA,n.UNSIGNED_BYTE)}function Yrt(n,t,e,r,a){var s=Xg(e,r);return Yg(n,t,s[0],s[1],a.internalFormatPackedFloat,n.RGBA,n.FLOAT)}function Qrt(n,t,e,r,a){var s=Xg(e,r);return Yg(n,t,s[0],s[1],a.internalFormatPackedHalfFloat,n.RGBA,a.textureTypeHalfFloat)}function Zrt(n,t,e,r){return ne(n,t,(function(){return n.bindBuffer(n.ARRAY_BUFFER,r)})),e3(n,t,e,"clipSpacePos",r,3,20,0)&&e3(n,t,e,"uv",r,2,20,12)}function Jrt(n,t,e,r,a,s,o){var i,u,l;ne(n,t,(function(){return n.bindTexture(n.TEXTURE_2D,e)})),s instanceof Uint8Array?(i=new Uint8Array(r*a*4),u=n.UNSIGNED_BYTE,l=n.RGBA):(i=new Float32Array(r*a*4),u=n.FLOAT,l=o.internalFormatPackedFloat),i.set(s),ne(n,t,(function(){return n.texImage2D(n.TEXTURE_2D,0,l,r,a,0,n.RGBA,u,i)})),ne(n,t,(function(){return n.bindTexture(n.TEXTURE_2D,null)}))}function tat(n,t,e,r){ne(n,t,(function(){return n.bindTexture(n.TEXTURE_2D,e)})),r.data instanceof Uint8Array?ne(n,t,(function(){return n.texImage2D(n.TEXTURE_2D,0,n.RGBA,r.width,r.height,0,n.RGBA,n.UNSIGNED_BYTE,r.data)})):ne(n,t,(function(){return n.texImage2D(n.TEXTURE_2D,0,n.RGBA,n.RGBA,n.UNSIGNED_BYTE,r)})),ne(n,t,(function(){return n.bindTexture(n.TEXTURE_2D,null)}))}function eat(n,t,e,r,a){var s=n.createBuffer();ne(n,t,(function(){return n.bindBuffer(n.PIXEL_PACK_BUFFER,s)}));var o=16*e*r;return ne(n,t,(function(){return n.bufferData(n.PIXEL_PACK_BUFFER,o,n.STREAM_READ)})),ne(n,t,(function(){return n.readPixels(0,0,r,e,n.RGBA,n.FLOAT,0)})),ne(n,t,(function(){return n.bindBuffer(n.PIXEL_PACK_BUFFER,null)})),s}function nat(n,t,e){var r=n,a=new Float32Array(e);return r.bindBuffer(r.PIXEL_PACK_BUFFER,t),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,a),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),a}function rat(n,t,e,r,a){var s=D1(e,r),o=s[0],i=s[1],u=new Uint8Array(e*r*4);return ne(n,t,(function(){return n.readPixels(0,0,o,i,a.downloadTextureFormat,n.UNSIGNED_BYTE,u)})),new Float32Array(u.buffer)}function aat(n,t,e,r,a,s,o,i){var u=n,l=new Float32Array((function(h,d){var f=Xg(h,d);return f[0]*f[1]*4})(s,o));return u.bindBuffer(u.PIXEL_PACK_BUFFER,t),u.getBufferSubData(u.PIXEL_PACK_BUFFER,0,l),u.bindBuffer(u.PIXEL_PACK_BUFFER,null),l}function sat(n,t,e,r){var a=new Float32Array(e*r*4);return ne(n,t,(function(){return n.readPixels(0,0,r,e,n.RGBA,n.FLOAT,a)})),a}var oat=(function(){function n(t){this.outputTexture=null,this.program=null,this.disposed=!1,this.vertexAttrsAreBound=!1,this.itemsToPoll=[];var e=kt().getNumber("WEBGL_VERSION");t!=null?(this.gl=t,Oet(e,t)):this.gl=Xo(e);var r="WEBGL_color_buffer_float";if(kt().getNumber("WEBGL_VERSION")===1){if(this.textureFloatExtension=Hy(this.gl,this.debug,"OES_texture_float"),Bs(this.gl,"OES_texture_half_float"))this.textureHalfFloatExtension=Hy(this.gl,this.debug,"OES_texture_half_float");else if(kt().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(r),Bs(this.gl,"EXT_color_buffer_half_float"))this.colorBufferHalfFloatExtension=Hy(this.gl,this.debug,"EXT_color_buffer_half_float");else if(kt().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(r="EXT_color_buffer_float",Bs(this.gl,r))this.colorBufferFloatExtension=this.gl.getExtension(r);else{if(!Bs(this.gl,"EXT_color_buffer_half_float"))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension("EXT_color_buffer_half_float")}this.vertexBuffer=Hrt(this.gl,this.debug),this.indexBuffer=jrt(this.gl,this.debug),this.framebuffer=Ket(this.gl,this.debug),this.textureConfig=FE(this.gl,this.textureHalfFloatExtension)}return Object.defineProperty(n.prototype,"debug",{get:function(){return kt().getBool("DEBUG")},enumerable:!0,configurable:!0}),n.prototype.dispose=function(){var t=this;if(!this.disposed){this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");var e=this.gl;ne(e,this.debug,(function(){return e.finish()})),ne(e,this.debug,(function(){return e.bindFramebuffer(e.FRAMEBUFFER,null)})),ne(e,this.debug,(function(){return e.deleteFramebuffer(t.framebuffer)})),ne(e,this.debug,(function(){return e.bindBuffer(e.ARRAY_BUFFER,null)})),ne(e,this.debug,(function(){return e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)})),ne(e,this.debug,(function(){return e.deleteBuffer(t.indexBuffer)})),this.disposed=!0}},n.prototype.createFloat32MatrixTexture=function(t,e){return this.throwIfDisposed(),qrt(this.gl,this.debug,t,e,this.textureConfig)},n.prototype.createFloat16MatrixTexture=function(t,e){return this.throwIfDisposed(),Krt(this.gl,this.debug,t,e,this.textureConfig)},n.prototype.createUnsignedBytesMatrixTexture=function(t,e){return this.throwIfDisposed(),Xrt(this.gl,this.debug,t,e,this.textureConfig)},n.prototype.uploadPixelDataToTexture=function(t,e){this.throwIfDisposed(),tat(this.gl,this.debug,t,e)},n.prototype.uploadDenseMatrixToTexture=function(t,e,r,a){this.throwIfDisposed(),Jrt(this.gl,this.debug,t,e,r,a,this.textureConfig)},n.prototype.createFloat16PackedMatrixTexture=function(t,e){return this.throwIfDisposed(),Qrt(this.gl,this.debug,t,e,this.textureConfig)},n.prototype.createPackedMatrixTexture=function(t,e){return this.throwIfDisposed(),Yrt(this.gl,this.debug,t,e,this.textureConfig)},n.prototype.deleteMatrixTexture=function(t){var e=this;this.throwIfDisposed(),this.outputTexture===t&&(n3(this.gl,this.debug,this.framebuffer),this.outputTexture=null),ne(this.gl,this.debug,(function(){return e.gl.deleteTexture(t)}))},n.prototype.downloadByteEncodedFloatMatrixFromOutputTexture=function(t,e,r){var a=this;return this.downloadMatrixDriver(t,(function(){return rat(a.gl,a.debug,e,r,a.textureConfig)}))},n.prototype.downloadPackedMatrixFromBuffer=function(t,e,r,a,s,o){return aat(this.gl,t,0,0,0,s,o,this.textureConfig)},n.prototype.downloadFloat32MatrixFromBuffer=function(t,e){return nat(this.gl,t,e)},n.prototype.createBufferFromTexture=function(t,e,r){this.bindTextureToFrameBuffer(t);var a=eat(this.gl,this.debug,e,r,this.textureConfig);return this.unbindTextureToFrameBuffer(),a},n.prototype.createAndWaitForFence=function(){var t=this.createFence(this.gl);return this.pollFence(t)},n.prototype.createFence=function(t){var e,r,a=this;if(kt().getBool("WEBGL_FENCE_API_ENABLED")){var s=t,o=s.fenceSync(s.SYNC_GPU_COMMANDS_COMPLETE,0);t.flush(),r=function(){var i=s.clientWaitSync(o,0,0);return i===s.ALREADY_SIGNALED||i===s.CONDITION_SATISFIED},e=o}else kt().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(e=this.beginQuery(),this.endQuery(),r=function(){return a.isQueryAvailable(e,kt().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}):r=function(){return!0};return{query:e,isFencePassed:r}},n.prototype.downloadMatrixFromPackedTexture=function(t,e,r){var a=this;return this.downloadMatrixDriver(t,(function(){return sat(a.gl,a.debug,e,r)}))},n.prototype.createProgram=function(t){this.throwIfDisposed();var e=this.gl,r=Pet(e,this.debug,t),a=Grt(e,this.debug),s=Uet(e,this.debug);return ne(e,this.debug,(function(){return e.attachShader(s,a)})),ne(e,this.debug,(function(){return e.attachShader(s,r)})),Wet(e,this.debug,s),this.debug&&QS(e,this.debug,s),this.vertexAttrsAreBound||(this.setProgram(s),this.vertexAttrsAreBound=Zrt(e,this.debug,this.program,this.vertexBuffer)),s},n.prototype.deleteProgram=function(t){var e=this;this.throwIfDisposed(),t===this.program&&(this.program=null),t!=null&&ne(this.gl,this.debug,(function(){return e.gl.deleteProgram(t)}))},n.prototype.setProgram=function(t){var e=this;this.throwIfDisposed(),this.program=t,this.program!=null&&this.debug&&QS(this.gl,this.debug,this.program),ne(this.gl,this.debug,(function(){return e.gl.useProgram(t)}))},n.prototype.getUniformLocation=function(t,e,r){return r===void 0&&(r=!0),this.throwIfDisposed(),r?Yet(this.gl,this.debug,t,e):Qet(this.gl,t,e)},n.prototype.getAttributeLocation=function(t,e){var r=this;return this.throwIfDisposed(),ne(this.gl,this.debug,(function(){return r.gl.getAttribLocation(t,e)}))},n.prototype.getUniformLocationNoThrow=function(t,e){return this.throwIfDisposed(),this.gl.getUniformLocation(t,e)},n.prototype.setInputMatrixTexture=function(t,e,r){this.throwIfDisposed(),this.throwIfNoProgram(),Zet(this.gl,this.debug,this.program,t,e,r)},n.prototype.setOutputMatrixTexture=function(t,e,r){this.setOutputMatrixTextureDriver(t,r,e)},n.prototype.setOutputPackedMatrixTexture=function(t,e,r){this.throwIfDisposed();var a=Xg(e,r),s=a[0],o=a[1];this.setOutputMatrixTextureDriver(t,s,o)},n.prototype.setOutputMatrixWriteRegion=function(t,e,r,a){this.setOutputMatrixWriteRegionDriver(r,t,a,e)},n.prototype.setOutputPackedMatrixWriteRegion=function(t,e,r,a){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")},n.prototype.debugValidate=function(){this.program!=null&&QS(this.gl,this.debug,this.program),jy(this.gl)},n.prototype.executeProgram=function(){this.throwIfDisposed(),this.throwIfNoProgram();var t=this.gl;this.debug&&this.debugValidate(),ne(t,this.debug,(function(){return t.drawElements(t.TRIANGLES,6,t.UNSIGNED_SHORT,0)}))},n.prototype.blockUntilAllProgramsCompleted=function(){var t=this;this.throwIfDisposed(),ne(this.gl,this.debug,(function(){return t.gl.finish()}))},n.prototype.getQueryTimerExtension=function(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=Hy(this.gl,this.debug,kt().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension},n.prototype.getQueryTimerExtensionWebGL2=function(){return this.getQueryTimerExtension()},n.prototype.getQueryTimerExtensionWebGL1=function(){return this.getQueryTimerExtension()},n.prototype.beginQuery=function(){if(kt().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){var t=this.gl,e=this.getQueryTimerExtensionWebGL2(),r=t.createQuery();return t.beginQuery(e.TIME_ELAPSED_EXT,r),r}var a=this.getQueryTimerExtensionWebGL1(),s=a.createQueryEXT();return a.beginQueryEXT(a.TIME_ELAPSED_EXT,s),s},n.prototype.endQuery=function(){if(kt().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")!==2){var t=this.getQueryTimerExtensionWebGL1();t.endQueryEXT(t.TIME_ELAPSED_EXT)}else{var e=this.gl,r=this.getQueryTimerExtensionWebGL2();e.endQuery(r.TIME_ELAPSED_EXT)}},n.prototype.waitForQueryAndGetTime=function(t){return Yt(this,void 0,void 0,(function(){var e=this;return Qt(this,(function(r){switch(r.label){case 0:return[4,XO((function(){return e.disposed||e.isQueryAvailable(t,kt().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}))];case 1:return r.sent(),[2,this.getQueryTime(t,kt().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))]}}))}))},n.prototype.getQueryTime=function(t,e){if(e===0)return null;if(e===2){var r=this.gl;return r.getQueryParameter(t,r.QUERY_RESULT)/1e6}var a=this.getQueryTimerExtensionWebGL1();return a.getQueryObjectEXT(t,a.QUERY_RESULT_EXT)/1e6},n.prototype.isQueryAvailable=function(t,e){if(e===0)return!0;if(e===2){var r=this.gl,a=this.getQueryTimerExtensionWebGL2(),s=r.getQueryParameter(t,r.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(a.GPU_DISJOINT_EXT)),s&&!this.disjoint}return s=(a=this.getQueryTimerExtensionWebGL1()).getQueryObjectEXT(t,a.QUERY_RESULT_AVAILABLE_EXT),this.disjoint==null&&(this.disjoint=this.gl.getParameter(a.GPU_DISJOINT_EXT)),s&&!this.disjoint},n.prototype.pollFence=function(t){var e=this;return new Promise((function(r){e.addItemToPoll((function(){return t.isFencePassed()}),(function(){return r()}))}))},n.prototype.pollItems=function(){for(var t=(function(r){for(var a=0;a<r.length&&r[a]();++a);return a-1})(this.itemsToPoll.map((function(r){return r.isDoneFn}))),e=0;e<=t;++e)(0,this.itemsToPoll[e].resolveFn)();this.itemsToPoll=this.itemsToPoll.slice(t+1)},n.prototype.addItemToPoll=function(t,e){var r=this;this.itemsToPoll.push({isDoneFn:t,resolveFn:e}),this.itemsToPoll.length>1||XO((function(){return r.pollItems(),r.itemsToPoll.length===0}))},n.prototype.bindTextureToFrameBuffer=function(t){this.throwIfDisposed(),ZS(this.gl,this.debug,t,this.framebuffer),this.debug&&jy(this.gl)},n.prototype.unbindTextureToFrameBuffer=function(){this.outputTexture!=null?(ZS(this.gl,this.debug,this.outputTexture,this.framebuffer),this.debug&&jy(this.gl)):n3(this.gl,this.debug,this.framebuffer)},n.prototype.downloadMatrixDriver=function(t,e){this.bindTextureToFrameBuffer(t);var r=e();return this.unbindTextureToFrameBuffer(),r},n.prototype.setOutputMatrixTextureDriver=function(t,e,r){this.throwIfDisposed();var a=this.gl;ZS(a,this.debug,t,this.framebuffer),this.debug&&jy(a),this.outputTexture=t,ne(a,this.debug,(function(){return a.viewport(0,0,e,r)})),ne(a,this.debug,(function(){return a.scissor(0,0,e,r)}))},n.prototype.setOutputMatrixWriteRegionDriver=function(t,e,r,a){var s=this;this.throwIfDisposed(),ne(this.gl,this.debug,(function(){return s.gl.scissor(t,e,r,a)}))},n.prototype.throwIfDisposed=function(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")},n.prototype.throwIfNoProgram=function(){if(this.program==null)throw new Error("No GPU program is currently set.")},n})();function m3(n,t){if(n.length!==t.length)throw Error("Binary was compiled with "+n.length+" inputs, but was executed with "+t.length+" inputs");n.forEach((function(e,r){var a=e.logicalShape,s=t[r],o=s.shape;if(!Fr(a,o))throw Error("Binary was compiled with different shapes than the current args. Shapes "+a+" and "+o+" must match");if(!e.isUniform||!s.isUniform){var i=e.texShape,u=s.isUniform?null:s.texData.texShape;if(!Fr(i,u))throw Error("Binary was compiled with different texture shapes than the current args. Shape "+i+" and "+u+" must match")}}))}var iat=function(n,t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n;for(var r=e.filterWidth,a=e.inChannels,s=e.strideWidth,o=e.strideHeight,i=e.padInfo,u=e.outWidth,l=e.dilationWidth,h=e.dilationHeight,d=e.dataFormat,f=i.left,m=i.top,v=a*r,y=ua(),b=d==="channelsLast",w=b?0:1,S=b?1:2,N="",C=0;C<=1;C++)for(var T=0;T<=1;T++)N+=`
          blockIndex = rc.y + `+T+`;
          pos = rc.x + `+C+`;

          if(blockIndex < `+n[1]+" && pos < "+n[0]+`) {
            offsetY = int(blockIndex / (`+u+")) * "+o+" - "+m+`;
            d0 = offsetY + `+h+" * (pos / "+v+`);

            if(d0 < `+t[w]+` && d0 >= 0) {

              offsetX = int(mod(float(blockIndex), `+u+".) * "+s+". - "+f+`.);
              d1 = offsetX + `+l+" * (int(mod(float(pos), "+v+".) / "+a+`.));

              if(d1 < `+t[S]+` && d1 >= 0) {

                ch = int(mod(float(pos), `+a+`.));

                if (`+b+`) {
                  innerDims = vec2(d1, ch);
                  result[`+(2*C+T)+`] = getChannel(
                    getA(d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[`+(2*C+T)+`] = getChannel(
                    getA(ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec2 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        `+N+`

        `+y.output+` = result;
      }
    `},uat=function(n,t,e,r,a){this.variableNames=["x"],this.outputShape=[];var s,o=t,i=n[3]-1;this.outputShape=n;var u="float("+e+") + float("+r+") * sum";s=a===.5?"inversesqrt("+u+")":a===1?"1.0/("+u+")":"exp(log("+u+") * float(-"+a+"));",this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -`+o+"; j <= "+o+`; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  `+i+`) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * `+s+`;
        setOutput(val);
      }
    `},lat=function(n,t,e,r,a){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=n,this.depth=n[3],this.depthRadius=t,this.bias=e,this.alpha=r,this.beta=a,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < `+this.depth+`; ++d) {
          int depthBegin = int(max(0.0, float(d - `+t+`)));
          int depthEnd = int(min(float(`+this.depth+`),
              float(d + `+t+` + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = `+this.depth+`;

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(`+r+") * norm + float("+e+`);

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(`+r+`)
                * float(`+a+`)
                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * `+a+`);
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `},cat=function(n,t,e,r,a){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;var s,o=t,i=n[3]-1;this.outputShape=n;var u="float("+e+") + float("+r+") * sum";s=a===.5?"inversesqrt("+u+")":a===1?"1.0/("+u+")":"exp(log("+u+") * float(-"+a+"));",this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < `+this.outputShape[3]+`;
        bool hasNextRow = c < `+this.outputShape[2]+`;

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - `+o+`;
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - `+o+"; j <= "+o+`; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(`+i+`));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * `+s+`;
        setOutput(result);
      }
    `},hat=function(n){this.variableNames=["dy","maxPos"],this.outputShape=n.inShape;var t=n.strideHeight,e=n.strideWidth,r=n.dilationHeight,a=n.effectiveFilterHeight,s=n.effectiveFilterWidth,o=a-1-n.padInfo.top,i=s-1-n.padInfo.left,u=a*s-1;this.userCode=`
      const ivec2 pads = ivec2(`+o+", "+i+`);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < `+a+`;
          wR += `+r+`) {
          float dyR = float(dyRCorner + wR) / `+t+`.0;

          if (dyR < 0.0 || dyR >= `+n.outHeight+`.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < `+s+`; wC++) {
            float dyC = float(dyCCorner + wC) / `+e+`.0;

            if (dyC < 0.0 || dyC >= `+n.outWidth+`.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = `+u+` - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * `+s+` + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `},dat=function(n){this.variableNames=["dy","maxPos"],this.outputShape=n.inShape;var t=n.strideDepth,e=n.strideHeight,r=n.strideWidth,a=n.dilationDepth,s=n.dilationHeight,o=n.dilationWidth,i=n.effectiveFilterDepth,u=n.effectiveFilterHeight,l=n.effectiveFilterWidth,h=i-1-n.padInfo.front,d=u-1-n.padInfo.top,f=l-1-n.padInfo.left,m=i*u*l-1;this.userCode=`
      const ivec3 pads = ivec3(`+h+", "+d+", "+f+`);

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < `+i+`;
           wD += `+a+`) {
          float dyD = float(dyDCorner + wD) / `+t+`.0;

          if (dyD < 0.0 || dyD >= `+n.outDepth+`.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < `+u+`;
              wR += `+s+`) {
            float dyR = float(dyRCorner + wR) / `+e+`.0;

            if (dyR < 0.0 || dyR >= `+n.outHeight+`.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < `+l+`;
                wC += `+o+`) {
              float dyC = float(dyCCorner + wC) / `+r+`.0;

              if (dyC < 0.0 || dyC >= `+n.outWidth+`.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = `+m+` -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * `+u+" * "+l+` +
                  wR * `+l+` + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `},rC=function(n,t,e,r,a,s,o){e===void 0&&(e=!1),r===void 0&&(r=!1),a===void 0&&(a=!1),s===void 0&&(s=null),o===void 0&&(o=!1),this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t;var i=e?n[1]:n[2],u=Math.ceil(i/2),l=e?"i * 2, rc.y":"rc.y, i * 2",h=r?"rc.z, i * 2":"i * 2, rc.z",d=e?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],f=r?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"],m="",v="";s&&(m=o?`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          `+s+`
        }`:`vec4 activation(vec4 x) {
          `+s+`
        }`,v="result = activation(result);");var y=a?"result += getBiasAtOutCoords();":"";a&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),this.userCode=`
      `+m+`

      const float sharedDimension = `+u+`.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        for (int i = 0; i < `+u+`; i++) {
          vec4 a = getMatrixA(rc.x, `+l+`);
          vec4 b = getMatrixB(rc.x, `+h+`);

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (`+d[0]+" * "+f[0]+`);
          result += (`+d[1]+" * "+f[1]+`);
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        `+y+`

        `+v+`

        setOutput(result);
      }
    `},pat=(function(){function n(t,e,r){this.variableNames=["probs"],this.outputShape=[t,r],this.userCode=`
      uniform float seed;

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < `+(e-1)+`; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(`+(e-1)+`));
      }
    `}return n.prototype.getCustomSetupFunc=function(t){var e=this;return function(r,a){e.seedLoc==null&&(e.seedLoc=r.getUniformLocation(a,"seed")),r.gl.uniform1f(e.seedLoc,t)}},n})(),fat=function(n,t,e,r){this.variableNames=["indices"],this.outputShape=[n,t],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(`+r+"), float("+e+`),
                      float(index == coords.y)));
      }
    `},mat=function(n){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=n;var t=n.length;if(t===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{var e=za("rc",t),r=yn(t),a=(function(i,u,l){if(i===1)return"rc > "+u[0];for(var h="",d=i-2;d<i;d++)h+=l[d]+" >= "+u[d],d<i-1&&(h+="||");return h})(t,n,e),s=(function(i,u,l,h){if(i===1)return"";var d=h.slice(-2);return`
    int r = `+d[0]+`;
    int c = `+d[1]+`;
    int rp1 = r + 1;
    int cp1 = c + 1;

    bool cEdge = cp1 >= `+u+`;
    bool rEdge = rp1 >= `+l+`;
  `})(t,n[n.length-1],n[n.length-2],e),o=(function(i,u){var l=i.length,h=(function(d,f){for(var m=[],v=0;v<=1;v++)for(var y=0;y<=1;y++){for(var b=(v===0?"r":"rp1")+", "+(y===0?"c":"cp1"),w=2;w<d;w++)b=f[f.length-1-w]+","+b;m.push(b)}return m})(l,u);return l===1?`getA(rc),
            rc + 1 >= `+i[0]+` ? 0. : getA(rc + 1),
            0, 0`:"getA("+h[0]+`),
          cEdge ? 0. : getA(`+h[1]+`),
          rEdge ? 0. : getA(`+h[2]+`),
          rEdge || cEdge ? 0. : getA(`+h[3]+")"})(n,e);this.userCode=`
        void main() {
          `+r+` rc = getOutputCoords();

          if(`+a+`) {
            setOutput(vec4(0));
          } else {
            `+s+`

            setOutput(vec4(`+o+`));
          }
        }
      `}},gat=function(n,t,e){this.variableNames=["x"],this.outputShape=t.map((function(u,l){return u[0]+n[l]+u[1]}));var r=n.length,a=yn(r),s=t.map((function(u){return u[0]})).join(","),o=t.map((function(u,l){return u[0]+n[l]})).join(","),i=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);this.userCode=r!==1?`
      `+a+" start = "+a+"("+s+`);
      `+a+" end = "+a+"("+o+`);

      void main() {
        `+a+` outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(float(`+e+`));
        } else {
          `+a+` coords = outC - start;
          setOutput(getX(`+i+`));
        }
      }
    `:`
        int start = `+s+`;
        int end = `+o+`;

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(float(`+e+`));
          } else {
            setOutput(getX(outC - start));
          }
        }
      `},vat=function(n,t,e){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map((function(b,w){return b[0]+n[w]+b[1]}));for(var r=n.length,a=yn(r),s=t.map((function(b){return b[0]})).join(","),o=t.map((function(b,w){return b[0]+n[w]})).join(","),i=za("rc",r),u=za("source",r),l=i[r-1]+" < "+this.outputShape[r-1],h=r===1?"source":"vec2("+u.slice(-2).join()+")",d=[a+" rc = outputLoc;",i[r-1]+` += 1;
       if(`+l+`) {
      `,r===1?"":`}
       rc = outputLoc;
       `+i[r-2]+` += 1;
       if(`+i[r-2]+" < "+this.outputShape[r-2]+") {",r===1?"":"  "+i[r-1]+` += 1;
         if(`+l+") {"],f=r===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))",m="",v=0,y=r===1?2:4;v<y;v++)m+=`
        `+d[v]+`
        if (`+f+`) {
          result[`+v+"] = float("+e+`);
        } else {
          `+a+` source = rc - start;
          result[`+v+"] = getChannel(getX("+u.join()+"), "+h+`);
        }
      `;m+=r===1?"} ":"}}",this.userCode=`
      const `+a+" start = "+a+"("+s+`);
      const `+a+" end = "+a+"("+o+`);

      void main() {
        `+a+` outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        `+m+`
        setOutput(result);
      }
    `},aC=function(n,t,e){if(this.variableNames=["x"],t==="avg"&&e)throw new Error("Cannot compute positions for average pool.");var r=n.filterWidth,a=n.strideHeight,s=n.strideWidth,o=n.dilationHeight,i=n.dilationWidth,u=n.effectiveFilterHeight,l=n.effectiveFilterWidth,h=n.padInfo.top,d=n.padInfo.left;this.outputShape=n.outShape;var f=t==="avg",m="0.0";if(f||(m="-1.0 / 1e-20"),e)this.userCode=`
        const ivec2 strides = ivec2(`+a+", "+s+`);
        const ivec2 pads = ivec2(`+h+", "+d+`);

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < `+u+`;
              wR += `+o+`) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= `+n.inHeight+`) {
              continue;
            }

            for (int wC = 0; wC < `+l+`;
                wC += `+i+`) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= `+n.inWidth+`) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value >= currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = wR * `+l+` + wC;
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;else{var v=t+"("+t+"("+t+"(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";t==="avg"&&(v="avgValue / count");var y=4*Math.floor(r/4),b=r%4,w=`
      if (`+f+`) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = max(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(`+a+", "+s+`);
      const ivec2 pads = ivec2(`+h+", "+d+`);
      const float initializationValue = `+m+`;
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= `+n.inWidth+`) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(`+m+`);
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < `+u+`;
            wR += `+o+`) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= `+n.inHeight+`) {
            continue;
          }

          for (int wC = 0; wC < `+y+`; wC += 4) {
            int xC = xCCorner + wC * `+i+`;

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + `+i+`, d),
              getValue(batch, xR, xC + 2 * `+i+`, d),
              getValue(batch, xR, xC + 3 * `+i+`, d)
            );

            `+w+`
          }

          int xC = xCCorner + `+y+`;
          if (`+(b===1)+`) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            `+w+`
          } else if (`+(b===2)+`) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + `+i+`, d),
              initializationValue,
              initializationValue
            );

            `+w+`
          } else if (`+(b===3)+`) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + `+i+`, d),
              getValue(batch, xR, xC + 2 * `+i+`, d),
              initializationValue
            );

            `+w+`
          }
        }
        setOutput(`+v+`);
      }
    `}},sC=function(n,t,e){if(this.variableNames=["x"],t==="avg"&&e)throw new Error("Cannot compute positions for average pool.");var r=n.filterWidth,a=n.strideDepth,s=n.strideHeight,o=n.strideWidth,i=n.dilationDepth,u=n.dilationHeight,l=n.dilationWidth,h=n.effectiveFilterDepth,d=n.effectiveFilterHeight,f=n.effectiveFilterWidth,m=n.padInfo.front,v=n.padInfo.top,y=n.padInfo.left;this.outputShape=n.outShape;var b=t==="avg",w="0.0";if(b||(w="-1.0 / 1e-20"),e)this.userCode=`
        const ivec3 strides =
            ivec3(`+a+", "+s+", "+o+`);
        const ivec3 pads = ivec3(`+m+", "+v+", "+y+`);

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < `+h+`;
              wD += `+i+`) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= `+n.inDepth+`) {
              continue;
            }

            for (int wR = 0; wR < `+d+`;
                wR += `+u+`) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= `+n.inHeight+`) {
                continue;
              }

              for (int wC = 0; wC < `+f+`;
                  wC += `+l+`) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= `+n.inWidth+`) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value >= currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition =
                      wD * `+d+" * "+f+` +
                      wR * `+f+` + wC;;
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;else{var S=t+"("+t+"("+t+"(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";t==="avg"&&(S="avgValue / count");var N=4*Math.floor(r/4),C=r%4,T=`
      if (`+b+`) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = max(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(`+a+", "+s+", "+o+`);
      const ivec3 pads = ivec3(`+m+", "+v+", "+y+`);
      const float initializationValue = `+w+`;
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= `+n.inWidth+`) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(`+w+`);
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < `+h+`;
            wD += `+i+`) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= `+n.inDepth+`) {
            continue;
          }

          for (int wR = 0; wR < `+d+`;
            wR += `+u+`) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= `+n.inHeight+`) {
              continue;
            }

            for (int wC = 0; wC < `+N+`; wC += 4) {
              int xC = xCCorner + wC * `+l+`;

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + `+l+`, ch),
                getValue(batch, xD, xR, xC + 2 * `+l+`, ch),
                getValue(batch, xD, xR, xC + 3 * `+l+`, ch)
              );

              `+T+`
            }

            int xC = xCCorner + `+N+`;
            if (`+(C===1)+`) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              `+T+`
            } else if (`+(C===2)+`) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + `+l+`, ch),
                initializationValue,
                initializationValue
              );

              `+T+`
            } else if (`+(C===3)+`) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + `+l+`, ch),
                getValue(batch, xD, xR, xC + 2 * `+l+`, ch),
                initializationValue
              );

              `+T+`
            }
          }
          setOutput(`+S+`);
        }
      }
    `}},yat=function(n,t){this.variableNames=["x"];var e=n.windowSize,r=n.batchSize,a=n.inSize,s=Math.ceil(a/e);this.outputShape=[r,s];var o="0.0",i="";t==="prod"?o="1.0":t==="min"?(o="1.0 / 1e-20",i="min"):t==="max"&&(o="-1.0 / 1e-20",i="max");var u=t+"("+t+"("+t+"(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";t==="sum"?u="sumValue":t==="prod"?u="prodValue":t==="all"?u="allValue":t==="any"&&(u="anyValue");var l=4*Math.floor(e/4),h=e%4,d=`
      if (`+(t==="sum")+`) {
        sumValue += dot(values, ones);
      } else if (`+(t==="prod")+`) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = `+i+`(values, minMaxValue);
      }
    `,f="vec4";t==="all"?(o="1.0",d=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,f="bvec4"):t==="any"&&(o="0.0",d=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,f="bvec4");var m="";a%e>0&&(m=`
        if (inIdx < 0 || inIdx >= `+a+`) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = `+o+`;
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        `+m+`
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * `+e+`;

        vec4 minMaxValue = vec4(`+o+`);
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < `+l+`; i += 4) {
          int inIdx = inOffset + i;
          `+f+" values = "+f+`(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          `+d+`
        }

        int inIdx = inOffset + `+l+`;
        if (`+(h===1)+`) {
          `+f+" values = "+f+`(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          `+d+`
        } else if (`+(h===2)+`) {
          `+f+" values = "+f+`(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          `+d+`
        } else if (`+(h===3)+`) {
          `+f+" values = "+f+`(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          `+d+`
        }
        setOutput(`+u+`);
      }
    `},bat=function(n,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n;for(var e="",r=0;r<4;r++){var a="thisRC = rc;";r%2==1&&(a+="thisRC.z += 1;"),r>1&&(a+="thisRC.y += 1;"),e+=`
        `+a+`
        `+(r>0?"if(thisRC.y < rows && thisRC.z < cols){":"")+`
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[`+r+`] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        `+(r>0?"}":"")+`
      `}this.userCode=`
      
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      `+Wl(["r","c","d"],t)+`
      return ivec3(r, c, d);
    }
  
      `+HE(n)+`

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = `+n[1]+`;
        int cols = `+n[2]+`;

        `+e+`

        setOutput(result);
      }
    `},xat=function(n,t,e){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t.shape;var r=t.shape,a=r[1],s=r[2],o=n.shape,i=o[1],u=o[2],l=[e&&i>1?a-1:a,e&&u>1?s-1:s],h=[e&&i>1?i-1:i,e&&u>1?u-1:u],d=l[0]/h[0],f=l[1]/h[1],m=1/d,v=1/f,y=2*Math.ceil(m)+2,b=2*Math.ceil(v)+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(`+d+`);
        const float widthScale = float(`+f+`);

        const float invHeightScale = float(`+m+`);
        const float invWidthScale = float(`+v+`);

        const int winHeight = int(`+y+`);
        const int winWidth = int(`+b+`);

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= `+i+`) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= `+u+`) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), `+(a-1)+`.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), `+(s-1)+`.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `},wat=function(n,t,e,r){this.variableNames=["A"],this.outputShape=[];var a=n[0],s=n[1],o=n[2],i=n[3];this.outputShape=[a,t,e,i];var u=[r&&t>1?s-1:s,r&&e>1?o-1:o],l=[r&&t>1?t-1:t,r&&e>1?e-1:e];this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          `+u[0]/l[0]+`,
          `+u[1]/l[1]+`);
      const vec2 inputShapeRC = vec2(`+s+".0, "+o+`.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(sourceFracIndexRC);
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `},Sat=function(n,t,e,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];var a=n[0],s=n[1],o=n[2],i=n[3];this.outputShape=[a,t,e,i];var u=[r&&t>1?s-1:s,r&&e>1?o-1:o],l=[r&&t>1?t-1:t,r&&e>1?e-1:e];this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          `+u[0]/l[0]+`,
          `+u[1]/l[1]+`,
          `+u[1]/l[1]+`);
      const vec3 inputShapeRC = vec3(`+s+".0, "+o+`.0,
                                     `+o+`.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = vec3(yRC) * effectiveInputOverOutputRatioRC;

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(sourceFracIndexRC);
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < `+(i-1)+`;
        bool hasNextRow = coords.z < `+(e-1)+`;

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `},Cat=function(n,t,e){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t.shape;var r=t.shape,a=r[1],s=r[2],o=n.shape,i=o[1],u=o[2],l=[e&&i>1?a-1:a,e&&u>1?s-1:s],h=[e&&i>1?i-1:i,e&&u>1?u-1:u],d=l[0]/h[0],f=l[1]/h[1],m=1/d,v=1/f,y=2*Math.ceil(m)+2,b=2*Math.ceil(v)+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(`+d+`);
        const float widthScale = float(`+f+`);

        const float invHeightScale = float(`+m+`);
        const float invWidthScale = float(`+v+`);

        const int winHeight = int(`+y+`);
        const int winWidth = int(`+b+`);

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= `+i+`) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= `+u+`) {
              continue;
            }

            float sourceFracRow =
              float(`+l[0]+`) *
                (float(dyR) / float(`+h[0]+`));

            float sourceFracCol =
                float(`+l[1]+`) *
                  (float(dyC) / float(`+h[1]+`));

            int sourceNearestRow = int(min(
                float(int(`+a+`) - 1),
                `+e+` ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(`+s+`) - 1),
                `+e+` ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `},Nat=function(n,t,e,r){this.variableNames=["A"],this.outputShape=[];var a=n[0],s=n[1],o=n[2],i=n[3];this.outputShape=[a,t,e,i];var u=[r&&t>1?s-1:s,r&&e>1?o-1:o],l=[r&&t>1?t-1:t,r&&e>1?e-1:e],h=r?"0.5":"0.0";this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          `+u[0]/l[0]+`,
          `+u[1]/l[1]+`);
      const vec2 inputShapeRC = vec2(`+s+".0, "+o+`.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + `+h+`)));

        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `},kat=function(n,t){this.variableNames=["x"];var e=n.length;if(e>4)throw new Error("WebGL backend: Reverse of rank-"+e+" tensor is not yet supported");if(this.outputShape=n,e!==1){var r=n.map((function(s,o){return(function(i){return t.indexOf(i)!==-1&&n[i]!==1?n[i]+" - coords["+i+"] - 1":"coords["+i+"]"})(o)})).join(","),a=yn(e);this.userCode=`
      void main() {
        `+a+` coords = getOutputCoords();
        setOutput(getX(`+r+`));
      }
    `}else this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(`+n[0]+` - coord - 1));
        }
      `},Tat=function(n,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;var e=n.length;if(e>4)throw new Error("WebGL backend: Reverse of rank-"+e+" tensor is not yet supported");this.outputShape=n;var r=za("rc",e),a=r[e-1]+" + 1 < "+this.outputShape[e-1],s=r[e-2]+" + 1 < "+this.outputShape[e-2],o=yn(e);function i(u){var l=n.map((function(h,d){return(function(f,m){return t.indexOf(f)!==-1&&n[f]!==1?n[f]+" - "+m[f]+" - 1":""+m[f]})(d,u)}));return"getChannel(getX("+l.join(",")+"), vec2("+l.slice(-2).join(",")+"))"}this.userCode=e===1?`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(`+n[0]+` - rc - 1),
            `+n[0]+` - rc - 1);
          if(`+a+`){
              result.g = getChannel(getX(`+n[0]+` - (rc  + 1) - 1),
                `+n[0]+` - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:`
        void main() {
          `+o+` rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = `+(function(u){return i(u)})(r.slice())+`;
          if(`+a+`){
            result.g = `+(function(u){return u[e-1]="("+u[e-1]+" + 1)",i(u)})(r.slice())+`;
          }
          if(`+s+`) {
            result.b = `+(function(u){return u[e-2]="("+u[e-2]+" + 1)",i(u)})(r.slice())+`;
            if(`+a+`) {
              result.a = `+(function(u){return u[e-1]="("+u[e-1]+" + 1)",u[e-2]="("+u[e-2]+" + 1)",i(u)})(r.slice())+`;
            }
          }
          setOutput(result);
        }
    `},g3=function(n,t,e,r,a,s,o){this.variableNames=["updates","indices","defaultValue"],this.outputShape=s;var i=yn(a.length),u=yn(s.length),l="";e===1?l="i":e===2&&(l="i, j");var h="getIndices("+l+")",d="";r===1?d="i":r===2&&(d="i, coords[1]");var f="getUpdates("+d+")",m=t>1?"strides[j]":"strides";this.userCode=`
        `+i+" strides = "+i+"("+a+`);

        void main() {
          `+u+` coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < `+n+`; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < `+t+`; j++) {
              int index = round(`+h+`);
              flattenedIndex += index * `+m+`;
            }
            if (flattenedIndex == coords[0]) {
              sum += `+f+`;
              found = true;
            }
          }
          setOutput(mix(getDefaultValue(), sum, float(found)));
        }
      `},Eat=function(n,t){this.variableNames=["x","segmentIds"];var e=n.windowSize,r=n.batchSize,a=n.inSize,s=n.numSegments,o=s*Math.ceil(a/e);this.outputShape=[r,o];var i=4*Math.floor(e/4),u=e%4,l=`
        sumValue += dot(values, segFilter);
    `,h="";a%e>0&&(h=`
        if (inIdx < 0 || inIdx >= `+a+`) {
          return initializationValue;
        }
      `);var d="";a%e>0&&(d=`
        if (inIdx < 0 || inIdx >= `+a+`) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = 0.0;

      float getValue(int batch, int inIdx) {
        `+h+`
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        `+d+`
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          `+s+")) * float("+e+`));
        int currentSeg = int(mod(float(outIdx), float(`+s+`)));

        float sumValue = 0.0;

        for (int i = 0; i < `+i+`; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          `+l+`
        }

        int inIdx = inOffset + `+i+`;
        if (`+(u===1)+`) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          `+l+`
        } else if (`+(u===2)+`) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          `+l+`
        } else if (`+(u===3)+`) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          `+l+`
        }
        setOutput(sumValue);
      }
    `},Iat=function(n,t,e){var r,a;if(this.variableNames=["c","a","b"],this.outputShape=t,e>4)throw Error("Where for rank "+e+" is not yet supported");if(e===1)a="resRC",r="resRC";else{for(var s=["resRC.x","resRC.y","resRC.z","resRC.w"],o=[],i=[],u=0;u<t.length;u++)i.push(""+s[u]),u<n&&o.push(""+s[u]);r=o.join(),a=i.join()}var l=yn(e);this.userCode=`
      void main() {
        `+l+` resRC = getOutputCoords();
        float cVal = getC(`+r+`);
        if (cVal >= 1.0) {
          setOutput(getA(`+a+`));
        } else {
          setOutput(getB(`+a+`));
        }
      }
    `},_at=(function(){function n(t){this.variableNames=["source"],this.outputShape=t,this.rank=t.length;var e,r=yn(this.rank),a="uniform int start["+this.rank+"];",s=(function(o){if(o===1)return"sourceLoc";if(o<=6)return oC.slice(0,o).map((function(i){return"sourceLoc."+i})).join(",");throw Error("Slicing for rank "+o+" is not yet supported")})(this.rank);e=`
        `+r+` sourceLoc;
        `+r+` coords = getOutputCoords();
        `+t.map((function(o,i){return"sourceLoc."+oC[i]+" = start["+i+"] + coords."+oC[i]+";"})).join(`
`)+`
      `,this.userCode=`
      `+a+`
      void main() {
        `+e+`
        setOutput(getSource(`+s+`));
      }
    `}return n.prototype.getCustomSetupFunc=function(t){var e=this;if(t.length!==this.rank)throw Error("The rank ("+this.rank+") of the program must match the length of start ("+t.length+")");return function(r,a){e.startLoc==null&&(e.startLoc=r.getUniformLocationNoThrow(a,"start"),e.startLoc==null)||r.gl.uniform1iv(e.startLoc,t)}},n})(),oC=["x","y","z","w","u","v"],Rat=(function(){function n(t){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.rank=t.length;var e=yn(this.rank),r=za("coords",this.rank),a=za("sourceLoc",this.rank),s=this.rank===1?"sourceLoc":"vec2("+a.slice(-2).join()+")",o="getChannel(getSource("+a.join()+"), "+s+")",i=`
      result.x = `+o+`;
      if (++`+r[this.rank-1]+" < "+t[this.rank-1]+`) {
        ++`+a[this.rank-1]+`;
        result.y = `+o+`;
        --`+a[this.rank-1]+`;
      }
    `,u=this.rank===1?"":`
      --`+r[this.rank-1]+`;
      if (++`+r[this.rank-2]+" < "+t[this.rank-2]+`) {
        ++`+a[this.rank-2]+`;
        result.z = `+o+`;
        if (++`+r[this.rank-1]+" < "+t[this.rank-1]+`) {
          ++`+a[this.rank-1]+`;
          result.w = `+o+`;
        }
      }
    `,l=this.rank<=4?`sourceLoc = coords +
            `+e+"("+t.map((function(h,d){return"start["+d+"]"})).join()+");":t.map((function(h,d){return a[d]+" = "+r[d]+" + start["+d+"];"})).join(`
`);this.userCode=`
      uniform int start[`+this.rank+`];
      void main() {
        `+e+` coords = getOutputCoords();
        `+e+` sourceLoc;
        `+l+`
        vec4 result = vec4(0.);
        `+i+`
        `+u+`
        setOutput(result);
      }
    `}return n.prototype.getCustomSetupFunc=function(t){var e=this;if(t.length!==this.rank)throw Error("The rank ("+this.rank+") of the program must match the length of start ("+t.length+")");return function(r,a){e.startLoc==null&&(e.startLoc=r.getUniformLocationNoThrow(a,"start"),e.startLoc==null)||r.gl.uniform1iv(e.startLoc,t)}},n})(),Aat=function(n,t,e){this.variableNames=["x"],this.outputShape=e;var r=e.length,a=yn(e.length),s=yn(e.length),o="";if(r===1)o="coords * strides + begin";else{var i=0;o=e.map((function(u,l){return i++,e.length===1?"coords * strides["+l+"] + begin["+l+"]":"coords["+(i-1)+"] * strides["+l+"] + begin["+l+"]"})).join(",")}this.userCode=`
      `+a+" begin = "+a+"("+n+`);
      `+a+" strides = "+a+"("+t+`);

      void main() {
        `+s+` coords = getOutputCoords();
        setOutput(getX(`+o+`));
      }
    `},Dat=(function(){function n(t){this.gpgpu=t,this.numUsedTextures=0,this.numFreeTextures=0,this.freeTextures={},this.logEnabled=!1,this.usedTextures={}}return n.prototype.acquireTexture=function(t,e,r){var a,s=v3(e,r),o=y3(t,s,r);if(o in this.freeTextures||(this.freeTextures[o]=[]),o in this.usedTextures||(this.usedTextures[o]=[]),this.freeTextures[o].length>0){this.numFreeTextures--,this.numUsedTextures++,this.log();var i=this.freeTextures[o].shift();return this.usedTextures[o].push(i),i}return this.numUsedTextures++,this.log(),s===os.PACKED_2X2_FLOAT32?a=this.gpgpu.createPackedMatrixTexture(t[0],t[1]):s===os.PACKED_2X2_FLOAT16?a=this.gpgpu.createFloat16PackedMatrixTexture(t[0],t[1]):s===os.UNPACKED_FLOAT32?a=this.gpgpu.createFloat32MatrixTexture(t[0],t[1]):s===os.UNPACKED_FLOAT16?a=this.gpgpu.createFloat16MatrixTexture(t[0],t[1]):s===os.PACKED_4X1_UNSIGNED_BYTE&&(a=this.gpgpu.createUnsignedBytesMatrixTexture(t[0],t[1])),this.usedTextures[o].push(a),a},n.prototype.releaseTexture=function(t,e,r,a){if(this.freeTextures!=null){var s=y3(e,v3(r,a),a);s in this.freeTextures||(this.freeTextures[s]=[]),this.freeTextures[s].push(t),this.numFreeTextures++,this.numUsedTextures--;var o=this.usedTextures[s],i=o.indexOf(t);if(i<0)throw new Error("Cannot release a texture that was never provided by this texture manager");o.splice(i,1),this.log()}},n.prototype.log=function(){if(this.logEnabled){var t=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",this.numFreeTextures+" / "+this.numUsedTextures,"("+t+")")}},n.prototype.getNumUsedTextures=function(){return this.numUsedTextures},n.prototype.getNumFreeTextures=function(){return this.numFreeTextures},n.prototype.dispose=function(){var t=this;if(this.freeTextures!=null){for(var e in this.freeTextures)this.freeTextures[e].forEach((function(r){t.gpgpu.deleteMatrixTexture(r)}));for(var e in this.usedTextures)this.usedTextures[e].forEach((function(a){t.gpgpu.deleteMatrixTexture(a)}));this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0}},n})();function v3(n,t){if(n===cs.UPLOAD)return os.PACKED_2X2_FLOAT32;if(n===cs.RENDER||n==null)return(function(e){return kt().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?e?os.PACKED_2X2_FLOAT32:os.UNPACKED_FLOAT32:e?os.PACKED_2X2_FLOAT16:os.UNPACKED_FLOAT16})(t);if(n===cs.DOWNLOAD||n===cs.PIXELS)return os.PACKED_4X1_UNSIGNED_BYTE;throw new Error("Unknown logical texture type "+n)}function y3(n,t,e){return n[0]+"_"+n[1]+"_"+t+"_"+e}var $at=function(n,t){this.variableNames=["A"];for(var e=new Array(n.length),r=0;r<e.length;r++)e[r]=n[r]*t[r];this.outputShape=e,this.rank=e.length;var a=yn(this.rank),s=(function(o){var i=o.length;if(i>5)throw Error("Tile for rank "+i+" is not yet supported");if(i===1)return"imod(resRC, "+o[0]+")";for(var u=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],l=[],h=0;h<o.length;h++)l.push("imod("+u[h]+", "+o[h]+")");return l.join()})(n);this.userCode=`
      void main() {
        `+a+` resRC = getOutputCoords();
        setOutput(getA(`+s+`));
      }
    `},Oat=function(n,t){this.variableNames=["A"];for(var e=new Array(n.length),r=0;r<e.length;r++)e[r]=n[t[r]];this.outputShape=e,this.rank=e.length;var a=yn(this.rank),s=(function(o){var i=o.length;if(i>6)throw Error("Transpose for rank "+i+" is not yet supported");for(var u=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],l=new Array(i),h=0;h<o.length;h++)l[o[h]]=u[h];return l.join()})(t);this.userCode=`
    void main() {
      `+a+` resRC = getOutputCoords();
      setOutput(getA(`+s+`));
    }
    `},Fat=function(n,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;for(var e=new Array(n.length),r=0;r<e.length;r++)e[r]=n[t[r]];if(this.outputShape=e,this.rank=e.length,this.rank>6)throw Error("Packed transpose for rank "+this.rank+" is not yet supported.");var a=yn(this.rank),s=hz("rc",this.rank),o=new Array(this.rank);for(r=0;r<t.length;r++)o[t[r]]=s[r];var i="vec2("+o.slice(-2).join()+")",u="++"+s[this.rank-1]+" < "+e[this.rank-1],l="getChannel(getA("+o.join()+"), "+i+")";this.userCode=`
    void main() {
      `+a+` rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = `+l+`;
      if(`+u+`) {
        result[1] = `+l+`;
      }
      --`+s[this.rank-1]+`;
      if(++`+s[this.rank-2]+" < "+e[this.rank-2]+`) {
        result[2] = `+l+`;
        if(`+u+`) {
          result[3] = `+l+`;
        }
      }
      setOutput(result);
    }
    `},jE=1.7580993408473768,qE=1.0507009873554805,Ee=function(n,t){this.variableNames=["A"],this.outputShape=n,this.userCode=`
      float unaryOperation(float x) {
        `+t+`
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `},ho="if (isnan(x)) return x;",Mat="return x;",b3="return abs(x);",gz=ho+`
  return (x < 0.0) ? 0.0 : x;
`,vz=ho+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,yz="return (x >= 0.0) ? x : (exp(x) - 1.0);",Lat=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = `+jE+`;
  float scale = `+qE+`;
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,x3="return -x;",w3="return ceil(x);",S3="return floor(x);",C3="return exp(x);",N3="return exp(x) - 1.0;",Bat=ho+`
  return sin(x);
`,zat=ho+`
  return cos(x);
`,Pat=ho+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,Vat=ho+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,Uat=ho+`
  return atan(x);
`,Wat=ho+"return log(x + sqrt(x * x + 1.0));",Gat=ho+`
  if (x < 1.0) return NAN;
  return log(x + sqrt(x * x - 1.0));`,Hat=ho+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
  return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,Yy="return x;",jat="return x;",bz=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,xz=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,wz=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,Ef=function(n,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.userCode=`
      vec4 unaryOperation(vec4 x) {
        `+t+`
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `},qat=function(n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=n;var t=n.length,e=za("rc",t),r=yn(t),a=(function(i,u){if(i===1)return"rc";for(var l="",h=0;h<i;h++)l+=u[h],h<i-1&&(l+=",");return l})(t,e),s=e.slice(-2),o=t<=1?"rc":"vec2("+s.join(",")+")";this.userCode=`
      void main() {
        `+r+` rc = getOutputCoords();
        vec4 packedInput = getA(`+a+`);

        setOutput(getChannel(packedInput, `+o+`));
      }
    `},Qy={};function Zy(n,t){if(t===void 0&&(t=!1),n==="linear")return t?jat:Mat;if(n==="relu")return t?bz:gz;if(n==="elu")return t?wz:yz;if(n==="relu6")return t?xz:vz;if(n==="prelu")return t?mz:fz;throw new Error("Activation "+n+" has not been implemented for the WebGL backend.")}var Kat=600,Xat=(function(n){function t(e){var r,a=n.call(this)||this;if(a.pendingRead=new WeakMap,a.pendingDisposal=new WeakSet,a.dataRefCount=new WeakMap,a.numBytesInGPU=0,a.uploadWaitMs=0,a.downloadWaitMs=0,a.warnedAboutMemory=!1,a.pendingDeletes=0,a.disposed=!1,!kt().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");if(e==null){var s=Xo(kt().getNumber("WEBGL_VERSION"));a.binaryCache=((r=kt().getNumber("WEBGL_VERSION"))in Qy||(Qy[r]={}),Qy[r]),a.gpgpu=new oat(s),a.canvas=s.canvas,a.gpgpuCreatedLocally=!0}else a.gpgpu=e,a.binaryCache={},a.gpgpuCreatedLocally=!1,a.canvas=e.gl.canvas;return a.textureManager=new Dat(a.gpgpu),a.numMBBeforeWarning=kt().global.screen==null?1024:kt().global.screen.height*kt().global.screen.width*window.devicePixelRatio*Kat/1024/1024,a.texData=new nz(a,lt),a}return co(t,n),t.prototype.numDataIds=function(){return this.texData.numDataIds()+(this.cpuBackend?this.cpuBackend.numDataIds():0)-this.pendingDeletes},t.prototype.write=function(e,r,a){if(kt().getBool("DEBUG")&&this.checkNumericalProblems(e),a==="complex64"&&e!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");var s={};return this.texData.set(s,{shape:r,dtype:a,values:e,usage:cs.UPLOAD}),s},t.prototype.move=function(e,r,a,s){if(kt().getBool("DEBUG")&&this.checkNumericalProblems(r),s==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:a,dtype:s,values:r,usage:cs.UPLOAD})},t.prototype.readSync=function(e){var r=this.texData.get(e),a=r.values,s=r.dtype,o=r.complexTensors,i=r.slice,u=r.shape,l=r.isPacked;if(i!=null){var h=void 0;h=l?new Ef(u,Yy):new Ee(u,Yy);var d=this.runWebGLProgram(h,[{dataId:e,shape:u,dtype:s}],s),f=this.readSync(d.dataId);return this.disposeData(d.dataId),f}if(a!=null)return this.convertAndCacheOnCPU(e);if(s==="string")return a;var m,v,y=this.activeTimers!=null;return y&&(m=So()),s==="complex64"?v=KN(o.real.dataSync(),o.imag.dataSync()):v=this.getValuesFromTexture(e),y&&(this.downloadWaitMs+=So()-m),this.convertAndCacheOnCPU(e,v)},t.prototype.read=function(e){return Yt(this,void 0,void 0,(function(){var r,a,s,o,i,u,l,h,d,f,m,v,y,b,w,S,N,C,T,I,_,$;return Qt(this,(function(R){switch(R.label){case 0:if(this.pendingRead.has(e))return r=this.pendingRead.get(e),[2,new Promise((function(D){return r.push(D)}))];if(a=this.texData.get(e),s=a.values,o=a.shape,i=a.slice,u=a.dtype,l=a.complexTensors,h=a.isPacked,i!=null)return d=void 0,d=h?new Ef(o,Yy):new Ee(o,Yy),f=this.runWebGLProgram(d,[{dataId:e,shape:o,dtype:u}],u),m=this.read(f.dataId),this.disposeData(f.dataId),[2,m];if(s!=null)return[2,this.convertAndCacheOnCPU(e)];if(!kt().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&kt().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");return v=null,u!=="complex64"&&kt().get("WEBGL_BUFFER_SUPPORTED")&&(y=this.decode(e),b=this.texData.get(y.dataId),v=($=this.gpgpu).createBufferFromTexture.apply($,[b.texture].concat(Pf(o)))),this.pendingRead.set(e,[]),u==="complex64"?[3,2]:[4,this.gpgpu.createAndWaitForFence()];case 1:R.sent(),R.label=2;case 2:return u!=="complex64"?[3,4]:[4,Promise.all([l.real.data(),l.imag.data()])];case 3:return S=R.sent(),N=S[0],C=S[1],w=KN(N,C),[3,5];case 4:v==null?w=this.getValuesFromTexture(e):(T=ee(o),w=this.gpgpu.downloadFloat32MatrixFromBuffer(v,T)),R.label=5;case 5:return y!=null&&this.disposeData(y.dataId),I=this.convertAndCacheOnCPU(e,w),_=this.pendingRead.get(e),this.pendingRead.delete(e),_.forEach((function(D){return D(I)})),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e),this.pendingDeletes--),[2,I]}}))}))},t.prototype.checkNumericalProblems=function(e){if(e!=null)for(var r=0;r<e.length;r++){var a=e[r];if(!Let(a))throw kt().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error("The value "+a+" cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'"):Error("The value "+a+" cannot be represented on this device.")}},t.prototype.getValuesFromTexture=function(e){var r,a=this.texData.get(e),s=a.shape,o=a.dtype,i=a.isPacked,u=ee(s);if(kt().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){var l=this.decode(e),h=this.texData.get(l.dataId),d=(r=this.gpgpu).downloadMatrixFromPackedTexture.apply(r,[h.texture].concat(Pf(s))).subarray(0,u);return this.disposeData(l.dataId),d}var f=kt().getBool("WEBGL_PACK")&&i===!0,m=f?JS(s):s,v=f?new Mrt(m):new Frt(m),y=this.runWebGLProgram(v,[{shape:m,dtype:o,dataId:e}],"float32"),b=this.texData.get(y.dataId),w=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(b.texture,b.texShape[0],b.texShape[1]).subarray(0,u);return this.disposeData(y.dataId),w},t.prototype.time=function(e){return Yt(this,void 0,void 0,(function(){var r,a,s,o,i,u,l;return Qt(this,(function(h){switch(h.label){case 0:return r=this.activeTimers,a=[],s=!1,this.programTimersStack==null?(this.programTimersStack=a,s=!0):this.activeTimers.push(a),this.activeTimers=a,e(),o=ed(this.activeTimers.map((function(d){return d.query}))).filter((function(d){return d!=null})),i=ed(this.activeTimers.map((function(d){return d.name}))).filter((function(d){return d!=null})),this.activeTimers=r,s&&(this.programTimersStack=null),u={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null},kt().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?[4,Promise.all(o)]:[3,2];case 1:return l=h.sent(),u.kernelMs=get(l),u.getExtraProfileInfo=function(){return l.map((function(d,f){return{name:i[f],ms:d}})).map((function(d){return d.name+": "+d.ms})).join(", ")},[3,3];case 2:u.kernelMs={error:"WebGL query timers are not supported in this environment."},h.label=3;case 3:return this.uploadWaitMs=0,this.downloadWaitMs=0,[2,u]}}))}))},t.prototype.memory=function(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU}},t.prototype.startTimer=function(){return kt().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:So(),endMs:null}},t.prototype.endTimer=function(e){return kt().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=So(),e)},t.prototype.getQueryTime=function(e){return Yt(this,void 0,void 0,(function(){var r;return Qt(this,(function(a){return kt().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?[2,this.gpgpu.waitForQueryAndGetTime(e)]:[2,(r=e).endMs-r.startMs]}))}))},t.prototype.disposeData=function(e){if(!this.pendingDisposal.has(e)){if(this.pendingRead.has(e))return this.pendingDisposal.add(e),void this.pendingDeletes++;if(this.texData.has(e)){this.releaseGPUData(e);var r=this.texData.get(e).complexTensors;r!=null&&(r.real.dispose(),r.imag.dispose()),this.texData.delete(e)}}},t.prototype.releaseGPUData=function(e){var r=this.texData.get(e),a=r.texture,s=r.dtype,o=r.texShape,i=r.usage,u=r.isPacked,l=r.slice,h=l&&l.origDataId||e,d=this.dataRefCount.get(h);d>1?this.dataRefCount.set(h,d-1):(this.dataRefCount.delete(h),a!=null&&(this.numBytesInGPU-=this.computeBytes(o,s),this.textureManager.releaseTexture(a,o,i,u)));var f=this.texData.get(e);f.texture=null,f.texShape=null,f.isPacked=!1,f.slice=null},t.prototype.getTexture=function(e){return this.uploadToGPU(e),this.texData.get(e).texture},t.prototype.getDataInfo=function(e){return this.texData.get(e)},t.prototype.getCPUBackend=function(){return kt().getBool("WEBGL_CPU_FORWARD")?(this.cpuBackend==null&&(this.cpuBackend=lt.findBackend("cpu")),this.cpuBackend):null},t.prototype.shouldExecuteOnCPU=function(e,r){var a=this;return r===void 0&&(r=128),this.getCPUBackend()!=null&&e.every((function(s){return a.texData.get(s.dataId).texture==null&&s.size<r}))},t.prototype.getGPGPUContext=function(){return this.gpgpu},t.prototype.complex=function(e,r){var a=this.makeOutput(e.shape,"complex64");return this.texData.get(a.dataId).complexTensors={real:lt.keep(e.clone()),imag:lt.keep(r.clone())},a},t.prototype.real=function(e){return this.texData.get(e.dataId).complexTensors.real.clone()},t.prototype.imag=function(e){return this.texData.get(e.dataId).complexTensors.imag.clone()},t.prototype.slice=function(e,r,a){if(this.shouldExecuteOnCPU([e]))return this.cpuBackend.slice(e,r,a);if(ee(a)===0)return Zr([],a,e.dtype);var s=this.texData.get(e.dataId).isPacked,o=tz(e.shape,r,a);if(s||!o){var i=kt().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Rat(a):new _at(a),u=i.getCustomSetupFunc(r);return this.compileAndRun(i,[e],null,u)}return this.uploadToGPU(e.dataId),this.shallowSlice(e,r,a)},t.prototype.shallowSlice=function(e,r,a){var s=this.texData.get(e.dataId),o=this.makeOutput(a,e.dtype),i=this.texData.get(o.dataId);Object.assign(i,s),i.shape=a,i.dtype=e.dtype;var u=ez(r,e.strides);s.slice&&(u+=s.slice.flatOffset),i.slice={flatOffset:u,origDataId:s.slice&&s.slice.origDataId||e.dataId};var l=this.dataRefCount.get(i.slice.origDataId)||1;return this.dataRefCount.set(i.slice.origDataId,l+1),o},t.prototype.stridedSlice=function(e,r,a,s){if(this.shouldExecuteOnCPU([e]))return this.cpuBackend.stridedSlice(e,r,a,s);var o=PE(r,a,s);if(o.some((function(u){return u===0})))return Zr([],o);var i=new Aat(r,s,o);return this.compileAndRun(i,[e])},t.prototype.reverse=function(e,r){var a=kt().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Tat(e.shape,r):new kat(e.shape,r);return this.compileAndRun(a,[e])},t.prototype.concat=function(e,r){if(e[0].dtype==="complex64"){var a=e.map((function(m){return Ls(m)})),s=e.map((function(m){return Eo(m)}));return Yr(this.concat(a,r),this.concat(s,r))}if(this.shouldExecuteOnCPU(e))return this.cpuBackend.concat(e,r);if(e.length===1)return e[0];if(e.length>kt().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){var o=Math.floor(e.length/2),i=this.concat(e.slice(0,o),r),u=this.concat(e.slice(o),r);return this.concat([i,u],r)}if(kt().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&e[0].rank>1){var l=new wrt(e.map((function(m){return m.shape})),r);return this.compileAndRun(l,e)}var h=rd(e.map((function(m){return m.shape})),r),d=e.map((function(m){return m.as2D(-1,ee(m.shape.slice(r)))})),f=new xrt(d.map((function(m){return m.shape})));return this.compileAndRun(f,d).reshape(h)},t.prototype.neg=function(e){if(this.shouldExecuteOnCPU([e]))return this.cpuBackend.neg(e);if(kt().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,x3,e.dtype);var r=new Ee(e.shape,x3);return this.compileAndRun(r,[e])},t.prototype.batchMatMul=function(e,r,a,s){var o=a?e.shape[2]:e.shape[1],i=s?r.shape[1]:r.shape[2],u=a?e.shape[1]:e.shape[2],l=e.shape[0];if((o===1||i===1)&&u>1e3){a&&(e=e.transpose([0,2,1])),s&&(r=r.transpose([0,2,1]));var h=i===1?e:e.as3D(l,u,1),d=i===1?2:1,f=i===1?r.as3D(l,1,u):r;return this.multiply(h,f).sum(d,!0)}var m=Qr(e.dtype,r.dtype),v=new rC(e.shape,[l,o,i],a,s);return this.compileAndRun(v,[e,r],m)},t.prototype.fusedBatchMatMul=function(e){var r=e.a,a=e.b,s=e.transposeA,o=e.transposeB,i=e.bias,u=e.activation,l=e.preluActivationWeights,h=s?r.shape[2]:r.shape[1],d=o?a.shape[1]:a.shape[2],f=r.shape[0],m=Qr(r.dtype,a.dtype),v=i!=null,y=l!=null,b=u?Zy(u,!0):null,w=new rC(r.shape,[f,h,d],s,o,v,b,y),S=[r,a];return i&&S.push(i),l&&S.push(l),this.compileAndRun(w,S,m)},t.prototype.multiply=function(e,r){if(e.dtype==="complex64"){var a=this.texData.get(e.dataId),s=this.texData.get(r.dataId),o=new u3(mrt,e.shape,r.shape),i=new u3(grt,e.shape,r.shape),u=[this.makeComplexComponentTensorInfo(e,a.complexTensors.real),this.makeComplexComponentTensorInfo(e,a.complexTensors.imag),this.makeComplexComponentTensorInfo(r,s.complexTensors.real),this.makeComplexComponentTensorInfo(r,s.complexTensors.imag)],l=this.compileAndRun(o,u),h=this.compileAndRun(i,u),d=this.complex(l,h);return l.dispose(),h.dispose(),d}if(this.shouldExecuteOnCPU([e,r]))return this.cpuBackend.multiply(e,r);if(kt().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(e,r,l3,e.dtype);var f=new zn(l3,e.shape,r.shape);return this.compileAndRun(f,[e,r],e.dtype)},t.prototype.batchNormalization=function(e,r,a,s,o,i){var u=[e,r,a],l=null;i!=null&&(l=i.shape,u.push(i));var h=null;if(o!=null&&(h=o.shape,u.push(o)),kt().getBool("WEBGL_PACK_NORMALIZATION")){var d=new frt(e.shape,r.shape,a.shape,l,h,s);return this.compileAndRun(d,u)}var f=new prt(e.shape,r.shape,a.shape,l,h,s);return this.compileAndRun(f,u)},t.prototype.localResponseNormalization4D=function(e,r,a,s,o){var i=kt().getBool("WEBGL_PACK_NORMALIZATION")?new cat(e.shape,r,a,s,o):new uat(e.shape,r,a,s,o);return this.compileAndRun(i,[e])},t.prototype.LRNGrad=function(e,r,a,s,o,i,u){var l=new lat(r.shape,s,o,i,u);return this.compileAndRun(l,[r,a,e])},t.prototype.tile=function(e,r){if(e.dtype==="string"){var a=this.readSync(e.dataId).map((function(o){return q0(o)}));return lz(be(e.shape,e.dtype,a),r)}var s=new $at(e.shape,r);return this.compileAndRun(s,[e])},t.prototype.pad=function(e,r,a){var s=kt().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new vat(e.shape,r,a):new gat(e.shape,r,a);return this.compileAndRun(s,[e])},t.prototype.transpose=function(e,r){if(this.shouldExecuteOnCPU([e]))return this.cpuBackend.transpose(e,r);var a=kt().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Fat(e.shape,r):new Oat(e.shape,r);return this.compileAndRun(a,[e])},t.prototype.gather=function(e,r,a){if(this.shouldExecuteOnCPU([e,r]))return this.cpuBackend.gather(e,r,a);var s=new Urt(e.shape,r.size,a);return this.compileAndRun(s,[e,r])},t.prototype.batchToSpaceND=function(e,r,a){Z(e.rank<=4,(function(){return"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet"}));var s=r.reduce((function(d,f){return d*f})),o=J0(e.shape,r,s),i=tb(o.length,r.length),u=eb(e.shape,r,s),l=YB(a,r.length),h=QB(u,a,r.length);return e.reshape(o).transpose(i).reshape(u).slice(l,h)},t.prototype.spaceToBatchND=function(e,r,a){Z(e.rank<=4,(function(){return"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet"}));var s=r.reduce((function(f,m){return f*m})),o=[[0,0]];o.push.apply(o,a);for(var i=1+r.length;i<e.shape.length;++i)o.push([0,0]);var u=e.pad(o),l=J0(u.shape,r,s,!1),h=tb(l.length,r.length,!1),d=eb(u.shape,r,s,!1);return u.reshape(l).transpose(h).reshape(d)},t.prototype.reduce=function(e,r,a){var s=e.shape[0],o=e.shape[1],i=tC(o),u=new yat({windowSize:i,inSize:o,batchSize:s},r),l=this.compileAndRun(u,[e],a);return l.shape[1]===1?l:this.reduce(l,r,a)},t.prototype.argReduce=function(e,r,a){a===void 0&&(a=null);var s=e.shape[0],o=e.shape[1];a!=null&&(s=a.shape[0],o=a.shape[1]);var i=tC(o),u=new art({windowSize:i,inSize:o,batchSize:s},r,a==null),l=[e];a!=null&&l.push(a);var h=this.compileAndRun(u,l,"int32");return h.shape[1]===1?h:this.argReduce(e,r,h)},t.prototype.argReducePacked=function(e,r,a){a===void 0&&(a=null);var s=a!=null?a.shape:e.shape,o=tC(s[s.length-1]),i=new crt(s,o,r,a==null),u=a==null?[e]:[e,a],l=this.compileAndRun(i,u,"int32");return l.rank===e.rank?this.argReducePacked(e,r,l):l},t.prototype.sum=function(e,r){ss("sum",r,e.rank);var a=na(e.shape,r),s=a[0],o=ee(a[1]),i=e.as2D(-1,o),u=jS(e.dtype);return this.reduce(i,"sum",u).reshape(s)},t.prototype.prod=function(e,r){if(this.shouldExecuteOnCPU([e]))return this.cpuBackend.prod(e,r);var a=na(e.shape,r),s=a[0],o=ee(a[1]),i=e.as2D(-1,o),u=jS(e.dtype);return this.reduce(i,"prod",u).reshape(s)},t.prototype.unsortedSegmentSum=function(e,r,a){var s=0,o=Yo([s],e.rank),i=e;o!=null&&(i=e.transpose(o),s=Qo(1,e.rank)[0]);var u=(function(m,v,y){for(var b=[],w=m.length,S=0;S<w;S++)S!==v?b.push(m[S]):b.push(y);return b})(i.shape,s,a),l=ee([i.shape[s]]),h=i.as2D(-1,l),d=jS(e.dtype),f=this.segOpCompute(h,"unsortedSegmentSum",r,d,a).reshape(u);return o!=null&&(f=f.transpose(ME(o))),f},t.prototype.segOpCompute=function(e,r,a,s,o){var i=e.shape[0],u=e.shape[1],l=(function(f,m){var v,y=!1;for(f<=JB?(v=f,y=!0):v=zN(f,Math.floor(Math.sqrt(f)));!y;)v>m||v===f?y=!0:v=zN(f,v+1);return v})(u,o),h=new Eat({windowSize:l,inSize:u,batchSize:i,numSegments:o}),d=this.compileAndRun(h,[e,a],s);return d.shape[1]===o?d:(a=Z0(0,o).tile([u/l]),this.segOpCompute(d,r,a,s,o))},t.prototype.argMinMaxReduce=function(e,r,a){var s=[r];if(ss("arg"+a.charAt(0).toUpperCase()+a.slice(1),s,e.rank),!kt().getBool("WEBGL_PACK_REDUCE")||e.rank<=2){var o=na(e.shape,s),i=o[0],u=ee(o[1]),l=e.as2D(-1,u);return this.argReduce(l,a).reshape(i)}return this.argReducePacked(e,a)},t.prototype.argMin=function(e,r){return this.argMinMaxReduce(e,r,"min")},t.prototype.argMax=function(e,r){return this.argMinMaxReduce(e,r,"max")},t.prototype.cumsum=function(e,r,a,s){if(r!==e.rank-1)throw new Error("WebGL cumsum shader expects an inner-most axis="+(e.rank-1)+" but got axis="+r);var o=new Rrt(e.shape,a,s);return this.compileAndRun(o,[e])},t.prototype.equal=function(e,r){if(kt().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(e,r,`
  return vec4(equal(a, b));
`,"bool");var a=new zn("return float(a == b);",e.shape,r.shape);return this.compileAndRun(a,[e,r],"bool")},t.prototype.notEqual=function(e,r){if(kt().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(e,r,`
  return vec4(notEqual(a, b));
`,"bool");var a=new zn("return float(a != b);",e.shape,r.shape);return this.compileAndRun(a,[e,r],"bool")},t.prototype.less=function(e,r){if(this.shouldExecuteOnCPU([e,r]))return this.cpuBackend.less(e,r);if(kt().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(e,r,`
  return vec4(lessThan(a, b));
`,"bool");var a=new zn("return float(a < b);",e.shape,r.shape);return this.compileAndRun(a,[e,r],"bool")},t.prototype.lessEqual=function(e,r){if(kt().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(e,r,`
  return vec4(lessThanEqual(a, b));
`,"bool");var a=new zn("return float(a <= b);",e.shape,r.shape);return this.compileAndRun(a,[e,r],"bool")},t.prototype.greater=function(e,r){if(this.shouldExecuteOnCPU([e,r]))return this.cpuBackend.greater(e,r);if(kt().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(e,r,`
  return vec4(greaterThan(a, b));
`,"bool");var a=new zn("return float(a > b);",e.shape,r.shape);return this.compileAndRun(a,[e,r],"bool")},t.prototype.greaterEqual=function(e,r){if(kt().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(e,r,`
  return vec4(greaterThanEqual(a, b));
`,"bool");var a=new zn("return float(a >= b);",e.shape,r.shape);return this.compileAndRun(a,[e,r],"bool")},t.prototype.logicalNot=function(e){var r=new Ee(e.shape,"return float(!(x >= 1.0));");return this.compileAndRun(r,[e])},t.prototype.logicalAnd=function(e,r){if(kt().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(e,r,`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,"bool");var a=new zn("return float(a >= 1.0 && b >= 1.0);",e.shape,r.shape);return this.compileAndRun(a,[e,r],"bool")},t.prototype.logicalOr=function(e,r){if(kt().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(e,r,`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,"bool");var a=new zn("return float(a >= 1.0 || b >= 1.0);",e.shape,r.shape);return this.compileAndRun(a,[e,r],"bool")},t.prototype.select=function(e,r,a){var s=new Iat(e.rank,r.shape,r.rank);return this.compileAndRun(s,[e,r,a],Qr(r.dtype,a.dtype))},t.prototype.where=function(e){Y0("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");var r=e.dataSync();return GE(e.shape,r)},t.prototype.topk=function(e,r,a){return cz(e.dataSync(),e.shape,e.dtype,r)},t.prototype.min=function(e,r){ss("min",r,e.rank);var a=na(e.shape,r),s=a[0],o=ee(a[1]),i=e.as2D(-1,o);return this.reduce(i,"min",i.dtype).reshape(s)},t.prototype.minimum=function(e,r){if(this.shouldExecuteOnCPU([e,r]))return this.cpuBackend.minimum(e,r);var a=kt().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new xi(`
  vec4 result = vec4(min(a, b));
  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));
  
  result.r = isNaN.r > 0. ? NAN : result.r;
  result.g = isNaN.g > 0. ? NAN : result.g;
  result.b = isNaN.b > 0. ? NAN : result.b;
  result.a = isNaN.a > 0. ? NAN : result.a;

  return result;
`,e.shape,r.shape):new zn(`
  if (isnan(a)) return a;
  if (isnan(b)) return b;

  return min(a, b);
`,e.shape,r.shape);return this.compileAndRun(a,[e,r])},t.prototype.mod=function(e,r){var a=kt().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new xi(`
  vec4 result = mod(a, b);
  vec4 isNaN = vec4(equal(b, vec4(0.0)));
  
  result.r = isNaN.r > 0. ? NAN : result.r;
  result.g = isNaN.g > 0. ? NAN : result.g;
  result.b = isNaN.b > 0. ? NAN : result.b;
  result.a = isNaN.a > 0. ? NAN : result.a;

  return result;
`,e.shape,r.shape):new zn(`if (b == 0.0) return NAN;
  return mod(a, b);`,e.shape,r.shape);return this.compileAndRun(a,[e,r])},t.prototype.max=function(e,r){if(this.shouldExecuteOnCPU([e]))return this.cpuBackend.max(e,r);ss("max",r,e.rank);var a=na(e.shape,r),s=a[0],o=ee(a[1]),i=e.as2D(-1,o);return this.reduce(i,"max",i.dtype).reshape(s)},t.prototype.maximum=function(e,r){if(this.shouldExecuteOnCPU([e,r]))return this.cpuBackend.maximum(e,r);var a=kt().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new xi(`
  vec4 result = vec4(max(a, b));
  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));
  
  result.r = isNaN.r > 0. ? NAN : result.r;
  result.g = isNaN.g > 0. ? NAN : result.g;
  result.b = isNaN.b > 0. ? NAN : result.b;
  result.a = isNaN.a > 0. ? NAN : result.a;

  return result;
`,e.shape,r.shape):new zn(`
  if (isnan(a)) return a;
  if (isnan(b)) return b;

  return max(a, b);
`,e.shape,r.shape);return this.compileAndRun(a,[e,r])},t.prototype.all=function(e,r){ss("all",r,e.rank);var a=na(e.shape,r),s=a[0],o=ee(a[1]),i=e.as2D(-1,o);return this.reduce(i,"all",i.dtype).reshape(s)},t.prototype.any=function(e,r){ss("any",r,e.rank);var a=na(e.shape,r),s=a[0],o=ee(a[1]),i=e.as2D(-1,o);return this.reduce(i,"any",i.dtype).reshape(s)},t.prototype.realDivide=function(e,r){if(kt().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(e,r,`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,"float32",!0);var a=new zn(`
if (a == b) {
  return 1.0;
};
return a / b;`,e.shape,r.shape);return this.compileAndRun(a,[e,r],"float32")},t.prototype.floorDiv=function(e,r){if(kt().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(e,r,`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,"int32");var a=new zn(`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,e.shape,r.shape);return this.compileAndRun(a,[e,r],"int32")},t.prototype.add=function(e,r){if(e.dtype==="complex64"&&r.dtype==="complex64")return this.complexSeparableBinaryOp(e,r,eC);if(this.shouldExecuteOnCPU([e,r]))return this.cpuBackend.add(e,r);var a=Qr(e.dtype,r.dtype);if(kt().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(e,r,eC,a);var s=new zn(eC,e.shape,r.shape);return this.compileAndRun(s,[e,r],a)},t.prototype.packedUnaryOp=function(e,r,a){var s=new Ef(e.shape,r);return this.compileAndRun(s,[e],a)},t.prototype.packedBinaryOp=function(e,r,a,s,o){o===void 0&&(o=!1);var i=new xi(a,e.shape,r.shape,o);return this.compileAndRun(i,[e,r],s)},t.prototype.complexSeparableBinaryOp=function(e,r,a){var s=this,o=this.texData.get(e.dataId),i=this.texData.get(r.dataId),u=[[o.complexTensors.real,i.complexTensors.real],[o.complexTensors.imag,i.complexTensors.imag]].map((function(f){var m=f[0],v=f[1],y=s.makeComplexComponentTensorInfo(e,m),b=s.makeComplexComponentTensorInfo(r,v),w=new zn(a,e.shape,r.shape);return s.compileAndRun(w,[y,b],Qr(m.dtype,v.dtype))})),l=u[0],h=u[1],d=this.complex(l,h);return l.dispose(),h.dispose(),d},t.prototype.makeComplexComponentTensorInfo=function(e,r){return{dataId:r.dataId,dtype:r.dtype,shape:e.shape}},t.prototype.addN=function(e){if(e.length===1)return e[0];if(e.length>kt().get("WEBGL_MAX_TEXTURES_IN_SHADER")){var r=Math.floor(e.length/2),a=this.addN(e.slice(0,r)),s=this.addN(e.slice(r));return this.addN([a,s])}var o=e.map((function(l){return l.dtype})).reduce((function(l,h){return Qr(l,h)})),i=e.map((function(l){return l.shape})),u=kt().getBool("WEBGL_PACK")?new rrt(e[0].shape,i):new nrt(e[0].shape,i);return this.compileAndRun(u,e,o)},t.prototype.subtract=function(e,r){if(e.dtype==="complex64"&&r.dtype==="complex64")return this.complexSeparableBinaryOp(e,r,nC);if(this.shouldExecuteOnCPU([e,r]))return this.cpuBackend.subtract(e,r);var a=Qr(e.dtype,r.dtype);if(kt().getBool("WEBGL_PACK_BINARY_OPERATIONS"))return this.packedBinaryOp(e,r,nC,e.dtype);var s=new zn(nC,e.shape,r.shape);return this.compileAndRun(s,[e,r],a)},t.prototype.pow=function(e,r){var a=kt().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new xi(`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));
  
  result.r = isNaN.r > 0. ? NAN : result.r;
  result.g = isNaN.g > 0. ? NAN : result.g;
  result.b = isNaN.b > 0. ? NAN : result.b;
  result.a = isNaN.a > 0. ? NAN : result.a;

  return result;
`,e.shape,r.shape):new zn(`
if(a < 0.0 && floor(b) < b){
  return NAN;
}
if (b == 0.0) {
  return 1.0;
}
return (round(mod(b, 2.0)) != 1) ?
    pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,e.shape,r.shape),s=Qr(e.dtype,r.dtype);return this.compileAndRun(a,[e,r],s)},t.prototype.ceil=function(e){if(this.shouldExecuteOnCPU([e]))return this.cpuBackend.ceil(e);if(kt().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,w3,e.dtype);var r=new Ee(e.shape,w3);return this.compileAndRun(r,[e])},t.prototype.floor=function(e){if(this.shouldExecuteOnCPU([e]))return this.cpuBackend.floor(e);if(kt().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,S3,e.dtype);var r=new Ee(e.shape,S3);return this.compileAndRun(r,[e])},t.prototype.sign=function(e){var r=new Ee(e.shape,`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`);return this.compileAndRun(r,[e])},t.prototype.isNaN=function(e){var r=new Ee(e.shape,"return float(isnan(x));");return this.compileAndRun(r,[e],"bool")},t.prototype.isInf=function(e){var r=new Ee(e.shape,"return float(isinf(x));");return this.compileAndRun(r,[e],"bool")},t.prototype.isFinite=function(e){var r=new Ee(e.shape,"return float(!isnan(x) && !isinf(x));");return this.compileAndRun(r,[e],"bool")},t.prototype.round=function(e){var r=new Ee(e.shape,`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`);return this.compileAndRun(r,[e])},t.prototype.exp=function(e){if(this.shouldExecuteOnCPU([e]))return this.cpuBackend.exp(e);if(kt().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,C3,e.dtype);var r=new Ee(e.shape,C3);return this.compileAndRun(r,[e])},t.prototype.expm1=function(e){if(this.shouldExecuteOnCPU([e]))return this.cpuBackend.expm1(e);if(kt().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,N3,e.dtype);var r=new Ee(e.shape,N3);return this.compileAndRun(r,[e])},t.prototype.softmax=function(e,r){var a=Tr([r],e.shape),s=this.max(e,a),o=ja(s.shape,a),i=this.subtract(e,s.reshape(o)),u=this.exp(i),l=this.sum(u,a).reshape(o);return this.realDivide(u,l)},t.prototype.log=function(e){if(this.shouldExecuteOnCPU([e]))return this.cpuBackend.log(e);if(kt().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,`
  vec4 result = log(x);
  vec4 isNaN = vec4(lessThan(x, vec4(0.0)));
  result.r = isNaN.r == 1.0 ? NAN : result.r;
  result.g = isNaN.g == 1.0 ? NAN : result.g;
  result.b = isNaN.b == 1.0 ? NAN : result.b;
  result.a = isNaN.a == 1.0 ? NAN : result.a;

  return result;
`,e.dtype);var r=new Ee(e.shape,`if (x < 0.0) return NAN;
  return log(x);`);return this.compileAndRun(r,[e])},t.prototype.log1p=function(e){var r=new Ee(e.shape,"return log(1.0 + x);");return this.compileAndRun(r,[e])},t.prototype.sqrt=function(e){var r=new Ee(e.shape,"return sqrt(x);");return this.compileAndRun(r,[e])},t.prototype.rsqrt=function(e){if(this.shouldExecuteOnCPU([e]))return this.cpuBackend.rsqrt(e);var r=new Ee(e.shape,"return inversesqrt(x);");return this.compileAndRun(r,[e])},t.prototype.reciprocal=function(e){var r=new Ee(e.shape,"return 1.0 / x;");return this.compileAndRun(r,[e])},t.prototype.relu=function(e){var r;return r=kt().getBool("WEBGL_PACK")?new Ef(e.shape,bz):new Ee(e.shape,gz),this.compileAndRun(r,[e])},t.prototype.relu6=function(e){var r;return r=kt().getBool("WEBGL_PACK")?new Ef(e.shape,xz):new Ee(e.shape,vz),this.compileAndRun(r,[e])},t.prototype.prelu=function(e,r){var a=kt().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new xi(mz,e.shape,r.shape):new zn(fz,e.shape,r.shape);return this.compileAndRun(a,[e,r])},t.prototype.elu=function(e){if(kt().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,wz,e.dtype);var r=new Ee(e.shape,yz);return this.compileAndRun(r,[e])},t.prototype.eluDer=function(e,r){var a=kt().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new xi(`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,e.shape,r.shape):new zn("return (b >= 1.0) ? a : a * (b + 1.0);",e.shape,r.shape);return this.compileAndRun(a,[e,r])},t.prototype.selu=function(e){var r=new Ee(e.shape,Lat);return this.compileAndRun(r,[e])},t.prototype.int=function(e){var r=new Ee(e.shape,"return float(int(x));");return this.compileAndRun(r,[e],"int32")},t.prototype.clip=function(e,r,a){var s,o=(s=kt().getBool("WEBGL_PACK_CLIP")?new yrt(e.shape):new vrt(e.shape)).getCustomSetupFunc(r,a);return this.compileAndRun(s,[e],null,o)},t.prototype.abs=function(e){if(this.shouldExecuteOnCPU([e]))return this.cpuBackend.abs(e);if(kt().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,b3,e.dtype);var r=new Ee(e.shape,b3);return this.compileAndRun(r,[e])},t.prototype.complexAbs=function(e){var r=this.texData.get(e.dataId),a=new brt(e.shape),s=[this.makeComplexComponentTensorInfo(e,r.complexTensors.real),this.makeComplexComponentTensorInfo(e,r.complexTensors.imag)];return this.compileAndRun(a,s)},t.prototype.sigmoid=function(e){var r=new Ee(e.shape,"return 1.0 / (1.0 + exp(-1.0 * x));");return this.compileAndRun(r,[e])},t.prototype.softplus=function(e){var r=new Ee(e.shape,`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`);return this.compileAndRun(r,[e])},t.prototype.sin=function(e){var r=new Ee(e.shape,Bat);return this.compileAndRun(r,[e])},t.prototype.cos=function(e){var r=new Ee(e.shape,zat);return this.compileAndRun(r,[e])},t.prototype.tan=function(e){var r=new Ee(e.shape,"return tan(x);");return this.compileAndRun(r,[e])},t.prototype.asin=function(e){var r=new Ee(e.shape,Pat);return this.compileAndRun(r,[e])},t.prototype.acos=function(e){var r=new Ee(e.shape,Vat);return this.compileAndRun(r,[e])},t.prototype.atan=function(e){var r=new Ee(e.shape,Uat);return this.compileAndRun(r,[e])},t.prototype.atan2=function(e,r){var a=kt().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new xi(`
  vec4 result = atan(a, b);
  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));
  
  result.r = isNaN.r > 0. ? NAN : result.r;
  result.g = isNaN.g > 0. ? NAN : result.g;
  result.b = isNaN.b > 0. ? NAN : result.b;
  result.a = isNaN.a > 0. ? NAN : result.a;

  return result;
`,e.shape,r.shape):new zn(`
  if (isnan(a)) return a;
  if (isnan(b)) return b;

  return atan(a, b);
`,e.shape,r.shape);return this.compileAndRun(a,[e,r])},t.prototype.sinh=function(e){var r=new Ee(e.shape,`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`);return this.compileAndRun(r,[e])},t.prototype.cosh=function(e){var r=new Ee(e.shape,`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`);return this.compileAndRun(r,[e])},t.prototype.tanh=function(e){var r=new Ee(e.shape,`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`);return this.compileAndRun(r,[e])},t.prototype.asinh=function(e){var r=new Ee(e.shape,Wat);return this.compileAndRun(r,[e])},t.prototype.acosh=function(e){var r=new Ee(e.shape,Gat);return this.compileAndRun(r,[e])},t.prototype.atanh=function(e){var r=new Ee(e.shape,Hat);return this.compileAndRun(r,[e])},t.prototype.erf=function(e){var r=new Ee(e.shape,`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = 0.3275911;
  float a1 = 0.254829592;
  float a2 = -0.284496736;
  float a3 = 1.421413741;
  float a4 = -1.453152027;
  float a5 = 1.061405429;

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`);return this.compileAndRun(r,[e])},t.prototype.step=function(e,r){var a=new Ee(e.shape,(function(s){return s===void 0&&(s=0),ho+`
    return x > 0.0 ? 1.0 : float(`+s+`);
  `})(r));return this.compileAndRun(a,[e])},t.prototype.conv2dByMatMul=function(e,r,a,s,o,i){var u=e.shape,l=this.texData.get(e.dataId),h=a.inChannels,d=u[0]*u[1]*u[2],f=a.outChannels,m=a.dataFormat==="channelsLast",v=(d===1||f===1)&&h>1e3,y=u[2]%2!=0&&!!l.isPacked;if(v||!kt().getBool("WEBGL_LAZILY_UNPACK")||!kt().getBool("WEBGL_PACK_BINARY_OPERATIONS")||!y){var b=m?u[0]*u[1]*u[2]:u[0]*u[2]*u[3],w=this.reshape(e,[1,b,a.inChannels]),S=this.reshape(r,[1,a.inChannels,a.outChannels]);return this.reshape(this.fusedBatchMatMul({a:w,b:S,transposeA:!1,transposeB:!1,bias:s,activation:o,preluActivationWeights:i}),a.outShape)}var N=m?u[0]*u[1]*(u[2]+1):u[0]*u[2]*(u[3]+1),C={dataId:e.dataId,shape:[1,N,a.inChannels],dtype:e.dtype},T=l.shape;l.shape=l.shape.slice(),l.shape[l.shape.length-2]++,Z(Ky(l.shape,C.shape),(function(){return"packed reshape "+l.shape+" to "+C.shape+" isn't free"}));var I=this.reshape(r,[1,a.inChannels,a.outChannels]),_=this.fusedBatchMatMul({a:C,b:I,transposeA:!1,transposeB:!1,bias:s,activation:o,preluActivationWeights:i}),$=this.texData.get(_.dataId);return Z($.isPacked,(function(){return"batchMatMul result is expected to be packed"})),l.shape=T,$.shape=a.outShape,lt.makeTensorFromDataId(_.dataId,a.outShape,_.dtype)},t.prototype.conv2dWithIm2Row=function(e,r,a,s,o,i){var u=a.filterWidth,l=a.filterHeight,h=a.inChannels,d=a.outWidth,f=a.outHeight,m=a.dataFormat==="channelsLast",v=u*l*h,y=f*d,b=[v,y],w=e.squeeze([0]),S=r.reshape([1,v,-1]),N=new iat(b,w.shape,a),C=this.compileAndRun(N,[w]).reshape([1,b[0],b[1]]),T=s!=null,I=i!=null,_=o?Zy(o,!0):null,$=new rC(C.shape,[1,y,a.outChannels],!0,!1,T,_,I),R=[C,S];s&&R.push(s),I&&R.push(i);var D=this.compileAndRun($,R);return m?D.reshape([1,f,d,a.outChannels]):D.reshape([1,a.outChannels,f,d])},t.prototype.fusedConv2d=function(e){var r=e.input,a=e.filter,s=e.convInfo,o=e.bias,i=e.activation,u=e.preluActivationWeights;if(s.filterHeight===1&&s.filterWidth===1&&s.dilationHeight===1&&s.dilationWidth===1&&s.strideHeight===1&&s.strideWidth===1&&(s.padInfo.type==="SAME"||s.padInfo.type==="VALID"))return this.conv2dByMatMul(r,a,s,o,i,u);if(kt().getBool("WEBGL_CONV_IM2COL")&&r.shape[0]===1)return this.conv2dWithIm2Row(r,a,s,o,i,u);var l=o!=null,h=u!=null,d=i?Zy(i,!1):null,f=new c3(s,l,d,h),m=[r,a];return o&&m.push(o),u&&m.push(u),this.compileAndRun(f,m)},t.prototype.conv2d=function(e,r,a){if(a.filterHeight===1&&a.filterWidth===1&&a.dilationHeight===1&&a.dilationWidth===1&&a.strideHeight===1&&a.strideWidth===1&&(a.padInfo.type==="SAME"||a.padInfo.type==="VALID"))return this.conv2dByMatMul(e,r,a);if(kt().getBool("WEBGL_CONV_IM2COL")&&e.shape[0]===1)return this.conv2dWithIm2Row(e,r,a);var s=new c3(a);return this.compileAndRun(s,[e,r])},t.prototype.conv2dDerInput=function(e,r,a){var s=new Crt(a);return this.compileAndRun(s,[e,r])},t.prototype.conv2dDerFilter=function(e,r,a){var s=new Srt(a);return this.compileAndRun(s,[e,r])},t.prototype.fusedDepthwiseConv2D=function(e){var r,a=e.input,s=e.filter,o=e.convInfo,i=e.bias,u=e.activation,l=e.preluActivationWeights,h=kt().getBool("WEBGL_PACK_DEPTHWISECONV")&&o.strideWidth<=2&&o.outChannels/o.inChannels==1,d=u?Zy(u,h):null,f=[a,s],m=i!=null,v=l!=null;return m&&f.push(i),v&&f.push(l),h?(r=new d3(o,m,d,v),this.compileAndRun(r,f)):(r=new h3(o,m,d,v),this.compileAndRun(r,f))},t.prototype.depthwiseConv2D=function(e,r,a){var s;return kt().getBool("WEBGL_PACK_DEPTHWISECONV")&&a.strideWidth<=2&&a.outChannels/a.inChannels==1?(s=new d3(a),this.compileAndRun(s,[e,r])):(s=new h3(a),this.compileAndRun(s,[e,r]))},t.prototype.depthwiseConv2DDerInput=function(e,r,a){var s=new Ert(a);return this.compileAndRun(s,[e,r])},t.prototype.depthwiseConv2DDerFilter=function(e,r,a){var s=new Trt(a);return this.compileAndRun(s,[e,r])},t.prototype.conv3d=function(e,r,a){var s=new Irt(a);return this.compileAndRun(s,[e,r])},t.prototype.conv3dDerInput=function(e,r,a){var s=new krt(a);return this.compileAndRun(s,[e,r])},t.prototype.conv3dDerFilter=function(e,r,a){var s=new Nrt(a);return this.compileAndRun(s,[e,r])},t.prototype.maxPool=function(e,r){var a=new aC(r,"max",!1);return this.compileAndRun(a,[e])},t.prototype.avgPool=function(e,r){var a=new aC(r,"avg",!1);return this.compileAndRun(a,[e],"float32")},t.prototype.maxPoolBackprop=function(e,r,a,s){var o=new aC(s,"max",!0),i=this.compileAndRun(o,[r]),u=new hat(s),l=this.compileAndRun(u,[e,i],r.dtype);return i.dispose(),l},t.prototype.avgPoolBackprop=function(e,r,a){var s=new hrt(a);return this.compileAndRun(s,[e],r.dtype)},t.prototype.cast=function(e,r){return sz(e,r,this)},t.prototype.unstack=function(e,r){for(var a=e.shape[r],s=new Array(e.rank-1),o=0,i=0;i<e.rank;i++)i!==r&&(s[o++]=e.shape[i]);var u=new Array(e.rank).fill(0),l=e.shape.slice();l[r]=1;var h=new Array(a);for(i=0;i<h.length;i++)u[r]=i,h[i]=this.slice(e,u,l).reshape(s);return h},t.prototype.avgPool3d=function(e,r){var a=new sC(r,"avg",!1);return this.compileAndRun(a,[e],"float32")},t.prototype.avgPool3dBackprop=function(e,r,a){var s=new drt(a);return this.compileAndRun(s,[e],r.dtype)},t.prototype.maxPool3d=function(e,r){var a=new sC(r,"max",!1);return this.compileAndRun(a,[e],"float32")},t.prototype.maxPool3dBackprop=function(e,r,a,s){var o=new sC(s,"max",!0),i=this.compileAndRun(o,[r]),u=new dat(s),l=this.compileAndRun(u,[e,i],r.dtype);return i.dispose(),l},t.prototype.reshape=function(e,r){var a=this.texData.get(e.dataId);if(a.isPacked&&!Ky(e.shape,r)&&(a.texture===null||!Ky(a.shape,r))){var s=this.packedReshape(e,r);return lt.makeTensorFromDataId(s.dataId,s.shape,s.dtype)}return qN(e,r)},t.prototype.resizeBilinear=function(e,r,a,s){var o=kt().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new Sat(e.shape,r,a,s):new wat(e.shape,r,a,s);return this.compileAndRun(o,[e],"float32")},t.prototype.resizeBilinearBackprop=function(e,r,a){var s=new xat(e,r,a);return this.compileAndRun(s,[e])},t.prototype.resizeNearestNeighbor=function(e,r,a,s){var o=new Nat(e.shape,r,a,s);return this.compileAndRun(o,[e])},t.prototype.resizeNearestNeighborBackprop=function(e,r,a){var s=new Cat(e,r,a);return this.compileAndRun(s,[e])},t.prototype.multinomial=function(e,r,a,s){var o=r?e:Wi(e),i=o.shape[0],u=o.shape[1],l=new pat(i,u,a),h=l.getCustomSetupFunc(s);return this.compileAndRun(l,[o],"int32",h)},t.prototype.oneHot=function(e,r,a,s){var o=new fat(e.size,r,a,s);return this.compileAndRun(o,[e])},t.prototype.diag=function(e){var r=new Ort(e.size);return this.compileAndRun(r,[e])},t.prototype.nonMaxSuppression=function(e,r,a,s,o){return Y0("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead"),UE(e.dataSync(),r.dataSync(),a,s,o)},t.prototype.cropAndResize=function(e,r,a,s,o,i){var u=new _rt(e.shape,r.shape,s,o,i);return this.compileAndRun(u,[e,r,a],"float32")},t.prototype.depthToSpace=function(e,r,a){Z(r>1,(function(){return"blockSize should be > 1 for depthToSpace, but was: "+r}));var s=e.shape[0],o=a==="NHWC"?e.shape[1]:e.shape[2],i=a==="NHWC"?e.shape[2]:e.shape[3],u=a==="NHWC"?e.shape[3]:e.shape[1],l=o*r,h=i*r,d=u/(r*r),f=new $rt(a==="NHWC"?[s,l,h,d]:[s,d,l,h],r,a);return this.compileAndRun(f,[e])},t.prototype.split=function(e,r,a){return uz(e,r,a)},t.prototype.scatterND=function(e,r,a){var s=nb(0,e,a),o=s.sliceRank,i=s.numUpdates,u=s.sliceSize,l=s.strides,h=s.outputSize,d=[h/u,u],f=e.reshape([i,o]),m=r.reshape([i,u]);if(h===0)return qN(Zr([]),a);var v=Pt(0),y=new g3(i,o,f.rank,m.rank,l,d);return this.compileAndRun(y,[m,f,v]).reshape(a)},t.prototype.sparseToDense=function(e,r,a,s){var o=nb(0,e,a),i=o.sliceRank,u=o.numUpdates,l=o.strides,h=o.outputSize,d=new g3(u,i,e.rank,r.rank,l,[h,1]);return this.compileAndRun(d,[r,e,s]).reshape(a)},t.prototype.fft=function(e){return this.fftImpl(e,!1)},t.prototype.ifft=function(e){return this.fftImpl(e,!0)},t.prototype.fftImpl=function(e,r){var a=this.texData.get(e.dataId),s=new f3(zrt,e.shape,r),o=new f3(Prt,e.shape,r),i=[this.makeComplexComponentTensorInfo(e,a.complexTensors.real),this.makeComplexComponentTensorInfo(e,a.complexTensors.imag)],u=this.compileAndRun(s,i),l=this.compileAndRun(o,i),h=this.complex(u,l).as2D(e.shape[0],e.shape[1]);return u.dispose(),l.dispose(),h},t.prototype.gatherND=function(e,r){var a=r.shape,s=a[a.length-1],o=ZB(e,r),i=o[0],u=o[1],l=o[2],h=o[3],d=r.reshape([u,s]),f=e.reshape([e.size/l,l]),m=new Wrt(s,h,[u,l]);return this.compileAndRun(m,[f,d]).reshape(i)},t.prototype.fill=function(e,r,a){if((a=a||qg(r))==="string"){var s=j0(a,ee(e));return s.fill(r),lt.makeTensor(s,e,a,this)}var o=new Vrt(e,r),i=o.getCustomSetupFunc(r);return this.compileAndRun(o,[],a,i)},t.prototype.onesLike=function(e){if(e.dtype==="string")throw new Error("onesLike is not supported under string dtype");return this.fill(e.shape,1,e.dtype)},t.prototype.zerosLike=function(e){return this.fill(e.shape,e.dtype==="string"?"":0,e.dtype)},t.prototype.linspace=function(e,r,a){return oz(e,r,a)},t.prototype.makeTensorInfo=function(e,r){var a=this.write(null,e,r);return this.texData.get(a).usage=null,{dataId:a,shape:e,dtype:r}},t.prototype.makeOutput=function(e,r){var a=this.makeTensorInfo(e,r).dataId;return lt.makeTensorFromDataId(a,e,r,this)},t.prototype.unpackTensor=function(e){var r=new qat(e.shape);return this.runWebGLProgram(r,[e],e.dtype)},t.prototype.packTensor=function(e){var r=new mat(e.shape);return this.runWebGLProgram(r,[e],e.dtype,null,!0)},t.prototype.packedReshape=function(e,r){var a=[K0(e.shape)].concat(X0(e.shape)),s={dtype:e.dtype,shape:a,dataId:e.dataId},o=[K0(r)].concat(X0(r)),i=new bat(o,a),u=this.runWebGLProgram(i,[s],e.dtype,null,!0);return{dataId:u.dataId,shape:r,dtype:u.dtype}},t.prototype.decode=function(e){var r,a=this.texData.get(e),s=a.isPacked,o=a.shape,i=a.dtype,u=JS(o);return r=s?new Drt(u):new Art(u),{dtype:i,shape:o,dataId:this.runWebGLProgram(r,[{shape:u,dtype:i,dataId:e}],i,null,!0).dataId}},t.prototype.runWebGLProgram=function(e,r,a,s,o){var i=this;o===void 0&&(o=!1);var u=this.makeTensorInfo(e.outputShape,a),l=this.texData.get(u.dataId);if(e.packedOutput&&(l.isPacked=!0),e.outPackingScheme===om.DENSE){var h=Pf(e.outputShape);l.texShape=h.map((function(N){return 2*N}))}if(e.outTexUsage!=null&&(l.usage=e.outTexUsage),ee(u.shape)===0)return l.values=am(u.dtype,0),u;var d=[],f=r.map((function(N){if(N.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");var C=i.texData.get(N.dataId);if(C.texture==null){if(!e.packedInputs&&ee(N.shape)<=kt().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:N.shape,texData:null,isUniform:!0,uniformValues:C.values};e.packedInputs&&(C.isPacked=!0,C.shape=N.shape)}else if(!!C.isPacked!=!!e.packedInputs)N=C.isPacked?i.unpackTensor(N):i.packTensor(N),d.push(N),C=i.texData.get(N.dataId);else if(C.isPacked&&!Ky(C.shape,N.shape)){var T=N,I=N.shape;N.shape=C.shape,N=i.packedReshape(N,I),d.push(N),C=i.texData.get(N.dataId),T.shape=I}return i.uploadToGPU(N.dataId),{shape:N.shape,texData:C,isUniform:!1}}));this.uploadToGPU(u.dataId);var m,v={shape:u.shape,texData:l,isUniform:!1},y=(function(N,C,T){var I="";C.concat(T).forEach((function(R){var D=R.texData!=null&&R.texData.slice!=null&&R.texData.slice.flatOffset>0,A=R.isUniform?"uniform":R.texData.texShape;I+=R.shape+"_"+A+"_"+D}));var _=N.userCode,$=N.constructor.name;return $+="_"+I+"_"+_})(e,f,v),b=this.getAndSaveBinary(y,(function(){return(function(N,C,T,I){var _=C.userCode,$=T.map((function(K,z){var U={logicalShape:K.shape,texShape:K.isUniform?null:K.texData.texShape,isUniform:K.isUniform,isPacked:!K.isUniform&&K.texData.isPacked,flatOffset:null};return K.texData!=null&&K.texData.slice!=null&&K.texData.slice.flatOffset>0&&(U.flatOffset=K.texData.slice.flatOffset),{name:C.variableNames[z],shapeInfo:U}})),R=$.map((function(K){return K.shapeInfo})),D={logicalShape:I.shape,texShape:I.texData.texShape,isUniform:!1,isPacked:I.texData.isPacked,flatOffset:null},A=srt($,D,_,C.packedInputs),L=N.createProgram(A),H=null,G=N.getUniformLocation(L,"NAN",!1);kt().getNumber("WEBGL_VERSION")===1&&(H=N.getUniformLocation(L,"INFINITY",!1));for(var q={},B=0;B<C.variableNames.length;B++){var j=C.variableNames[B];q[j]=N.getUniformLocation(L,j,!1),q["offset"+j]=N.getUniformLocation(L,"offset"+j,!1)}return{program:C,source:A,webGLProgram:L,uniformLocations:q,inShapeInfos:R,outShapeInfo:D,infLoc:H,nanLoc:G}})(i.gpgpu,e,f,v)})),w=this.activeTimers!=null;if(w&&(m=this.startTimer()),(function(N,C,T,I,_){m3(C.inShapeInfos,T),m3([C.outShapeInfo],[I]);var $=I.texData.texture,R=I.texData.texShape;I.texData.isPacked?N.setOutputPackedMatrixTexture($,R[0],R[1]):N.setOutputMatrixTexture($,R[0],R[1]),N.setProgram(C.webGLProgram),kt().getNumber("WEBGL_VERSION")===1&&C.infLoc!==null&&N.gl.uniform1f(C.infLoc,1/0),C.nanLoc!==null&&N.gl.uniform1f(C.nanLoc,NaN),T.forEach((function(D,A){var L=C.program.variableNames[A],H=C.uniformLocations[L],G=C.uniformLocations["offset"+L];if(H!=null)if(D.isUniform)if(ee(D.shape)<2)N.gl.uniform1f(H,D.uniformValues[0]);else{var q=D.uniformValues;q instanceof Float32Array||(q=new Float32Array(q)),N.gl.uniform1fv(H,q)}else D.texData.slice!=null&&G!=null&&N.gl.uniform1i(G,D.texData.slice.flatOffset),N.setInputMatrixTexture(D.texData.texture,H,A)})),_?.(N,C.webGLProgram),N.executeProgram()})(this.gpgpu,b,f,v,s),d.forEach((function(N){return i.disposeData(N.dataId)})),w&&(m=this.endTimer(m),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(m)})),!kt().getBool("WEBGL_LAZILY_UNPACK")&&l.isPacked&&o===!1){var S=this.unpackTensor(u);return this.disposeData(u.dataId),S}return u},t.prototype.compileAndRun=function(e,r,a,s,o){o===void 0&&(o=!1),a=a||r[0].dtype;var i=this.runWebGLProgram(e,r,a,s,o);return lt.makeTensorFromDataId(i.dataId,i.shape,i.dtype)},t.prototype.getAndSaveBinary=function(e,r){return e in this.binaryCache||(this.binaryCache[e]=r()),this.binaryCache[e]},t.prototype.getTextureManager=function(){return this.textureManager},t.prototype.dispose=function(){var e=this;this.disposed||(kt().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach((function(r){e.gpgpu.deleteProgram(e.binaryCache[r].webGLProgram),delete e.binaryCache[r]})),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)},t.prototype.floatPrecision=function(){var e=this;return this.floatPrecisionValue==null&&(this.floatPrecisionValue=Gt((function(){if(!kt().get("WEBGL_RENDER_FLOAT32_ENABLED")){var r=kt().getBool("DEBUG");kt().set("DEBUG",!1);var a=e.abs(Pt(1e-8)).dataSync()[0];if(kt().set("DEBUG",r),a>0)return 32}return 16}))),this.floatPrecisionValue},t.prototype.epsilon=function(){return this.floatPrecision()===32?1e-7:1e-4},t.prototype.uploadToGPU=function(e){var r,a=this.texData.get(e),s=a.shape,o=a.dtype,i=a.values,u=a.texture,l=a.usage,h=a.isPacked;if(u==null){var d,f=this.activeTimers!=null;f&&(d=So());var m=a.texShape;if(m==null&&(m=ent(s,h),a.texShape=m),i!=null){var v=JS(s),y=void 0,b=m[1],w=m[0],S=i instanceof Uint8Array;h?(b=(r=Xg(m[0],m[1]))[0],w=r[1],y=new Brt(v,[w,b],S)):y=new Lrt(v,[w,b],S);var N=this.makeTensorInfo([w,b],o);this.texData.get(N.dataId).usage=S?cs.PIXELS:cs.UPLOAD,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(N.dataId),b,w,i);var C=this.runWebGLProgram(y,[N],o,null,!0),T=this.texData.get(C.dataId);a.texture=T.texture,a.texShape=T.texShape,a.isPacked=T.isPacked,a.usage=T.usage,this.disposeData(N.dataId),this.texData.delete(C.dataId),a.values=null,f&&(this.uploadWaitMs+=So()-d)}else{var I=this.acquireTexture(m,l,o,h);a.texture=I}}},t.prototype.convertAndCacheOnCPU=function(e,r){var a=this.texData.get(e),s=a.dtype;return this.releaseGPUData(e),r!=null&&(a.values=(function(o,i){if(i==="float32"||i==="complex64")return o;if(i==="int32"||i==="bool"){for(var u=i==="int32"?new Int32Array(o.length):new Uint8Array(o.length),l=0;l<u.length;++l)u[l]=Math.round(o[l]);return u}throw new Error("Unknown dtype "+i)})(r,s)),a.values},t.prototype.acquireTexture=function(e,r,a,s){if(this.numBytesInGPU+=this.computeBytes(e,a),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){var o=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn("High memory usage in GPU: "+o+" MB, most likely due to a memory leak")}return this.textureManager.acquireTexture(e,r,s)},t.prototype.computeBytes=function(e,r){return e[0]*e[1]*OB(r)},t})(rz);VB()&&lt.registerBackend("webgl",(function(){return new Xat}),2);var Yat=st({square_:function(n){var t=Y(n,"x","square"),e=[t];return lt.runKernelFunc((function(r,a){return a([t]),r.square(t)}),{x:t},null,"Square",{},e,[])}}),um="SquaredDifference",Sz=st({squaredDifference_:function(n,t){var e,r=Y(n,"a","squaredDifference"),a=Y(t,"b","squaredDifference");e=Mn(r,a),r=e[0],a=e[1],Le(r.shape,a.shape);var s={a:r,b:a},o=[r,a];return lt.runKernelFunc((function(i,u){var l=i.squaredDifference(r,a);return u([r,a]),l}),s,(function(i,u){var l=u[0],h=u[1],d=Pt(2);return{a:function(){return i.mul(l.sub(h).mul(d))},b:function(){return i.mul(h.sub(l).mul(d))}}}),um,{},o,[])}}),Qat=st({abs_:function(n){var t=Y(n,"x","abs");return t.dtype==="complex64"?lt.runKernelFunc((function(e){return e.complexAbs(t)}),{$x:t}):lt.runKernelFunc((function(e,r){var a=e.abs(t);return r([t]),a}),{x:t},(function(e,r){var a=r[0];return{x:function(){return e.mul(a.toFloat().step(-1))}}}),"Abs")}}),Zat=st({acos_:function(n){var t=Y(n,"x","acos");return lt.runKernelFunc((function(e,r){var a=e.acos(t);return r([t]),a}),{$x:t},(function(e,r){var a=r[0];return{$x:function(){return e.divStrict(Pt(1).sub(a.toFloat().square()).sqrt()).neg()}}}))}}),Jat=st({acosh_:function(n){var t=Y(n,"x","acosh");return lt.runKernelFunc((function(e,r){var a=e.acosh(t);return r([t]),a}),{$x:t},(function(e,r){var a=r[0];return{$x:function(){return e.divStrict(a.toFloat().square().sub(1).sqrt())}}}))}}),tst=st({asin_:function(n){var t=Y(n,"x","asin");return lt.runKernelFunc((function(e,r){var a=e.asin(t);return r([t]),a}),{$x:t},(function(e,r){var a=r[0];return{$x:function(){return e.divStrict(Pt(1).sub(a.toFloat().square()).sqrt())}}}))}}),est=st({asinh_:function(n){var t=Y(n,"x","asinh");return lt.runKernelFunc((function(e,r){var a=e.asinh(t);return r([t]),a}),{$x:t},(function(e,r){var a=r[0];return{$x:function(){return e.divStrict(Pt(1).add(a.toFloat().square()).sqrt())}}}))}}),nst=st({atan_:function(n){var t=Y(n,"x","atan");return lt.runKernelFunc((function(e,r){var a=e.atan(t);return r([t]),a}),{$x:t},(function(e,r){var a=r[0];return{$x:function(){return e.div(a.toFloat().square().add(1))}}}))}}),rst=st({atanh_:function(n){var t=Y(n,"x","atanh");return lt.runKernelFunc((function(e,r){var a=e.atanh(t);return r([t]),a}),{$x:t},(function(e,r){var a=r[0];return{$x:function(){return e.div(Pt(1).sub(a.toFloat().square()))}}}))}}),ast=st({ceil_:function(n){var t=Y(n,"x","ceil");return lt.runKernelFunc((function(e){return e.ceil(t)}),{$x:t},(function(e){return{$x:function(){return He(e)}}}))}}),KE=st({clipByValue_:function(n,t,e){var r=Y(n,"x","clipByValue");Z(t<=e,(function(){return"Error in clip: min ("+t+") must be less than or equal to max ("+e+")."}));var a=[r],s={min:t,max:e};return lt.runKernelFunc((function(o,i){var u=o.clip(r,t,e);return i([r]),u}),{x:r},(function(o,i){var u=i[0];return{x:function(){return o.where(u.greaterEqual(t).logicalAnd(u.lessEqual(e)),He(o))}}}),"ClipByValue",s,a)}}),sst=st({cos_:function(n){var t=Y(n,"x","cos"),e=[t];return lt.runKernelFunc((function(r,a){var s=r.cos(t);return a([t]),s}),{x:t},(function(r,a){var s=a[0];return{x:function(){return s.toFloat().sin().neg().mul(r)}}}),"Cos",{},e)}}),ost=st({cosh_:function(n){var t=Y(n,"x","cosh");return lt.runKernelFunc((function(e,r){var a=e.cosh(t);return r([t]),a}),{$x:t},(function(e,r){var a=r[0];return{$x:function(){return a.toFloat().sinh().mulStrict(e)}}}))}}),ist=st({erf_:function(n){var t=Y(n,"x","erf");return Z(t.dtype==="int32"||t.dtype==="float32",(function(){return"Input dtype must be `int32` or `float32`."})),t.dtype==="int32"&&(t=t.toFloat()),lt.runKernelFunc((function(e,r){var a=e.erf(t);return r([t]),a}),{$x:t},(function(e,r){var a=r[0];return{$x:function(){return e.mul(a.square().neg().exp().mul(2/Math.sqrt(Math.PI)))}}}))}}),XN=st({exp_:function(n){var t=Y(n,"x","exp");return lt.runKernelFunc((function(e,r){var a=e.exp(t);return r([a]),a}),{x:t},(function(e,r){return{x:function(){return e.mulStrict(r[0])}}}),"Exp",{},[],[!0])}}),ust=st({expm1_:function(n){var t=Y(n,"x","expm1");return lt.runKernelFunc((function(e,r){var a=e.expm1(t);return r([t]),a}),{$x:t},(function(e,r){var a=r[0];return{$x:function(){return e.mul(a.exp())}}}))}}),lst=st({floor_:function(n){var t=Y(n,"x","floor");return lt.runKernelFunc((function(e){return e.floor(t)}),{$x:t},(function(e){return{$x:function(){return He(e)}}}))}}),cst=st({log_:function(n){var t=Y(n,"x","log"),e=[t];return lt.runKernelFunc((function(r,a){var s=r.log(t);return a([t]),s}),{x:t},(function(r,a){var s=a[0];return{x:function(){return r.div(s.toFloat())}}}),"Log",{},e)}}),hst=st({log1p_:function(n){var t=Y(n,"x","log1p");return lt.runKernelFunc((function(e,r){var a=e.log1p(t);return r([t]),a}),{$x:t},(function(e,r){var a=r[0];return{$x:function(){return e.div(a.add(1))}}}))}}),dst=st({logSigmoid_:function(n){var t=Y(n,"x","logSigmoid");return lt.runKernelFunc((function(e,r){var a=e.softplus(t.neg()).neg();return r([t]),a}),{$x:t},(function(e,r){var a=r[0];return{$x:function(){return e.mul(a.neg().sigmoid())}}}))}}),ob=st({neg_:function(n){var t=Y(n,"x","neg"),e=[t];return lt.runKernelFunc((function(r){return r.neg(t)}),{x:t},(function(r){return{x:function(){return r.neg()}}}),"Neg",{},e)}}),pst=st({reciprocal_:function(n){var t=Y(n,"x","reciprocal");return lt.runKernelFunc((function(e,r){var a=e.reciprocal(t);return r([t]),a}),{$x:t},(function(e,r){var a=r[0];return{$x:function(){return e.div(a.square().neg())}}}))}}),fst=st({round_:function(n){var t=Y(n,"x","round");return lt.runKernelFunc((function(e){return e.round(t)}),{$x:t},(function(e){return{$x:function(){return He(e)}}}))}}),Cz=st({rsqrt_:function(n){var t=Y(n,"x","rsqrt"),e=[t];return lt.runKernelFunc((function(r,a){var s=r.rsqrt(t);return a([t]),s}),{x:t},(function(r,a){var s=a[0];return{x:function(){return r.div(s.pow(1.5).mul(2)).neg()}}}),"Rsqrt",{},e)}}),Nz=st({sigmoid_:function(n){var t=Y(n,"x","sigmoid");return lt.runKernelFunc((function(e,r){var a=e.sigmoid(t);return r([a]),a}),{x:t},(function(e,r){var a=r[0];return{x:function(){return e.mul(a.mul(Pt(1).sub(a)))}}}),"Sigmoid")}}),mst=st({sign_:function(n){var t=Y(n,"x","sign");return lt.runKernelFunc((function(e){return e.sign(t)}),{$x:t},(function(e){return{$x:function(){return He(e)}}}))}}),gst=st({isNaN_:function(n){var t=Y(n,"x","isNaN");return lt.runKernelFunc((function(e){return e.isNaN(t)}),{$x:t},(function(e){return{$x:function(){return He(e)}}}))}}),vst=st({isInf_:function(n){var t=Y(n,"x","isInf");return lt.runKernelFunc((function(e){return e.isInf(t)}),{$x:t},(function(e){return{$x:function(){return He(e)}}}))}}),yst=st({isFinite_:function(n){var t=Y(n,"x","isFinite");return lt.runKernelFunc((function(e){return e.isFinite(t)}),{$x:t},(function(e){return{$x:function(){return He(e)}}}))}}),bst=st({sin_:function(n){var t=Y(n,"x","sin"),e=[t];return lt.runKernelFunc((function(r,a){var s=r.sin(t);return a([t]),s}),{x:t},(function(r,a){var s=a[0];return{x:function(){return s.toFloat().cos().mul(r)}}}),"Sin",{},e)}}),xst=st({sinh_:function(n){var t=Y(n,"x","sinh");return lt.runKernelFunc((function(e,r){var a=e.sinh(t);return r([t]),a}),{$x:t},(function(e,r){var a=r[0];return{$x:function(){return a.toFloat().cosh().mulStrict(e)}}}))}}),wst=st({softplus_:function(n){var t=Y(n,"x","softplus");return lt.runKernelFunc((function(e,r){var a=e.softplus(t);return r([t]),a}),{$x:t},(function(e,r){var a=r[0];return{$x:function(){return e.mul(a.sigmoid())}}}))}}),Sst=st({sqrt_:function(n){var t=Y(n,"x","sqrt");return lt.runKernelFunc((function(e,r){var a=e.sqrt(t);return r([t]),a}),{$x:t},(function(e,r){var a=r[0];return{$x:function(){return e.div(a.toFloat().sqrt().mul(2))}}}))}}),Cst=st({step_:function(n,t){t===void 0&&(t=0);var e=Y(n,"x","step");return lt.runKernelFunc((function(r){return r.step(e,t)}),{$x:e},(function(r){return{$x:function(){return He(r)}}}))}}),Nst=st({tan_:function(n){var t=Y(n,"x","tan");return lt.runKernelFunc((function(e,r){var a=e.tan(t);return r([t]),a}),{$x:t},(function(e,r){var a=r[0];return{$x:function(){return e.div(a.cos().square())}}}))}}),kst=st({tanh_:function(n){var t=Y(n,"x","tanh");return lt.runKernelFunc((function(e,r){var a=e.tanh(t);return r([a]),a}),{x:t},(function(e,r){var a=r[0];return{x:function(){return Pt(1).sub(a.square()).mulStrict(e)}}}),"Tanh",{},null,[!0])}});function kz(n,t,e,r,a,s){var o,i,u=Y(n,"x","batchNorm"),l=Y(t,"mean","batchNorm"),h=Y(e,"variance","batchNorm");return a!=null&&(o=Y(a,"scale","batchNorm")),r!=null&&(i=Y(r,"offset","batchNorm")),Z(u.rank===2,(function(){return"Error in batchNorm3D: x must be rank 3 but got rank "+u.rank+"."})),Z(l.rank===2||l.rank===1,(function(){return"Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank "+l.rank+"."})),Z(h.rank===2||h.rank===1,(function(){return"Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank "+h.rank+"."})),o!=null&&Z(o.rank===2||o.rank===1,(function(){return"Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank "+o.rank+"."})),i!=null&&Z(i.rank===2||i.rank===1,(function(){return"Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank "+i.rank+"."})),Qg(u,l,h,i,o,s)}function Tz(n,t,e,r,a,s){var o,i,u=Y(n,"x","batchNorm"),l=Y(t,"mean","batchNorm"),h=Y(e,"variance","batchNorm");return a!=null&&(o=Y(a,"scale","batchNorm")),r!=null&&(i=Y(r,"offset","batchNorm")),Z(u.rank===3,(function(){return"Error in batchNorm3D: x must be rank 3 but got rank "+u.rank+"."})),Z(l.rank===3||l.rank===1,(function(){return"Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank "+l.rank+"."})),Z(h.rank===3||h.rank===1,(function(){return"Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank "+h.rank+"."})),o!=null&&Z(o.rank===3||o.rank===1,(function(){return"Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank "+o.rank+"."})),i!=null&&Z(i.rank===3||i.rank===1,(function(){return"Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank "+i.rank+"."})),Qg(u,l,h,i,o,s)}function Ez(n,t,e,r,a,s){var o,i,u=Y(n,"x","batchNorm"),l=Y(t,"mean","batchNorm"),h=Y(e,"variance","batchNorm");return a!=null&&(o=Y(a,"scale","batchNorm")),r!=null&&(i=Y(r,"offset","batchNorm")),Z(u.rank===4,(function(){return"Error in batchNorm4D: x must be rank 4 but got rank "+u.rank+"."})),Z(l.rank===4||l.rank===1,(function(){return"Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank "+l.rank+"."})),Z(h.rank===4||h.rank===1,(function(){return"Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank "+h.rank+"."})),o!=null&&Z(o.rank===4||o.rank===1,(function(){return"Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank "+o.rank+"."})),i!=null&&Z(i.rank===4||i.rank===1,(function(){return"Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank "+i.rank+"."})),Qg(u,l,h,i,o,s)}function Qg(n,t,e,r,a,s){s==null&&(s=.001);var o,i,u,l=Y(n,"x","batchNorm"),h=Y(t,"mean","batchNorm"),d=Y(e,"variance","batchNorm");a!=null&&(o=Y(a,"scale","batchNorm")),r!=null&&(i=Y(r,"offset","batchNorm")),Z(h.rank===d.rank,(function(){return"Batch normalization gradient requires mean and variance to have equal ranks."})),Z(i==null||h.rank===i.rank,(function(){return"Batch normalization gradient requires mean and offset to have equal ranks."})),Z(o==null||h.rank===o.rank,(function(){return"Batch normalization gradient requires mean and scale to have equal ranks."})),u=l.rank===0||l.rank===1?l.as4D(1,1,1,l.size):l.rank===2?l.as4D(1,1,l.shape[0],l.shape[1]):l.rank===3?l.as4D(1,l.shape[0],l.shape[1],l.shape[2]):l;var f=[l,h,d,o];return lt.runKernelFunc((function(m,v){var y=m.batchNormalization(u,Jy(h),Jy(d),s,Jy(o),Jy(i));return v([l,h,d,o]),y}),{x:l,mean:h,variance:d,scale:o,offset:i},(function(m,v){var y=v,b=y[0],w=y[1],S=y[2],N=y[3],C=N??Pt(1),T=Sr(w.shape,u.shape),I=[];if(w.rank===1){for(var _=0;_<u.shape.length-1;++_)I.push(u.shape[_]);I.push(1)}var $=b.sub(w),R=m.mul(C),D=Cz(S.add(Pt(s))),A=D.mul(D).mul(D).mul(Pt(-.5));return{x:function(){return w.rank===1?m.mul(Bh(D.as4D(1,1,1,w.shape[0]),I)).mul(C).reshape(b.shape):m.mul(D).mul(C).reshape(b.shape)},mean:function(){var L=D.mul(Pt(-1)).mul(R);return w.rank===1&&(L=L.sum(T)),L.reshape(w.shape)},variance:function(){var L=A.mul($).mul(R);return w.rank===1&&(L=L.sum(T)),L.reshape(w.shape)},scale:function(){var L=$.mul(D),H=m.mul(L);return w.rank===1&&(H=H.sum(T)),H.reshape(w.shape)},offset:function(){var L=m;return w.rank===1&&(L=L.sum(T)),L.reshape(w.shape)}}}),"BatchNormalization",{varianceEpsilon:s},f).reshape(l.shape)}function Jy(n){return n==null?null:n.rank===0?n.as1D():n.rank===1?n:n.rank===2?n.as4D(1,1,n.shape[0],n.shape[1]):n.rank===3?n.as4D(1,n.shape[0],n.shape[1],n.shape[2]):n}function F1(){UB("tf.batchNormalization() is going away. Use tf.batchNorm() instead, and note the positional argument change of scale, offset, and varianceEpsilon")}var Tst=st({batchNormalization2d_:function(n,t,e,r,a,s){return r===void 0&&(r=.001),F1(),kz(n,t,e,s,a,r)}}),Est=st({batchNormalization3d_:function(n,t,e,r,a,s){return r===void 0&&(r=.001),F1(),Tz(n,t,e,s,a,r)}}),Ist=st({batchNormalization4d_:function(n,t,e,r,a,s){return r===void 0&&(r=.001),F1(),Ez(n,t,e,s,a,r)}}),_st=st({batchNormalization_:function(n,t,e,r,a,s){return r===void 0&&(r=.001),F1(),Qg(n,t,e,s,a,r)}}),Iz=st({batchNorm_:Qg}),Rst=st({batchNorm2d_:kz}),Ast=st({batchNorm3d_:Tz}),Dst=st({batchNorm4d_:Ez}),M1=st({logicalAnd_:function(n,t){var e=Y(n,"a","logicalAnd","bool"),r=Y(t,"b","logicalAnd","bool");return Le(e.shape,r.shape),lt.runKernelFunc((function(a){return a.logicalAnd(e,r)}),{a:e,b:r},null,"LogicalAnd")}}),$st=st({logicalNot_:function(n){var t=Y(n,"x","logicalNot","bool");return lt.runKernelFunc((function(e){return e.logicalNot(t)}),{$x:t})}}),_z=st({logicalOr_:function(n,t){var e=Y(n,"a","logicalOr","bool"),r=Y(t,"b","logicalOr","bool");return Le(e.shape,r.shape),lt.runKernelFunc((function(a){return a.logicalOr(e,r)}),{$a:e,$b:r})}}),Ost=st({logicalXor_:function(n,t){var e=Y(n,"a","logicalXor","bool"),r=Y(t,"b","logicalXor","bool");return Le(e.shape,r.shape),_z(n,t).logicalAnd(M1(n,t).logicalNot())}}),uc=st({where_:function(n,t,e){var r=Y(t,"a","where"),a=Y(e,"b","where"),s=Y(n,"condition","where","bool");return Je(r.shape,a.shape,"Error in where: "),s.rank===1?Z(s.shape[0]===r.shape[0],(function(){return"The first dimension of `a` must match the size of `condition`."})):Je(s.shape,a.shape,"Error in where: "),lt.runKernelFunc((function(o,i){var u=o.select(s,r,a);return i([s]),u}),{$condition:s,$a:r,$b:a},(function(o,i){var u=i[0];return{$condition:function(){return He(u).toFloat()},$a:function(){return o.mul(u.cast(o.dtype))},$b:function(){return o.mul(u.logicalNot().cast(o.dtype))}}}))}}),Rz=function(n){return Yt(this,void 0,void 0,(function(){var t,e,r;return Qt(this,(function(a){switch(a.label){case 0:return[4,(t=Y(n,"condition","whereAsync","bool")).data()];case 1:return e=a.sent(),r=GE(t.shape,e),n!==t&&t.dispose(),[2,r]}}))}))},$e=st({add_:function(n,t){var e,r=Y(n,"a","add"),a=Y(t,"b","add");e=Mn(r,a),r=e[0],a=e[1];var s=Le(r.shape,a.shape);return lt.runKernelFunc((function(o){return o.add(r,a)}),{a:r,b:a},(function(o){return{a:function(){var i=o,u=Sr(r.shape,s);return u.length>0&&(i=i.sum(u)),i.reshape(r.shape)},b:function(){var i=o,u=Sr(a.shape,s);return u.length>0&&(i=i.sum(u)),i.reshape(a.shape)}}}),"Add")}}),Fst=st({addN_:function(n){Z(Array.isArray(n),(function(){return"The argument passed to tf.addN() must be a list of tensors"})),Z(n.length>=1,(function(){return"Must pass at least one tensor to tf.addN(), but got "+n.length}));var t=n.map((function(a,s){return Y(a,"tensors"+s,"addN")})),e=t[0];t.forEach((function(a){if(a.dtype!==e.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")})),t.forEach((function(a){if(!Fr(a.shape,e.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")}));var r=t;return lt.runKernelFunc((function(a){return a.addN(t)}),r,(function(a){var s={};return t.forEach((function(o,i){s[i]=function(){return a.clone()}})),s}),"AddN")}}),Mst=st({addStrict_:function(n,t){var e=Y(n,"a","addStrict"),r=Y(t,"b","addStrict");return Je(e.shape,r.shape,"Error in addStrict: "),e.add(r)}}),Lst=st({atan2_:function(n,t){var e,r=Y(n,"a","atan2"),a=Y(t,"b","atan2");e=Mn(r,a),r=e[0],a=e[1];var s=Le(r.shape,a.shape);return lt.runKernelFunc((function(o,i){var u=o.atan2(r,a);return i([r,a]),u}),{$a:r,$b:a},(function(o,i){var u=i[0],l=i[1];return{$a:function(){var h=$e(u.square(),l.square()),d=o.mul(l.div(h)),f=Sr(u.shape,s);return f.length>0&&(d=d.sum(f)),d.reshape(u.shape)},$b:function(){var h=$e(u.square(),l.square()),d=ob(o.mul(u.div(h))),f=Sr(l.shape,s);return f.length>0&&(d=d.sum(f)),d.reshape(l.shape)}}}))}}),Js=st({div_:function(n,t){var e,r=Y(n,"a","div"),a=Y(t,"b","div");if(e=Mn(r,a),r=e[0],a=e[1],r.dtype==="int32"&&a.dtype==="int32")return Az(r,a);var s=Le(r.shape,a.shape);return lt.runKernelFunc((function(o,i){var u=o.realDivide(r,a);return i([r,a]),u}),{a:r,b:a},(function(o,i){var u=i[0],l=i[1];return{a:function(){var h=o.div(l.toFloat()),d=Sr(u.shape,s);return d.length>0?h.sum(d).reshape(u.shape):h},b:function(){var h=o.mul(u.toFloat()),d=Sr(l.shape,s);d.length>0&&(h=h.sum(d).reshape(l.shape));var f=l.square();return h.div(f.toFloat()).neg()}}}),"Div")}}),Bst=st({divNoNan_:function(n,t){var e,r=Y(n,"a","div"),a=Y(t,"b","div");r=(e=Mn(r,a))[0],a=e[1];var s=Js(r,a),o=He(s),i=a.equal(o);return uc(i,o,s)}}),zst=st({divStrict_:function(n,t){var e=Y(n,"a","div"),r=Y(t,"b","div");return Je(e.shape,r.shape,"Error in divideStrict: "),e.div(r)}}),Az=st({floorDiv_:function(n,t){var e,r=Y(n,"a","floorDiv"),a=Y(t,"b","floorDiv");e=Mn(r,a),r=e[0],a=e[1];var s=Le(r.shape,a.shape);return lt.runKernelFunc((function(o,i){var u=o.floorDiv(r,a);return i([r,a]),u}),{a:r,b:a},(function(o,i){var u=i[0],l=i[1];return{a:function(){var h=o.div(l.toFloat()),d=Sr(u.shape,s);return d.length>0?h.sum(d).reshape(u.shape):h},b:function(){var h=o.mul(u.toFloat()),d=Sr(l.shape,s);d.length>0&&(h=h.sum(d).reshape(l.shape));var f=l.square();return h.div(f.toFloat()).neg()}}}),"FloorDiv")}}),XE=st({maximum_:function(n,t){var e,r=Y(n,"a","maximum"),a=Y(t,"b","maximum");return e=Mn(r,a),r=e[0],a=e[1],r.dtype==="bool"&&(r=r.toInt(),a=a.toInt()),Le(r.shape,a.shape),lt.runKernelFunc((function(s,o){var i=s.maximum(r,a);return o([r,a]),i}),{a:r,b:a},(function(s,o){var i=o[0],u=o[1];return{a:function(){return s.mul(i.greaterEqual(u).toFloat())},b:function(){return s.mul(i.less(u).toFloat())}}}),"Maximum")}}),Pst=st({maximumStrict_:function(n,t){var e=Y(n,"a","maximumStrict"),r=Y(t,"b","maximumStrict");return Je(e.shape,r.shape,"Error in maximumStrict: "),e.maximum(r)}}),Dz=st({minimum_:function(n,t){var e,r=Y(n,"a","minimum"),a=Y(t,"b","minimum");return e=Mn(r,a),r=e[0],a=e[1],r.dtype==="bool"&&(r=r.toInt(),a=a.toInt()),Le(r.shape,a.shape),lt.runKernelFunc((function(s,o){var i=s.minimum(r,a);return o([r,a]),i}),{a:r,b:a},(function(s,o){var i=o[0],u=o[1];return{a:function(){return s.mul(i.lessEqual(u).toFloat())},b:function(){return s.mul(i.greater(u).toFloat())}}}),"Minimum")}}),Vst=st({minimumStrict_:function(n,t){var e=Y(n,"a","minimumStrict"),r=Y(t,"b","minimumStrict");return Je(e.shape,r.shape,"Error in minimumStrict: "),e.minimum(r)}}),Ust=st({mod_:function(n,t){var e,r=Y(n,"a","mod"),a=Y(t,"b","mod");e=Mn(r,a),r=e[0],a=e[1];var s=Le(r.shape,a.shape);return lt.runKernelFunc((function(o,i){var u=o.mod(r,a);return i([r,a]),u}),{$a:r,$b:a},(function(o,i){var u=i[0],l=i[1];return{$a:function(){var h=Sr(u.shape,s);return h.length>0?o.sum(h).reshape(u.shape):o},$b:function(){var h=o.mul(u.div(l).floor().neg()),d=Sr(l.shape,s);return d.length>0?h.sum(d).reshape(l.shape):h}}}))}}),Wst=st({modStrict_:function(n,t){var e=Y(n,"a","modStrict"),r=Y(t,"b","modStrict");return Je(e.shape,r.shape,"Error in modStrict: "),e.mod(r)}}),da=st({mul_:function(n,t){var e,r=Y(n,"a","mul"),a=Y(t,"b","mul");e=Mn(r,a),r=e[0],a=e[1];var s=Le(r.shape,a.shape);return lt.runKernelFunc((function(o,i){var u=o.multiply(r,a);return i([r,a]),u}),{a:r,b:a},(function(o,i){var u=i[0],l=i[1];return{a:function(){var h=o.mul(l.toFloat()),d=Sr(u.shape,s);return d.length>0?h.sum(d).reshape(u.shape):h},b:function(){var h=o.mul(u.toFloat()),d=Sr(l.shape,s);return d.length>0?h.sum(d).reshape(l.shape):h}}}),"Mul")}}),Gst=st({mulStrict_:function(n,t){var e=Y(n,"a","mul"),r=Y(t,"b","mul");return Je(e.shape,r.shape,"Error in multiplyStrict: "),e.mul(r)}}),ib=st({pow_:function(n,t){var e,r=Y(n,"base","pow"),a=Y(t,"exp","pow");e=Mn(r,a),r=e[0],a=e[1];var s=Le(r.shape,a.shape),o=[r,a];return lt.runKernelFunc((function(i,u){var l=i.pow(r,a);return u([r,a,l]),l}),{a:r,b:a},(function(i,u){var l=u[0],h=u[1],d=u[2];return{a:function(){var f=h.toFloat(),m=i.mul(f.mul(l.pow(f.sub(Pt(1))))),v=Sr(l.shape,s);return v.length>0&&(m=m.sum(v)),m.reshape(l.shape)},b:function(){var f=l.greater(0),m=l.log().where(f,He(l)),v=i.mul(d.mul(m)),y=Sr(h.shape,s);return y.length>0&&(v=v.sum(y)),v.reshape(h.shape)}}}),"Pow",{},o,[!0])}}),Hst=st({powStrict_:function(n,t){return Je(n.shape,t.shape,"Error in powStrict: "),n.pow(t)}}),jst=st({squaredDifferenceStrict_:function(n,t){var e=Y(n,"a","squaredDifferenceStrict"),r=Y(t,"b","squaredDifferenceStrict");return Je(e.shape,r.shape,"Error in squaredDifferenceStrict: "),e.squaredDifference(r)}}),Cr=st({sub_:function(n,t){var e,r=Y(n,"a","sub"),a=Y(t,"b","sub");e=Mn(r,a),r=e[0],a=e[1];var s=Le(r.shape,a.shape);return lt.runKernelFunc((function(o){return o.subtract(r,a)}),{a:r,b:a},(function(o){return{a:function(){var i=o,u=Sr(r.shape,s);return u.length>0&&(i=i.sum(u)),i.reshape(r.shape)},b:function(){var i=o,u=Sr(a.shape,s);return u.length>0&&(i=i.sum(u)),i.neg().reshape(a.shape)}}}),"Sub")}}),qst=st({subStrict_:function(n,t){var e=Y(n,"a","subStrict"),r=Y(t,"b","subStrict");return Je(e.shape,r.shape,"Error in subStrict: "),e.sub(r)}}),$z=st({equal_:function(n,t){var e,r=Y(n,"a","equal"),a=Y(t,"b","equal");return e=Mn(r,a),r=e[0],a=e[1],Le(r.shape,a.shape),lt.runKernelFunc((function(s){return s.equal(r,a)}),{$a:r,$b:a})}}),Kst=st({equalStrict_:function(n,t){var e=Y(n,"a","equalStrict"),r=Y(t,"b","equalStrict");return Je(e.shape,r.shape,"Error in equalStrict: "),e.equal(r)}}),Xst=st({greater_:function(n,t){var e,r=Y(n,"a","greater"),a=Y(t,"b","greater");return e=Mn(r,a),r=e[0],a=e[1],Le(r.shape,a.shape),lt.runKernelFunc((function(s){return s.greater(r,a)}),{a:r,b:a},null,"Greater")}}),Oz=st({greaterEqual_:function(n,t){var e,r=Y(n,"a","greaterEqual"),a=Y(t,"b","greaterEqual");return e=Mn(r,a),r=e[0],a=e[1],Le(r.shape,a.shape),lt.runKernelFunc((function(s,o){var i=s.greaterEqual(r,a);return o([r,a]),i}),{a:r,b:a},(function(s,o){var i=o[0],u=o[1];return{a:function(){return He(i)},b:function(){return He(u)}}}),"GreaterEqual")}}),Yst=st({greaterEqualStrict_:function(n,t){var e=Y(n,"a","greaterEqualStrict"),r=Y(t,"b","greaterEqualStrict");return Je(e.shape,r.shape,"Error in greaterEqualStrict: "),e.greaterEqual(r)}}),Qst=st({greaterStrict_:function(n,t){var e=Y(n,"a","greaterStrict"),r=Y(t,"b","greaterStrict");return Je(e.shape,r.shape,"Error in greaterStrict: "),e.greater(r)}}),Zst=st({less_:function(n,t){var e,r=Y(n,"a","less"),a=Y(t,"b","less");return e=Mn(r,a),r=e[0],a=e[1],Le(r.shape,a.shape),lt.runKernelFunc((function(s){return s.less(r,a)}),{a:r,b:a},null,"Less")}}),Jst=st({lessEqual_:function(n,t){var e,r=Y(n,"a","lessEqual"),a=Y(t,"b","lessEqual");return e=Mn(r,a),r=e[0],a=e[1],Le(r.shape,a.shape),lt.runKernelFunc((function(s,o){var i=s.lessEqual(r,a);return o([r,a]),i}),{a:r,b:a},null,"LessEqual")}}),tot=st({lessEqualStrict_:function(n,t){var e=Y(n,"a","lessEqualStrict"),r=Y(t,"b","lessEqualStrict");return Je(e.shape,r.shape,"Error in lessEqualStrict: "),e.lessEqual(r)}}),eot=st({lessStrict_:function(n,t){var e=Y(n,"a","lessStrict"),r=Y(t,"b","lessStrict");return Je(e.shape,r.shape,"Error in lessStrict: "),e.less(r)}}),not=st({notEqual_:function(n,t){var e,r=Y(n,"a","notEqual"),a=Y(t,"b","notEqual");return e=Mn(r,a),r=e[0],a=e[1],Le(r.shape,a.shape),lt.runKernelFunc((function(s){return s.notEqual(r,a)}),{a:r,b:a},null,"NotEqual")}}),rot=st({notEqualStrict_:function(n,t){var e=Y(n,"a","notEqualStrict"),r=Y(t,"b","notEqualStrict");return Je(e.shape,r.shape,"Error in notEqualStrict: "),e.notEqual(r)}});function k3(n,t){for(var e=[],r=n;r<t;++r)e.push(r);return e}function T3(n){for(var t=[],e=0;e<n.length;++e)for(var r=0;r<n[e].length;++r)t.push(n[e][r]);return t}var YE=st({gather_:function(n,t,e){e===void 0&&(e=0);var r=Y(n,"x","gather"),a=Y(t,"indices","gather","int32");e=Tr(e,r.shape)[0];var s=(function(o,i,u){for(var l=o.shape[u],h=[],d=1,f=1,m=0;m<u;m++)h.push(o.shape[m]),d*=o.shape[m];for(m=0;m<i.rank;m++)h.push(i.shape[m]);for(m=u+1;m<o.rank;m++)h.push(o.shape[m]),f*=o.shape[m];return{batchSize:d,sliceSize:f,dimSize:l,outputShape:h}})(r,a,e);return lt.runKernelFunc((function(o,i){var u=o.gather(r,a.flatten(),e);return i([a]),u}),{x:r,indices:a},(function(o,i){var u=i[0];return{x:function(){var l=r.shape,h=u.size,d=l.slice(0,e),f=d.length,m=l.slice(e,l.length).slice(1),v=m.length,y=k3(0,f),b=k3(f+1,f+1+v),w=T3([d,[h],m]),S=o.reshape(w),N=u.reshape([h]),C=T3([[f],y,b]),T=S.transpose(C),I=Fz(T,N,r.shape[e]),_=ME(C);return I=I.transpose(_)},indices:function(){return u}}}),"Gather",{axis:e}).reshape(s.outputShape)}}),Fz=st({unsortedSegmentSum_:function(n,t,e){var r=Y(n,"x","unsortedSegmentSum"),a=Y(t,"segmentIds","unsortedSegmentSum","int32");return Z(Qn(e),(function(){return"numSegments must be of dtype int"})),lt.runKernelFunc((function(s,o){var i=s.unsortedSegmentSum(r,a,e);return o([a]),i}),{$x:r},(function(s,o){var i=o[0];return{$x:function(){return(function(u,l){for(var h=XE(l,He(l)),d=YE(u,h),f=Oz(l,Pt(0,"int32")),m=d.rank-f.rank,v=0;v<m;++v)f=Ms(f,v+1);f=M1(f,fp(d.shape,"bool"));var y=He(d);return uc(f,d,y)})(s,i)}}}))}}),aot=function(n,t,e){return Yt(this,void 0,void 0,(function(){var r,a,s,o,i,u,l,h,d,f,m,v,y;return Qt(this,(function(b){switch(b.label){case 0:for(r=Y(n,"tensor","boolMask"),a=Y(t,"mask","boolMask","bool"),s=e??0,o=a.rank,i=r.shape,Z(o>0,(function(){return"mask cannot be scalar"})),Je(i.slice(s,s+o),a.shape,"mask's shape must match the first K dimensions of tensor's shape,"),u=1,l=s;l<s+o;l++)u*=i[l];return h=i.slice(0,s).concat([u],i.slice(s+o)),d=r.reshape(h),f=a.reshape([-1]),[4,Rz(f)];case 1:return m=b.sent(),v=m.squeeze([1]),y=YE(d,v,s),n!==r&&r.dispose(),t!==a&&a.dispose(),v.dispose(),d.dispose(),f.dispose(),m.dispose(),[2,y]}}))}))};function Mz(n,t,e,r,a,s,o){s===void 0&&(s="NHWC"),Z(n.length===t.rank,(function(){return"Length of inShape ("+n.length+") and rank of dy ("+t.rank+") must match"}));var i=n,u=t,l=!1;t.rank===3&&(l=!0,u=t.as4D(1,t.shape[0],t.shape[1],t.shape[2]),i=[1,n[0],n[1],n[2]]),Z(i.length===4,(function(){return"Error in conv2dDerInput: inShape must be length 4, but got length "+i.length+"."})),Z(u.rank===4,(function(){return"Error in conv2dDerInput: dy must be rank 4, but got rank "+u.rank})),Z(e.rank===4,(function(){return"Error in conv2dDerInput: filter must be rank 4, but got rank "+e.rank}));var h=s==="NHWC"?i[3]:i[1],d=s==="NHWC"?u.shape[3]:u.shape[1];Z(h===e.shape[2],(function(){return"Error in conv2dDerInput: depth of input ("+h+") must match input depth for filter "+e.shape[2]+"."})),Z(d===e.shape[3],(function(){return"Error in conv2dDerInput: depth of output ("+d+") must match output depth for filter "+e.shape[3]+"."})),o!=null&&Z(Qn(a),(function(){return"Error in conv2dDerInput: pad must be an integer when using, dimRoundingMode "+o+" but got pad "+a+"."}));var f=VE(s),m=kc(i,e.shape,r,1,a,o,!1,f),v=lt.runKernelFunc((function(y,b){var w=y.conv2dDerInput(u,e,m);return b([e,u]),w}),{dy4D:u,filter:e},(function(y,b){var w=b[0],S=b[1];return{dy4D:function(){return Us(y,w,r,a,s,1,o)},filter:function(){return QE(y,S,w.shape,r,a,s,o)}}}));return l?v.as3D(v.shape[1],v.shape[2],v.shape[3]):v}function iC(n){var t=(function(s){return typeof s=="number"?[s,s,s]:s.length===2?[s[0],s[1],1]:s})(n),e=t[0],r=t[1],a=t[2];return e===1&&r===1&&a===1}function Lz(n,t,e,r,a){Z(n.length===t.rank,(function(){return"Length of inShape ("+n.length+") and rank of dy ("+t.rank+") must match"}));var s=n,o=t,i=!1;t.rank===4&&(i=!0,o=t.as5D(1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]),s=[1,n[0],n[1],n[2],n[3]]);var u=s[4],l=o.shape[4];Z(s.length===5,(function(){return"Error in conv3dDerInput: inShape must be length 5, but got length "+s.length+"."})),Z(o.rank===5,(function(){return"Error in conv3dDerInput: dy must be rank 5, but got rank "+o.rank})),Z(e.rank===5,(function(){return"Error in conv3dDerInput: filter must be rank 5, but got rank "+e.rank})),Z(u===e.shape[3],(function(){return"Error in conv3dDerInput: depth of input ("+u+") must match input depth for filter "+e.shape[3]+"."})),Z(l===e.shape[4],(function(){return"Error in conv3dDerInput: depth of output ("+l+") must match output depth for filter "+e.shape[4]+"."}));var h=ab(s,e.shape,r,1,a),d=lt.runKernelFunc((function(f){return f.conv3dDerInput(o,e,h)}),{dy5D:o});return i?d.as4D(d.shape[1],d.shape[2],d.shape[3],d.shape[4]):d}var sot=st({conv1d_:function(n,t,e,r,a,s,o){a===void 0&&(a="NWC"),s===void 0&&(s=1);var i=Y(n,"x","conv1d"),u=Y(t,"filter","conv1d"),l=i,h=!1;i.rank===2&&(h=!0,l=i.as3D(1,i.shape[0],i.shape[1])),Z(l.rank===3,(function(){return"Error in conv1d: input must be rank 3, but got rank "+l.rank+"."})),Z(u.rank===3,(function(){return"Error in conv1d: filter must be rank 3, but got rank "+u.rank+"."})),o!=null&&Z(Qn(r),(function(){return"Error in conv1d: pad must be an integer when using, dimRoundingMode "+o+" but got pad "+r+"."})),Z(l.shape[2]===u.shape[1],(function(){return"Error in conv1d: depth of input ("+l.shape[2]+") must match input depth for filter "+u.shape[1]+"."})),Z(qa(e,s),(function(){return"Error in conv1D: Either stride or dilation must be 1. Got stride "+e+" and dilation '"+s+"'"})),Z(a==="NWC",(function(){return"Error in conv1d: got dataFormat of "+a+" but only NWC is currently supported."}));var d=u.as4D(1,u.shape[0],u.shape[1],u.shape[2]),f=l.as4D(l.shape[0],1,l.shape[1],l.shape[2]),m=Us(f,d,[1,e],r,"NHWC",[1,s],o);return h?m.as2D(m.shape[2],m.shape[3]):m.as3D(m.shape[0],m.shape[2],m.shape[3])}}),Us=st({conv2d_:function(n,t,e,r,a,s,o){a===void 0&&(a="NHWC"),s===void 0&&(s=[1,1]);var i=Y(n,"x","conv2d"),u=Y(t,"filter","conv2d"),l=i,h=!1;i.rank===3&&(h=!0,l=i.as4D(1,i.shape[0],i.shape[1],i.shape[2])),Z(l.rank===4,(function(){return"Error in conv2d: input must be rank 4, but got rank "+l.rank+"."})),Z(u.rank===4,(function(){return"Error in conv2d: filter must be rank 4, but got rank "+u.rank+"."})),o!=null&&Z(Qn(r),(function(){return"Error in conv2d: pad must be an integer when using, dimRoundingMode "+o+" but got pad "+r+"."}));var d=a==="NHWC"?l.shape[3]:l.shape[1];Z(d===u.shape[2],(function(){return"Error in conv2d: depth of input ("+d+") must match input depth for filter "+u.shape[2]+"."})),Z(qa(e,s),(function(){return"Error in conv2D: Either strides or dilations must be 1. Got strides "+e+" and dilations '"+s+"'"}));var f=VE(a),m=kc(l.shape,u.shape,e,s,r,o,!1,f),v=[u,l],y=lt.runKernelFunc((function(b,w){var S=b.conv2d(l,u,m);return w([u,l]),S}),{x:l,filter:u},(function(b,w){var S=w,N=S[0],C=S[1];return Z(ad(s),(function(){return"Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '"+s+"'"})),{x:function(){return Bz(C.shape,b,N,e,r,a)},filter:function(){return QE(C,b,N.shape,e,r,a)}}}),"Conv2D",m,v);return h?y.as3D(y.shape[1],y.shape[2],y.shape[3]):y}}),oot=st({conv3d_:function(n,t,e,r,a,s){a===void 0&&(a="NDHWC"),s===void 0&&(s=[1,1,1]);var o=Y(n,"x","conv3d"),i=Y(t,"filter","conv3d"),u=o,l=!1;o.rank===4&&(l=!0,u=o.as5D(1,o.shape[0],o.shape[1],o.shape[2],o.shape[3])),Z(u.rank===5,(function(){return"Error in conv3d: input must be rank 5, but got rank "+u.rank+"."})),Z(i.rank===5,(function(){return"Error in conv3d: filter must be rank 5, but got rank "+i.rank+"."})),Z(u.shape[4]===i.shape[3],(function(){return"Error in conv3d: depth of input ("+u.shape[4]+") must match input depth for filter "+i.shape[3]+"."})),Z((function(f,m){return iC(f)||iC(m)})(e,s),(function(){return"Error in conv3D: Either strides or dilations must be 1. Got strides "+e+" and dilations '"+s+"'"})),Z(a==="NDHWC",(function(){return"Error in conv3d: got dataFormat of "+a+" but only NDHWC is currently supported."}));var h=ab(u.shape,i.shape,e,s,r),d=lt.runKernelFunc((function(f,m){var v=f.conv3d(u,i,h);return m([u,i]),v}),{x:u,$filter:i},(function(f,m){Z(iC(s),(function(){return"Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '"+s+"'"}));var v=m[0],y=m[1];return{x:function(){return Lz(v.shape,f,y,e,r)},$filter:function(){return(function(b,w,S,N,C){var T=b;b.rank===4&&(T=b.as5D(1,b.shape[0],b.shape[1],b.shape[2],b.shape[3]));var I=w;I.rank===4&&(I=w.as5D(1,w.shape[0],w.shape[1],w.shape[2],w.shape[3])),Z(T.rank===5,(function(){return"Error in conv3dDerFilter: input must be rank 5, but got shape "+T.shape+"."})),Z(I.rank===5,(function(){return"Error in conv3dDerFilter: dy must be rank 5, but got shape "+I.shape+"."})),Z(S.length===5,(function(){return"Error in conv3dDerFilter: filterShape must be length 5, but got "+S+"."})),Z(T.shape[4]===S[3],(function(){return"Error in conv3dDerFilter: depth of input "+T.shape[4]+") must match input depth in filter ("+S[3]+"."})),Z(I.shape[4]===S[4],(function(){return"Error in conv3dDerFilter: depth of dy ("+I.shape[4]+") must match output depth for filter ("+S[4]+")."}));var _=ab(T.shape,S,N,1,C);return lt.runKernelFunc((function($){return $.conv3dDerFilter(T,I,_)}),{x5D:T,dy5D:I})})(v,f,y.shape,e,r)}}}));return l?d.as4D(d.shape[1],d.shape[2],d.shape[3],d.shape[4]):d}}),QE=st({conv2dDerFilter_:function(n,t,e,r,a,s,o){s===void 0&&(s="NHWC");var i=n;n.rank===3&&(i=n.as4D(1,n.shape[0],n.shape[1],n.shape[2]));var u=t;u.rank===3&&(u=t.as4D(1,t.shape[0],t.shape[1],t.shape[2])),Z(i.rank===4,(function(){return"Error in conv2dDerFilter: input must be rank 4, but got shape "+i.shape+"."})),Z(u.rank===4,(function(){return"Error in conv2dDerFilter: dy must be rank 4, but got shape "+u.shape+"."})),Z(e.length===4,(function(){return"Error in conv2dDerFilter: filterShape must be length 4, but got "+e+"."}));var l=s==="NHWC"?i.shape[3]:i.shape[1],h=s==="NHWC"?u.shape[3]:u.shape[1];Z(l===e[2],(function(){return"Error in conv2dDerFilter: depth of input "+l+") must match input depth in filter ("+e[2]+"."})),Z(h===e[3],(function(){return"Error in conv2dDerFilter: depth of dy ("+h+") must match output depth for filter ("+e[3]+")."})),o!=null&&Z(Qn(a),(function(){return"Error in conv2dDerFilter: pad must be an integer when using, dimRoundingMode "+o+" but got pad "+a+"."}));var d=VE(s),f=kc(i.shape,e,r,1,a,o,!1,d);return lt.runKernelFunc((function(m){return m.conv2dDerFilter(i,u,f)}),{x4D:i,dy4D:u})}}),Bz=st({conv2dDerInput_:Mz}),L1=st({depthwiseConv2d_:function(n,t,e,r,a,s,o){s===void 0&&(s=[1,1]);var i=Y(n,"x","depthwiseConv2d"),u=Y(t,"filter","depthwiseConv2d"),l=i,h=!1;i.rank===3&&(h=!0,l=i.as4D(1,i.shape[0],i.shape[1],i.shape[2])),Z(l.rank===4,(function(){return"Error in depthwiseConv2d: input must be rank 4, but got rank "+l.rank+"."})),Z(u.rank===4,(function(){return"Error in depthwiseConv2d: filter must be rank 4, but got rank "+u.rank+"."})),Z(l.shape[3]===u.shape[2],(function(){return"Error in depthwiseConv2d: number of input channels ("+l.shape[3]+") must match the inChannels dimension in filter "+u.shape[2]+"."})),s==null&&(s=[1,1]),Z(qa(e,s),(function(){return"Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides "+e+" and dilations '"+s+"'"})),o!=null&&Z(Qn(r),(function(){return"Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode "+o+" but got pad "+r+"."}));var d=kc(l.shape,u.shape,e,s,r,o,!0),f=[l,u],m=lt.runKernelFunc((function(v,y){var b=v.depthwiseConv2D(l,u,d);return y([l,u]),b}),{x:l,filter:u},(function(v,y){Z(ad(s),(function(){return"Error in gradient of depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '"+s+"'"}));var b=y[0],w=y[1];return{x:function(){return zz(b.shape,v,w,d)},filter:function(){return Pz(b,v,w.shape,d)}}}),"DepthwiseConv2dNative",d,f);return h?m.as3D(m.shape[1],m.shape[2],m.shape[3]):m}}),zz=st({depthwiseConv2dDerInput_:function(n,t,e,r){var a=t,s=!1;t.rank===3&&(s=!0,a=t.as4D(1,t.shape[0],t.shape[1],t.shape[2]));var o=lt.runKernelFunc((function(i){return i.depthwiseConv2DDerInput(a,e,r)}),{dy4D:a});return s?o.as3D(o.shape[1],o.shape[2],o.shape[3]):o}}),Pz=st({depthwiseConv2dDerFilter_:function(n,t,e,r){var a=n;n.rank===3&&(a=n.as4D(1,n.shape[0],n.shape[1],n.shape[2]));var s=t;return s.rank===3&&(s=t.as4D(1,t.shape[0],t.shape[1],t.shape[2])),lt.runKernelFunc((function(o){return o.depthwiseConv2DDerFilter(a,s,r)}),{x4D:a,dy4D:s})}}),ZE=st({separableConv2d_:function(n,t,e,r,a,s,o){s===void 0&&(s=[1,1]),o===void 0&&(o="NHWC");var i=Y(n,"x","separableConv2d"),u=Y(t,"depthwiseFilter","separableConv2d"),l=Y(e,"pointwiseFilter","separableConv2d"),h=i,d=!1;if(i.rank===3&&(d=!0,h=i.as4D(1,i.shape[0],i.shape[1],i.shape[2])),o==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");Z(h.rank===4,(function(){return"Error in separableConv2d: input must be rank 4, but got rank "+h.rank+"."})),Z(u.rank===4,(function(){return"Error in separableConv2d: depthwise filter must be rank 4, but got rank "+u.rank+"."})),Z(l.rank===4,(function(){return"Error in separableConv2d: pointwise filter must be rank 4, but got rank "+u.rank+"."})),Z(l.shape[0]===1,(function(){return"Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got "+l.shape[0]+"."})),Z(l.shape[1]===1,(function(){return"Error in separableConv2d: the second dimension of pointwise filter must be 1, but got "+l.shape[1]+"."}));var f=u.shape[2],m=u.shape[3];Z(l.shape[2]===f*m,(function(){return"Error in separableConv2d: the third dimension of pointwise filter must be "+f*m+", but got "+l.shape[2]+"."}));var v=L1(h,u,r,a,o,s),y=Us(v,l,1,"valid",o);return d?y.as3D(y.shape[1],y.shape[2],y.shape[3]):y}}),iot=st({conv2dTranspose_:function(n,t,e,r,a,s){return Mz(e,Y(n,"x","conv2dTranspose"),Y(t,"filter","conv2dTranspose"),r,a,"NHWC",s)}}),uot=st({conv3dTranspose_:function(n,t,e,r,a){return Lz(e,Y(n,"x","conv3dTranspose"),Y(t,"filter","conv3dTranspose"),r,a)}}),B1=st({matMul_:function(n,t,e,r){var a;e===void 0&&(e=!1),r===void 0&&(r=!1);var s=Y(n,"a","matMul"),o=Y(t,"b","matMul");a=Mn(s,o),s=a[0],o=a[1];var i=e?s.shape[s.rank-2]:s.shape[s.rank-1],u=r?o.shape[o.rank-1]:o.shape[o.rank-2],l=e?s.shape[s.rank-1]:s.shape[s.rank-2],h=r?o.shape[o.rank-2]:o.shape[o.rank-1],d=s.shape.slice(0,-2),f=o.shape.slice(0,-2),m=ee(d),v=ee(f);Z(s.rank>=2&&o.rank>=2&&s.rank===o.rank,(function(){return"Error in matMul: inputs must have the same rank of at least 2, got ranks "+s.rank+" and "+o.rank+"."})),Z(Fr(d,f),(function(){return"Error in matMul: outer dimensions ("+d+") and ("+f+") of Tensors with shapes "+s.shape+" and "+o.shape+" must match."})),Z(i===u,(function(){return"Error in matMul: inner shapes ("+i+") and ("+u+") of Tensors with shapes "+s.shape+" and "+o.shape+" and transposeA="+e+" and transposeB="+r+" must match."}));var y=s.shape.slice(0,-2).concat([l,h]),b=e?s.as3D(m,i,l):s.as3D(m,l,i),w=r?o.as3D(v,h,u):o.as3D(v,u,h),S={transposeA:e,transposeB:r};return lt.runKernelFunc((function(N,C){var T=N.batchMatMul(b,w,e,r);return C([b,w]),T}),{a:b,b:w},(function(N,C){var T=C,I=T[0],_=T[1];return e||r?!e&&r?{a:function(){return N.matMul(_,!1,!1)},b:function(){return N.matMul(I,!0,!1)}}:e&&!r?{a:function(){return _.matMul(N,!1,!0)},b:function(){return I.matMul(N,!1,!1)}}:{a:function(){return _.matMul(N,!0,!0)},b:function(){return N.matMul(I,!0,!0)}}:{a:function(){return N.matMul(_,!1,!0)},b:function(){return I.matMul(N,!0,!1)}}}),"BatchMatMul",S).reshape(y)}}),lot=st({dot_:function(n,t){var e=Y(n,"t1","dot"),r=Y(t,"t2","dot");Z(!(e.rank!==1&&e.rank!==2||r.rank!==1&&r.rank!==2),(function(){return"Error in dot: inputs must all be rank 1 or 2, but got ranks "+e.rank+" and "+r.rank+"."}));var a=e.rank===1?e.size:e.shape[1],s=r.rank===1?r.size:r.shape[0];return Z(a===s,(function(){return"Error in dot: inner dimensions of inputs must match, but got "+a+" and "+s+"."})),e.rank===1&&r.rank===1?e.as2D(1,-1).matMul(r.as2D(-1,1)).asScalar():e.rank===1&&r.rank===2?e.as2D(1,-1).matMul(r.as2D(r.shape[0],r.shape[1])).as1D():e.rank===2&&r.rank===1?e.matMul(r.as2D(-1,1)).as1D():e.matMul(r.as2D(r.shape[0],r.shape[1]))}}),cot=st({outerProduct_:function(n,t){var e=Y(n,"v1","outerProduct"),r=Y(t,"v2","outerProduct");return Z(e.rank===1&&r.rank===1,(function(){return"Error in outerProduct: inputs must be rank 1, but got ranks "+e.rank+" and "+r.rank+"."})),e.as2D(-1,1).matMul(r.as2D(1,-1))}}),Zg=st({reverse_:function(n,t){var e=Y(n,"x","reverse");if(e.rank===0)return e.clone();var r=Tr(t,e.shape);return lt.runKernelFunc((function(a){return a.reverse(e,r)}),{$x:e},(function(a){return{$x:function(){return a.reverse(r)}}})).reshapeAs(e)}}),hot=st({reverse1d_:function(n){var t=Y(n,"x","reverse");return Z(t.rank===1,(function(){return"Error in reverse1D: x must be rank 1 but got rank "+t.rank+"."})),Zg(t,0)}}),dot=st({reverse2d_:function(n,t){var e=Y(n,"x","reverse");return Z(e.rank===2,(function(){return"Error in reverse2D: x must be rank 2 but got rank "+e.rank+"."})),Zg(e,t)}}),pot=st({reverse3d_:function(n,t){var e=Y(n,"x","reverse");return Z(e.rank===3,(function(){return"Error in reverse3D: x must be rank 3 but got rank "+e.rank+"."})),Zg(e,t)}}),fot=st({reverse4d_:function(n,t){var e=Y(n,"x","reverse");return Z(e.rank===4,(function(){return"Error in reverse4D: x must be rank 4 but got rank "+e.rank+"."})),Zg(e,t)}});function Vz(n,t,e,r,a,s){var o=Y(n,"x","maxPool"),i=o,u=!1;o.rank===3&&(u=!0,i=o.as4D(1,o.shape[0],o.shape[1],o.shape[2])),Z(i.rank===4,(function(){return"Error in maxPool: input must be rank 4 but got rank "+i.rank+"."})),Z(qa(e,r),(function(){return"Error in maxPool: Either strides or dilations must be 1. Got strides "+e+" and dilations '"+r+"'"})),s!=null&&Z(Qn(a),(function(){return"Error in maxPool: pad must be an integer when using, dimRoundingMode "+s+" but got pad "+a+"."}));var l=im(i.shape,t,e,r,a,s);if(l.filterWidth===1&&l.filterHeight===1&&Fr(l.inShape,l.outShape))return o.clone();var h=[i],d=lt.runKernelFunc((function(f,m){var v=f.maxPool(i,l);return m([i,v]),v}),{x:i},(function(f,m){var v=m[0],y=m[1];return{x:function(){return(function(b,w,S,N,C,T,I,_){var $=Y(b,"dy","maxPoolBackprop"),R=Y(w,"input","maxPoolBackprop"),D=Y(S,"output","maxPoolBackprop");Z(R.rank===$.rank,(function(){return"Rank of input ("+R.rank+") does not match rank of dy ("+$.rank+")"})),Z(qa(C,T),(function(){return"Error in maxPoolBackProp: Either strides or dilations must be 1. Got strides "+C+" and dilations '"+T+"'"})),Z($.rank===4,(function(){return"Error in maxPoolBackprop: dy must be rank 4 but got rank "+$.rank+"."})),Z(R.rank===4,(function(){return"Error in maxPoolBackprop: input must be rank 4 but got rank "+R.rank+"."}));var A=im(R.shape,N,C,T,I,_);return lt.runKernelFunc((function(L){return L.maxPoolBackprop($,R,D,A)}),{$dy:$,$input:R})})(f,v,y,t,e,r,a)}}}),"MaxPool",l,h);return u?d.as3D(d.shape[1],d.shape[2],d.shape[3]):d}function Uz(n,t,e,r,a,s){var o=Y(n,"x","avgPool","float32");Z(qa(e,r),(function(){return"Error in avgPool: Either strides or dilations must be 1. Got strides "+e+" and dilations '"+r+"'"}));var i=o,u=!1;o.rank===3&&(u=!0,i=o.as4D(1,o.shape[0],o.shape[1],o.shape[2])),Z(i.rank===4,(function(){return"Error in avgPool: x must be rank 4 but got rank "+i.rank+"."})),s!=null&&Z(Qn(a),(function(){return"Error in avgPool: pad must be an integer when using, dimRoundingMode "+s+" but got pad "+a+"."}));var l=im(i.shape,t,e,r,a,s);if(l.filterWidth===1&&l.filterHeight===1&&Fr(l.inShape,l.outShape))return o.clone();var h=lt.runKernelFunc((function(d){return d.avgPool(i,l)}),{x:i},(function(d){return{x:function(){return(function(f,m,v,y,b,w){var S=Y(f,"dy","avgPoolBackprop"),N=Y(m,"input","avgPoolBackprop");Z(N.rank===S.rank,(function(){return"Rank of input ("+N.rank+") does not match rank of dy ("+S.rank+")"})),Z(qa(y,b),(function(){return"Error in avgPoolBackprop: Either strides or dilations must be 1. Got strides "+y+" and dilations '"+b+"'"}));var C=N,T=S,I=!1;N.rank===3&&(I=!0,C=N.as4D(1,N.shape[0],N.shape[1],N.shape[2]),T=S.as4D(1,S.shape[0],S.shape[1],S.shape[2])),Z(T.rank===4,(function(){return"Error in avgPoolBackprop: dy must be rank 4 but got rank "+T.rank+"."})),Z(C.rank===4,(function(){return"Error in avgPoolBackprop: input must be rank 4 but got rank "+C.rank+"."}));var _=im(C.shape,v,y,b,w),$=lt.runKernelFunc((function(R){return R.avgPoolBackprop(T,C,_)}),{dy4D:T,input4D:C});return I?$.as3D($.shape[1],$.shape[2],$.shape[3]):$})(d,i,t,e,r,a)}}}),"AvgPool",l);return h=h.cast(o.dtype),u?h.as3D(h.shape[1],h.shape[2],h.shape[3]):h}var Rr=st({maxPool_:function(n,t,e,r,a){return Vz(n,t,e,1,r,a)}}),Jg=st({avgPool_:function(n,t,e,r,a){return Uz(n,t,e,1,r,a)}}),mot=st({pool_:function(n,t,e,r,a,s){a==null&&(a=[1,1]),s==null&&(s=1),r===0&&(r="valid");var o=Y(n,"x","maxPool"),i=o,u=!1;o.rank===3&&(u=!0,i=o.as4D(1,o.shape[0],o.shape[1],o.shape[2])),Z(qa(s,a),(function(){return"Error in pool: Either strides or dilations must be 1. Got strides "+s+" and dilations '"+a+"'"}));var l,h=im(i.shape,t,s,a,r),d=[h.dilationHeight,h.dilationWidth];l=r==="same"?(function(C,T){var I=C.map((function(R,D){return R+(R-1)*(T[D]-1)})).map((function(R){return R-1})),_=I.map((function(R){return Math.floor(R/2)})),$=I.map((function(R,D){return R-_[D]}));return I.map((function(R,D){return[_[D],$[D]]}))})([h.filterHeight,h.filterWidth],d):[[0,0],[0,0]];var f=d[0]===1&&d[1]===1,m=(function(C,T,I){var _=I.map((function(G){return G[0]})),$=I.map((function(G){return G[1]})),R=C.concat(_,$),D=T.map((function(G,q){return(G-R[q]%G)%G})),A=$.map((function(G,q){return G+D[q]})),L=T.map((function(G,q){return[_[q],A[q]]})),H=T.map((function(G,q){return[0,D[q]]}));return[L,H]})([h.inHeight,h.inWidth],d,l),v=m[0],y=m[1],b=f?r:"valid",w=f?i:KB(i,d,v),S=(e==="avg"?function(){return Uz(w,t,s,1,b)}:function(){return Vz(w,t,s,1,b)})(),N=f?S:HB(S,d,y);return u?N.as3D(N.shape[1],N.shape[2],N.shape[3]):N}}),got=st({maxPool3d_:function(n,t,e,r,a,s,o){s===void 0&&(s="NDHWC");var i=Y(n,"x","maxPool3d"),u=i,l=!1;i.rank===4&&(l=!0,u=i.as5D(1,i.shape[0],i.shape[1],i.shape[2],i.shape[3])),o==null&&(o=[1,1,1]),Z(u.rank===5,(function(){return"Error in maxPool3d: x must be rank 5 but got rank "+u.rank+"."})),Z(s==="NDHWC",(function(){return"Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of "+s})),Z(qa(e,o),(function(){return"Error in maxPool3d: Either strides or dilations must be 1. Got strides "+e+" and dilations '"+o+"'"})),a!=null&&Z(Qn(r),(function(){return"Error in maxPool3d: pad must be an integer when using, dimRoundingMode "+a+" but got pad "+r+"."}));var h=rb(u.shape,t,e,o,r,a,s),d=lt.runKernelFunc((function(f,m){var v=f.maxPool3d(u,h);return m([u,v]),v}),{x:u},(function(f,m){var v=m[0],y=m[1];return{x:function(){return(function(b,w,S,N,C,T,I,_){var $=Y(b,"dy","maxPool3dBackprop"),R=Y(w,"input","maxPool3dBackprop"),D=Y(S,"output","maxPool3dBackprop"),A=$,L=R,H=D,G=!1;R.rank===4&&(G=!0,A=$.as5D(1,$.shape[0],$.shape[1],$.shape[2],$.shape[3]),L=R.as5D(1,R.shape[0],R.shape[1],R.shape[2],R.shape[3]),H=D.as5D(1,D.shape[0],D.shape[1],D.shape[2],D.shape[3])),Z(A.rank===5,(function(){return"Error in maxPool3dBackprop: dy must be rank 5 but got rank "+A.rank+"."})),Z(L.rank===5,(function(){return"Error in maxPool3dBackprop: input must be rank 5 but got rank "+L.rank+"."})),Z(H.rank===5,(function(){return"Error in maxPool3dBackprop: output must be rank 5 but got rank "+H.rank+"."})),T==null&&(T=[1,1,1]),Z(qa(C,T),(function(){return"Error in maxPool3dBackprop: Either strides or dilations must be 1. Got strides "+C+" and dilations '"+T+"'"})),_!=null&&Z(Qn(I),(function(){return"Error in maxPool3dBackprop: pad must be an integer when using, dimRoundingMode "+_+" but got pad "+I+"."}));var q=rb(L.shape,N,C,T,I,_),B=lt.runKernelFunc((function(j){return j.maxPool3dBackprop(A,L,H,q)}),{dy5D:A,input5D:L});return G?B.as4D(B.shape[1],B.shape[2],B.shape[3],B.shape[4]):B})(f,v,y,t,e,o,r,a)}}}));return l?d.as4D(d.shape[1],d.shape[2],d.shape[3],d.shape[4]):d}}),vot=st({avgPool3d_:function(n,t,e,r,a,s,o){s===void 0&&(s="NDHWC");var i=Y(n,"x","avgPool3d","float32"),u=i,l=!1;i.rank===4&&(l=!0,u=i.as5D(1,i.shape[0],i.shape[1],i.shape[2],i.shape[3])),o==null&&(o=[1,1,1]),Z(u.rank===5,(function(){return"Error in avgPool3d: x must be rank 5 but got rank "+u.rank+"."})),Z(s==="NDHWC",(function(){return"Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of "+s})),Z(qa(e,o),(function(){return"Error in avgPool3d: Either strides or dilations must be 1. Got strides "+e+" and dilations '"+o+"'"})),a!=null&&Z(Qn(r),(function(){return"Error in avgPool3d: pad must be an integer when using, dimRoundingMode "+a+" but got pad "+r+"."}));var h=rb(u.shape,t,e,o,r,a,s),d=lt.runKernelFunc((function(f){return f.avgPool3d(u,h)}),{x:u},(function(f){return{x:function(){return(function(m,v,y,b,w,S,N){var C=Y(m,"dy","avgPool3dBackprop"),T=Y(v,"input","avgPool3dBackprop"),I=C,_=T,$=!1;T.rank===4&&($=!0,I=C.as5D(1,C.shape[0],C.shape[1],C.shape[2],C.shape[3]),_=T.as5D(1,T.shape[0],T.shape[1],T.shape[2],T.shape[3])),Z(I.rank===5,(function(){return"Error in avgPool3dBackprop: dy must be rank 5 but got rank "+I.rank+"."})),Z(_.rank===5,(function(){return"Error in avgPool3dBackprop: input must be rank 5 but got rank "+_.rank+"."})),w==null&&(w=[1,1,1]),Z(qa(b,w),(function(){return"Error in avgPool3dBackprop: Either strides or dilations must be 1. Got strides "+b+" and dilations '"+w+"'"})),N!=null&&Z(Qn(S),(function(){return"Error in maxPool3dBackprop: pad must be an integer when using, dimRoundingMode "+N+" but got pad "+S+"."}));var R=rb(_.shape,y,b,w,S,N),D=lt.runKernelFunc((function(A){return A.avgPool3dBackprop(I,_,R)}),{dy5D:I,input5D:_});return $?D.as4D(D.shape[1],D.shape[2],D.shape[3],D.shape[4]):D})(f,u,t,e,o,r,a)}}}));return d=d.cast(u.dtype),l?d.as4D(d.shape[1],d.shape[2],d.shape[3],d.shape[4]):d}}),Ho=st({slice_:function(n,t,e){var r,a,s=Y(n,"x","slice");if(s.rank===0)throw new Error("Slicing scalar is not possible");(r=typeof t=="number"?[t].concat(new Array(s.rank-1).fill(0)):t.length<s.rank?t.concat(new Array(s.rank-t.length).fill(0)):t.slice()).forEach((function(u){Z(u!==-1,(function(){return"slice() does not support negative begin indexing."}))})),a=(a=e==null?new Array(s.rank).fill(-1):typeof e=="number"?[e].concat(new Array(s.rank-1).fill(-1)):e.length<s.rank?e.concat(new Array(s.rank-e.length).fill(-1)):e).map((function(u,l){return u>=0?u:(Z(u===-1,(function(){return"Negative size values should be exactly -1 but got "+u+" for the slice() size at index "+l+"."})),s.shape[l]-r[l])})),Hnt(s,r,a);var o=s.shape,i={begin:r,size:a};return lt.runKernelFunc((function(u){return u.slice(s,r,a)}),{x:s},(function(u){for(var l=[],h=0;h<u.rank;h++)l.push([r[h],o[h]-r[h]-a[h]]);return{x:function(){return u.pad(l)}}}),"Slice",i)}}),yot=st({slice1d_:function(n,t,e){var r=Y(n,"x","slice1d");return Z(r.rank===1,(function(){return"slice1d expects a rank-1 tensor, but got a rank-"+r.rank+" tensor"})),Ho(r,[t],[e])}}),bot=st({slice2d_:function(n,t,e){var r=Y(n,"x","slice2d");return Z(r.rank===2,(function(){return"slice2d expects a rank-2 tensor, but got a rank-"+r.rank+" tensor"})),Ho(r,t,e)}}),Wz=st({slice3d_:function(n,t,e){var r=Y(n,"x","slice3d");return Z(r.rank===3,(function(){return"slice3d expects a rank-3 tensor, but got a rank-"+r.rank+" tensor"})),Ho(r,t,e)}}),xot=st({slice4d_:function(n,t,e){var r=Y(n,"x","slice4d");return Z(r.rank===4,(function(){return"slice4d expects a rank-4 tensor, but got a rank-"+r.rank+" tensor"})),Ho(r,t,e)}});function Gz(n,t,e,r,a){return t.rank<e.rank&&(t=t.reshape(ja(t.shape,r))),n.rank<e.rank&&(n=n.reshape(ja(n.shape,r))),{x:function(){var s=n.mul(e.equal(t).cast(n.dtype));return a==null?s:s.transpose(a)}}}var wot=st({all_:function(n,t,e){t===void 0&&(t=null),e===void 0&&(e=!1);var r=Y(n,"x","all","bool"),a=Tr(t,r.shape),s=a,o=Yo(s,r.rank);o!=null&&(r=r.transpose(o),s=Qo(s.length,r.rank));var i=lt.runKernelFunc((function(l){return l.all(r,s)}),{$x:r});if(e){var u=ja(i.shape,a);return i.reshape(u)}return i}}),Sot=st({any_:function(n,t,e){t===void 0&&(t=null),e===void 0&&(e=!1);var r=Y(n,"x","any","bool"),a=Tr(t,r.shape),s=a,o=Yo(s,r.rank);o!=null&&(r=r.transpose(o),s=Qo(s.length,r.rank));var i=lt.runKernelFunc((function(l){return l.any(r,s)}),{$x:r});if(e){var u=ja(i.shape,a);return i.reshape(u)}return i}}),Cot=st({argMax_:function(n,t){t===void 0&&(t=0);var e=Y(n,"x","argMax");t==null&&(t=0);var r=Tr(t,e.shape),a=Yo(r,e.rank);a!=null&&(e=e.transpose(a),r=Qo(r.length,e.rank));var s={axis:r[0]},o=[e];return lt.runKernelFunc((function(i,u){var l=i.argMax(e,r[0]);return u([e]),l}),{x:e},(function(i,u){var l=u[0];return{x:function(){return He(l)}}}),"ArgMax",s,o)}}),Not=st({argMin_:function(n,t){t===void 0&&(t=0);var e=Y(n,"x","argMin");t==null&&(t=0);var r=Tr(t,e.shape),a=Yo(r,e.rank);return a!=null&&(e=e.transpose(a),r=Qo(r.length,e.rank)),lt.runKernelFunc((function(s,o){var i=s.argMin(e,r[0]);return o([e]),i}),{$x:e},(function(s,o){var i=o[0];return{$x:function(){return He(i)}}}))}}),kot=st({logSumExp_:function(n,t,e){t===void 0&&(t=null),e===void 0&&(e=!1);var r=Y(n,"x","logSumExp"),a=Tr(t,r.shape),s=r.max(a,!0),o=r.sub(s).exp().sum(a).log(),i=s.reshape(o.shape).add(o);if(e){var u=ja(i.shape,a);return i.reshape(u)}return i}}),z1=st({max_:function(n,t,e){t===void 0&&(t=null),e===void 0&&(e=!1);var r=Y(n,"x","max"),a=r,s=Tr(t,r.shape),o=s,i=Yo(o,r.rank);i!=null&&(r=r.transpose(i),o=Qo(o.length,r.rank));var u=[r],l=lt.runKernelFunc((function(d,f){var m=d.max(r,o);return f([a,m]),m}),{x:r},(function(d,f){return Gz(d,f[1],f[0],s,i)}),"Max",{axes:o},u,[!0]);if(e){var h=ja(l.shape,s);l=l.reshape(h)}return l}}),Tot=st({mean_:function(n,t,e){t===void 0&&(t=null),e===void 0&&(e=!1);var r=Y(n,"x","mean"),a=Tr(t,r.shape),s=ee(na(r.shape,a)[1]);return O1((function(o){var i=Pt(s);return{value:(i.dtype===o.dtype?o:o.cast(i.dtype)).div(i).sum(t,e),gradFunc:function(u){var l=o.shape.slice();return a.forEach((function(h){l[h]=1})),u.reshape(l).mul(fp(o.shape,"float32")).div(s)}}}))(r)}}),Eot=st({min_:function(n,t,e){t===void 0&&(t=null),e===void 0&&(e=!1);var r=Y(n,"x","min"),a=r,s=Tr(t,r.shape),o=s,i=Yo(o,r.rank);i!=null&&(r=r.transpose(i),o=Qo(o.length,r.rank));var u=[r],l=lt.runKernelFunc((function(d,f){var m=d.min(r,o);return f([a,m]),m}),{x:r},(function(d,f){return Gz(d,f[1],f[0],s,i)}),"Min",{axes:o},u,[!0]);if(e){var h=ja(l.shape,s);l=l.reshape(h)}return l}}),Iot=st({moments_:function(n,t,e){t===void 0&&(t=null),e===void 0&&(e=!1);var r=Tr(t,(n=Y(n,"x","moments")).shape),a=n.mean(r,e),s=a.shape;e||(s=ja(a.shape,r));var o=n.toFloat().sub(a.reshape(s)).square();return{mean:a,variance:o.mean(r,e)}}}),Hz=st({sum_:function(n,t,e){t===void 0&&(t=null),e===void 0&&(e=!1);var r=Y(n,"x","sum");r.dtype==="bool"&&(r=r.toInt());var a=Tr(t,r.shape);return O1((function(s){var o=Yo(a,s.rank),i=a,u=s;o!=null&&(u=s.transpose(o),i=Qo(i.length,s.rank));var l=function(m){var v=s.shape.slice();return a.forEach((function(y){v[y]=1})),m.reshape(v).mul(fp(s.shape,"float32"))},h={axes:i},d=lt.runKernelFunc((function(m){return m.sum(u,i)}),{x:u},(function(m){return{x:function(){return l(m)}}}),"Sum",h);if(e){var f=ja(d.shape,a);d=d.reshape(f)}return{value:d,gradFunc:l}}))(r)}}),_ot=st({prod_:function(n,t,e){t===void 0&&(t=null),e===void 0&&(e=!1);var r=Y(n,"x","prod");r.dtype==="bool"&&(r=r.toInt());var a=Tr(t,r.shape),s=Yo(a,r.rank),o=a,i=r;s!=null&&(i=r.transpose(s),o=Qo(o.length,r.rank));var u=lt.runKernelFunc((function(h){return h.prod(i,o)}),{permutedX:i});if(e){var l=ja(u.shape,a);u=u.reshape(l)}return u}}),jz=st({elu_:function(n){var t=Y(n,"x","elu");return lt.runKernelFunc((function(e,r){var a=e.elu(t);return r([a]),a}),{$x:t},(function(e,r){var a=r[0];return{$x:function(){return lt.runKernelFunc((function(s){return s.eluDer(e,a)}),{dy:e,y:a})}}}))}}),Rot=st({leakyRelu_:function(n,t){t===void 0&&(t=.2);var e=Y(n,"x","leakyRelu");return XE(Pt(t).mul(e),e)}}),qz=st({prelu_:function(n,t){var e=Y(n,"x","prelu"),r=Y(t,"alpha","prelu");return lt.runKernelFunc((function(a,s){var o=a.prelu(e,r);return s([e,r]),o}),{x:e,alpha:r},(function(a,s){var o=s[0],i=s[1],u=o.greater(0);return{x:function(){return uc(u,a,a.mul(i))},alpha:function(){var l=uc(u,He(a),a.mul(o)),h=Sr(i.shape,a.shape);return h.length>0&&(l=l.sum(h)),l.reshape(i.shape)}}}),"Prelu")}}),Fn=st({relu_:function(n){var t=Y(n,"x","relu");return t.dtype==="bool"?t.toInt():lt.runKernelFunc((function(e,r){var a=e.relu(t);return r([t]),a}),{x:t},(function(e,r){var a=r[0];return{x:function(){return e.mulStrict(a.step().toFloat())}}}),"Relu")}}),Kz=st({relu6_:function(n){var t=Y(n,"x","relu6");return t.dtype==="bool"?t.toInt():lt.runKernelFunc((function(e,r){var a=e.relu6(t);return r([t]),a}),{x:t},(function(e,r){var a=r[0],s=a.lessEqual(6).mul(a.step());return{x:function(){return e.mulStrict(s.toFloat())}}}),"Relu6")}}),Aot=st({selu_:function(n){var t=Y(n,"x","selu");return lt.runKernelFunc((function(e,r){var a=e.selu(t);return r([t]),a}),{$x:t},(function(e,r){var a=r[0];return{$x:function(){var s=a.greater(Pt(0)),o=Pt(jE),i=Pt(qE),u=e.mul(i),l=e.mul(o).mul(a.toFloat().exp());return uc(s,u,l)}}}))}}),Uu=st({transpose_:function(n,t){var e=Y(n,"x","transpose");if(t==null&&(t=e.shape.map((function(a,s){return s})).reverse()),Z(e.rank===t.length,(function(){return"Error in transpose: rank of input "+e.rank+" must match length of perm "+t+"."})),t.forEach((function(a){Z(a>=0&&a<e.rank,(function(){return"All entries in 'perm' must be between 0 and "+(e.rank-1)+" but got "+t}))})),e.rank<=1)return e.clone();var r={perm:t};return lt.runKernelFunc((function(a){return a.transpose(e,t)}),{x:e},(function(a){var s=ME(t);return{x:function(){return a.transpose(s)}}}),"Transpose",r)}}),Dot=st({localResponseNormalization_:function(n,t,e,r,a){t===void 0&&(t=5),e===void 0&&(e=1),r===void 0&&(r=1),a===void 0&&(a=.5);var s=Y(n,"x","localResponseNormalization");Z(s.rank===4||s.rank===3,(function(){return`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank `+s.rank+"."})),Z(Qn(t),(function(){return"Error in localResponseNormalization: depthRadius must be an integer but got depthRadius "+t+"."}));var o=s,i=!1;s.rank===3&&(i=!0,o=s.as4D(1,s.shape[0],s.shape[1],s.shape[2]));var u=lt.runKernelFunc((function(l,h){var d=l.localResponseNormalization4D(o,t,e,r,a);return h([o,d]),d}),{x4D:o},(function(l,h){var d=h[0],f=h[1];return{x4D:function(){return lt.runKernelFunc((function(m){return m.LRNGrad(l,d,f,t,e,r,a)}),{})}}}));return i?u.as3D(u.shape[1],u.shape[2],u.shape[3]):u}}),Xz=st({norm_:function(n,t,e,r){t===void 0&&(t="euclidean"),e===void 0&&(e=null),r===void 0&&(r=!1);var a=(function i(u,l,h){if(h===void 0&&(h=null),u.rank===0)return u.abs();if(u.rank!==1&&h===null)return i(u.reshape([-1]),l,h);if(u.rank===1||typeof h=="number"||Array.isArray(h)&&h.length===1){if(l===1)return u.abs().sum(h);if(l===1/0)return u.abs().max(h);if(l===-1/0)return u.abs().min(h);if(l==="euclidean"||l===2)return u.abs().pow(Pt(2,"int32")).sum(h).sqrt();throw new Error("Error in norm: invalid ord value: "+l)}if(Array.isArray(h)&&h.length===2){if(l===1)return u.abs().sum(h[0]).max(h[1]-1);if(l===1/0)return u.abs().sum(h[1]).max(h[0]);if(l===-1/0)return u.abs().sum(h[1]).min(h[0]);if(l==="fro"||l==="euclidean")return u.square().sum(h).sqrt();throw new Error("Error in norm: invalid ord value: "+l)}throw new Error("Error in norm: invalid axis: "+h)})(n=Y(n,"x","norm"),t,e),s=a.shape;if(r){var o=Tr(e,n.shape);s=ja(a.shape,o)}return a.reshape(s)}}),$ot=st({basicLSTMCell_:function(n,t,e,r,a,s){var o=Y(n,"forgetBias","basicLSTMCell"),i=Y(t,"lstmKernel","basicLSTMCell"),u=Y(e,"lstmBias","basicLSTMCell"),l=Y(r,"data","basicLSTMCell"),h=Y(a,"c","basicLSTMCell"),d=Y(s,"h","basicLSTMCell"),f=l.concat(d,1).matMul(i).add(u),m=f.shape[0],v=f.shape[1]/4,y=[m,v],b=f.slice([0,0],y),w=f.slice([0,v],y),S=f.slice([0,2*v],y),N=f.slice([0,3*v],y),C=b.sigmoid().mulStrict(w.tanh()).addStrict(h.mulStrict(o.add(S).sigmoid())),T=C.tanh().mulStrict(N.sigmoid());return[C,T]}}),Oot=st({multiRNNCell_:function(n,t,e,r){for(var a=Y(t,"data","multiRNNCell"),s=Q0(e,"c","multiRNNCell"),o=Q0(r,"h","multiRNNCell"),i=a,u=[],l=0;l<n.length;l++){var h=n[l](i,s[l],o[l]);u.push(h[0]),u.push(h[1]),i=h[1]}var d=[],f=[];for(l=0;l<u.length;l+=2)d.push(u[l]),f.push(u[l+1]);return[d,f]}}),Fot=st({movingAverage_:function(n,t,e,r,a){a===void 0&&(a=!0);var s=Y(n,"v","movingAverage"),o=Y(t,"x","movingAverage"),i=Y(e,"decay","movingAverage");Det(s,o),Z(Fr(s.shape,o.shape),(function(){return"Shape mismatch in v and x"}));var u=Pt(1),l=u.sub(i),h=o.sub(s).mul(l);if(a){Z(r!=null,(function(){return"When using zeroDebias: true, step is required."}));var d=Y(r,"step","movingAverage");h=h.div(u.sub(ib(i,d)))}return s.add(h)}}),Mot=st({stridedSlice_:function(n,t,e,r,a,s,o,i,u){if(a===void 0&&(a=0),s===void 0&&(s=0),o===void 0&&(o=0),i===void 0&&(i=0),u===void 0&&(u=0),r==null&&(r=new Array(t.length)),o!==0)throw new Error("ellipsis mask is not yet supported");var l=Y(n,"x","stridedSlice"),h=s3(i),d=l.shape.slice();h.forEach((function(b){t[b]=0,e[b]=1,d.splice(b,0,1)})),l=l.reshape(d);for(var f=0;f<l.rank;f++)t[f]=jnt(a,t,r,l.shape,f),e[f]=qnt(s,e,r,l.shape,f),r[f]=r[f]||1;var m=s3(u);m.forEach((function(b){e[b]=t[b]+1,r[b]=1}));var v=PE(t,e,r),y=v.filter((function(b,w){return m.indexOf(w)===-1}));return r.every((function(b){return b===1}))?Ho(l,t,v).reshape(y):lt.runKernelFunc((function(b){return b.stridedSlice(l,t,e,r)}),{$x:l}).reshape(y)}}),Lot=st({topk_:function(n,t,e){t===void 0&&(t=1),e===void 0&&(e=!0);var r=Y(n,"x","topk");if(r.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");var a=r.shape[r.shape.length-1];if(t>a)throw new Error("'k' passed to topk() must be <= the last dimension ("+a+") but got "+t);var s=lt.runKernelFunc((function(o){return o.topk(r,t,e)}),{$x:r});return{values:s[0],indices:s[1]}}}),Bot=st({scatterND_:function(n,t,e){var r=Y(n,"indices","scatterND","int32"),a=Y(t,"updates","scatterND");return Gnt(a,r,e),lt.runKernelFunc((function(s){return s.scatterND(r,a,e)}),{indices:r,updates:a},null,"ScatterNd",{shape:e})}}),JE=st({fft_:function(n){Z(n.dtype==="complex64",(function(){return"The dtype for tf.spectral.fft() must be complex64 but got "+n.dtype+"."}));var t=n.shape[n.shape.length-1],e=n.size/t,r=n.as2D(e,t);return lt.runKernelFunc((function(a){return a.fft(r)}),{input:n}).reshape(n.shape)}}),ub=st({ifft_:function(n){Z(n.dtype==="complex64",(function(){return"The dtype for tf.spectral.ifft() must be complex64 but got "+n.dtype+"."}));var t=n.shape[n.shape.length-1],e=n.size/t,r=n.as2D(e,t);return lt.runKernelFunc((function(a){return a.ifft(r)}),{input:n}).reshape(n.shape)}}),tI=st({rfft_:function(n,t){Z(n.dtype==="float32",(function(){return"The dtype for rfft() must be real value but got "+n.dtype}));var e,r=n.shape[n.shape.length-1],a=n.size/r;if(t!=null&&t<r){var s=n.shape.map((function(w){return 0})),o=n.shape.map((function(w){return w}));o[n.shape.length-1]=t,e=n.slice(s,o),r=t}else if(t!=null&&t>r){var i=n.shape.map((function(w){return w}));i[n.shape.length-1]=t-r,e=n.concat(Sn(i),n.shape.length-1),r=t}else e=n;var u=e.zerosLike(),l=Yr(e,u).as2D(a,r),h=JE(l),d=Math.floor(r/2)+1,f=Ls(h),m=Eo(h),v=f.split([d,r-d],f.shape.length-1),y=m.split([d,r-d],m.shape.length-1),b=e.shape.slice();return b[e.shape.length-1]=d,Yr(v[0],y[0]).reshape(b)}}),Yz=st({irfft_:function(n){var t=n.shape[n.shape.length-1],e=n.size/t;if(t<=2){var r=n.as2D(e,t),a=ub(r);return Ls(a)}var s=[e,2*(t-1)],o=Ls(n).as2D(e,t),i=Eo(n).as2D(e,t),u=o.slice([0,1],[e,t-2]).reverse(1),l=i.slice([0,1],[e,t-2]).reverse(1).mul(Pt(-1)),h=o.concat(u,1),d=i.concat(l,1);return r=Yr(h,d).as2D(s[0],s[1]),a=ub(r),Ls(a)}}),zot=Object.freeze({fft:JE,ifft:ub,rfft:tI,irfft:Yz}),Pot=st({sparseToDense_:function(n,t,e,r){r===void 0&&(r=0);var a=Y(n,"sparseIndices","sparseToDense","int32"),s=Y(t,"sparseValues","sparseToDense"),o=Y(r,"defaultValue","sparseToDense",s.dtype);return(function(i,u,l,h){if(i.dtype!=="int32")throw new Error("tf.sparseToDense() expects the indices to be int32 type, but the dtype was "+i.dtype+".");if(i.rank>2)throw new Error("sparseIndices should be a scalar, vector, or matrix, but got shape "+i.shape+".");var d=i.rank>0?i.shape[0]:1,f=i.rank>1?i.shape[1]:1;if(l.length!==f)throw new Error("outputShape has incorrect number of elements:, "+l.length+", should be: "+f+".");var m=u.size;if(u.rank!==0&&(u.rank!==1||m!==d))throw new Error("sparseValues has incorrect shape "+u.shape+", should be [] or ["+d+"]");if(u.dtype!==h.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")})(a,s,e,o),lt.runKernelFunc((function(i){return i.sparseToDense(a,s,e,o)}),{$sparseIndices:a,$sparseValues:s,$defaultValue:o})}}),Vot=st({gatherND_:function(n,t){var e=Y(t,"indices","gatherND","int32"),r=Y(n,"x","gatherND");return lt.runKernelFunc((function(a){return a.gatherND(r,e)}),{x:r,indices:e},null,"GatherNd")}}),Uot=st({diag_:function(n){var t=Y(n,"x","diag").flatten(),e=n.shape.concat(n.shape);return lt.runKernelFunc((function(r){return r.diag(t)}),{$x:t}).reshape(e)}}),Wot=st({dropout_:function(n,t,e,r){var a=Y(n,"x","dropout");if(Z(a.dtype==="float32",(function(){return"x has to be a floating point tensor since it's going to be scaled, but got a "+a.dtype+" tensor instead."})),Z(t>=0&&t<1,(function(){return"rate must be a float in the range [0, 1), but got "+t+"."})),t===0)return n instanceof $n?a.clone():a;var s=(function(u,l){if(l==null)return u.shape.slice();if(Fr(u.shape,l))return l;if(u.shape.length===l.length){for(var h=[],d=0;d<u.shape.length;d++)l[d]==null&&u.shape[d]!=null?h.push(u.shape[d]):h.push(l[d]);return h}return l})(a,e),o=1-t,i=qB(s,0,1,"float32",r).add(o).floor().div(o);return a.mul(i)}});function Qz(n,t,e){for(var r=1-n%2,a=new Float32Array(n),s=0;s<n;++s){var o=2*Math.PI*s/(n+r-1);a[s]=t-e*Math.cos(o)}return rr(a,"float32")}var eI=st({hannWindow_:function(n){return Qz(n,.5,.5)}}),Zz=st({hammingWindow_:function(n){return Qz(n,.54,.46)}}),nI=st({frame_:function(n,t,e,r,a){r===void 0&&(r=!1),a===void 0&&(a=0);for(var s=0,o=[];s+t<=n.size;)o.push(Ho(n,s,t)),s+=e;if(r)for(;s<n.size;){var i=s+t-n.size,u=yr([Ho(n,s,t-i),Bo([i],a)]);o.push(u),s+=e}return o.length===0?_u([],[0,t]):yr(o).as2D(o.length,t)}}),Jz=st({stft_:function(n,t,e,r,a){var s;a===void 0&&(a=eI),r==null&&(s=t,r=Math.floor(Math.pow(2,Math.ceil(Math.log(s)/Math.log(2)))));for(var o=nI(n,t,e),i=da(o,a(t)),u=[],l=0;l<o.shape[0];l++)u.push(tI(i.slice([l,0],[1,t]),r));return yr(u)}}),Got=Object.freeze({hannWindow:eI,hammingWindow:Zz,frame:nI,stft:Jz}),la,Hot=function(n,t,e){return e===void 0&&(e=1),Yt(this,void 0,void 0,(function(){var r,a,s,o,i,u,l,h,d,f,m,v,y,b;return Qt(this,(function(w){switch(w.label){case 0:return r=Y(n,"predictions","inTopK"),a=Y(t,"targets","inTopK"),Z(r.rank>1,(function(){return"inTopK() expects the predictions to be of rank 2 or higher, but got "+r.rank})),Z(r.rank-1===a.rank,(function(){return"predictions rank should be 1 larger than targets rank, but got predictions rank "+r.rank+" and targets rank "+a.rank})),Je(r.shape.slice(0,r.shape.length-1),a.shape,"predictions's shape should be align with the targets' shape, except the last dimension."),s=r.shape[r.shape.length-1],Z(e>0&&e<=s,(function(){return"'k' passed to inTopK() must be > 0 && <= the predictions last dimension ("+s+"), but got "+e})),[4,r.data()];case 1:return o=w.sent(),[4,a.data()];case 2:for(i=w.sent(),u=[o.length/s,s],h=u[1],d=am("bool",l=u[0]),f=0;f<l;f++){for(m=f*h,v=o.subarray(m,m+h),y=[],b=0;b<v.length;b++)y.push({value:v[b],index:b});for(y.sort((function(S,N){return N.value-S.value})),d[f]=0,b=0;b<e;b++)if(y[b].index===i[f]){d[f]=1;break}}return n!==r&&r.dispose(),t!==a&&a.dispose(),[2,Zr(d,a.shape,"bool")]}}))}))};(function(n){n[n.NONE=0]="NONE",n[n.MEAN=1]="MEAN",n[n.SUM=2]="SUM",n[n.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"})(la||(la={}));var jot=st({absoluteDifference_:function(n,t,e,r){r===void 0&&(r=la.SUM_BY_NONZERO_WEIGHTS);var a=Y(n,"labels","absoluteDifference"),s=Y(t,"predictions","absoluteDifference"),o=null;e!=null&&(o=Y(e,"weights","absoluteDifference")),Je(a.shape,s.shape,"Error in absoluteDifference: ");var i=a.sub(s).abs();return Gi(i,o,r)}}),Gi=st({computeWeightedLoss_:function(n,t,e){e===void 0&&(e=la.SUM_BY_NONZERO_WEIGHTS);var r=Y(n,"losses","computeWeightedLoss"),a=null;t!=null&&(a=Y(t,"weights","computeWeightedLoss"));var s=a==null?r:r.mul(a);if(e===la.NONE)return s;if(e===la.SUM)return s.sum();if(e===la.MEAN){if(a==null)return s.mean();var o=r.size/a.size,i=s.sum().div(a.sum());return o>1?i.div(Pt(o)):i}if(e===la.SUM_BY_NONZERO_WEIGHTS){if(a==null)return s.sum().div(Pt(r.size));var u=a.mul(fp(r.shape)).notEqual(Pt(0)).sum().toFloat();return s.sum().div(u)}throw Error("Unknown reduction: "+e)}}),qot=st({cosineDistance_:function(n,t,e,r,a){a===void 0&&(a=la.SUM_BY_NONZERO_WEIGHTS);var s=Y(n,"labels","cosineDistance"),o=Y(t,"predictions","cosineDistance"),i=null;r!=null&&(i=Y(r,"weights","cosineDistance")),Je(s.shape,o.shape,"Error in cosineDistance: ");var u=Pt(1).sub(s.mul(o).sum(e,!0));return Gi(u,i,a)}}),Kot=st({hingeLoss_:function(n,t,e,r){r===void 0&&(r=la.SUM_BY_NONZERO_WEIGHTS);var a=Y(n,"labels","hingeLoss"),s=Y(t,"predictions","hingeLoss"),o=null;e!=null&&(o=Y(e,"weights","hingeLoss")),Je(a.shape,s.shape,"Error in hingeLoss: ");var i=Pt(1);a=Pt(2).mul(a).sub(i);var u=i.sub(a.mul(s)).relu();return Gi(u,o,r)}}),Xot=st({huberLoss_:function(n,t,e,r,a){r===void 0&&(r=1),a===void 0&&(a=la.SUM_BY_NONZERO_WEIGHTS);var s=Y(n,"labels","huberLoss"),o=Y(t,"predictions","huberLoss"),i=null;e!=null&&(i=Y(e,"weights","huberLoss")),Je(s.shape,o.shape,"Error in huberLoss: ");var u=Pt(r),l=o.sub(s).abs(),h=Dz(l,u),d=l.sub(h),f=Pt(.5).mul(h.square()).add(u.mul(d));return Gi(f,i,a)}}),Yot=st({logLoss_:function(n,t,e,r,a){r===void 0&&(r=1e-7),a===void 0&&(a=la.SUM_BY_NONZERO_WEIGHTS);var s=Y(n,"labels","logLoss"),o=Y(t,"predictions","logLoss"),i=null;e!=null&&(i=Y(e,"weights","logLoss")),Je(s.shape,o.shape,"Error in logLoss: ");var u=Pt(1),l=Pt(r),h=s.mul(o.add(l).log()).neg().sub(u.sub(s).mul(u.sub(o).add(l).log()));return Gi(h,i,a)}}),Qot=st({meanSquaredError_:function(n,t,e,r){r===void 0&&(r=la.SUM_BY_NONZERO_WEIGHTS);var a=Y(n,"labels","meanSquaredError"),s=Y(t,"predictions","meanSquaredError"),o=null;e!=null&&(o=Y(e,"weights","meanSquaredError")),Je(a.shape,s.shape,"Error in meanSquaredError: ");var i=a.squaredDifference(s);return Gi(i,o,r)}}),Zot=st({sigmoidCrossEntropy_:function(n,t,e,r,a){r===void 0&&(r=0),a===void 0&&(a=la.SUM_BY_NONZERO_WEIGHTS);var s=Y(n,"multiClassLabels","sigmoidCrossEntropy"),o=Y(t,"logits","sigmoidCrossEntropy"),i=null;if(e!=null&&(i=Y(e,"weights","sigmoidCrossEntropy")),Je(s.shape,o.shape,"Error in sigmoidCrossEntropy: "),r>0){var u=Pt(r),l=Pt(1),h=Pt(.5);s=s.mul(l.sub(u)).add(h.mul(u))}var d=(function(f,m){var v=Y(f,"labels","sigmoidCrossEntropyWithLogits"),y=Y(m,"logits","sigmoidCrossEntropyWithLogits");Je(v.shape,y.shape,"Error in sigmoidCrossEntropyWithLogits: ");var b=y.relu(),w=y.mul(v),S=y.abs().neg().exp().log1p();return b.sub(w).add(S)})(s,o);return Gi(d,i,a)}}),Jot=st({softmaxCrossEntropy_:function(n,t,e,r,a){r===void 0&&(r=0),a===void 0&&(a=la.SUM_BY_NONZERO_WEIGHTS);var s=Y(n,"onehotLabels","softmaxCrossEntropy"),o=Y(t,"logits","softmaxCrossEntropy"),i=null;if(e!=null&&(i=Y(e,"weights","softmaxCrossEntropy")),Je(s.shape,o.shape,"Error in softmaxCrossEntropy: "),r>0){var u=Pt(r),l=Pt(1),h=Pt(s.shape[1]);s=s.mul(l.sub(u)).add(u.div(h))}var d=(function(f,m,v){if(v===void 0&&(v=-1),v===-1&&(v=m.rank-1),v!==m.rank-1)throw Error("Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank "+m.rank+" and dim was "+v);return O1((function(y,b,w){var S=b.logSumExp([v],!0),N=b.toFloat().sub(S);return w([y,N]),{value:N.mul(y).neg().sum([v]),gradFunc:function(C,T){var I=T[0],_=T[1],$=ja(C.shape,[v]);return[C.reshape($).mul(I.toFloat().sub(_.exp())),C.reshape($).mul(_.exp().sub(I.toFloat()))]}}}))(f,m)})(s,o);return Gi(d,i,a)}}),tit=Object.freeze({get Reduction(){return la},absoluteDifference:jot,computeWeightedLoss:Gi,cosineDistance:qot,hingeLoss:Kot,huberLoss:Xot,logLoss:Yot,meanSquaredError:Qot,sigmoidCrossEntropy:Zot,softmaxCrossEntropy:Jot});function E3(n,t){return t===void 0&&(t=!1),lt.tidy((function(){if(n.shape.length!==2)throw new Error("qr2d() requires a 2D Tensor, but got a "+n.shape.length+"D Tensor.");for(var e=n.shape[0],r=n.shape[1],a=jB(e),s=n.clone(),o=_u([[1]],[1,1]),i=o.clone(),u=e>=r?r:e,l=function(d){var f,m=s,v=i,y=a;f=lt.tidy((function(){var b=s.slice([d,d],[e-d,1]),w=b.norm(),S=s.slice([d,d],[1,1]),N=_u([[-1]]).where(S.greater(0),_u([[1]])),C=S.sub(N.mul(w)),T=b.div(C);i=T.shape[0]===1?o.clone():o.concat(T.slice([1,0],[T.shape[0]-1,T.shape[1]]),0);var I=N.matMul(C).div(w).neg(),_=s.slice([d,0],[e-d,r]),$=I.mul(i);if(d===0)s=_.sub($.matMul(i.transpose().matMul(_)));else{var R=_.sub($.matMul(i.transpose().matMul(_)));s=s.slice([0,0],[d,r]).concat(R,0)}var D=a.slice([0,d],[e,a.shape[1]-d]);if(d===0)a=D.sub(D.matMul(i).matMul($.transpose()));else{var A=D.sub(D.matMul(i).matMul($.transpose()));a=a.slice([0,0],[e,d]).concat(A,1)}return[i,s,a]})),i=f[0],s=f[1],a=f[2],Ua([m,v,y])},h=0;h<u;++h)l(h);return!t&&e>r&&(a=a.slice([0,0],[e,r]),s=s.slice([0,0],[r,r])),[a,s]}))}var eit=st({bandPart_:function(n,t,e){if(t%1!=0)throw new Error("bandPart(): numLower must be an integer, got "+t+".");if(e%1!=0)throw new Error("bandPart(): numUpper must be an integer, got "+e+".");var r=Y(n,"a","bandPart");if(r.rank<2)throw new Error("bandPart(): Rank must be at least 2, got "+r.rank+".");var a=r.shape,s=r.shape.slice(-2),o=s[0],i=s[1];if(!(t<=o))throw new Error("bandPart(): numLower ("+t+") must not be greater than the number of rows ("+o+").");if(!(e<=i))throw new Error("bandPart(): numUpper ("+e+") must not be greater than the number of columns ("+i+").");t<0&&(t=o),e<0&&(e=i);var u=Z0(0,o,1,"int32").reshape([-1,1]),l=Z0(0,i,1,"int32"),h=Cr(u,l),d=M1(h.lessEqual(Pt(+t,"int32")),h.greaterEqual(Pt(-e,"int32"))),f=Sn([o,i],r.dtype);return ys(br(r.reshape([-1,o,i])).map((function(m){return uc(d,m,f)}))).reshape(a)}}),nit=st({gramSchmidt_:function(n){var t;if(Array.isArray(n)){t=!1,Z(n!=null&&n.length>0,(function(){return"Gram-Schmidt process: input must not be null, undefined, or empty"}));for(var e=n[0].shape[0],r=function(u){Z(n[u].shape[0]===e,(function(){return"Gram-Schmidt: Non-unique lengths found in the input vectors: ("+n[u].shape[0]+" vs. "+e+")"}))},a=1;a<n.length;++a)r(a)}else t=!0,n=BE(n,n.shape[0],0).map((function(u){return XB(u,[0])}));Z(n.length<=n[0].shape[0],(function(){return"Gram-Schmidt: Number of vectors ("+n.length+") exceeds number of dimensions ("+n[0].shape[0]+")."}));var s=[],o=n,i=function(u){s.push(lt.tidy((function(){var l=o[u];if(u>0)for(var h=0;h<u;++h){var d=Hz(s[h].mulStrict(l)).mul(s[h]);l=l.sub(d)}return l.div(Xz(l,"euclidean"))})))};for(a=0;a<n.length;++a)i(a);return t?ys(s,0):s}}),rit=st({qr_:function(n,t){if(t===void 0&&(t=!1),n.rank<2)throw new Error("qr() requires input tensor to have a rank >= 2, but got rank "+n.rank);if(n.rank===2)return E3(n,t);var e=n.shape.slice(0,n.shape.length-2).reduce((function(o,i){return o*i})),r=br(n.reshape([e,n.shape[n.shape.length-2],n.shape[n.shape.length-1]]),0),a=[],s=[];return r.forEach((function(o){var i=E3(o,t),u=i[0],l=i[1];a.push(u),s.push(l)})),[ys(a,0).reshape(n.shape),ys(s,0).reshape(n.shape)]}}),ait=Object.freeze({bandPart:eit,gramSchmidt:nit,qr:rit});function P1(n,t,e,r,a,s){r==null&&(r=.5),a==null&&(a=Number.NEGATIVE_INFINITY),s==null&&(s=0);var o=n.shape[0];return e=Math.min(e,o),Z(0<=r&&r<=1,(function(){return"iouThreshold must be in [0, 1], but was '"+r+"'"})),Z(n.rank===2,(function(){return"boxes must be a 2D tensor, but was of rank '"+n.rank+"'"})),Z(n.shape[1]===4,(function(){return"boxes must have 4 columns, but 2nd dimension was "+n.shape[1]})),Z(t.rank===1,(function(){return"scores must be a 1D tensor"})),Z(t.shape[0]===o,(function(){return"scores has incompatible shape with boxes. Expected "+o+", but was "+t.shape[0]})),Z(0<=s&&s<=1,(function(){return"softNmsSigma must be in [0, 1], but was '"+s+"'"})),{maxOutputSize:e,iouThreshold:r,scoreThreshold:a,softNmsSigma:s}}var sit=st({resizeBilinear_:function(n,t,e){e===void 0&&(e=!1);var r=Y(n,"images","resizeBilinear");Z(r.rank===3||r.rank===4,(function(){return"Error in resizeBilinear: x must be rank 3 or 4, but got rank "+r.rank+"."})),Z(t.length===2,(function(){return"Error in resizeBilinear: new shape must 2D, but got shape "+t+"."}));var a=r,s=!1;r.rank===3&&(s=!0,a=r.as4D(1,r.shape[0],r.shape[1],r.shape[2]));var o=t[0],i=t[1],u=lt.runKernelFunc((function(l,h){return h([a]),l.resizeBilinear(a,o,i,e)}),{x:a},(function(l,h){return{x:function(){return lt.runKernelFunc((function(d){return d.resizeBilinearBackprop(l,h[0],e)}),{})}}}),"ResizeBilinear",{alignCorners:e,newHeight:o,newWidth:i});return s?u.as3D(u.shape[1],u.shape[2],u.shape[3]):u}}),oit=st({resizeNearestNeighbor_:function(n,t,e){e===void 0&&(e=!1);var r=Y(n,"images","resizeNearestNeighbor");Z(r.rank===3||r.rank===4,(function(){return"Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank "+r.rank+"."})),Z(t.length===2,(function(){return"Error in resizeNearestNeighbor: new shape must 2D, but got shape "+t+"."})),Z(r.dtype==="float32"||r.dtype==="int32",(function(){return"`images` must have `int32` or `float32` as dtype"}));var a=r,s=!1;r.rank===3&&(s=!0,a=r.as4D(1,r.shape[0],r.shape[1],r.shape[2]));var o=t[0],i=t[1],u=lt.runKernelFunc((function(l,h){return h([a]),l.resizeNearestNeighbor(a,o,i,e)}),{batchImages:a},(function(l,h){return{batchImages:function(){return lt.runKernelFunc((function(d){return d.resizeNearestNeighborBackprop(l,h[0],e)}),{})}}}));return s?u.as3D(u.shape[1],u.shape[2],u.shape[3]):u}}),iit=st({nonMaxSuppression_:function(n,t,e,r,a){r===void 0&&(r=.5),a===void 0&&(a=Number.NEGATIVE_INFINITY);var s=Y(n,"boxes","nonMaxSuppression"),o=Y(t,"scores","nonMaxSuppression"),i=P1(s,o,e,r,a);e=i.maxOutputSize,r=i.iouThreshold,a=i.scoreThreshold;var u={maxOutputSize:e,iouThreshold:r,scoreThreshold:a};return lt.runKernelFunc((function(l){return l.nonMaxSuppression(s,o,e,r,a)}),{boxes:s,scores:o},null,"NonMaxSuppressionV3",u)}}),uit=function(n,t,e,r,a){return r===void 0&&(r=.5),a===void 0&&(a=Number.NEGATIVE_INFINITY),Yt(this,void 0,void 0,(function(){var s,o,i,u,l,h,d;return Qt(this,(function(f){switch(f.label){case 0:return s=Y(n,"boxes","nonMaxSuppressionAsync"),o=Y(t,"scores","nonMaxSuppressionAsync"),i=P1(s,o,e,r,a),e=i.maxOutputSize,r=i.iouThreshold,a=i.scoreThreshold,[4,Promise.all([s.data(),o.data()])];case 1:return u=f.sent(),l=u[0],h=u[1],d=UE(l,h,e,r,a),s!==n&&s.dispose(),o!==t&&o.dispose(),[2,d]}}))}))},lit=st({nonMaxSuppressionWithScore_:function(n,t,e,r,a,s){r===void 0&&(r=.5),a===void 0&&(a=Number.NEGATIVE_INFINITY),s===void 0&&(s=0);var o=Y(n,"boxes","nonMaxSuppression"),i=Y(t,"scores","nonMaxSuppression"),u=P1(o,i,e,r,a,s),l={maxOutputSize:e=u.maxOutputSize,iouThreshold:r=u.iouThreshold,scoreThreshold:a=u.scoreThreshold,softNmsSigma:s=u.softNmsSigma},h=lt.runKernel("NonMaxSuppressionV5",{boxes:o,scores:i},l);return{selectedIndices:h[0],selectedScores:h[1]}}}),cit=function(n,t,e,r,a,s){return r===void 0&&(r=.5),a===void 0&&(a=Number.NEGATIVE_INFINITY),s===void 0&&(s=0),Yt(this,void 0,void 0,(function(){var o,i,u,l,h,d,f;return Qt(this,(function(m){switch(m.label){case 0:return o=Y(n,"boxes","nonMaxSuppressionAsync"),i=Y(t,"scores","nonMaxSuppressionAsync"),u=P1(o,i,e,r,a,s),e=u.maxOutputSize,r=u.iouThreshold,a=u.scoreThreshold,s=u.softNmsSigma,[4,Promise.all([o.data(),i.data()])];case 1:return l=m.sent(),h=l[0],d=l[1],f=WE(h,d,e,r,a,s),o!==n&&o.dispose(),i!==t&&i.dispose(),[2,f]}}))}))},hit=st({cropAndResize_:function(n,t,e,r,a,s){var o=Y(n,"image","cropAndResize"),i=Y(t,"boxes","cropAndResize","float32"),u=Y(e,"boxInd","cropAndResize","int32");a=a||"bilinear",s=s||0;var l=i.shape[0];return Z(o.rank===4,(function(){return"Error in cropAndResize: image must be rank 4,but got rank "+o.rank+"."})),Z(i.rank===2&&i.shape[1]===4,(function(){return"Error in cropAndResize: boxes must be have size ["+l+",4] but had shape "+i.shape+"."})),Z(u.rank===1&&u.shape[0]===l,(function(){return"Error in cropAndResize: boxInd must be have size ["+l+"] but had shape "+i.shape+"."})),Z(r.length===2,(function(){return"Error in cropAndResize: cropSize must be of length 2, but got length "+r.length+"."})),Z(r[0]>=1&&r[1]>=1,(function(){return"cropSize must be atleast [1,1], but was "+r})),Z(a==="bilinear"||a==="nearest",(function(){return"method must be bilinear or nearest, but was "+a})),lt.runKernelFunc((function(h,d){return h.cropAndResize(o,i,u,r,a,s)}),{images:o,boxes:i,boxInd:u},null,"CropAndResize",{method:a,extrapolationValue:s,cropSize:r})}}),rI=Object.freeze({resizeBilinear:sit,resizeNearestNeighbor:oit,nonMaxSuppression:iit,nonMaxSuppressionAsync:uit,nonMaxSuppressionWithScore:lit,nonMaxSuppressionWithScoreAsync:cit,cropAndResize:hit}),aI=function(n,t){return!(n>0)||t==="linear"},sI=function(n,t,e){if(e==null||e==="linear")return n;if(e==="relu")return n.mul(t.step());throw new Error("Gradient for activation "+e+" has not been implemented yet.")},oI=function(n,t){var e=t,r=Sr(n.shape,t.shape);return r.length>0&&(e=e.sum(r)),e.reshape(n.shape)},iI=function(n,t,e){if(t==="linear")return n;if(t==="relu")return Fn(n);if(t==="elu")return jz(n);if(t==="relu6")return Kz(n);if(t==="prelu")return qz(n,e);throw new Error("Unknown fused activation "+t+".")},dit=st({fusedMatMul_:function(n){var t,e=n.a,r=n.b,a=n.transposeA,s=a!==void 0&&a,o=n.transposeB,i=o!==void 0&&o,u=n.bias,l=n.activation,h=l===void 0?"linear":l,d=n.preluActivationWeights;if(aI(lt.state.gradientDepth,h)===!1){var f=B1(e,r,s,i);return u!=null&&(f=$e(f,u)),iI(f,h,d)}var m=Y(e,"a","fused matMul"),v=Y(r,"b","fused matMul");t=Mn(m,v),m=t[0],v=t[1];var y=s?m.shape[m.rank-2]:m.shape[m.rank-1],b=i?v.shape[v.rank-1]:v.shape[v.rank-2],w=s?m.shape[m.rank-1]:m.shape[m.rank-2],S=i?v.shape[v.rank-2]:v.shape[v.rank-1],N=m.shape.slice(0,-2),C=v.shape.slice(0,-2),T=ee(N),I=ee(C);Z(m.rank>=2&&v.rank>=2&&m.rank===v.rank,(function(){return"Error in fused matMul: inputs must have the same rank of at least 2, got ranks "+m.rank+" and "+v.rank+"."})),Z(Fr(N,C),(function(){return"Error in fused matMul: outer dimensions ("+N+") and ("+C+") of Tensors with shapes "+m.shape+" and "+v.shape+" must match."})),Z(y===b,(function(){return"Error in fused matMul: inner shapes ("+y+") and ("+b+") of Tensors with shapes "+m.shape+" and "+v.shape+" and transposeA="+s+" and transposeB="+i+" must match."}));var _,$,R=m.shape.slice(0,-2).concat([w,S]),D=s?m.as3D(T,y,w):m.as3D(T,w,y),A=i?v.as3D(I,S,b):v.as3D(I,b,S);u!=null&&Le(R,(_=Mn(_=Y(u,"bias","fused matMul"),m)[0]).shape),d!=null&&($=Y(d,"prelu weights","fused matMul"));var L={a:D,b:A};u!=null&&(L.bias=_),d!=null&&(L.preluActivationWeights=$);var H=[D,A];return lt.runKernelFunc((function(G,q){var B=G.fusedBatchMatMul({a:D,b:A,transposeA:s,transposeB:i,bias:_,activation:h,preluActivationWeights:$});return q([D,A,B]),B}),L,(function(G,q){var B=q[0],j=q[1],K=q[2],z=sI(G,K,h),U={};return u!=null&&(U={bias:function(){return oI(_,z)}}),Object.assign(s||i?!s&&i?{a:function(){return z.matMul(j,!1,!1)},b:function(){return z.matMul(B,!0,!1)}}:s&&!i?{a:function(){return j.matMul(z,!1,!0)},b:function(){return B.matMul(z,!1,!1)}}:{a:function(){return j.matMul(z,!0,!0)},b:function(){return z.matMul(B,!0,!0)}}:{a:function(){return z.matMul(j,!1,!0)},b:function(){return B.matMul(z,!0,!1)}},U)}),"_FusedMatMul",{transposeA:s,transposeB:i,activation:h},H,[!0]).reshape(R)}}),pit=st({fusedConv2d_:function(n){var t=n.x,e=n.filter,r=n.strides,a=n.pad,s=n.dataFormat,o=s===void 0?"NHWC":s,i=n.dilations,u=i===void 0?[1,1]:i,l=n.dimRoundingMode,h=n.bias,d=n.activation,f=d===void 0?"linear":d,m=n.preluActivationWeights;if(f=f||"linear",aI(lt.state.gradientDepth,f)===!1){var v=Us(t,e,r,a,o,u,l);return h!=null&&(v=$e(v,h)),iI(v,f,m)}var y=Y(t,"x","conv2d"),b=Y(e,"filter","conv2d"),w=y,S=!1;y.rank===3&&(S=!0,w=y.as4D(1,y.shape[0],y.shape[1],y.shape[2])),Z(w.rank===4,(function(){return"Error in fused conv2d: input must be rank 4, but got rank "+w.rank+"."})),Z(b.rank===4,(function(){return"Error in fused conv2d: filter must be rank 4, but got rank "+b.rank+"."})),l!=null&&Z(Qn(a),(function(){return"Error in fused conv2d: pad must be an integer when using, dimRoundingMode "+l+" but got pad "+a+"."})),Z(w.shape[3]===b.shape[2],(function(){return"Error in conv2d: depth of input ("+w.shape[3]+") must match input depth for filter "+b.shape[2]+"."})),Z(qa(r,u),(function(){return"Error in conv2D: Either strides or dilations must be 1. Got strides "+r+" and dilations '"+u+"'"})),Z(o==="NHWC",(function(){return"Error in conv2d: got dataFormat of "+o+" but only NHWC is currently supported."}));var N,C,T=kc(w.shape,b.shape,r,u,a,l);h!=null&&(N=Mn(N=Y(h,"bias","fused conv2d"),y)[0],Le(T.outShape,N.shape)),m!=null&&(C=Y(m,"prelu weights","fused conv2d"));var I={x:w,filter:b};h!=null&&(I.bias=N),m!=null&&(I.preluActivationWeights=C);var _=[b,w],$=lt.runKernelFunc((function(R,D){var A=R.fusedConv2d({input:w,filter:b,convInfo:T,bias:N,activation:f,preluActivationWeights:C});return D([b,w,A]),A}),I,(function(R,D){var A=D,L=A[0],H=A[1],G=A[2],q=sI(R,G,f);Z(ad(u),(function(){return"Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '"+u+"'"}));var B={};return h!=null&&(B={bias:function(){return oI(N,q)}}),Object.assign({x:function(){return Bz(H.shape,q,L,r,a)},filter:function(){return QE(H,q,L.shape,r,a)}},B)}),"FusedConv2D",{convInfo:T,activation:f},_,[!0]);return S?$.as3D($.shape[1],$.shape[2],$.shape[3]):$}}),fit=st({fusedDepthwiseConv2d_:function(n){var t=n.x,e=n.filter,r=n.strides,a=n.pad,s=n.dataFormat,o=s===void 0?"NHWC":s,i=n.dilations,u=i===void 0?[1,1]:i,l=n.dimRoundingMode,h=n.bias,d=n.activation,f=d===void 0?"linear":d,m=n.preluActivationWeights;if(aI(lt.state.gradientDepth,f)===!1){var v=L1(t,e,r,a,o,u,l);return h!=null&&(v=$e(v,h)),iI(v,f,m)}var y=Y(t,"x","depthwiseConv2d"),b=Y(e,"filter","depthwiseConv2d"),w=y,S=!1;y.rank===3&&(S=!0,w=y.as4D(1,y.shape[0],y.shape[1],y.shape[2])),Z(w.rank===4,(function(){return"Error in fused depthwiseConv2d: input must be rank 4, but got rank "+w.rank+"."})),Z(b.rank===4,(function(){return"Error in fused depthwiseConv2d: filter must be rank 4, but got rank "+b.rank+"."})),Z(w.shape[3]===b.shape[2],(function(){return"Error in fused depthwiseConv2d: number of input channels ("+w.shape[3]+") must match the inChannels dimension in filter "+b.shape[2]+"."})),u==null&&(u=[1,1]),Z(qa(r,u),(function(){return"Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides "+r+" and dilations '"+u+"'"})),l!=null&&Z(Qn(a),(function(){return"Error in fused depthwiseConv2d: pad must be an integer when using dimRoundingMode "+l+" but got pad "+a+"."}));var N,C,T=kc(w.shape,b.shape,r,u,a,l,!0);h!=null&&(N=Mn(N=Y(h,"bias","fused conv2d"),y)[0],Le(T.outShape,N.shape)),m!=null&&(C=Y(m,"prelu weights","fused depthwiseConv2d"));var I={x:w,filter:b};h!=null&&(I.bias=N),m!=null&&(I.preluActivationWeights=C);var _=[b,w],$=lt.runKernelFunc((function(R,D){var A=R.fusedDepthwiseConv2D({input:w,filter:b,convInfo:T,bias:N,activation:f,preluActivationWeights:C});return D([b,w,A]),A}),I,(function(R,D){Z(ad(u),(function(){return"Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '"+u+"'"}));var A=D[0],L=D[1],H=D[2],G=sI(R,H,f),q={};return h!=null&&(q={bias:function(){return oI(N,G)}}),Object.assign({x:function(){return zz(L.shape,G,A,T)},filter:function(){return Pz(L,G,A.shape,T)}},q)}),"FusedDepthwiseConv2D",{convInfo:T,activation:f},_,[!0]);return S?$.as3D($.shape[1],$.shape[2],$.shape[3]):$}}),mit=Object.freeze({matMul:dit,conv2d:pit,depthwiseConv2d:fit}),git=Object.freeze({image:rI,linalg:ait,losses:tit,spectral:zot,fused:mit,signal:Got,square:Yat,squaredDifference:Sz,conv1d:sot,conv2d:Us,conv3d:oot,depthwiseConv2d:L1,separableConv2d:ZE,conv2dTranspose:iot,conv3dTranspose:uot,op:st,batchNormalization2d:Tst,batchNormalization3d:Est,batchNormalization4d:Ist,batchNormalization:_st,batchNorm:Iz,batchNorm2d:Rst,batchNorm3d:Ast,batchNorm4d:Dst,booleanMaskAsync:aot,complex:Yr,real:Ls,imag:Eo,concat:yr,concat1d:mnt,concat2d:gnt,concat3d:vnt,concat4d:ynt,split:BE,matMul:B1,dot:lot,outerProduct:cot,reverse:Zg,reverse1d:hot,reverse2d:dot,reverse3d:pot,reverse4d:fot,maxPool:Rr,avgPool:Jg,pool:mot,maxPool3d:got,avgPool3d:vot,slice:Ho,slice1d:yot,slice2d:bot,slice3d:Wz,slice4d:xot,abs:Qat,acos:Zat,acosh:Jat,asin:tst,asinh:est,atan:nst,atanh:rst,ceil:ast,clipByValue:KE,cos:sst,cosh:ost,erf:ist,exp:XN,expm1:ust,floor:lst,log:cst,log1p:hst,logSigmoid:dst,neg:ob,reciprocal:pst,round:fst,rsqrt:Cz,sigmoid:Nz,sign:mst,isNaN:gst,isInf:vst,isFinite:yst,sin:bst,sinh:xst,softplus:wst,sqrt:Sst,step:Cst,tan:Nst,tanh:kst,all:wot,any:Sot,argMax:Cot,argMin:Not,logSumExp:kot,max:z1,mean:Tot,min:Eot,moments:Iot,sum:Hz,prod:_ot,equal:$z,equalStrict:Kst,greater:Xst,greaterEqual:Oz,greaterEqualStrict:Yst,greaterStrict:Qst,less:Zst,lessEqual:Jst,lessEqualStrict:tot,lessStrict:eot,notEqual:not,notEqualStrict:rot,add:$e,addN:Fst,addStrict:Mst,atan2:Lst,div:Js,divNoNan:Bst,divStrict:zst,floorDiv:Az,maximum:XE,maximumStrict:Pst,minimum:Dz,minimumStrict:Vst,mod:Ust,modStrict:Wst,mul:da,mulStrict:Gst,pow:ib,powStrict:Hst,squaredDifferenceStrict:jst,sub:Cr,subStrict:qst,elu:jz,leakyRelu:Rot,prelu:qz,relu:Fn,relu6:Kz,selu:Aot,logicalAnd:M1,logicalNot:$st,logicalOr:_z,logicalXor:Ost,where:uc,whereAsync:Rz,buffer:be,print:Ent,batchToSpaceND:HB,broadcastTo:Int,cast:_nt,clone:Rnt,cumsum:Ant,depthToSpace:Dnt,expandDims:Ms,eye:jB,multinomial:$nt,oneHot:HN,pad:Nc,pad1d:Ont,pad2d:Fnt,pad3d:Mnt,pad4d:Lnt,rand:Bnt,randomNormal:znt,randomGamma:Pnt,randomUniform:qB,reshape:to,spaceToBatchND:KB,squeeze:XB,stack:ys,tile:Bh,truncatedNormal:Vnt,unstack:br,setdiff1dAsync:Unt,fill:Bo,linspace:fnt,ones:fp,range:Z0,scalar:Pt,tensor:Zr,tensor1d:rr,tensor2d:_u,tensor3d:LE,tensor4d:Ba,tensor5d:hnt,tensor6d:dnt,variable:pnt,zeros:Sn,onesLike:GB,zerosLike:He,transpose:Uu,softmax:Wi,logSoftmax:Xnt,localResponseNormalization:Dot,norm:Xz,gather:YE,unsortedSegmentSum:Fz,basicLSTMCell:$ot,multiRNNCell:Oot,movingAverage:Fot,stridedSlice:Mot,topk:Lot,scatterND:Bot,fft:JE,ifft:ub,rfft:tI,irfft:Yz,sparseToDense:Pot,gatherND:Vot,diag:Uot,dropout:Wot,hannWindow:eI,hammingWindow:Zz,frame:nI,stft:Jz,inTopKAsync:Hot});function Dt(n,t){Array.isArray(n)||(n=[n]),n.forEach((function(e){e!=null&&Z(e.dtype!=="complex64",(function(){return t+" does not support complex64 tensors."}))}))}function uC(n,t,e,r){if(e==="linear")return n.linear(t);if(e==="relu")return n.relu(t);if(e==="elu")return n.elu(t);if(e==="relu6")return n.relu6(t);if(e==="prelu")return n.prelu(t,r);throw new Error("Activation "+e+" has not been implemented for the CPU backend.")}var vit=(function(n){function t(){var e=n.call(this)||this;return e.blockSize=48,e.firstUse=!0,e.data=new nz(e,lt),e}return co(t,n),t.prototype.write=function(e,r,a){this.firstUse&&(this.firstUse=!1,kt().get("IS_NODE")&&Y0(`
============================
Hi there . Looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, which binds to TensorFlow C++, by running npm i @tensorflow/tfjs-node, or npm i @tensorflow/tfjs-node-gpu if you have CUDA. Then call require('@tensorflow/tfjs-node'); (-gpu suffix for CUDA) at the start of your program. Visit https://github.com/tensorflow/tfjs-node for more details.
============================`));var s={};return this.data.set(s,{values:e,dtype:a}),s},t.prototype.move=function(e,r,a,s){this.data.set(e,{values:r,dtype:s})},t.prototype.numDataIds=function(){return this.data.numDataIds()},t.prototype.read=function(e){return Yt(this,void 0,void 0,(function(){return Qt(this,(function(r){return[2,this.readSync(e)]}))}))},t.prototype.readSync=function(e){var r=this.data.get(e),a=r.dtype,s=r.complexTensors;return a==="complex64"?KN(this.readSync(s.real.dataId),this.readSync(s.imag.dataId)):this.data.get(e).values},t.prototype.bufferSync=function(e){var r=this.readSync(e.dataId),a=r;if(e.dtype==="string")try{a=r.map((function(s){return q0(s)}))}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return be(e.shape,e.dtype,a)},t.prototype.makeOutput=function(e,r,a){var s=this.write(e,r,a);return lt.makeTensorFromDataId(s,r,a,this)},t.prototype.disposeData=function(e){if(this.data.has(e)){var r=this.data.get(e).complexTensors;r!=null&&(r.real.dispose(),r.imag.dispose()),this.data.delete(e)}},t.prototype.time=function(e){return Yt(this,void 0,void 0,(function(){var r;return Qt(this,(function(a){return r=So(),e(),[2,{kernelMs:So()-r}]}))}))},t.prototype.memory=function(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}},t.prototype.complex=function(e,r){var a=this.makeOutput(null,e.shape,"complex64");return this.data.get(a.dataId).complexTensors={real:lt.keep(e.clone()),imag:lt.keep(r.clone())},a},t.prototype.real=function(e){return this.data.get(e.dataId).complexTensors.real.clone()},t.prototype.imag=function(e){return this.data.get(e.dataId).complexTensors.imag.clone()},t.prototype.slice=function(e,r,a){if(Dt(e,"slice"),tz(e.shape,r,a)){var s=ez(r,e.strides),o=ee(a);return Zr(this.readSync(e.dataId).subarray(s,s+o),a,e.dtype)}for(var i=be(a,e.dtype),u=this.bufferSync(e),l=0;l<i.size;++l){var h=i.indexToLoc(l).map((function(d,f){return d+r[f]}));i.values[l]=u.get.apply(u,h)}return i.toTensor()},t.prototype.stridedSlice=function(e,r,a,s){Dt(e,"stridedSlice");var o=PE(r,a,s);if(o.some((function(m){return m===0})))return Zr([],o);for(var i=be(o,e.dtype),u=this.bufferSync(e),l=0;l<i.size;l++){for(var h=i.indexToLoc(l),d=new Array(h.length),f=0;f<d.length;f++)d[f]=h[f]*s[f]+r[f];i.set.apply(i,[u.get.apply(u,d)].concat(h))}return i.toTensor()},t.prototype.diag=function(e){for(var r=this.readSync(e.dataId),a=be([e.size,e.size],e.dtype),s=a.values,o=0;o<r.length;o++)s[o*e.size+o]=r[o];return a.toTensor()},t.prototype.unstack=function(e,r){for(var a=e.shape[r],s=new Array(e.rank-1),o=0,i=0;i<e.rank;i++)i!==r&&(s[o++]=e.shape[i]);var u=new Array(e.rank).fill(0),l=e.shape.slice();l[r]=1;var h=new Array(a);for(i=0;i<h.length;i++)u[r]=i,h[i]=this.slice(e,u,l).reshape(s);return h},t.prototype.reverse=function(e,r){Dt(e,"reverse");for(var a=be(e.shape,e.dtype),s=this.bufferSync(e),o=function(u){var l=a.indexToLoc(u),h=l.slice();r.forEach((function(d){return h[d]=e.shape[d]-1-h[d]})),a.set.apply(a,[s.get.apply(s,h)].concat(l))},i=0;i<a.size;i++)o(i);return a.toTensor()},t.prototype.concat=function(e,r){var a=this;if(e[0].dtype==="complex64"){var s=e.map((function(m){return Ls(m)})),o=e.map((function(m){return Eo(m)}));return Yr(this.concat(s,r),this.concat(o,r))}var i=e.map((function(m){var v=ee(m.shape.slice(r));return m.as2D(-1,v)})),u=rd(i.map((function(m){return m.shape})),1),l=be(u,e[0].dtype).values;if(i[0].shape[0]===1){var h=0;i.forEach((function(m){l.set(a.readSync(m.dataId),h),h+=m.size}))}else{var d=0;i.forEach((function(m){for(var v=a.readSync(m.dataId),y=0,b=0;b<m.shape[0];++b)for(var w=b*u[1]+d,S=0;S<m.shape[1];++S)l[w+S]=v[y++];d+=m.shape[1]}))}var f=rd(e.map((function(m){return m.shape})),r);return Zr(l,f,e[0].dtype)},t.prototype.neg=function(e){return Dt(e,"neg"),this.multiply(Pt(-1),e)},t.prototype.add=function(e,r){return e.dtype==="complex64"||r.dtype==="complex64"?this.broadcastedBinaryComplexOp(e.cast("complex64"),r.cast("complex64"),(function(a,s,o,i){return{real:a+o,imag:s+i}})):this.broadcastedBinaryOp(e,r,Qr(e.dtype,r.dtype),(function(a,s){return a+s}))},t.prototype.addN=function(e){var r=this;Dt(e,"addN");for(var a=e.map((function(h){return r.readSync(h.dataId)})),s=be(e[0].shape,e[0].dtype),o=s.values,i=0;i<e.length;i++)for(var u=a[i],l=0;l<o.length;l++)o[l]+=u[l];return s.toTensor()},t.prototype.softmax=function(e,r){var a=Tr([r],e.shape),s=this.max(e,a),o=ja(s.shape,a),i=this.subtract(e,s.reshape(o)),u=this.exp(i),l=this.sum(u,a).reshape(o);return this.realDivide(u,l)},t.prototype.subtract=function(e,r){return e.dtype==="complex64"||r.dtype==="complex64"?this.broadcastedBinaryComplexOp(e.cast("complex64"),r.cast("complex64"),(function(a,s,o,i){return{real:a-o,imag:s-i}})):this.broadcastedBinaryOp(e,r,Qr(e.dtype,r.dtype),(function(a,s){return a-s}))},t.prototype.pow=function(e,r){return Dt([e,r],"pow"),this.broadcastedBinaryOp(e,r,e.dtype,(function(a,s){return Math.pow(a,s)}))},t.prototype.batchMatMul=function(e,r,a,s){Dt([e,r],"matMul");for(var o=a?e.shape[1]:e.shape[2],i=a?e.shape[2]:e.shape[1],u=s?r.shape[1]:r.shape[2],l=e.shape[0],h=this.readSync(e.dataId),d=this.readSync(r.dataId),f=a?[e.strides[0],1,e.strides[1]]:[e.strides[0],e.strides[1],1],m=f[0],v=f[1],y=f[2],b=s?[1,r.strides[1],r.strides[0]]:[r.strides[1],1,r.strides[0]],w=b[0],S=b[1],N=b[2],C=i*u,T=be([l,i,u],e.dtype),I=T.values,_=this.blockSize,$=0;$<l;$++)for(var R=0;R<i;R+=_)for(var D=0;D<u;D+=_)for(var A=0;A<o;A+=_)for(var L=Math.min(R+_,i),H=Math.min(D+_,u),G=Math.min(A+_,o),q=R;q<L;q++)for(var B=D;B<H;B++){for(var j=0,K=A;K<G;K++)j+=h[$*m+q*v+K*y]*d[K*w+B*S+$*N];I[$*C+(q*u+B)]+=j}return T.toTensor()},t.prototype.fusedBatchMatMul=function(e){var r=e.a,a=e.b,s=e.transposeA,o=e.transposeB,i=e.bias,u=e.activation,l=e.preluActivationWeights,h=this.batchMatMul(r,a,s,o);return i&&(h=this.add(h,i)),u&&(h=uC(this,h,u,l)),h},t.prototype.multiply=function(e,r){return e.dtype==="complex64"||r.dtype==="complex64"?this.broadcastedBinaryComplexOp(e.cast("complex64"),r.cast("complex64"),(function(a,s,o,i){return{real:a*o-s*i,imag:a*i+s*o}})):this.broadcastedBinaryOp(e,r,Qr(e.dtype,r.dtype),(function(a,s){return a*s}))},t.prototype.realDivide=function(e,r){return Dt([e,r],"realDivide"),this.broadcastedBinaryOp(e,r,"float32",(function(a,s){return a/s}))},t.prototype.floorDiv=function(e,r){return Dt([e,r],"floorDiv"),this.broadcastedBinaryOp(e,r,"int32",(function(a,s){return Math.floor(a/s)}))},t.prototype.sum=function(e,r){Dt(e,"sum"),ss("sum",r,e.rank);for(var a=na(e.shape,r),s=a[0],o=a[1],i=Sn(s,Qr(e.dtype,"int32")),u=ee(o),l=this.readSync(i.dataId),h=this.readSync(e.dataId),d=0;d<l.length;++d){for(var f=d*u,m=0,v=0;v<u;++v)m+=h[f+v];l[d]=m}return i},t.prototype.prod=function(e,r){Dt(e,"sum");for(var a=na(e.shape,r),s=a[0],o=a[1],i=Sn(s,Qr(e.dtype,"int32")),u=ee(o),l=this.readSync(i.dataId),h=this.readSync(e.dataId),d=0;d<l.length;++d){for(var f=d*u,m=1,v=0;v<u;++v)m*=h[f+v];l[d]=m}return i},t.prototype.unsortedSegmentSum=function(e,r,a){Dt(e,"unsortedSegmentSum");for(var s=[],o=e.rank-r.rank,i=0;i<o;++i)r=r.expandDims(i+1);for(i=0;i<a;++i){var u=Pt(i,"int32"),l=$z(u,r).asType("float32").mul(e).sum(0);s.push(l)}return ys(s)},t.prototype.argMin=function(e,r){Dt(e,"argMin");var a=[r];ss("argMin",a,e.rank);for(var s=na(e.shape,a),o=s[0],i=s[1],u=Sn(o,"int32"),l=ee(i),h=this.readSync(u.dataId),d=this.readSync(e.dataId),f=0;f<h.length;++f){for(var m=f*l,v=d[m],y=0,b=0;b<l;++b){var w=d[m+b];w<v&&(v=w,y=b)}h[f]=y}return u},t.prototype.argMax=function(e,r){Dt(e,"argMax");var a=[r];ss("argMax",a,e.rank);for(var s=na(e.shape,a),o=s[0],i=s[1],u=Sn(o,"int32"),l=ee(i),h=this.readSync(u.dataId),d=this.readSync(e.dataId),f=0;f<h.length;++f){for(var m=f*l,v=d[m],y=0,b=0;b<l;++b){var w=d[m+b];w>v&&(v=w,y=b)}h[f]=y}return u},t.prototype.cumsum=function(e,r,a,s){if(Dt(e,"cumsum"),r!==e.rank-1)throw new Error("backend.cumsum in CPU expects an inner-most axis="+(e.rank-1)+" but got axis="+r);for(var o=Qr(e.dtype,"int32"),i=Sn(e.shape,o),u=this.readSync(i.dataId),l=this.readSync(e.dataId),h=e.shape[e.rank-1],d=s?function(b,w){return b+h-w-1}:function(b,w){return b+w},f=0;f<l.length;f+=h)for(var m=0;m<h;m++){var v=d(f,m);if(m===0)u[v]=a?0:l[v];else{var y=d(f,m-1);u[v]=a?l[y]+u[y]:l[v]+u[y]}}return i},t.prototype.equal=function(e,r){return Dt([e,r],"equal"),this.broadcastedBinaryOp(e,r,"bool",(function(a,s){return a===s?1:0}))},t.prototype.notEqual=function(e,r){return Dt([e,r],"notEqual"),this.broadcastedBinaryOp(e,r,"bool",(function(a,s){return a!==s?1:0}))},t.prototype.less=function(e,r){return Dt([e,r],"less"),this.broadcastedBinaryOp(e,r,"bool",(function(a,s){return a<s?1:0}))},t.prototype.lessEqual=function(e,r){return Dt([e,r],"lessEqual"),this.broadcastedBinaryOp(e,r,"bool",(function(a,s){return a<=s?1:0}))},t.prototype.greater=function(e,r){return Dt([e,r],"greater"),this.broadcastedBinaryOp(e,r,"bool",(function(a,s){return a>s?1:0}))},t.prototype.greaterEqual=function(e,r){return Dt([e,r],"greaterEqual"),this.broadcastedBinaryOp(e,r,"bool",(function(a,s){return a>=s?1:0}))},t.prototype.logicalNot=function(e){Dt(e,"logicalNot");for(var r=this.readSync(e.dataId),a=new Uint8Array(r.length),s=0;s<r.length;++s)a[s]=r[s]?0:1;return this.makeOutput(a,e.shape,"bool")},t.prototype.logicalAnd=function(e,r){return Dt([e,r],"logicalAnd"),this.broadcastedBinaryOp(e,r,"bool",(function(a,s){return a&&s}))},t.prototype.logicalOr=function(e,r){return Dt([e,r],"logicalOr"),this.broadcastedBinaryOp(e,r,"bool",(function(a,s){return a||s}))},t.prototype.select=function(e,r,a){Dt([e,r,a],"select");for(var s=this.readSync(e.dataId),o=this.readSync(r.dataId),i=this.readSync(a.dataId),u=Sn(r.shape,Qr(r.dtype,a.dtype)),l=this.readSync(u.dataId),h=0,d=e.rank===0||e.rank>1||r.rank===1?1:ee(r.shape.slice(1)),f=0;f<s.length;f++)for(var m=0;m<d;m++)s[f]===1?l[h++]=o[f]:l[h++]=i[f];return u},t.prototype.where=function(e){Dt([e],"where");var r=this.readSync(e.dataId);return GE(e.shape,r)},t.prototype.topk=function(e,r,a){return Dt(e,"topk"),cz(this.readSync(e.dataId),e.shape,e.dtype,r)},t.prototype.min=function(e,r){Dt(e,"min"),ss("min",r,e.rank);for(var a=na(e.shape,r),s=a[0],o=a[1],i=Sn(s,e.dtype),u=ee(o),l=this.readSync(i.dataId),h=this.readSync(e.dataId),d=0;d<l.length;++d){for(var f=d*u,m=h[f],v=0;v<u;++v){var y=h[f+v];y<m&&(m=y)}l[d]=m}return i},t.prototype.minimum=function(e,r){return Dt([e,r],"minimum"),this.broadcastedBinaryOp(e,r,e.dtype,(function(a,s){return Math.min(a,s)}))},t.prototype.mod=function(e,r){return Dt([e,r],"mod"),this.broadcastedBinaryOp(e,r,e.dtype,(function(a,s){var o=a%s;return a<0&&s<0||a>=0&&s>=0?o:(o+s)%s}))},t.prototype.max=function(e,r){Dt(e,"max"),ss("max",r,e.rank);for(var a=na(e.shape,r),s=a[0],o=a[1],i=Sn(s,e.dtype),u=ee(o),l=this.readSync(i.dataId),h=this.readSync(e.dataId),d=0;d<l.length;++d){for(var f=d*u,m=h[f],v=0;v<u;++v){var y=h[f+v];y>m&&(m=y)}l[d]=m}return i},t.prototype.maximum=function(e,r){return Dt([e,r],"maximum"),this.broadcastedBinaryOp(e,r,e.dtype,(function(a,s){return Math.max(a,s)}))},t.prototype.all=function(e,r){Dt(e,"all"),ss("all",r,e.rank);for(var a=na(e.shape,r),s=a[0],o=a[1],i=Sn(s,e.dtype),u=ee(o),l=this.readSync(i.dataId),h=this.readSync(e.dataId),d=0;d<l.length;++d){for(var f=d*u,m=h[f],v=0;v<u;++v){var y=h[f+v];m=m&&y}l[d]=m}return i},t.prototype.any=function(e,r){Dt(e,"any"),ss("any",r,e.rank);for(var a=na(e.shape,r),s=a[0],o=a[1],i=Sn(s,e.dtype),u=ee(o),l=this.readSync(i.dataId),h=this.readSync(e.dataId),d=0;d<l.length;++d){for(var f=d*u,m=h[f],v=0;v<u;++v){var y=h[f+v];m=m||y}l[d]=m}return i},t.prototype.squaredDifference=function(e,r){return Dt([e,r],"squaredDifference"),this.broadcastedBinaryOp(e,r,e.dtype,(function(a,s){var o=a-s;return o*o}))},t.prototype.ceil=function(e){Dt(e,"ceil");for(var r=this.readSync(e.dataId),a=new Float32Array(r.length),s=0;s<r.length;++s)a[s]=Math.ceil(r[s]);return this.makeOutput(a,e.shape,"float32")},t.prototype.floor=function(e){Dt(e,"floor");for(var r=this.readSync(e.dataId),a=new Float32Array(r.length),s=0;s<r.length;++s)a[s]=Math.floor(r[s]);return this.makeOutput(a,e.shape,"float32")},t.prototype.sign=function(e){Dt(e,"x");for(var r=this.readSync(e.dataId),a=new Float32Array(r.length),s=0;s<r.length;++s)r[s]<0?a[s]=-1:r[s]>0?a[s]=1:a[s]=0;return this.makeOutput(a,e.shape,"float32")},t.prototype.isNaN=function(e){Dt(e,"x");for(var r=this.readSync(e.dataId),a=new Uint8Array(r.length),s=0;s<r.length;++s)Number.isNaN(r[s])&&(a[s]=1);return this.makeOutput(a,e.shape,"bool")},t.prototype.isInf=function(e){Dt(e,"x");for(var r=this.readSync(e.dataId),a=new Uint8Array(r.length),s=0;s<r.length;++s)Math.abs(r[s])===1/0&&(a[s]=1);return this.makeOutput(a,e.shape,"bool")},t.prototype.isFinite=function(e){Dt(e,"x");for(var r=this.readSync(e.dataId),a=new Uint8Array(r.length),s=0;s<r.length;++s)Number.isFinite(r[s])&&(a[s]=1);return this.makeOutput(a,e.shape,"bool")},t.prototype.round=function(e){Dt(e,"round");for(var r=this.readSync(e.dataId),a=new Float32Array(r.length),s=0;s<r.length;++s){var o=Math.floor(r[s]);r[s]-o<.5?a[s]=Math.floor(r[s]):r[s]-o>.5?a[s]=Math.ceil(r[s]):a[s]=o%2==0?o:o+1}return this.makeOutput(a,e.shape,"float32")},t.prototype.exp=function(e){Dt(e,"exp");for(var r=this.readSync(e.dataId),a=new Float32Array(r.length),s=0;s<r.length;++s)a[s]=Math.exp(r[s]);return this.makeOutput(a,e.shape,"float32")},t.prototype.expm1=function(e){Dt(e,"expm1");for(var r=this.readSync(e.dataId),a=new Float32Array(r.length),s=0;s<r.length;++s)a[s]=Math.expm1(r[s]);return this.makeOutput(a,e.shape,"float32")},t.prototype.log=function(e){Dt(e,"log");for(var r=this.readSync(e.dataId),a=new Float32Array(r.length),s=0;s<r.length;++s){var o=r[s];a[s]=Math.log(o)}return this.makeOutput(a,e.shape,"float32")},t.prototype.log1p=function(e){Dt(e,"log1p");for(var r=this.readSync(e.dataId),a=new Float32Array(r.length),s=0;s<r.length;++s){var o=r[s];a[s]=Math.log1p(o)}return this.makeOutput(a,e.shape,"float32")},t.prototype.sqrt=function(e){Dt(e,"sqrt");for(var r=this.readSync(e.dataId),a=new Float32Array(r.length),s=0;s<r.length;++s){var o=r[s];a[s]=Math.sqrt(o)}return this.makeOutput(a,e.shape,"float32")},t.prototype.rsqrt=function(e){Dt(e,"rsqrt");for(var r=this.readSync(e.dataId),a=new Float32Array(r.length),s=0;s<r.length;++s){var o=r[s];a[s]=1/Math.sqrt(o)}return this.makeOutput(a,e.shape,"float32")},t.prototype.reciprocal=function(e){Dt(e,"reciprocal");for(var r=this.readSync(e.dataId),a=new Float32Array(r.length),s=0;s<r.length;++s)a[s]=1/r[s];return this.makeOutput(a,e.shape,"float32")},t.prototype.linear=function(e){return e},t.prototype.relu=function(e){Dt(e,"relu");for(var r=Sn(e.shape,e.dtype),a=this.readSync(r.dataId),s=this.readSync(e.dataId),o=0;o<s.length;++o)a[o]=Math.max(0,s[o]);return r},t.prototype.relu6=function(e){Dt(e,"relu");for(var r=Sn(e.shape,e.dtype),a=this.readSync(r.dataId),s=this.readSync(e.dataId),o=0;o<s.length;++o)a[o]=Math.min(Math.max(0,s[o]),6);return r},t.prototype.prelu=function(e,r){return Dt([e,r],"prelu"),this.broadcastedBinaryOp(e,r,e.dtype,(function(a,s){return a<0?s*a:a}))},t.prototype.elu=function(e){Dt(e,"elu");for(var r=new Float32Array(e.size),a=this.readSync(e.dataId),s=0;s<a.length;++s){var o=a[s];r[s]=o>=0?o:Math.exp(o)-1}return this.makeOutput(r,e.shape,"float32")},t.prototype.eluDer=function(e,r){Dt([e,r],"eluDer");for(var a=new Float32Array(r.size),s=this.readSync(r.dataId),o=this.readSync(e.dataId),i=0;i<s.length;++i){var u=s[i];a[i]=u>=1?o[i]:o[i]*(u+1)}return this.makeOutput(a,r.shape,"float32")},t.prototype.selu=function(e){Dt(e,"selu");for(var r=jE,a=qE,s=new Float32Array(e.size),o=this.readSync(e.dataId),i=0;i<o.length;++i){var u=o[i];s[i]=u>=0?a*u:r*(Math.exp(u)-1)}return this.makeOutput(s,e.shape,"float32")},t.prototype.clip=function(e,r,a){Dt(e,"clip");for(var s=new Float32Array(e.size),o=this.readSync(e.dataId),i=0;i<o.length;++i){var u=o[i];s[i]=u>a?a:u<r?r:u}return this.makeOutput(s,e.shape,"float32")},t.prototype.abs=function(e){for(var r=new Float32Array(e.size),a=this.readSync(e.dataId),s=0;s<a.length;++s)r[s]=Math.abs(a[s]);return this.makeOutput(r,e.shape,"float32")},t.prototype.complexAbs=function(e){for(var r=new Float32Array(e.size),a=this.readSync(e.dataId),s=0;s<e.size;++s){var o=a[2*s],i=a[2*s+1];r[s]=Math.hypot(o,i)}return this.makeOutput(r,e.shape,"float32")},t.prototype.int=function(e){Dt(e,"int");for(var r=new Int32Array(e.size),a=this.readSync(e.dataId),s=0;s<a.length;++s)r[s]=a[s];return this.makeOutput(r,e.shape,"int32")},t.prototype.sigmoid=function(e){Dt(e,"sigmoid");for(var r=new Float32Array(e.size),a=this.readSync(e.dataId),s=0;s<a.length;++s)r[s]=1/(1+Math.exp(-a[s]));return this.makeOutput(r,e.shape,"float32")},t.prototype.softplus=function(e){Dt(e,"softplus");for(var r=Math.log(11920928955078125e-23)+2,a=new Float32Array(e.size),s=this.readSync(e.dataId),o=0;o<s.length;++o){var i=s[o]>-r,u=s[o]<r,l=Math.exp(s[o]),h=void 0;h=u?l:i?s[o]:Math.log(1+l),a[o]=h}return this.makeOutput(a,e.shape,"float32")},t.prototype.sin=function(e){Dt(e,"sin");for(var r=new Float32Array(e.size),a=this.readSync(e.dataId),s=0;s<a.length;++s)r[s]=Math.sin(a[s]);return this.makeOutput(r,e.shape,"float32")},t.prototype.cos=function(e){Dt(e,"cos");for(var r=new Float32Array(e.size),a=this.readSync(e.dataId),s=0;s<a.length;++s)r[s]=Math.cos(a[s]);return this.makeOutput(r,e.shape,"float32")},t.prototype.tan=function(e){Dt(e,"tan");for(var r=new Float32Array(e.size),a=this.readSync(e.dataId),s=0;s<a.length;++s)r[s]=Math.tan(a[s]);return this.makeOutput(r,e.shape,"float32")},t.prototype.asin=function(e){Dt(e,"asin");for(var r=new Float32Array(e.size),a=this.readSync(e.dataId),s=0;s<a.length;++s)r[s]=Math.asin(a[s]);return this.makeOutput(r,e.shape,"float32")},t.prototype.acos=function(e){Dt(e,"acos");for(var r=new Float32Array(e.size),a=this.readSync(e.dataId),s=0;s<a.length;++s)r[s]=Math.acos(a[s]);return this.makeOutput(r,e.shape,"float32")},t.prototype.atan=function(e){Dt(e,"atan");for(var r=new Float32Array(e.size),a=this.readSync(e.dataId),s=0;s<a.length;++s)r[s]=Math.atan(a[s]);return this.makeOutput(r,e.shape,"float32")},t.prototype.atan2=function(e,r){return Dt([e,r],"atan2"),this.broadcastedBinaryOp(e,r,e.dtype,(function(a,s){return Math.atan2(a,s)}))},t.prototype.sinh=function(e){Dt(e,"sinh");for(var r=new Float32Array(e.size),a=this.readSync(e.dataId),s=0;s<a.length;++s)r[s]=Math.sinh(a[s]);return this.makeOutput(r,e.shape,"float32")},t.prototype.cosh=function(e){Dt(e,"cosh");for(var r=new Float32Array(e.size),a=this.readSync(e.dataId),s=0;s<a.length;++s)r[s]=Math.cosh(a[s]);return this.makeOutput(r,e.shape,"float32")},t.prototype.tanh=function(e){Dt(e,"tanh");for(var r=new Float32Array(e.size),a=this.readSync(e.dataId),s=0;s<a.length;++s)r[s]=vet(a[s]);return this.makeOutput(r,e.shape,"float32")},t.prototype.asinh=function(e){Dt(e,"asinh");for(var r=new Float32Array(e.size),a=this.readSync(e.dataId),s=0;s<a.length;++s)r[s]=Math.asinh(a[s]);return this.makeOutput(r,e.shape,"float32")},t.prototype.acosh=function(e){Dt(e,"acosh");for(var r=new Float32Array(e.size),a=this.readSync(e.dataId),s=0;s<a.length;++s)r[s]=Math.acosh(a[s]);return this.makeOutput(r,e.shape,"float32")},t.prototype.atanh=function(e){Dt(e,"atanh");for(var r=new Float32Array(e.size),a=this.readSync(e.dataId),s=0;s<a.length;++s)r[s]=Math.atanh(a[s]);return this.makeOutput(r,e.shape,"float32")},t.prototype.erf=function(e){Dt(e,"erf");for(var r=new Float32Array(e.size),a=this.readSync(e.dataId),s=0;s<a.length;++s){var o=Math.sign(a[s]),i=Math.abs(a[s]),u=1/(1+.3275911*i);r[s]=o*(1-((((1.061405429*u-1.453152027)*u+1.421413741)*u-.284496736)*u+.254829592)*u*Math.exp(-i*i))}return this.makeOutput(r,e.shape,"float32")},t.prototype.step=function(e,r){r===void 0&&(r=0),Dt(e,"step");for(var a=new Float32Array(e.size),s=this.readSync(e.dataId),o=0;o<s.length;++o){var i=s[o];isNaN(i)?a[o]=NaN:a[o]=i>0?1:r}return this.makeOutput(a,e.shape,"float32")},t.prototype.fusedConv2d=function(e){var r=e.input,a=e.filter,s=e.convInfo,o=e.bias,i=e.activation,u=e.preluActivationWeights,l=this.conv2d(r,a,s);return o&&(l=this.add(l,o)),i&&(l=uC(this,l,i,u)),l},t.prototype.conv2d=function(e,r,a){Dt([e,r],"conv2d");for(var s=a.filterHeight,o=a.filterWidth,i=a.dilationHeight,u=a.dilationWidth,l=a.padInfo.left,h=a.padInfo.top,d=a.dataFormat==="channelsLast",f=be(a.outShape,e.dtype),m=e.strides[0],v=d?e.strides[1]:e.strides[2],y=d?e.strides[2]:1,b=d?1:e.strides[1],w=f.strides[0],S=d?f.strides[1]:f.strides[2],N=d?f.strides[2]:1,C=d?1:f.strides[1],T=this.readSync(e.dataId),I=this.readSync(r.dataId),_=f.values,$=0;$<a.batchSize;++$)for(var R=$*m,D=$*w,A=0;A<a.outHeight;++A)for(var L=D+A*S,H=A*a.strideHeight-h,G=0;G<s;G++){var q=H+G*i;if(!(q<0||q>=a.inHeight))for(var B=G*r.strides[0],j=R+q*v,K=0;K<a.outWidth;++K)for(var z=L+K*N,U=K*a.strideWidth-l,M=0;M<o;M++){var X=U+M*u;if(!(X<0||X>=a.inWidth))for(var Q=j+X*y,rt=B+M*r.strides[1],ct=0;ct<a.inChannels;++ct){for(var pt=T[Q+ct*b],yt=0;yt<a.outChannels;++yt)_[z+yt*C]+=pt*I[rt+yt];rt+=a.outChannels}}}return f.toTensor()},t.prototype.conv3d=function(e,r,a){for(var s=a.filterDepth,o=a.filterHeight,i=a.filterWidth,u=a.dilationDepth,l=a.dilationHeight,h=a.dilationWidth,d=a.padInfo.front,f=a.padInfo.left,m=a.padInfo.top,v=be(a.outShape,e.dtype),y=this.readSync(e.dataId),b=this.readSync(r.dataId),w=v.values,S=0;S<a.batchSize;++S)for(var N=S*e.strides[0],C=S*v.strides[0],T=0;T<a.outDepth;++T)for(var I=C+T*v.strides[1],_=T*a.strideDepth-d,$=0;$<s;$++){var R=_+$*u;if(!(R<0||R>=a.inDepth))for(var D=$*r.strides[0],A=N+R*e.strides[1],L=0;L<a.outHeight;++L)for(var H=I+L*v.strides[2],G=L*a.strideHeight-m,q=0;q<o;q++){var B=G+q*l;if(!(B<0||B>=a.inHeight))for(var j=D+q*r.strides[1],K=A+B*e.strides[2],z=0;z<a.outWidth;++z)for(var U=H+z*a.outChannels,M=z*a.strideWidth-f,X=0;X<i;X++){var Q=M+X*h;if(!(Q<0||Q>=a.inWidth))for(var rt=j+X*r.strides[2],ct=K+Q*a.inChannels,pt=rt,yt=0;yt<a.inChannels;++yt){for(var Tt=y[ct+yt],gt=0;gt<a.outChannels;++gt)w[U+gt]+=Tt*b[pt+gt];pt+=a.outChannels}}}}return v.toTensor()},t.prototype.conv2dDerInput=function(e,r,a){Dt([e,r],"conv2dDerInput");for(var s=be(a.inShape,"float32"),o=s.values,i=this.readSync(e.dataId),u=this.readSync(r.dataId),l=r.strides,h=l[0],d=l[1],f=l[2],m=a.batchSize,v=a.filterHeight,y=a.filterWidth,b=a.inChannels,w=a.inHeight,S=a.inWidth,N=a.outChannels,C=a.outHeight,T=a.outWidth,I=a.strideHeight,_=a.strideWidth,$=a.dataFormat,R=v-1-a.padInfo.top,D=y-1-a.padInfo.left,A=$==="channelsLast",L=s.strides[0],H=A?s.strides[1]:s.strides[2],G=A?s.strides[2]:1,q=A?1:s.strides[1],B=e.strides[0],j=A?e.strides[1]:e.strides[2],K=A?e.strides[2]:1,z=A?1:e.strides[1],U=0;U<m;++U)for(var M=0;M<b;++M)for(var X=0;X<w;++X)for(var Q=X-R,rt=Math.max(0,Math.ceil(Q/I)),ct=Math.min(C,(v+Q)/I),pt=0;pt<S;++pt){for(var yt=pt-D,Tt=Math.max(0,Math.ceil(yt/_)),gt=Math.min(T,(y+yt)/_),Rt=0,At=rt;At<ct;++At)for(var Lt=At*I-Q,Mt=Tt;Mt<gt;++Mt)for(var Wt=B*U+j*At+K*Mt,se=h*(v-1-Lt)+d*(y-1-(Mt*_-yt))+f*M,Xt=0;Xt<N;++Xt)Rt+=i[Wt+z*Xt]*u[se+Xt];o[L*U+H*X+G*pt+q*M]=Rt}return s.toTensor()},t.prototype.conv3dDerInput=function(e,r,a){for(var s=be(a.inShape,"float32"),o=s.values,i=s.strides,u=i[0],l=i[1],h=i[2],d=i[3],f=this.readSync(e.dataId),m=e.strides,v=m[0],y=m[1],b=m[2],w=m[3],S=this.readSync(r.dataId),N=r.strides,C=N[0],T=N[1],I=N[2],_=N[3],$=a.batchSize,R=a.filterDepth,D=a.filterHeight,A=a.filterWidth,L=a.inChannels,H=a.inDepth,G=a.inHeight,q=a.inWidth,B=a.outChannels,j=a.outDepth,K=a.outHeight,z=a.outWidth,U=a.strideDepth,M=a.strideHeight,X=a.strideWidth,Q=R-1-a.padInfo.front,rt=D-1-a.padInfo.top,ct=A-1-a.padInfo.left,pt=0;pt<$;++pt)for(var yt=0;yt<L;++yt)for(var Tt=0;Tt<H;++Tt)for(var gt=Tt-Q,Rt=Math.max(0,Math.ceil(gt/U)),At=Math.min(j,(R+gt)/U),Lt=0;Lt<G;++Lt)for(var Mt=Lt-rt,Wt=Math.max(0,Math.ceil(Mt/M)),se=Math.min(K,(D+Mt)/M),Xt=0;Xt<q;++Xt){for(var Se=Xt-ct,pe=Math.max(0,Math.ceil(Se/X)),Xe=Math.min(z,(A+Se)/X),We=0,hn=Rt;hn<At;++hn)for(var vn=hn*U-gt,Hn=Wt;Hn<se;++Hn)for(var Ge=Hn*M-Mt,Ot=pe;Ot<Xe;++Ot)for(var Ht=v*pt+y*hn+b*Hn+w*Ot,Ce=C*(R-1-vn)+T*(D-1-Ge)+I*(A-1-(Ot*X-Se))+_*yt,ge=0;ge<B;++ge)We+=f[Ht+ge]*S[Ce+ge];o[u*pt+l*Tt+h*Lt+d*Xt+yt]=We}return s.toTensor()},t.prototype.conv2dDerFilter=function(e,r,a){Dt([e,r],"conv2dDerFilter");for(var s=a.strideHeight,o=a.strideWidth,i=a.filterHeight,u=a.filterWidth,l=a.dataFormat==="channelsLast",h=be(a.filterShape,"float32"),d=a.padInfo.left,f=a.padInfo.top,m=this.bufferSync(e),v=this.bufferSync(r),y=0;y<i;++y)for(var b=Math.max(0,Math.ceil((f-y)/s)),w=Math.min(a.outHeight,(a.inHeight+f-y)/s),S=0;S<u;++S)for(var N=Math.max(0,Math.ceil((d-S)/o)),C=Math.min(a.outWidth,(a.inWidth+d-S)/o),T=0;T<a.inChannels;++T)for(var I=0;I<a.outChannels;++I){for(var _=0,$=0;$<a.batchSize;++$)for(var R=b;R<w;++R)for(var D=y+R*s-f,A=N;A<C;++A){var L=S+A*o-d;_+=l?m.get($,D,L,T)*v.get($,R,A,I):m.get($,T,D,L)*v.get($,I,R,A)}h.set(_,y,S,T,I)}return h.toTensor()},t.prototype.conv3dDerFilter=function(e,r,a){for(var s=a.strideDepth,o=a.strideHeight,i=a.strideWidth,u=a.filterDepth,l=a.filterHeight,h=a.filterWidth,d=be(a.filterShape,"float32"),f=d.values,m=d.strides,v=m[0],y=m[1],b=m[2],w=m[3],S=this.readSync(r.dataId),N=r.strides,C=N[0],T=N[1],I=N[2],_=N[3],$=this.readSync(e.dataId),R=e.strides,D=R[0],A=R[1],L=R[2],H=R[3],G=a.padInfo.front,q=a.padInfo.left,B=a.padInfo.top,j=0;j<u;++j)for(var K=Math.max(0,Math.ceil((G-j)/s)),z=Math.min(a.outDepth,(a.inDepth+G-j)/s),U=j*v,M=0;M<l;++M)for(var X=Math.max(0,Math.ceil((B-M)/o)),Q=Math.min(a.outHeight,(a.inHeight+B-M)/o),rt=M*y+U,ct=0;ct<h;++ct)for(var pt=Math.max(0,Math.ceil((q-ct)/i)),yt=Math.min(a.outWidth,(a.inWidth+q-ct)/i),Tt=ct*b+rt,gt=0;gt<a.inChannels;++gt)for(var Rt=gt*w+Tt,At=0;At<a.outChannels;++At){for(var Lt=0,Mt=0;Mt<a.batchSize;++Mt)for(var Wt=Mt*D,se=Mt*C,Xt=K;Xt<z;++Xt)for(var Se=(j+Xt*s-G)*A+Wt,pe=Xt*T+se,Xe=X;Xe<Q;++Xe)for(var We=(M+Xe*o-B)*L+Se,hn=Xe*I+pe,vn=pt;vn<yt;++vn){var Hn=vn*_+hn;Lt+=$[(ct+vn*i-q)*H+We+gt]*S[Hn+At]}f[Rt+At]=Lt}return d.toTensor()},t.prototype.fusedDepthwiseConv2D=function(e){var r=e.input,a=e.filter,s=e.convInfo,o=e.bias,i=e.activation,u=e.preluActivationWeights,l=this.depthwiseConv2D(r,a,s);return o&&(l=this.add(l,o)),i&&(l=uC(this,l,i,u)),l},t.prototype.depthwiseConv2D=function(e,r,a){Dt([e,r],"depthwiseConv2D");for(var s=a.filterHeight,o=a.filterWidth,i=a.dilationHeight,u=a.dilationWidth,l=a.padInfo.left,h=a.padInfo.top,d=a.outChannels/a.inChannels,f=be(a.outShape,e.dtype),m=this.readSync(e.dataId),v=this.readSync(r.dataId),y=f.values,b=0;b<a.batchSize;++b)for(var w=b*e.strides[0],S=b*f.strides[0],N=0;N<a.outHeight;++N)for(var C=S+N*f.strides[1],T=N*a.strideHeight-l,I=0;I<s;++I){var _=T+I*i;if(!(_<0||_>=a.inHeight))for(var $=I*r.strides[0],R=w+_*e.strides[1],D=0;D<a.outWidth;++D)for(var A=C+D*f.strides[2],L=D*a.strideWidth-h,H=0;H<o;++H){var G=L+H*u;if(!(G<0||G>=a.inWidth))for(var q=$+H*r.strides[1],B=R+G*a.inChannels,j=A,K=q,z=0;z<a.inChannels;++z){for(var U=m[B+z],M=0;M<d;++M)y[j+M]+=U*v[K+M];j+=d,K+=d}}}return f.toTensor()},t.prototype.depthwiseConv2DDerInput=function(e,r,a){Dt([e,r],"depthwiseConv2DDerInput");for(var s=be(a.inShape,"float32"),o=s.values,i=s.strides,u=i[0],l=i[1],h=i[2],d=this.readSync(e.dataId),f=e.strides,m=f[0],v=f[1],y=f[2],b=this.readSync(r.dataId),w=r.strides,S=w[0],N=w[1],C=w[2],T=a.batchSize,I=a.filterHeight,_=a.filterWidth,$=a.inChannels,R=a.inHeight,D=a.inWidth,A=a.outChannels,L=a.outHeight,H=a.outWidth,G=a.strideHeight,q=a.strideWidth,B=I-1-a.padInfo.top,j=_-1-a.padInfo.left,K=A/$,z=0;z<T;++z)for(var U=0;U<$;++U)for(var M=0;M<R;++M)for(var X=M-B,Q=Math.max(0,Math.ceil(X/G)),rt=Math.min(L,(I+X)/G),ct=0;ct<D;++ct){for(var pt=ct-j,yt=Math.max(0,Math.ceil(pt/q)),Tt=Math.min(H,(_+pt)/q),gt=0,Rt=Q;Rt<rt;++Rt)for(var At=Rt*G-X,Lt=yt;Lt<Tt;++Lt)for(var Mt=m*z+v*Rt+y*Lt,Wt=S*(I-1-At)+N*(_-1-(Lt*q-pt))+C*U,se=0;se<K;++se)gt+=d[Mt+(U*K+se)]*b[Wt+se];o[u*z+l*M+h*ct+U]=gt}return s.toTensor()},t.prototype.depthwiseConv2DDerFilter=function(e,r,a){Dt([e,r],"depthwiseConv2DDerFilter");for(var s=a.strideHeight,o=a.strideWidth,i=a.filterHeight,u=a.filterWidth,l=be(a.filterShape,"float32"),h=a.padInfo.left,d=a.padInfo.top,f=a.outChannels/a.inChannels,m=this.bufferSync(e),v=this.bufferSync(r),y=0;y<i;++y)for(var b=Math.max(0,Math.ceil((d-y)/s)),w=Math.min(a.outHeight,(a.inHeight+d-y)/s),S=0;S<u;++S)for(var N=Math.max(0,Math.ceil((h-S)/o)),C=Math.min(a.outWidth,(a.inWidth+h-S)/o),T=0;T<a.outChannels;++T){for(var I=Math.trunc(T/f),_=T%f,$=0,R=0;R<a.batchSize;++R)for(var D=b;D<w;++D)for(var A=y+D*s-d,L=N;L<C;++L){var H=S+L*o-h;$+=m.get(R,A,H,I)*v.get(R,D,L,T)}l.set($,y,S,I,_)}return l.toTensor()},t.prototype.tile=function(e,r){return Dt(e,"tile"),lz(this.bufferSync(e),r)},t.prototype.pad=function(e,r,a){Dt(e,"pad");var s=r.map((function(f,m){return f[0]+e.shape[m]+f[1]})),o=r.map((function(f){return f[0]})),i=this.bufferSync(e),u=be(s,e.dtype);a!==0&&u.values.fill(a);for(var l=0;l<e.size;l++){var h=i.indexToLoc(l),d=h.map((function(f,m){return f+o[m]}));u.set.apply(u,[i.get.apply(i,h)].concat(d))}return u.toTensor()},t.prototype.transpose=function(e,r){Dt(e,"transpose");for(var a=new Array(e.rank),s=0;s<a.length;s++)a[s]=e.shape[r[s]];var o=this.readSync(e.dataId),i=be(a,e.dtype),u=this.bufferSync(e);for(s=0;s<e.size;++s){for(var l=u.indexToLoc(s),h=new Array(l.length),d=0;d<h.length;d++)h[d]=l[r[d]];var f=i.locToIndex(h);i.values[f]=o[s]}return i.toTensor()},t.prototype.gather=function(e,r,a){Dt([e,r],"gather");var s=e.shape.slice(),o=this.readSync(r.dataId);s[a]=o.length;for(var i=be(s,e.dtype),u=this.bufferSync(e),l=0;l<i.size;++l){var h=i.indexToLoc(l),d=h.slice();d[a]=o[h[a]];var f=u.locToIndex(d);i.values[l]=u.values[f]}return i.toTensor()},t.prototype.batchToSpaceND=function(e,r,a){Dt([e],"batchToSpaceND");var s=r.reduce((function(d,f){return d*f})),o=J0(e.shape,r,s),i=tb(o.length,r.length),u=eb(e.shape,r,s),l=YB(a,r.length),h=QB(u,a,r.length);return e.reshape(o).transpose(i).reshape(u).slice(l,h)},t.prototype.spaceToBatchND=function(e,r,a){Dt([e],"spaceToBatchND");var s=r.reduce((function(f,m){return f*m})),o=[[0,0]];o.push.apply(o,a);for(var i=1+r.length;i<e.shape.length;++i)o.push([0,0]);var u=e.pad(o),l=J0(u.shape,r,s,!1),h=tb(l.length,r.length,!1),d=eb(u.shape,r,s,!1);return u.reshape(l).transpose(h).reshape(d)},t.prototype.pool=function(e,r,a){Dt(e,"pool");for(var s=r.strideHeight,o=r.strideWidth,i=r.dilationHeight,u=r.dilationWidth,l=r.effectiveFilterHeight,h=r.effectiveFilterWidth,d=r.padInfo.top,f=r.padInfo.left,m=a==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,v=this.readSync(e.dataId),y=be(r.outShape,e.dtype),b=y.values,w=r.outShape[1]*r.outShape[2]*r.outShape[3],S=r.outShape[2]*r.outShape[3],N=r.outShape[3],C=0;C<r.batchSize;++C)for(var T=C*w,I=C*e.strides[0],_=0;_<r.inChannels;++_)for(var $=0;$<r.outHeight;++$)for(var R=$*s-d,D=Math.max(0,R),A=Math.min(r.inHeight,l+R),L=T+$*S,H=0;H<r.outWidth;++H){for(var G=H*o-f,q=Math.max(0,G),B=Math.min(r.inWidth,h+G),j=m,K=0,z=0,U=D;U<A;U+=i){for(var M=I+U*e.strides[1],X=q;X<B;X+=u){var Q=v[M+X*e.strides[2]+_];a==="max"&&Q>j?j=Q:a==="avg"&&(K+=Q,z++)}if(isNaN(j))break}b[L+H*N+_]=a==="avg"?K/z:j}return y.toTensor()},t.prototype.maxPool=function(e,r){return this.pool(e,r,"max")},t.prototype.maxPoolPositions=function(e,r){for(var a=be(r.outShape,"int32"),s=r.strideHeight,o=r.strideWidth,i=r.dilationHeight,u=r.dilationWidth,l=r.effectiveFilterHeight,h=r.effectiveFilterWidth,d=r.padInfo.top,f=r.padInfo.left,m=this.bufferSync(e),v=0;v<r.batchSize;++v)for(var y=0;y<r.inChannels;++y)for(var b=0;b<r.outHeight;++b){for(var w=b*s-d,S=w;S<0;)S+=i;for(var N=Math.min(r.inHeight,l+w),C=0;C<r.outWidth;++C){for(var T=C*o-f,I=T;I<0;)I+=u;for(var _=Math.min(r.inWidth,h+T),$=Number.NEGATIVE_INFINITY,R=-1,D=S;D<N;D+=i)for(var A=D-w,L=I;L<_;L+=u){var H=L-T,G=m.get(v,D,L,y);G>$&&($=G,R=A*h+H)}a.set(R,v,b,C,y)}}return a.toTensor()},t.prototype.maxPoolBackprop=function(e,r,a,s){Dt([r,a],"maxPoolBackprop");for(var o=this.maxPoolPositions(r,s),i=s.strideHeight,u=s.strideWidth,l=s.dilationHeight,h=s.dilationWidth,d=s.effectiveFilterHeight,f=s.effectiveFilterWidth,m=f-1-s.padInfo.left,v=d-1-s.padInfo.top,y=be(r.shape,"float32"),b=this.bufferSync(o),w=this.bufferSync(e),S=0;S<s.batchSize;++S)for(var N=0;N<s.inChannels;++N)for(var C=0;C<s.inHeight;++C)for(var T=0;T<s.inWidth;++T){for(var I=C-v,_=T-m,$=0,R=0;R<d;R+=l){var D=(I+R)/i;if(!(D<0||D>=s.outHeight||Math.floor(D)!==D))for(var A=0;A<f;A+=h){var L=(_+A)/u;if(!(L<0||L>=s.outWidth||Math.floor(L)!==L)){var H=d*f-1-b.get(S,D,L,N)===R*f+A?1:0;H!==0&&($+=w.get(S,D,L,N)*H)}}}y.set($,S,C,T,N)}return y.toTensor()},t.prototype.avgPoolBackprop=function(e,r,a){Dt([e,r],"avgPoolBackprop");for(var s=a.strideHeight,o=a.strideWidth,i=a.filterHeight,u=a.filterWidth,l=a.dilationHeight,h=a.dilationWidth,d=a.effectiveFilterHeight,f=a.effectiveFilterWidth,m=f-1-a.padInfo.left,v=d-1-a.padInfo.top,y=be(r.shape,"float32"),b=1/(i*u),w=this.bufferSync(e),S=0;S<a.batchSize;++S)for(var N=0;N<a.inChannels;++N)for(var C=0;C<a.inHeight;++C)for(var T=0;T<a.inWidth;++T){for(var I=C-v,_=T-m,$=0,R=0;R<d;R+=l){var D=(I+R)/s;if(!(D<0||D>=a.outHeight||Math.floor(D)!==D))for(var A=0;A<f;A+=h){var L=(_+A)/o;L<0||L>=a.outWidth||Math.floor(L)!==L||($+=w.get(S,D,L,N))}}y.set($*b,S,C,T,N)}return y.toTensor()},t.prototype.pool3d=function(e,r,a){Dt(e,"pool3d");for(var s=r.strideDepth,o=r.strideHeight,i=r.strideWidth,u=r.dilationDepth,l=r.dilationHeight,h=r.dilationWidth,d=r.effectiveFilterDepth,f=r.effectiveFilterHeight,m=r.effectiveFilterWidth,v=r.padInfo.front,y=r.padInfo.top,b=r.padInfo.left,w=a==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,S=this.readSync(e.dataId),N=be(r.outShape,e.dtype),C=N.values,T=r.outShape[1]*r.outShape[2]*r.outShape[3]*r.outShape[4],I=r.outShape[2]*r.outShape[3]*r.outShape[4],_=r.outShape[3]*r.outShape[4],$=r.outShape[4],R=0;R<r.batchSize;++R)for(var D=R*T,A=R*e.strides[0],L=0;L<r.inChannels;++L)for(var H=0;H<r.outDepth;++H){for(var G=H*s-v,q=G;q<0;)q+=u;for(var B=Math.min(r.inDepth,d+G),j=D+H*I,K=0;K<r.outHeight;++K){for(var z=K*o-y,U=z;U<0;)U+=l;for(var M=Math.min(r.inHeight,f+z),X=j+K*_,Q=0;Q<r.outWidth;++Q){for(var rt=Q*i-b,ct=rt;ct<0;)ct+=h;for(var pt=Math.min(r.inWidth,m+rt),yt=X+Q*$,Tt=w,gt=0,Rt=0,At=q;At<B;At+=u){for(var Lt=A+At*e.strides[1],Mt=U;Mt<M;Mt+=l){for(var Wt=Lt+Mt*e.strides[2],se=ct;se<pt;se+=h){var Xt=S[Wt+se*e.strides[3]+L];if(a==="max"&&Xt>Tt?Tt=Xt:a==="avg"&&(gt+=Xt,Rt++),isNaN(Tt))break}if(isNaN(Tt))break}if(isNaN(Tt))break}C[yt+L]=a==="avg"?gt/Rt:Tt}}}return N.toTensor()},t.prototype.avgPool3d=function(e,r){return Dt(e,"avgPool3d"),this.pool3d(e,r,"avg").toFloat()},t.prototype.avgPool3dBackprop=function(e,r,a){Dt([e,r],"avgPool3dBackprop");for(var s=a.strideDepth,o=a.strideHeight,i=a.strideWidth,u=a.filterDepth,l=a.filterHeight,h=a.filterWidth,d=a.dilationDepth,f=a.dilationHeight,m=a.dilationWidth,v=a.effectiveFilterDepth,y=a.effectiveFilterHeight,b=a.effectiveFilterWidth,w=v-1-a.padInfo.front,S=b-1-a.padInfo.left,N=y-1-a.padInfo.top,C=be(r.shape,"float32"),T=1/(u*l*h),I=this.bufferSync(e),_=0;_<a.batchSize;++_)for(var $=0;$<a.inChannels;++$)for(var R=0;R<a.inDepth;++R)for(var D=0;D<a.inHeight;++D)for(var A=0;A<a.inWidth;++A){for(var L=R-w,H=D-N,G=A-S,q=0,B=0;B<v;B+=d){var j=(L+B)/s;if(!(j<0||j>=a.outDepth||Math.floor(j)!==j))for(var K=0;K<y;K+=f){var z=(H+K)/o;if(!(z<0||z>=a.outHeight||Math.floor(z)!==z))for(var U=0;U<b;U+=m){var M=(G+U)/i;M<0||M>=a.outWidth||Math.floor(M)!==M||(q+=I.get(_,j,z,M,$))}}}C.set(q*T,_,R,D,A,$)}return C.toTensor()},t.prototype.maxPool3d=function(e,r){return Dt(e,"maxPool3d"),this.pool3d(e,r,"max").toFloat()},t.prototype.maxPool3dPositions=function(e,r){for(var a=be(r.outShape,"int32"),s=r.strideDepth,o=r.strideHeight,i=r.strideWidth,u=r.dilationDepth,l=r.dilationHeight,h=r.dilationWidth,d=r.effectiveFilterDepth,f=r.effectiveFilterHeight,m=r.effectiveFilterWidth,v=r.padInfo.front,y=r.padInfo.top,b=r.padInfo.left,w=this.bufferSync(e),S=0;S<r.batchSize;++S)for(var N=0;N<r.inChannels;++N)for(var C=0;C<r.outDepth;++C){for(var T=C*s-v,I=T;I<0;)I+=u;for(var _=Math.min(r.inDepth,d+T),$=0;$<r.outHeight;++$){for(var R=$*o-y,D=R;D<0;)D+=l;for(var A=Math.min(r.inHeight,f+R),L=0;L<r.outWidth;++L){for(var H=L*i-b,G=H;G<0;)G+=h;for(var q=Math.min(r.inWidth,m+H),B=Number.NEGATIVE_INFINITY,j=-1,K=I;K<_;K+=u)for(var z=K-T,U=D;U<A;U+=l)for(var M=U-R,X=G;X<q;X+=h){var Q=X-H,rt=w.get(S,K,U,X,N);rt>=B&&(B=rt,j=z*f*m+M*f+Q)}a.set(j,S,C,$,L,N)}}}return a.toTensor()},t.prototype.maxPool3dBackprop=function(e,r,a,s){Dt([r,a],"maxPool3dBackprop");for(var o=this.maxPool3dPositions(r,s),i=s.strideDepth,u=s.strideHeight,l=s.strideWidth,h=s.dilationDepth,d=s.dilationHeight,f=s.dilationWidth,m=s.effectiveFilterDepth,v=s.effectiveFilterHeight,y=s.effectiveFilterWidth,b=m-1-s.padInfo.front,w=y-1-s.padInfo.left,S=v-1-s.padInfo.top,N=be(r.shape,"float32"),C=this.bufferSync(o),T=this.bufferSync(e),I=0;I<s.batchSize;++I)for(var _=0;_<s.inChannels;++_)for(var $=0;$<s.inDepth;++$)for(var R=0;R<s.inHeight;++R)for(var D=0;D<s.inWidth;++D){for(var A=$-b,L=R-S,H=D-w,G=0,q=0;q<m;q+=h){var B=(A+q)/i;if(!(B<0||B>=s.outDepth||Math.floor(B)!==B))for(var j=0;j<v;j+=d){var K=(L+j)/u;if(!(K<0||K>=s.outHeight||Math.floor(K)!==K))for(var z=0;z<y;z+=f){var U=(H+z)/l;if(!(U<0||U>=s.outWidth||Math.floor(U)!==U)){var M=m*v*y-1-C.get(I,B,K,U,_)===q*v*y+j*y+z?1:0;M!==0&&(G+=T.get(I,B,K,U,_)*M)}}}}N.set(G,I,$,R,D,_)}return N.toTensor()},t.prototype.cast=function(e,r){return sz(e,r,this)},t.prototype.reshape=function(e,r){return qN(e,r)},t.prototype.avgPool=function(e,r){return Dt(e,"avgPool"),this.pool(e,r,"avg").toFloat()},t.prototype.resizeBilinear=function(e,r,a,s){Dt(e,"resizeBilinear");for(var o=e.shape,i=o[0],u=o[1],l=o[2],h=o[3],d=this.readSync(e.dataId),f=new Float32Array(ee([i,r,a,h])),m=[s&&r>1?u-1:u,s&&a>1?l-1:l],v=[s&&r>1?r-1:r,s&&a>1?a-1:a],y=0,b=m[0]/v[0],w=m[1]/v[1],S=0;S<i;S++)for(var N=0;N<r;N++)for(var C=b*N,T=Math.floor(C),I=C-T,_=Math.min(u-1,Math.ceil(C)),$=S*e.strides[0]+T*e.strides[1],R=S*e.strides[0]+_*e.strides[1],D=0;D<a;D++)for(var A=w*D,L=Math.floor(A),H=A-L,G=Math.min(l-1,Math.ceil(A)),q=$+L*e.strides[2],B=R+L*e.strides[2],j=$+G*e.strides[2],K=R+G*e.strides[2],z=0;z<h;z++){var U=d[q+z],M=d[B+z],X=U+(d[j+z]-U)*H,Q=X+(M+(d[K+z]-M)*H-X)*I;f[y++]=Q}return Zr(f,[i,r,a,h])},t.prototype.resizeBilinearBackprop=function(e,r,a){Dt([e,r],"resizeBilinearBackprop");for(var s=r.shape,o=s[0],i=s[1],u=s[2],l=s[3],h=e.shape,d=h[1],f=h[2],m=new Float32Array(o*i*u*l),v=[a&&d>1?i-1:i,a&&f>1?u-1:u],y=[a&&d>1?d-1:d,a&&f>1?f-1:f],b=v[0]/y[0],w=v[1]/y[1],S=this.readSync(e.dataId),N=0,C=0;C<o;C++)for(var T=C*r.strides[0],I=0;I<d;I++)for(var _=I*b,$=Math.floor(_),R=Math.min(Math.ceil(_),i-1),D=T+$*r.strides[1],A=T+R*r.strides[1],L=_-$,H=1-L,G=0;G<f;G++)for(var q=G*w,B=Math.floor(q),j=Math.min(Math.ceil(q),u-1),K=q-B,z=1-K,U=D+B*r.strides[2],M=D+j*r.strides[2],X=A+B*r.strides[2],Q=A+j*r.strides[2],rt=H*z,ct=H*K,pt=L*z,yt=L*K,Tt=0;Tt<l;Tt++){var gt=S[N++];m[U+Tt]+=gt*rt,m[M+Tt]+=gt*ct,m[X+Tt]+=gt*pt,m[Q+Tt]+=gt*yt}return Ba(m,[o,u,i,l],r.dtype)},t.prototype.resizeNearestNeighbor=function(e,r,a,s){Dt(e,"resizeNearestNeighbor");for(var o=e.shape,i=o[0],u=o[1],l=o[2],h=o[3],d=this.readSync(e.dataId),f=new Float32Array(i*r*a*h),m=[s&&r>1?u-1:u,s&&a>1?l-1:l],v=[s&&r>1?r-1:r,s&&a>1?a-1:a],y=m[0]/v[0],b=m[1]/v[1],w=0,S=0;S<i;S++)for(var N=S*e.strides[0],C=0;C<r;C++)for(var T=y*C,I=N+Math.min(u-1,s?Math.round(T):Math.floor(T))*e.strides[1],_=0;_<a;_++)for(var $=b*_,R=I+Math.min(l-1,s?Math.round($):Math.floor($))*e.strides[2],D=0;D<h;D++){var A=d[R+D];f[w++]=A}return Zr(f,[i,r,a,h],e.dtype)},t.prototype.resizeNearestNeighborBackprop=function(e,r,a){Dt([e,r],"resizeNearestNeighborBackprop");for(var s=r.shape,o=s[0],i=s[1],u=s[2],l=s[3],h=e.shape,d=h[1],f=h[2],m=new Float32Array(o*i*u*l),v=this.readSync(e.dataId),y=[a&&d>1?i-1:i,a&&f>1?u-1:u],b=[a&&d>1?d-1:d,a&&f>1?f-1:f],w=y[0]/b[0],S=y[1]/b[1],N=1/w,C=1/S,T=2*Math.ceil(N)+2,I=2*Math.ceil(C)+2,_=0;_<o;_++)for(var $=_*r.strides[0],R=0;R<i;R++)for(var D=$+R*r.strides[1],A=Math.floor(R*N),L=Math.floor(A-T/2),H=0;H<u;H++)for(var G=D+H*r.strides[2],q=Math.floor(H*C),B=Math.floor(q-I/2),j=0;j<l;j++){for(var K=0,z=0;z<T;z++){var U=z+L;if(!(U<0||U>=d)){var M=$+U*e.strides[1],X=U*w;if(R===Math.min(i-1,a?Math.round(X):Math.floor(X)))for(var Q=0;Q<I;Q++){var rt=Q+B;if(!(rt<0||rt>=f)){var ct=M+rt*e.strides[2],pt=rt*S;H===Math.min(u-1,a?Math.round(pt):Math.floor(pt))&&(K+=v[ct+j])}}}}m[G+j]=K}return Ba(m,r.shape,r.dtype)},t.prototype.batchNormalization=function(e,r,a,s,o,i){Dt([e,r,a,o,i],"batchNorm");for(var u=this.readSync(e.dataId),l=this.readSync(r.dataId),h=this.readSync(a.dataId),d=o?this.readSync(o.dataId):new Float32Array([1]),f=i?this.readSync(i.dataId):new Float32Array([0]),m=new Float32Array(u.length),v=f.length,y=d.length,b=h.length,w=l.length,S=0,N=0,C=0,T=0,I=0;I<u.length;++I)m[I]=f[S++]+(u[I]-l[N++])*d[C++]/Math.sqrt(h[T++]+s),S>=v&&(S=0),N>=w&&(N=0),C>=y&&(C=0),T>=b&&(T=0);return Ba(m,e.shape)},t.prototype.localResponseNormalization4D=function(e,r,a,s,o){Dt(e,"localResponseNormalization4D");var i=e.shape[3],u=i-1,l=this.readSync(e.dataId),h=e.size,d=new Float32Array(h);function f(b){for(var w=b%i,S=b-w+Math.max(0,w-r),N=b-w+Math.min(w+r,u),C=0;S<=N;S++){var T=l[S];C+=T*T}return C}for(var m=0;m<h;m++){var v=f(m),y=l[m]*Math.pow(a+s*v,-o);d[m]=y}return Ba(d,e.shape)},t.prototype.LRNGrad=function(e,r,a,s,o,i,u){Dt(e,"LRNGrad");for(var l=e.shape[3],h=this.readSync(e.dataId),d=this.readSync(r.dataId),f=this.readSync(a.dataId),m=new Float32Array(e.size),v=e.size,y=0;y<v;y++){for(var b=y%l,w=y-b+Math.max(0,b-s),S=y-b+Math.min(l,b+s+1),N=0,C=w;C<S;C++)N+=Math.pow(d[C],2);for(N=i*N+o,C=w;C<S;C++){var T=-2*i*u*d[C]*f[y]/N;y===C&&(T+=Math.pow(N,-u)),T*=h[y],m[C]+=T}}return Ba(m,e.shape)},t.prototype.multinomial=function(e,r,a,s){Dt(e,"multinomial");for(var o=r?e:Wi(e),i=o.shape[0],u=o.shape[1],l=Sn([i,a],"int32"),h=this.readSync(l.dataId),d=this.readSync(o.dataId),f=0;f<i;++f){var m=f*u,v=new Float32Array(u-1);v[0]=d[m];for(var y=1;y<v.length;++y)v[y]=v[y-1]+d[m+y];for(var b=$1(s.toString()),w=f*a,S=0;S<a;++S){var N=b();h[w+S]=v.length;for(var C=0;C<v.length;C++)if(N<v[C]){h[w+S]=C;break}}}return l},t.prototype.oneHot=function(e,r,a,s){Dt(e,"oneHot");var o=new Float32Array(e.size*r);o.fill(s);for(var i=this.readSync(e.dataId),u=0;u<e.size;++u)i[u]>=0&&i[u]<r&&(o[u*r+i[u]]=a);return _u(o,[e.size,r],"int32")},t.prototype.nonMaxSuppression=function(e,r,a,s,o){return Dt(e,"nonMaxSuppression"),UE(this.readSync(e.dataId),this.readSync(r.dataId),a,s,o)},t.prototype.fft=function(e){return this.fftBatch(e,!1)},t.prototype.ifft=function(e){return this.fftBatch(e,!0)},t.prototype.fftBatch=function(e,r){for(var a=e.shape[0],s=e.shape[1],o=be(e.shape,"float32"),i=be(e.shape,"float32"),u=Ls(e).as2D(a,s),l=Eo(e).as2D(a,s),h=0;h<a;h++)for(var d=u.slice([h,0],[1,s]),f=l.slice([h,0],[1,s]),m=Yr(d,f),v=this.readSync(this.fftImpl(m,r).dataId),y=0;y<s;y++){var b=o3(v,y);o.values[h*s+y]=b.real,i.values[h*s+y]=b.imag}return Yr(o.toTensor(),i.toTensor()).as2D(a,s)},t.prototype.fftImpl=function(e,r){var a=e.as1D(),s=a.size;if(this.isExponentOf2(s)){var o=this.fftRadix2(a,s,r).as2D(e.shape[0],e.shape[1]);return r&&(o=Yr(Ls(o).div(Pt(s)),Eo(o).div(Pt(s)))),o}var i=this.readSync(e.dataId),u=(function(l){for(var h=new Float32Array(l.length/2),d=new Float32Array(l.length/2),f=0;f<l.length;f+=2)h[f/2]=l[f],d[f/2]=l[f+1];return{real:h,imag:d}})(this.fourierTransformByMatmul(i,s,r));return Yr(u.real,u.imag).as2D(e.shape[0],e.shape[1])},t.prototype.isExponentOf2=function(e){return(e&e-1)==0},t.prototype.fftRadix2=function(e,r,a){if(r===1)return e;var s=this.readSync(e.dataId),o=r/2,i=(function(w){for(var S=Math.ceil(w.length/4),N=new Float32Array(S),C=new Float32Array(S),T=0;T<w.length;T+=4)N[Math.floor(T/4)]=w[T],C[Math.floor(T/4)]=w[T+1];return{real:N,imag:C}})(s),u=Yr(i.real,i.imag).as1D(),l=(function(w){for(var S=Math.floor(w.length/4),N=new Float32Array(S),C=new Float32Array(S),T=2;T<w.length;T+=4)N[Math.floor(T/4)]=w[T],C[Math.floor(T/4)]=w[T+1];return{real:N,imag:C}})(s),h=Yr(l.real,l.imag).as1D();u=this.fftRadix2(u,o,a),h=this.fftRadix2(h,o,a);var d=(function(w,S){for(var N=new Float32Array(w/2),C=new Float32Array(w/2),T=0;T<Math.ceil(w/2);T++){var I=(S?2:-2)*Math.PI*(T/w);N[T]=Math.cos(I),C[T]=Math.sin(I)}return{real:N,imag:C}})(r,a),f=Yr(d.real,d.imag).mul(h),m=u.add(f),v=u.sub(f),y=Ls(m).concat(Ls(v)),b=Eo(m).concat(Eo(v));return Yr(y,b).as1D()},t.prototype.fourierTransformByMatmul=function(e,r,a){for(var s=new Float32Array(2*r),o=0;o<r;o++){for(var i=0,u=0,l=0;l<r;l++){var h=Qnt(o*l,r,a),d=o3(e,l);i+=d.real*h.real-d.imag*h.imag,u+=d.real*h.imag+d.imag*h.real}a&&(i/=r,u/=r),Ynt(s,i,u,o)}return s},t.prototype.depthToSpace=function(e,r,a){Z(a==="NHWC",(function(){return"Only NHWC dataFormat supported on CPU for depthToSpace. Got "+a})),Z(r>1,(function(){return"blockSize should be > 1 for depthToSpace, but was: "+r}));for(var s=e.shape[0],o=e.shape[1],i=e.shape[2],u=e.shape[3],l=o*r,h=i*r,d=u/(r*r),f=this.readSync(e.dataId),m=new Float32Array(s*l*h*d),v=0,y=0;y<s;++y)for(var b=0;b<l;++b)for(var w=Math.floor(b/r),S=b%r,N=0;N<h;++N)for(var C=Math.floor(N/r),T=(S*r+N%r)*d,I=0;I<d;++I){var _=I+T+u*(C+i*(w+o*y));m[v++]=f[_]}return Ba(m,[s,l,h,d])},t.prototype.broadcastedBinaryOp=function(e,r,a,s){var o=Le(e.shape,r.shape),i=be(o,a),u=this.readSync(e.dataId),l=this.readSync(r.dataId),h=Cu(e.shape,o),d=Cu(r.shape,o),f=i.values;if(h.length+d.length===0)for(var m=0;m<f.length;++m)f[m]=s(u[m%u.length],l[m%l.length]);else{var v=this.bufferSync(e),y=this.bufferSync(r),b=function(w){var S=i.indexToLoc(w),N=S.slice(-e.rank);h.forEach((function(_){return N[_]=0}));var C=v.locToIndex(N),T=S.slice(-r.rank);d.forEach((function(_){return T[_]=0}));var I=y.locToIndex(T);f[w]=s(u[C],l[I])};for(m=0;m<f.length;++m)b(m)}return i.toTensor()},t.prototype.broadcastedBinaryComplexOp=function(e,r,a){var s=Le(e.shape,r.shape),o=be(s,"float32"),i=be(s,"float32"),u=this.readSync(e.dataId),l=this.readSync(r.dataId),h=Cu(e.shape,s),d=Cu(r.shape,s),f=o.values,m=i.values;if(h.length+d.length===0)for(var v=0;v<f.length;v++){var y=v%u.length,b=v%l.length,w=a(u[2*y],u[2*y+1],l[2*b],l[2*b+1]);f[v]=w.real,m[v]=w.imag}else{var S=this.bufferSync(this.data.get(e.dataId).complexTensors.real),N=this.bufferSync(this.data.get(r.dataId).complexTensors.real),C=function(T){var I=o.indexToLoc(T),_=I.slice(-e.rank);h.forEach((function(L){return _[L]=0}));var $=S.locToIndex(_),R=I.slice(-r.rank);d.forEach((function(L){return R[L]=0}));var D=N.locToIndex(R),A=a(u[2*$],u[2*$+1],l[2*D],l[2*D+1]);f[T]=A.real,m[T]=A.imag};for(v=0;v<f.length;v++)C(v)}return this.complex(o.toTensor(),i.toTensor())},t.prototype.split=function(e,r,a){return uz(e,r,a)},t.prototype.dispose=function(){},t.prototype.floatPrecision=function(){return 32},t.prototype.epsilon=function(){return 1e-7},t.prototype.cropAndResize=function(e,r,a,s,o,i){for(var u=e.shape,l=u[0],h=u[1],d=u[2],f=u[3],m=r.shape[0],v=s[0],y=s[1],b=be([m,v,y,f],"float32"),w=this.readSync(r.dataId),S=this.readSync(a.dataId),N=this.readSync(e.dataId),C=e.strides,T=b.strides,I=0;I<m;I++){var _=4*I,$=w[_],R=w[_+1],D=w[_+2],A=w[_+3],L=S[I];if(!(L>=l))for(var H=v>1?(D-$)*(h-1)/(v-1):0,G=y>1?(A-R)*(d-1)/(y-1):0,q=0;q<v;q++){var B=v>1?$*(h-1)+q*H:.5*($+D)*(h-1);if(B<0||B>h-1)for(var j=0;j<y;j++)for(var K=0;K<f;K++){var z=K+j*T[2]+q*T[1]+I*T[0];b.values[z]=i}else if(o==="bilinear"){var U=Math.floor(B),M=Math.ceil(B),X=B-U;for(j=0;j<y;j++)if((At=y>1?R*(d-1)+j*G:.5*(R+A)*(d-1))<0||At>d-1)for(K=0;K<f;K++)z=K+j*T[2]+q*T[1]+I*T[0],b.values[z]=i;else{var Q=Math.floor(At),rt=Math.ceil(At),ct=At-Q;for(K=0;K<f;K++){var pt=N[z=K+Q*C[2]+U*C[1]+L*C[0]],yt=N[z=K+rt*C[2]+U*C[1]+L*C[0]],Tt=N[z=K+Q*C[2]+M*C[1]+L*C[0]],gt=pt+(yt-pt)*ct,Rt=Tt+(N[z=K+rt*C[2]+M*C[1]+L*C[0]]-Tt)*ct;z=K+j*T[2]+q*T[1]+I*T[0],b.values[z]=gt+(Rt-gt)*X}}}else for(j=0;j<y;++j){var At;if((At=y>1?R*(d-1)+j*G:.5*(R+A)*(d-1))<0||At>d-1)for(K=0;K<f;K++)z=K+j*T[2]+q*T[1]+I*T[0],b.values[z]=i;else{var Lt=Math.round(At),Mt=Math.round(B);for(K=0;K<f;K++){var Wt=K+Lt*C[2]+Mt*C[1]+L*C[0],se=K+j*T[2]+q*T[1]+I*T[0];b.values[se]=N[Wt]}}}}}return b.toTensor()},t.prototype.sparseToDense=function(e,r,a,s){var o=nb(0,e,a),i=o.sliceRank,u=o.numUpdates,l=o.sliceSize,h=o.strides,d=o.outputSize;return this.scatter(e,r,a,d,l,u,i,h,s,!1)},t.prototype.gatherND=function(e,r){var a=r.shape,s=a[a.length-1],o=ZB(e,r),i=o[0],u=o[1],l=o[2],h=o[3];if(u===0)return Zr([],i,e.dtype);for(var d=new sm([u,l],e.dtype),f=this.readSync(r.dataId),m=this.readSync(e.dataId),v=0;v<u;v++){for(var y=[],b=0,w=0;w<s;w++){var S=f[v*s+w];b+=S*h[w],y.push(S)}if(b<0||b>=e.size/l)throw new Error("Invalid indices: "+y+" does not index into "+e.shape);for(var N=0;N<l;N++)d.values[v*l+N]=m[b*l+N]}return d.toTensor().reshape(i)},t.prototype.scatterND=function(e,r,a){var s=nb(0,e,a),o=s.sliceRank,i=s.numUpdates,u=s.sliceSize,l=s.strides,h=s.outputSize,d=Pt(0);return this.scatter(e,r,a,h,u,i,o,l,d,!0)},t.prototype.fill=function(e,r,a){var s=j0(a=a||qg(r),ee(e));return s.fill(r),lt.makeTensor(s,e,a,this)},t.prototype.onesLike=function(e){if(e.dtype==="string")throw new Error("onesLike is not supported for string tensors");return this.fill(e.shape,1,e.dtype)},t.prototype.zerosLike=function(e){var r=j0(e.dtype,ee(e.shape));return this.makeOutput(r,e.shape,e.dtype)},t.prototype.linspace=function(e,r,a){return oz(e,r,a)},t.prototype.scatter=function(e,r,a,s,o,i,u,l,h,d){var f=[s/o,o],m=this.readSync(e.dataId),v=this.readSync(r.dataId);if(s===0)return Zr([],a,r.dtype);var y=new sm(f,r.dtype);y.values.fill(this.readSync(h.dataId)[0]);for(var b=0;b<i;b++){for(var w=[],S=0,N=0;N<u;N++){var C=m[b*u+N];w.push(C),S+=C*l[N]}if(S<0||S>=s/o)throw new Error("Invalid indices: "+w+" does not index into "+a);for(var T=0;T<o;T++)d?y.values[S*o+T]+=v[b*o+T]:y.values[S*o+T]=r.rank===0?v[0]:v[b*o+T]}return y.toTensor().reshape(a)},t})(rz);lt.registerBackend("cpu",(function(){return new vit}),1);for(var lC=0,I3=[{kernelName:"NonMaxSuppressionV5",backendName:"cpu",kernelFunc:function(n){var t=n.inputs,e=n.backend,r=n.attrs,a=t,s=a.boxes,o=a.scores,i=r,u=i.maxOutputSize,l=i.iouThreshold,h=i.scoreThreshold,d=i.softNmsSigma,f=e;Dt(s,"NonMaxSuppressionWithScore");var m=WE(f.data.get(s.dataId).values,f.data.get(o.dataId).values,u,l,h,d);return[m.selectedIndices,m.selectedScores]}},{kernelName:"Square",backendName:"cpu",kernelFunc:function(n){var t=n.inputs,e=n.backend,r=t.x,a=e;Dt(r,"square");for(var s=a.data.get(r.dataId).values,o=new Float32Array(s.length),i=0;i<s.length;++i){var u=s[i];o[i]=u*u}return{dataId:a.write(o,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},{kernelName:um,backendName:"cpu",kernelFunc:function(n){var t=n.inputs,e=n.backend,r=t,a=r.a,s=r.b,o=e;Dt([a,s],um);var i=o.data.get(a.dataId).values,u=o.data.get(s.dataId).values,l=(function(f,m,v,y,b,w){var S=Le(f,m),N=S.length,C=Lo(S),T=am(b,ee(S)),I=f.length,_=m.length,$=Lo(f),R=Lo(m),D=Cu(f,S),A=Cu(m,S);if(D.length+A.length===0)for(var L=0;L<T.length;++L)T[L]=w(v[L%v.length],y[L%y.length]);else{var H=function(G){var q=Eet(G,N,C),B=q.slice(-I);D.forEach((function(U){return B[U]=0}));var j=QO(B,I,$),K=q.slice(-_);A.forEach((function(U){return K[U]=0}));var z=QO(K,_,R);T[G]=w(v[j],y[z])};for(L=0;L<T.length;++L)H(L)}return[T,S]})(a.shape,s.shape,i,u,a.dtype,(function(f,m){var v=f-m;return v*v})),h=l[0],d=l[1];return{dataId:o.write(h,d,a.dtype),shape:d,dtype:a.dtype}}}];lC<I3.length;lC++)AB(I3[lC]);var Sh,yit=function(n){this.variableNames=["A"];var t=ua(),e=n[0],r=n[1];this.outputShape=n,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(`+r+".0, "+e+`.0);

        vec4 values = `+t.texture2D+`(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `},bit=function(n){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;var t=ua(),e=n[0],r=n[1];this.outputShape=n,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(`+r+".0, "+e+`.0);
            vec4 values = `+t.texture2D+`(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        `+t.output+` = result;
      }
    `};for(var cC=0,_3=[{kernelName:"FromPixels",backendName:"webgl",kernelFunc:function(n){var t=n.inputs,e=n.backend,r=n.attrs,a=t.pixels,s=r.numChannels,o=typeof HTMLVideoElement<"u"&&a instanceof HTMLVideoElement,i=typeof HTMLImageElement<"u"&&a instanceof HTMLImageElement,u=o?[a.videoWidth,a.videoHeight]:[a.width,a.height],l=u[0],h=u[1],d=[h,l],f=[h,l,s];(i||o)&&(Sh==null&&(Sh=document.createElement("canvas").getContext("2d")),Sh.canvas.width=l,Sh.canvas.height=h,Sh.drawImage(a,0,0,l,h),a=Sh.canvas);var m=e.makeTensorInfo(d,"int32");e.texData.get(m.dataId).usage=cs.PIXELS,e.gpgpu.uploadPixelDataToTexture(e.getTexture(m.dataId),a);var v=kt().getBool("WEBGL_PACK")?new bit(f):new yit(f),y=e.runWebGLProgram(v,[m],"int32");return e.disposeData(m.dataId),y}},{kernelName:"NonMaxSuppressionV5",backendName:"webgl",kernelFunc:function(n){var t=n.inputs,e=n.backend,r=n.attrs;Y0("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");var a=t,s=a.boxes,o=a.scores,i=r,u=i.maxOutputSize,l=i.iouThreshold,h=i.scoreThreshold,d=i.softNmsSigma,f=e,m=WE(f.readSync(s.dataId),f.readSync(o.dataId),u,l,h,d);return[m.selectedIndices,m.selectedScores]}},{kernelName:"Square",backendName:"webgl",kernelFunc:function(n){var t=n.inputs,e=n.backend,r=t.x,a=e,s=new Ee(r.shape,"return x * x;");return a.runWebGLProgram(s,[r],r.dtype)}},{kernelName:um,backendName:"webgl",kernelFunc:function(n){var t=n.inputs,e=n.backend,r=t,a=r.a,s=r.b,o=e,i=kt().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new xi("return (a - b) * (a - b);",a.shape,s.shape):new zn("return (a - b) * (a - b);",a.shape,s.shape);return o.compileAndRun(i,[a,s])}}];cC<_3.length;cC++)AB(_3[cC]);for(var hC=0,R3=[{kernelName:"Square",gradFunc:function(n,t){var e=t[0];return{x:function(){return n.mul(e.toFloat().mul(2))}}}},{kernelName:um,gradFunc:function(n,t){var e=t[0],r=t[1],a=Pt(2);return{a:function(){return da(n,da(a,Cr(e,r)))},b:function(){return da(n,da(a,Cr(r,e)))}}}}];hC<R3.length;hC++)met(R3[hC]);var xit=(function(){function n(){}return n.prototype.fetch=function(t,e){return fetch(t,e)},n.prototype.now=function(){return performance.now()},n.prototype.encode=function(t,e){if(e!=="utf-8"&&e!=="utf8")throw new Error("Browser's encoder only supports utf-8, but got "+e);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(t)},n.prototype.decode=function(t,e){return new TextDecoder(e).decode(t)},n})();kt().get("IS_BROWSER")&&kt().setPlatform("browser",new xit);var dC,wit=function(){return require("node-fetch")},Sit=(function(){function n(){this.util=require("util"),this.textEncoder=new this.util.TextEncoder}return n.prototype.fetch=function(t,e){return kt().global.fetch!=null?kt().global.fetch(t,e):(dC==null&&(dC=wit()),dC(t,e))},n.prototype.now=function(){var t=process.hrtime();return 1e3*t[0]+t[1]/1e6},n.prototype.encode=function(t,e){if(e!=="utf-8"&&e!=="utf8")throw new Error("Node built-in encoder only supports utf-8, but got "+e);return this.textEncoder.encode(t)},n.prototype.decode=function(t,e){return t.length===0?"":new this.util.TextDecoder(e).decode(t)},n})();kt().get("IS_NODE")&&kt().setPlatform("node",new Sit);var YN={float32:4,int32:4,uint16:2,uint8:1,bool:1},lb=4;function tP(n,t){for(var e={},r=0,a=function(i){var u=i.name,l=i.dtype,h=i.shape,d=ee(h),f=void 0;if("quantization"in i){var m=i.quantization;if(m.dtype!=="uint8"&&m.dtype!=="uint16")throw new Error("Weight "+i.name+" has unknown quantization dtype "+m.dtype+". Supported quantization dtypes are: 'uint8' and 'uint16'.");var v=YN[m.dtype],y=n.slice(r,r+d*v),b=m.dtype==="uint8"?new Uint8Array(y):new Uint16Array(y);if(l==="float32")f=Float32Array.from(b,(function(I){return I*m.scale+m.min}));else{if(l!=="int32")throw new Error("Unsupported dtype in weight '"+u+"': "+l);f=Int32Array.from(b,(function(I){return Math.round(I*m.scale+m.min)}))}r+=d*v}else if(l==="string"){var w=ee(i.shape);f=[];for(var S=0;S<w;S++){var N=new Uint32Array(n.slice(r,r+lb))[0];r+=lb;var C=new Uint8Array(n.slice(r,r+N));f.push(C),r+=N}}else{var T=YN[l];if(y=n.slice(r,r+d*T),l==="float32")f=new Float32Array(y);else if(l==="int32")f=new Int32Array(y);else{if(l!=="bool")throw new Error("Unsupported dtype in weight '"+u+"': "+l);f=new Uint8Array(y)}r+=d*T}e[u]=Zr(f,h,l)},s=0,o=t;s<o.length;s++)a(o[s]);return e}function Cit(n){if(n===null)throw new Error("Invalid input value: "+JSON.stringify(n));var t=0,e=[];n.forEach((function(s){if(t+=s.byteLength,e.push(s.byteLength===s.buffer.byteLength?s:new s.constructor(s)),!(s instanceof Float32Array||s instanceof Int32Array||s instanceof Uint8Array))throw new Error("Unsupported TypedArray subtype: "+s.constructor.name)}));var r=new Uint8Array(t),a=0;return e.forEach((function(s){r.set(new Uint8Array(s.buffer),a),a+=s.byteLength})),r.buffer}var QN=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function A3(n){return QN?Buffer.byteLength(n):new Blob([n]).size}function uI(n){var t=0;n.forEach((function(a){t+=a.byteLength}));var e=new Uint8Array(t),r=0;return n.forEach((function(a){e.set(new Uint8Array(a),r),r+=a.byteLength})),e.buffer}function D3(n){for(n=n.trim();n.endsWith("/");)n=n.slice(0,n.length-1);var t=n.split("/");return t[t.length-1]}function tv(n){if(n.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:n.modelTopology==null?0:A3(JSON.stringify(n.modelTopology)),weightSpecsBytes:n.weightSpecs==null?0:A3(JSON.stringify(n.weightSpecs)),weightDataBytes:n.weightData==null?0:n.weightData.byteLength}}var hs=(function(){function n(){this.saveRouters=[],this.loadRouters=[]}return n.getInstance=function(){return n.instance==null&&(n.instance=new n),n.instance},n.registerSaveRouter=function(t){n.getInstance().saveRouters.push(t)},n.registerLoadRouter=function(t){n.getInstance().loadRouters.push(t)},n.getSaveHandlers=function(t){return n.getHandlers(t,"save")},n.getLoadHandlers=function(t,e){return n.getHandlers(t,"load",e)},n.getHandlers=function(t,e,r){var a=[];return(e==="load"?n.getInstance().loadRouters:n.getInstance().saveRouters).forEach((function(s){var o=s(t,r);o!==null&&a.push(o)})),a},n})(),Ph="://",Ru=(function(){function n(){this.managers={}}return n.getInstance=function(){return n.instance==null&&(n.instance=new n),n.instance},n.registerManager=function(t,e){Z(t!=null,(function(){return"scheme must not be undefined or null."})),t.endsWith(Ph)&&(t=t.slice(0,t.indexOf(Ph))),Z(t.length>0,(function(){return"scheme must not be an empty string."}));var r=n.getInstance();Z(r.managers[t]==null,(function(){return"A model store manager is already registered for scheme '"+t+"'."})),r.managers[t]=e},n.getManager=function(t){var e=this.getInstance().managers[t];if(e==null)throw new Error("Cannot find model manager for scheme '"+t+"'");return e},n.getSchemes=function(){return Object.keys(this.getInstance().managers)},n})();function E0(n){if(n.indexOf(Ph)===-1)throw new Error("The url string provided does not contain a scheme. Supported schemes are: "+Ru.getSchemes().join(","));return{scheme:n.split(Ph)[0],path:n.split(Ph)[1]}}function $3(n,t,e){return e===void 0&&(e=!1),Yt(this,void 0,void 0,(function(){var r,a,s,o,i,u,l,h,d;return Qt(this,(function(f){switch(f.label){case 0:return Z(n!==t,(function(){return"Old path and new path are the same: '"+n+"'"})),Z((r=hs.getLoadHandlers(n)).length>0,(function(){return"Copying failed because no load handler is found for source URL "+n+"."})),Z(r.length<2,(function(){return"Copying failed because more than one ("+r.length+") load handlers for source URL "+n+"."})),a=r[0],Z((s=hs.getSaveHandlers(t)).length>0,(function(){return"Copying failed because no save handler is found for destination URL "+t+"."})),Z(s.length<2,(function(){return"Copying failed because more than one ("+r.length+") save handlers for destination URL "+t+"."})),o=s[0],i=E0(n).scheme,u=E0(n).path,l=i===E0(n).scheme,[4,a.load()];case 1:return h=f.sent(),e&&l?[4,Ru.getManager(i).removeModel(u)]:[3,3];case 2:f.sent(),f.label=3;case 3:return[4,o.save(h)];case 4:return d=f.sent(),!e||l?[3,6]:[4,Ru.getManager(i).removeModel(u)];case 5:f.sent(),f.label=6;case 6:return[2,d.modelArtifactsInfo]}}))}))}var Gl="models_store",Nu="model_info_store";function eP(){if(!kt().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");var n=window||self,t=n.indexedDB||n.mozIndexedDB||n.webkitIndexedDB||n.msIndexedDB||n.shimIndexedDB;if(t==null)throw new Error("The current browser does not appear to support IndexedDB.");return t}function ZN(n){var t=n.result;t.createObjectStore(Gl,{keyPath:"modelPath"}),t.createObjectStore(Nu,{keyPath:"modelPath"})}var Vh=(function(){function n(t){if(this.indexedDB=eP(),t==null||!t)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=t}return n.prototype.save=function(t){return Yt(this,void 0,void 0,(function(){return Qt(this,(function(e){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return[2,this.databaseAction(this.modelPath,t)]}))}))},n.prototype.load=function(){return Yt(this,void 0,void 0,(function(){return Qt(this,(function(t){return[2,this.databaseAction(this.modelPath)]}))}))},n.prototype.databaseAction=function(t,e){var r=this;return new Promise((function(a,s){var o=r.indexedDB.open("tensorflowjs",1);o.onupgradeneeded=function(){return ZN(o)},o.onsuccess=function(){var i=o.result;if(e==null){var u=i.transaction(Gl,"readonly"),l=u.objectStore(Gl).get(r.modelPath);l.onsuccess=function(){if(l.result==null)return i.close(),s(new Error("Cannot find model with path '"+r.modelPath+"' in IndexedDB."));a(l.result.modelArtifacts)},l.onerror=function(y){return i.close(),s(l.error)},u.oncomplete=function(){return i.close()}}else{var h,d=tv(e),f=i.transaction(Nu,"readwrite"),m=f.objectStore(Nu),v=m.put({modelPath:r.modelPath,modelArtifactsInfo:d});v.onsuccess=function(){var y=(h=i.transaction(Gl,"readwrite")).objectStore(Gl).put({modelPath:r.modelPath,modelArtifacts:e,modelArtifactsInfo:d});y.onsuccess=function(){return a({modelArtifactsInfo:d})},y.onerror=function(b){var w=(m=f.objectStore(Nu)).delete(r.modelPath);w.onsuccess=function(){return i.close(),s(y.error)},w.onerror=function(S){return i.close(),s(y.error)}}},v.onerror=function(y){return i.close(),s(v.error)},f.oncomplete=function(){h==null?i.close():h.oncomplete=function(){return i.close()}}}},o.onerror=function(i){return s(o.error)}}))},n.URL_SCHEME="indexeddb://",n})(),O3=function(n){return kt().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(Vh.URL_SCHEME)?(t=n.slice(Vh.URL_SCHEME.length),new Vh(t)):null;var t};hs.registerSaveRouter(O3),hs.registerLoadRouter(O3);var Nit=(function(){function n(){this.indexedDB=eP()}return n.prototype.listModels=function(){return Yt(this,void 0,void 0,(function(){var t=this;return Qt(this,(function(e){return[2,new Promise((function(r,a){var s=t.indexedDB.open("tensorflowjs",1);s.onupgradeneeded=function(){return ZN(s)},s.onsuccess=function(){var o=s.result,i=o.transaction(Nu,"readonly"),u=i.objectStore(Nu).getAll();u.onsuccess=function(){for(var l={},h=0,d=u.result;h<d.length;h++){var f=d[h];l[f.modelPath]=f.modelArtifactsInfo}r(l)},u.onerror=function(l){return o.close(),a(u.error)},i.oncomplete=function(){return o.close()}},s.onerror=function(o){return a(s.error)}}))]}))}))},n.prototype.removeModel=function(t){return Yt(this,void 0,void 0,(function(){var e=this;return Qt(this,(function(r){var a;return t=(a=t).startsWith(Vh.URL_SCHEME)?a.slice(Vh.URL_SCHEME.length):a,[2,new Promise((function(s,o){var i=e.indexedDB.open("tensorflowjs",1);i.onupgradeneeded=function(){return ZN(i)},i.onsuccess=function(){var u,l=i.result,h=l.transaction(Nu,"readwrite"),d=h.objectStore(Nu),f=d.get(t);f.onsuccess=function(){if(f.result==null)return l.close(),o(new Error("Cannot find model with path '"+t+"' in IndexedDB."));var m=d.delete(t),v=function(){var y=(u=l.transaction(Gl,"readwrite")).objectStore(Gl).delete(t);y.onsuccess=function(){return s(f.result.modelArtifactsInfo)},y.onerror=function(b){return o(f.error)}};m.onsuccess=v,m.onerror=function(y){return v(),l.close(),o(f.error)}},f.onerror=function(m){return l.close(),o(f.error)},h.oncomplete=function(){u==null?l.close():u.oncomplete=function(){return l.close()}}},i.onerror=function(u){return o(i.error)}}))]}))}))},n})();if(kt().getBool("IS_BROWSER"))try{Ru.registerManager(Vh.URL_SCHEME,new Nit)}catch{}var Ti="/",Oh="tensorflowjs_models",nP="info",kit="model_topology",Tit="weight_specs",Eit="weight_data",Iit="model_metadata";function rP(n){return{info:[Oh,n,nP].join(Ti),topology:[Oh,n,kit].join(Ti),weightSpecs:[Oh,n,Tit].join(Ti),weightData:[Oh,n,Eit].join(Ti),modelMetadata:[Oh,n,Iit].join(Ti)}}function _it(n){var t=n.split(Ti);if(t.length<3)throw new Error("Invalid key format: "+n);return t.slice(1,t.length-1).join(Ti)}var Uh=(function(){function n(t){if(!kt().getBool("IS_BROWSER")||typeof window>"u"||window.localStorage===void 0)throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,t==null||!t)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=t,this.keys=rP(this.modelPath)}return n.prototype.save=function(t){return Yt(this,void 0,void 0,(function(){var e,r,a;return Qt(this,(function(s){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");e=JSON.stringify(t.modelTopology),r=JSON.stringify(t.weightSpecs),a=tv(t);try{return this.LS.setItem(this.keys.info,JSON.stringify(a)),this.LS.setItem(this.keys.topology,e),this.LS.setItem(this.keys.weightSpecs,r),this.LS.setItem(this.keys.weightData,(function(o){if(QN)return Buffer.from(o).toString("base64");for(var i=new Uint8Array(o),u="",l=0,h=i.length;l<h;l++)u+=String.fromCharCode(i[l]);return btoa(u)})(t.weightData)),this.LS.setItem(this.keys.modelMetadata,JSON.stringify({format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,userDefinedMetadata:t.userDefinedMetadata})),[2,{modelArtifactsInfo:a}]}catch{throw this.LS.removeItem(this.keys.info),this.LS.removeItem(this.keys.topology),this.LS.removeItem(this.keys.weightSpecs),this.LS.removeItem(this.keys.weightData),this.LS.removeItem(this.keys.modelMetadata),new Error("Failed to save model '"+this.modelPath+"' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes="+a.modelTopologyBytes+", weightSpecsBytes="+a.weightSpecsBytes+", weightDataBytes="+a.weightDataBytes+".")}return[2]}))}))},n.prototype.load=function(){return Yt(this,void 0,void 0,(function(){var t,e,r,a,s,o,i;return Qt(this,(function(u){if((t=JSON.parse(this.LS.getItem(this.keys.info)))==null)throw new Error("In local storage, there is no model with name '"+this.modelPath+"'");if(t.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");if(e={},(r=JSON.parse(this.LS.getItem(this.keys.topology)))==null)throw new Error("In local storage, the topology of model '"+this.modelPath+"' is missing.");if(e.modelTopology=r,(a=JSON.parse(this.LS.getItem(this.keys.weightSpecs)))==null)throw new Error("In local storage, the weight specs of model '"+this.modelPath+"' are missing.");if(e.weightSpecs=a,(s=this.LS.getItem(this.keys.modelMetadata))!=null&&(o=JSON.parse(s),e.format=o.format,e.generatedBy=o.generatedBy,e.convertedBy=o.convertedBy,e.userDefinedMetadata=o.userDefinedMetadata),(i=this.LS.getItem(this.keys.weightData))==null)throw new Error("In local storage, the binary weight values of model '"+this.modelPath+"' are missing.");return e.weightData=(function(l){if(QN){var h=Buffer.from(l,"base64");return h.buffer.slice(h.byteOffset,h.byteOffset+h.byteLength)}for(var d=atob(l),f=new Uint8Array(d.length),m=0;m<d.length;++m)f.set([d.charCodeAt(m)],m);return f.buffer})(i),[2,e]}))}))},n.URL_SCHEME="localstorage://",n})(),F3=function(n){return kt().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(Uh.URL_SCHEME)?(t=n.slice(Uh.URL_SCHEME.length),new Uh(t)):null;var t};hs.registerSaveRouter(F3),hs.registerLoadRouter(F3);var Rit=(function(){function n(){Z(kt().getBool("IS_BROWSER"),(function(){return"Current environment is not a web browser"})),Z(typeof window>"u"||window.localStorage!==void 0,(function(){return"Current browser does not appear to support localStorage"})),this.LS=window.localStorage}return n.prototype.listModels=function(){return Yt(this,void 0,void 0,(function(){var t,e,r,a,s,o;return Qt(this,(function(i){for(t={},e=Oh+Ti,r=Ti+nP,a=0;a<this.LS.length;++a)(s=this.LS.key(a)).startsWith(e)&&s.endsWith(r)&&(o=_it(s),t[o]=JSON.parse(this.LS.getItem(s)));return[2,t]}))}))},n.prototype.removeModel=function(t){return Yt(this,void 0,void 0,(function(){var e,r;return Qt(this,(function(a){var s;if(t=(s=t).startsWith(Uh.URL_SCHEME)?s.slice(Uh.URL_SCHEME.length):s,e=rP(t),this.LS.getItem(e.info)==null)throw new Error("Cannot find model at path '"+t+"'");return r=JSON.parse(this.LS.getItem(e.info)),this.LS.removeItem(e.info),this.LS.removeItem(e.topology),this.LS.removeItem(e.weightSpecs),this.LS.removeItem(e.weightData),[2,r]}))}))},n})();if(kt().getBool("IS_BROWSER"))try{Ru.registerManager(Uh.URL_SCHEME,new Rit)}catch{}var Ait="model",Dit=".json",$it=".weights.bin";function M3(n){return new Promise((function(t){return setTimeout(t)})).then(n)}var pC=(function(){function n(t){if(!kt().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");t.startsWith(n.URL_SCHEME)&&(t=t.slice(n.URL_SCHEME.length)),t!=null&&t.length!==0||(t=Ait),this.modelTopologyFileName=t+Dit,this.weightDataFileName=t+$it}return n.prototype.save=function(t){return Yt(this,void 0,void 0,(function(){var e,r,a,s,o,i;return Qt(this,(function(u){switch(u.label){case 0:if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");if(e=window.URL.createObjectURL(new Blob([t.weightData],{type:"application/octet-stream"})),!(t.modelTopology instanceof ArrayBuffer))return[3,1];throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");case 1:return r=[{paths:["./"+this.weightDataFileName],weights:t.weightSpecs}],a={modelTopology:t.modelTopology,format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,weightsManifest:r},s=window.URL.createObjectURL(new Blob([JSON.stringify(a)],{type:"application/json"})),(o=this.jsonAnchor==null?document.createElement("a"):this.jsonAnchor).download=this.modelTopologyFileName,o.href=s,[4,M3((function(){return o.dispatchEvent(new MouseEvent("click"))}))];case 2:return u.sent(),t.weightData==null?[3,4]:((i=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor).download=this.weightDataFileName,i.href=e,[4,M3((function(){return i.dispatchEvent(new MouseEvent("click"))}))]);case 3:u.sent(),u.label=4;case 4:return[2,{modelArtifactsInfo:tv(t)}]}}))}))},n.URL_SCHEME="downloads://",n})(),Oit=(function(){function n(t){if(t==null||t.length<1)throw new Error("When calling browserFiles, at least 1 file is required, but received "+t);this.files=t}return n.prototype.load=function(){return Yt(this,void 0,void 0,(function(){var t,e,r=this;return Qt(this,(function(a){return t=this.files[0],e=this.files.slice(1),[2,new Promise((function(s,o){var i=new FileReader;i.onload=function(u){var l=JSON.parse(u.target.result),h=l.modelTopology;if(h!=null){e.length===0&&s({modelTopology:h});var d=l.weightsManifest;if(d!=null){var f;try{f=r.checkManifestAndWeightFiles(d,e)}catch(b){return void o(b)}var m=[],v=[],y=[];d.forEach((function(b){b.paths.forEach((function(w){v.push(w),y.push(null)})),m.push.apply(m,b.weights)})),d.forEach((function(b){b.paths.forEach((function(w){var S=new FileReader;S.onload=function(N){var C=N.target.result,T=v.indexOf(w);y[T]=C,y.indexOf(null)===-1&&s({modelTopology:h,weightSpecs:m,weightData:uI(y),format:l.format,generatedBy:l.generatedBy,convertedBy:l.convertedBy,userDefinedMetadata:l.userDefinedMetadata})},S.onerror=function(N){return o("Failed to weights data from file of path '"+w+"'.")},S.readAsArrayBuffer(f[w])}))}))}else o(new Error("weightManifest field is missing from file "+t.name))}else o(new Error("modelTopology field is missing from file "+t.name))},i.onerror=function(u){return o("Failed to read model topology and weights manifest JSON from file '"+t.name+"'. BrowserFiles supports loading Keras-style tf.Model artifacts only.")},i.readAsText(t)}))]}))}))},n.prototype.checkManifestAndWeightFiles=function(t,e){for(var r=[],a=e.map((function(u){return D3(u.name)})),s={},o=0,i=t;o<i.length;o++)i[o].paths.forEach((function(u){var l=D3(u);if(r.indexOf(l)!==-1)throw new Error("Duplicate file basename found in weights manifest: '"+l+"'");if(r.push(l),a.indexOf(l)===-1)throw new Error("Weight file with basename '"+l+"' is not provided.");s[u]=e[a.indexOf(l)]}));if(r.length!==e.length)throw new Error("Mismatch in the number of files in weights manifest ("+r.length+") and the number of weight files provided ("+e.length+").");return s},n})();function L3(n,t,e,r){(function(s){Z(s!=null&&Array.isArray(s)&&s.length>0,(function(){return"promises must be a none empty array"}))})(n),(function(s,o){Z(s>=0&&s<=1,(function(){return"Progress fraction must be in range [0, 1], but got startFraction "+s})),Z(o>=0&&o<=1,(function(){return"Progress fraction must be in range [0, 1], but got endFraction "+o})),Z(o>=s,(function(){return"startFraction must be no more than endFraction, but got startFraction "+s+" and endFraction "+o}))})(e=e??0,r=r??1);var a=0;return Promise.all(n.map((function(s){return s.then((function(o){var i=e+ ++a/n.length*(r-e);return t(i),o})),s})))}function aP(n,t){return Yt(this,void 0,void 0,(function(){var e,r,a,s,o,i,u,l,h;return Qt(this,(function(d){switch(d.label){case 0:return t==null&&(t={}),e=t.fetchFunc==null?kt().platform.fetch:t.fetchFunc,r=n.map((function(f){return e(f,t.requestInit,{isBinary:!0})})),a=0,s=.5,t.onProgress!=null?[3,2]:[4,Promise.all(r)];case 1:return o=d.sent(),[3,4];case 2:return[4,L3(r,t.onProgress,a,s)];case 3:o=d.sent(),d.label=4;case 4:return i=o.map((function(f){return f.arrayBuffer()})),u=.5,l=1,t.onProgress!=null?[3,6]:[4,Promise.all(i)];case 5:return h=d.sent(),[3,8];case 6:return[4,L3(i,t.onProgress,u,l)];case 7:h=d.sent(),d.label=8;case 8:return[2,h]}}))}))}function B3(n){var t=this;return function(e,r,a){return r===void 0&&(r=""),Yt(t,void 0,void 0,(function(){var s,o,i,u,l,h,d,f,m,v;return Qt(this,(function(y){switch(y.label){case 0:if(s=e.map((function(){return!1})),o={},i=a!=null?a.map((function(){return!1})):[],u=[],e.forEach((function(b,w){var S=0;b.weights.forEach((function(N){var C="quantization"in N?N.quantization.dtype:N.dtype,T=YN[C]*ee(N.shape),I=function(){s[w]=!0,o[w]==null&&(o[w]=[]),o[w].push({manifestEntry:N,groupOffset:S,sizeBytes:T})};a!=null?a.forEach((function(_,$){_===N.name&&(I(),i[$]=!0)})):I(),u.push(N.name),S+=T}))})),!i.every((function(b){return b})))throw l=a.filter((function(b,w){return!i[w]})),new Error("Could not find weights in manifest with names: "+l.join(", ")+`. 
Manifest JSON has weights with names: `+u.join(", ")+".");return h=s.reduce((function(b,w,S){return w&&b.push(S),b}),[]),d=[],h.forEach((function(b){e[b].paths.forEach((function(w){var S=r+(r.endsWith("/")?"":"/")+w;d.push(S)}))})),[4,n(d)];case 1:return f=y.sent(),m={},v=0,h.forEach((function(b){for(var w=e[b].paths.length,S=0,N=0;N<w;N++)S+=f[v+N].byteLength;for(var C=new ArrayBuffer(S),T=new Uint8Array(C),I=0,_=0;_<w;_++){var $=new Uint8Array(f[v+_]);T.set($,I),I+=$.byteLength}o[b].forEach((function(R){var D=tP(C.slice(R.groupOffset,R.groupOffset+R.sizeBytes),[R.manifestEntry]);for(var A in D)m[A]=D[A]})),v+=w})),[2,m]}}))}))}}hs.registerSaveRouter((function(n){return kt().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(pC.URL_SCHEME)?(function(t){return t===void 0&&(t="model"),new pC(t)})(n.slice(pC.URL_SCHEME.length)):null}));var sP=(function(){function n(t,e){if(this.DEFAULT_METHOD="POST",e==null&&(e={}),this.weightPathPrefix=e.weightPathPrefix,this.onProgress=e.onProgress,e.fetchFunc!=null?(Z(typeof e.fetchFunc=="function",(function(){return"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"})),this.fetch=e.fetchFunc):this.fetch=kt().platform.fetch,Z(t!=null&&t.length>0,(function(){return"URL path for http must not be null, undefined or empty."})),Array.isArray(t)&&Z(t.length===2,(function(){return"URL paths for http must have a length of 2, (actual length is "+t.length+")."})),this.path=t,e.requestInit!=null&&e.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=e.requestInit||{}}return n.prototype.save=function(t){return Yt(this,void 0,void 0,(function(){var e,r,a,s;return Qt(this,(function(o){switch(o.label){case 0:if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");return(e=Object.assign({method:this.DEFAULT_METHOD},this.requestInit)).body=new FormData,r=[{paths:["./model.weights.bin"],weights:t.weightSpecs}],a={modelTopology:t.modelTopology,format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,userDefinedMetadata:t.userDefinedMetadata,weightsManifest:r},e.body.append("model.json",new Blob([JSON.stringify(a)],{type:"application/json"}),"model.json"),t.weightData!=null&&e.body.append("model.weights.bin",new Blob([t.weightData],{type:"application/octet-stream"}),"model.weights.bin"),[4,this.fetch(this.path,e)];case 1:if((s=o.sent()).ok)return[2,{modelArtifactsInfo:tv(t),responses:[s]}];throw new Error("BrowserHTTPRequest.save() failed due to HTTP response status "+s.status+".")}}))}))},n.prototype.load=function(){return Yt(this,void 0,void 0,(function(){var t,e,r,a,s,o,i,u,l,h,d,f;return Qt(this,(function(m){switch(m.label){case 0:return[4,this.fetch(this.path,this.requestInit)];case 1:if(!(t=m.sent()).ok)throw new Error("Request to "+this.path+" failed with status code "+t.status+". Please verify this URL points to the model JSON of the model to load.");m.label=2;case 2:return m.trys.push([2,4,,5]),[4,t.json()];case 3:return e=m.sent(),[3,5];case 4:throw m.sent(),r="Failed to parse model JSON of response from "+this.path+".",this.path.endsWith(".pb")?r+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":r+=" Please make sure the server is serving valid JSON for this request.",new Error(r);case 5:if(a=e.modelTopology,s=e.weightsManifest,o=e.generatedBy,i=e.convertedBy,u=e.format,l=e.userDefinedMetadata,a==null&&s==null)throw new Error("The JSON from HTTP path "+this.path+" contains neither model topology or manifest for weights.");return s==null?[3,7]:[4,this.loadWeights(s)];case 6:f=m.sent(),h=f[0],d=f[1],m.label=7;case 7:return[2,{modelTopology:a,weightSpecs:h,weightData:d,userDefinedMetadata:l,generatedBy:o,convertedBy:i,format:u}]}}))}))},n.prototype.loadWeights=function(t){return Yt(this,void 0,void 0,(function(){var e,r,a,s,o,i,u,l,h,d,f;return Qt(this,(function(m){switch(m.label){case 0:for(e=Array.isArray(this.path)?this.path[1]:this.path,r=(function(v){var y=v.lastIndexOf("/"),b=v.lastIndexOf("?"),w=v.substring(0,y),S=b>y?v.substring(b):"";return[w+"/",S]})(e),a=r[0],s=r[1],o=this.weightPathPrefix||a,i=[],u=0,l=t;u<l.length;u++)h=l[u],i.push.apply(i,h.weights);return d=[],t.forEach((function(v){v.paths.forEach((function(y){d.push(o+y+s)}))})),[4,aP(d,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress})];case 1:return f=m.sent(),[2,[i,uI(f)]]}}))}))},n.URL_SCHEME_REGEX=/^https?:\/\//,n})();function JN(n){return n.match(sP.URL_SCHEME_REGEX)!=null}var z3=function(n,t){return typeof fetch>"u"?null:(Array.isArray(n)?n.every((function(e){return JN(e)})):JN(n))?tk(n,{onProgress:t}):null};function tk(n,t){return new sP(n,t)}hs.registerSaveRouter(z3),hs.registerLoadRouter(z3);var fC=(function(){function n(t){this.modelArtifacts=t}return n.prototype.load=function(){return Yt(this,void 0,void 0,(function(){return Qt(this,(function(t){return[2,this.modelArtifacts]}))}))},n})(),Fit=(function(){function n(t){this.saveHandler=t}return n.prototype.save=function(t){return Yt(this,void 0,void 0,(function(){return Qt(this,(function(e){return[2,this.saveHandler(t)]}))}))},n})(),oP=Object.freeze({browserFiles:function(n){return new Oit(n)},browserHTTPRequest:function(n,t){return tk(n,t)},concatenateArrayBuffers:uI,decodeWeights:tP,encodeWeights:function(n,t){return Yt(this,void 0,void 0,(function(){var e,r,a,s,o,i=this;return Qt(this,(function(u){switch(u.label){case 0:for(e=[],r=[],a=Array.isArray(n)?n.map((function(l){return l.name})):Object.keys(n),s=function(l){var h=a[l],d=Array.isArray(n)?n[l].tensor:n[h];if(d.dtype!=="float32"&&d.dtype!=="int32"&&d.dtype!=="bool"&&d.dtype!=="string")throw new Error("Unsupported dtype in weight '"+h+"': "+d.dtype);var f={name:h,shape:d.shape,dtype:d.dtype};if(d.dtype==="string"){var m=new Promise((function(v){return Yt(i,void 0,void 0,(function(){var y,b,w,S,N,C,T;return Qt(this,(function(I){switch(I.label){case 0:return[4,d.bytes()];case 1:for(y=I.sent(),b=y.reduce((function(_,$){return _+$.length}),0)+lb*y.length,w=new Uint8Array(b),S=0,N=0;N<y.length;N++)C=y[N],T=new Uint8Array(new Uint32Array([C.length]).buffer),w.set(T,S),S+=lb,w.set(C,S),S+=C.length;return v(w),[2]}}))}))}));r.push(m)}else r.push(d.data());t!=null&&(f.group=t),e.push(f)},o=0;o<a.length;++o)s(o);return[4,Promise.all(r)];case 1:return[2,{data:Cit(u.sent()),specs:e}]}}))}))},fromMemory:function(n,t,e,r){return arguments.length===1?n.modelTopology!=null||n.weightSpecs!=null?new fC(n):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new fC({modelTopology:n})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new fC({modelTopology:n,weightSpecs:t,weightData:e,trainingConfig:r}))},getLoadHandlers:function(n,t){return hs.getLoadHandlers(n,t)},getModelArtifactsInfoForJSON:tv,getSaveHandlers:function(n){return hs.getSaveHandlers(n)},http:tk,isHTTPScheme:JN,loadWeights:function(n,t,e,r){return t===void 0&&(t=""),Yt(this,void 0,void 0,(function(){return Qt(this,(function(a){return[2,B3((function(s){return aP(s,{requestInit:r})}))(n,t,e)]}))}))},registerLoadRouter:function(n){return hs.registerLoadRouter(n)},registerSaveRouter:function(n){return hs.registerSaveRouter(n)},weightsLoaderFactory:B3,withSaveHandler:function(n){return new Fit(n)},copyModel:function(n,t){return Yt(this,void 0,void 0,(function(){return Qt(this,(function(e){return[2,$3(n,t,!1)]}))}))},listModels:function(){return Yt(this,void 0,void 0,(function(){var n,t,e,r,a,s,o;return Qt(this,(function(i){switch(i.label){case 0:n=Ru.getSchemes(),t={},e=0,r=n,i.label=1;case 1:return e<r.length?(a=r[e],[4,Ru.getManager(a).listModels()]):[3,4];case 2:for(o in s=i.sent())t[a+Ph+o]=s[o];i.label=3;case 3:return e++,[3,1];case 4:return[2,t]}}))}))},moveModel:function(n,t){return Yt(this,void 0,void 0,(function(){return Qt(this,(function(e){return[2,$3(n,t,!0)]}))}))},removeModel:function(n){return Yt(this,void 0,void 0,(function(){var t;return Qt(this,(function(e){return t=E0(n),[2,Ru.getManager(t.scheme).removeModel(t.path)]}))}))}}),Ch;st({confusionMatrix_:function(n,t,e){var r=Y(n,"labels","confusionMatrix"),a=Y(t,"predictions","confusionMatrix");Z(e==null||e>0&&Number.isInteger(e),(function(){return"If provided, numClasses must be a positive integer, but got "+e})),Z(r.rank===1,(function(){return"Expected the rank of labels to be 1, but got "+r.rank})),Z(a.rank===1,(function(){return"Expected the rank of predictions to be 1, but got "+a.rank})),Z(r.shape[0]===a.shape[0],(function(){return"Mismatch in the number of examples: "+r.shape[0]+" vs. "+a.shape[0]+". Labels and predictions should have the same number of elements."})),Z(e>0&&Number.isInteger(e),(function(){return"numClasses is required to be a positive integer, but got "+e}));var s=HN(r.asType("int32"),e),o=HN(a.asType("int32"),e);return s.transpose().matMul(o).asType("int32")}});var Mit=st({fromPixels_:function(n,t){if(t===void 0&&(t=3),t>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(n==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");var e=!1,r=!1,a=!1,s=!1,o=!1;if(n.data instanceof Uint8Array)e=!0;else if(typeof ImageData<"u"&&n instanceof ImageData)r=!0;else if(typeof HTMLVideoElement<"u"&&n instanceof HTMLVideoElement)a=!0;else if(typeof HTMLImageElement<"u"&&n instanceof HTMLImageElement)s=!0;else{if(n.getContext==null)throw new Error("pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was "+n.constructor.name);o=!0}if(a&&a&&n.readyState<2)throw new Error("The video element has not loaded data yet. Please wait for `loadeddata` event on the <video> element.");if(RB("FromPixels",lt.backendName)!=null)return lt.runKernel("FromPixels",{pixels:n},{numChannels:t});var i,u,l=a?[n.videoWidth,n.videoHeight]:[n.width,n.height],h=l[0],d=l[1];if(o?i=n.getContext("2d").getImageData(0,0,h,d).data:r||e?i=n.data:(s||a)&&(Ch==null&&(Ch=document.createElement("canvas").getContext("2d")),Ch.canvas.width=h,Ch.canvas.height=d,Ch.drawImage(n,0,0,h,d),i=Ch.getImageData(0,0,h,d).data),t===4)u=new Int32Array(i);else{var f=h*d;u=new Int32Array(f*t);for(var m=0;m<f;m++)for(var v=0;v<t;++v)u[m*t+v]=i[4*m+v]}return LE(u,[d,h,t],"int32")}}),lI=Object.freeze({toPixels:function(n,t){return Yt(this,void 0,void 0,(function(){var e,r,a,s,o,i,u,l,h,d,f,m,v,y,b,w,S,N,C,T,I,_,$;return Qt(this,(function(R){switch(R.label){case 0:if(e=Y(n,"img","toPixels"),n instanceof $n||(e=e.toInt()),e.rank!==2&&e.rank!==3)throw new Error("toPixels only supports rank 2 or 3 tensors, got rank "+e.rank+".");if(r=e.shape.slice(0,2),a=r[0],s=r[1],(o=e.rank===2?1:e.shape[2])>4||o===2)throw new Error("toPixels only supports depth of size 1, 3 or 4 but got "+o);return[4,e.data()];case 1:return i=R.sent(),u=e.min(),l=e.max(),[4,Promise.all([u.data(),l.data()])];case 2:if(h=R.sent(),d=h[0],f=h[1],m=d[0],v=f[0],u.dispose(),l.dispose(),e.dtype==="float32"){if(m<0||v>1)throw new Error("Tensor values for a float32 Tensor must be in the range [0 - 1] but got range ["+m+" - "+v+"].")}else{if(e.dtype!=="int32")throw new Error("Unsupported type for toPixels: "+e.dtype+". Please use float32 or int32 tensors.");if(m<0||v>255)throw new Error("Tensor values for a int32 Tensor must be in the range [0 - 255] but got range ["+m+" - "+v+"].")}for(y=e.dtype==="float32"?255:1,b=new Uint8ClampedArray(s*a*4),w=0;w<a*s;++w)S=void 0,N=void 0,C=void 0,T=void 0,o===1?(S=i[w]*y,N=i[w]*y,C=i[w]*y,T=255):o===3?(S=i[3*w]*y,N=i[3*w+1]*y,C=i[3*w+2]*y,T=255):o===4&&(S=i[4*w]*y,N=i[4*w+1]*y,C=i[4*w+2]*y,T=i[4*w+3]*y),b[(I=4*w)+0]=Math.round(S),b[I+1]=Math.round(N),b[I+2]=Math.round(C),b[I+3]=Math.round(T);return t!=null&&(t.width=s,t.height=a,_=t.getContext("2d"),$=new ImageData(b,s,a),_.putImageData($,0,0)),e!==n&&e.dispose(),[2,b]}}))}))},fromPixels:Mit}),Lit=(function(){function n(){}return n.prototype.getClassName=function(){return this.constructor.className},n.fromConfig=function(t,e){return new t(e)},n})(),Bit=(function(){function n(){this.classNameMap={}}return n.getMap=function(){return n.instance==null&&(n.instance=new n),n.instance},n.register=function(t){n.getMap().classNameMap[t.className]=[t,t.fromConfig]},n})();function Tc(n){Z(n.className!=null,(function(){return"Class being registered does not have the static className property defined."})),Z(typeof n.className=="string",(function(){return"className is required to be a string, but got type "+typeof n.className})),Z(n.className.length>0,(function(){return"Class being registered has an empty-string as its className, which is disallowed."})),Bit.register(n)}var Ec=(function(n){function t(){return n!==null&&n.apply(this,arguments)||this}return co(t,n),t.prototype.minimize=function(e,r,a){r===void 0&&(r=!1);var s=this.computeGradients(e,a),o=s.value,i=s.grads;if(a!=null){var u=a.map((function(l){return{name:l.name,tensor:i[l.name]}}));this.applyGradients(u)}else this.applyGradients(i);return Ua(i),r?o:(o.dispose(),null)},Object.defineProperty(t.prototype,"iterations",{get:function(){return this.iterations_==null&&(this.iterations_=0),this.iterations_},enumerable:!0,configurable:!0}),t.prototype.incrementIterations=function(){this.iterations_=this.iterations+1},t.prototype.computeGradients=function(e,r){return Knt(e,r)},t.prototype.dispose=function(){this.iterations_!=null&&Ua(this.iterations_)},t.prototype.saveIterations=function(){return Yt(this,void 0,void 0,(function(){return Qt(this,(function(e){return this.iterations_==null&&(this.iterations_=0),[2,{name:"iter",tensor:Pt(this.iterations_,"int32")}]}))}))},t.prototype.getWeights=function(){return Yt(this,void 0,void 0,(function(){return Qt(this,(function(e){throw new Error("getWeights() is not implemented for this optimizer yet.")}))}))},t.prototype.setWeights=function(e){return Yt(this,void 0,void 0,(function(){return Qt(this,(function(r){throw new Error("setWeights() is not implemented for this optimizer class "+this.getClassName())}))}))},t.prototype.extractIterations=function(e){return Yt(this,void 0,void 0,(function(){var r;return Qt(this,(function(a){switch(a.label){case 0:return r=this,[4,e[0].tensor.data()];case 1:return r.iterations_=a.sent()[0],[2,e.slice(1)]}}))}))},t})(Lit);Object.defineProperty(Ec,Symbol.hasInstance,{value:function(n){return n.minimize!=null&&n.computeGradients!=null&&n.applyGradients!=null}});var zit=(function(n){function t(e,r,a){a===void 0&&(a=null);var s=n.call(this)||this;return s.learningRate=e,s.rho=r,s.epsilon=a,s.accumulatedGrads=[],s.accumulatedUpdates=[],a==null&&(s.epsilon=lt.backend.epsilon()),s}return co(t,n),t.prototype.applyGradients=function(e){var r=this;(Array.isArray(e)?e.map((function(a){return a.name})):Object.keys(e)).forEach((function(a,s){var o=lt.registeredVariables[a];r.accumulatedGrads[s]==null&&(r.accumulatedGrads[s]={originalName:a+"/accum_grad",variable:Gt((function(){return He(o).variable(!1)}))}),r.accumulatedUpdates[s]==null&&(r.accumulatedUpdates[s]={originalName:a+"/accum_var",variable:Gt((function(){return He(o).variable(!1)}))});var i=Array.isArray(e)?e[s].tensor:e[a];if(i!=null){var u=r.accumulatedGrads[s].variable,l=r.accumulatedUpdates[s].variable;Gt((function(){var h=u.mul(r.rho).add(i.square().mul(1-r.rho)),d=l.add(r.epsilon).sqrt().div(u.add(r.epsilon).sqrt()).mul(i),f=l.mul(r.rho).add(d.square().mul(1-r.rho));u.assign(h),l.assign(f);var m=d.mul(-r.learningRate).add(o);o.assign(m)}))}})),this.incrementIterations()},t.prototype.dispose=function(){this.accumulatedUpdates!=null&&(Ua(this.accumulatedGrads.map((function(e){return e.variable}))),Ua(this.accumulatedUpdates.map((function(e){return e.variable}))))},t.prototype.getWeights=function(){return Yt(this,void 0,void 0,(function(){var e;return Qt(this,(function(r){switch(r.label){case 0:return e=this.accumulatedGrads.concat(this.accumulatedUpdates),[4,this.saveIterations()];case 1:return[2,[r.sent()].concat(e.map((function(a){return{name:a.originalName,tensor:a.variable}})))]}}))}))},t.prototype.setWeights=function(e){return Yt(this,void 0,void 0,(function(){var r;return Qt(this,(function(a){switch(a.label){case 0:return[4,this.extractIterations(e)];case 1:return e=a.sent(),r=e.length/2,this.accumulatedGrads=e.slice(0,r).map((function(s){return{originalName:s.name,variable:s.tensor.variable(!1)}})),this.accumulatedUpdates=e.slice(r,2*r).map((function(s){return{originalName:s.name,variable:s.tensor.variable(!1)}})),[2]}}))}))},t.prototype.getConfig=function(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}},t.fromConfig=function(e,r){return new e(r.learningRate,r.rho,r.epsilon)},t.className="Adadelta",t})(Ec);Tc(zit);var Pit=(function(n){function t(e,r){r===void 0&&(r=.1);var a=n.call(this)||this;return a.learningRate=e,a.initialAccumulatorValue=r,a.accumulatedGrads=[],a}return co(t,n),t.prototype.applyGradients=function(e){var r=this;(Array.isArray(e)?e.map((function(a){return a.name})):Object.keys(e)).forEach((function(a,s){var o=lt.registeredVariables[a];r.accumulatedGrads[s]==null&&(r.accumulatedGrads[s]={originalName:a+"/accumulator",variable:Gt((function(){return Bo(o.shape,r.initialAccumulatorValue).variable(!1)}))});var i=Array.isArray(e)?e[s].tensor:e[a];if(i!=null){var u=r.accumulatedGrads[s].variable;Gt((function(){var l=u.add(i.square());u.assign(l);var h=i.div(l.add(lt.backend.epsilon()).sqrt()).mul(-r.learningRate).add(o);o.assign(h)}))}})),this.incrementIterations()},t.prototype.dispose=function(){this.accumulatedGrads!=null&&Ua(this.accumulatedGrads.map((function(e){return e.variable})))},t.prototype.getWeights=function(){return Yt(this,void 0,void 0,(function(){return Qt(this,(function(e){switch(e.label){case 0:return[4,this.saveIterations()];case 1:return[2,[e.sent()].concat(this.accumulatedGrads.map((function(r){return{name:r.originalName,tensor:r.variable}})))]}}))}))},t.prototype.setWeights=function(e){return Yt(this,void 0,void 0,(function(){return Qt(this,(function(r){switch(r.label){case 0:return[4,this.extractIterations(e)];case 1:return e=r.sent(),this.accumulatedGrads=e.map((function(a){return{originalName:a.name,variable:a.tensor.variable(!1)}})),[2]}}))}))},t.prototype.getConfig=function(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}},t.fromConfig=function(e,r){return new e(r.learningRate,r.initialAccumulatorValue)},t.className="Adagrad",t})(Ec);Tc(Pit);var Vit=(function(n){function t(e,r,a,s){s===void 0&&(s=null);var o=n.call(this)||this;return o.learningRate=e,o.beta1=r,o.beta2=a,o.epsilon=s,o.accumulatedFirstMoment=[],o.accumulatedSecondMoment=[],Gt((function(){o.accBeta1=Pt(r).variable(),o.accBeta2=Pt(a).variable()})),s==null&&(o.epsilon=lt.backend.epsilon()),o}return co(t,n),t.prototype.applyGradients=function(e){var r=this,a=Array.isArray(e)?e.map((function(s){return s.name})):Object.keys(e);Gt((function(){var s=Cr(1,r.accBeta1),o=Cr(1,r.accBeta2);a.forEach((function(i,u){var l=lt.registeredVariables[i];r.accumulatedFirstMoment[u]==null&&(r.accumulatedFirstMoment[u]={originalName:i+"/m",variable:Gt((function(){return He(l).variable(!1)}))}),r.accumulatedSecondMoment[u]==null&&(r.accumulatedSecondMoment[u]={originalName:i+"/v",variable:Gt((function(){return He(l).variable(!1)}))});var h=Array.isArray(e)?e[u].tensor:e[i];if(h!=null){var d=r.accumulatedFirstMoment[u].variable,f=r.accumulatedSecondMoment[u].variable,m=d.mul(r.beta1).add(h.mul(1-r.beta1)),v=f.mul(r.beta2).add(h.square().mul(1-r.beta2)),y=m.div(s),b=v.div(o);d.assign(m),f.assign(v);var w=y.div(b.sqrt().add(r.epsilon)).mul(-r.learningRate).add(l);l.assign(w)}})),r.accBeta1.assign(r.accBeta1.mul(r.beta1)),r.accBeta2.assign(r.accBeta2.mul(r.beta2))})),this.incrementIterations()},t.prototype.dispose=function(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&Ua(this.accumulatedFirstMoment.map((function(e){return e.variable}))),this.accumulatedSecondMoment!=null&&Ua(this.accumulatedSecondMoment.map((function(e){return e.variable})))},t.prototype.getWeights=function(){return Yt(this,void 0,void 0,(function(){var e;return Qt(this,(function(r){switch(r.label){case 0:return e=this.accumulatedFirstMoment.concat(this.accumulatedSecondMoment),[4,this.saveIterations()];case 1:return[2,[r.sent()].concat(e.map((function(a){return{name:a.originalName,tensor:a.variable}})))]}}))}))},t.prototype.setWeights=function(e){return Yt(this,void 0,void 0,(function(){var r,a=this;return Qt(this,(function(s){switch(s.label){case 0:return[4,this.extractIterations(e)];case 1:return e=s.sent(),Gt((function(){a.accBeta1.assign(ib(a.beta1,a.iterations_+1)),a.accBeta2.assign(ib(a.beta2,a.iterations_+1))})),r=e.length/2,this.accumulatedFirstMoment=e.slice(0,r).map((function(o){return{originalName:o.name,variable:o.tensor.variable(!1)}})),this.accumulatedSecondMoment=e.slice(r,2*r).map((function(o){return{originalName:o.name,variable:o.tensor.variable(!1)}})),[2]}}))}))},t.prototype.getConfig=function(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}},t.fromConfig=function(e,r){return new e(r.learningRate,r.beta1,r.beta2,r.epsilon)},t.className="Adam",t})(Ec);Tc(Vit);var Uit=(function(n){function t(e,r,a,s,o){s===void 0&&(s=null),o===void 0&&(o=0);var i=n.call(this)||this;return i.learningRate=e,i.beta1=r,i.beta2=a,i.epsilon=s,i.decay=o,i.accumulatedFirstMoment=[],i.accumulatedWeightedInfNorm=[],Gt((function(){i.iteration=Pt(0).variable(),i.accBeta1=Pt(r).variable()})),s==null&&(i.epsilon=lt.backend.epsilon()),i}return co(t,n),t.prototype.applyGradients=function(e){var r=this,a=Array.isArray(e)?e.map((function(s){return s.name})):Object.keys(e);Gt((function(){var s=Cr(1,r.accBeta1),o=Js(-r.learningRate,r.iteration.mul(r.decay).add(1));a.forEach((function(i,u){var l=lt.registeredVariables[i];r.accumulatedFirstMoment[u]==null&&(r.accumulatedFirstMoment[u]={originalName:i+"/m",variable:He(l).variable(!1)}),r.accumulatedWeightedInfNorm[u]==null&&(r.accumulatedWeightedInfNorm[u]={originalName:i+"/v",variable:He(l).variable(!1)});var h=Array.isArray(e)?e[u].tensor:e[i];if(h!=null){var d=r.accumulatedFirstMoment[u].variable,f=r.accumulatedWeightedInfNorm[u].variable,m=d.mul(r.beta1).add(h.mul(1-r.beta1)),v=f.mul(r.beta2),y=h.abs(),b=v.maximum(y);d.assign(m),f.assign(b);var w=o.div(s).mul(m.div(b.add(r.epsilon))).add(l);l.assign(w)}})),r.iteration.assign(r.iteration.add(1)),r.accBeta1.assign(r.accBeta1.mul(r.beta1))})),this.incrementIterations()},t.prototype.dispose=function(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&Ua(this.accumulatedFirstMoment.map((function(e){return e.variable}))),this.accumulatedWeightedInfNorm!=null&&Ua(this.accumulatedWeightedInfNorm.map((function(e){return e.variable})))},t.prototype.getWeights=function(){return Yt(this,void 0,void 0,(function(){return Qt(this,(function(e){throw new Error("getWeights() is not implemented for Adamax yet.")}))}))},t.prototype.setWeights=function(e){return Yt(this,void 0,void 0,(function(){return Qt(this,(function(r){throw new Error("setWeights() is not implemented for Adamax yet.")}))}))},t.prototype.getConfig=function(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}},t.fromConfig=function(e,r){return new e(r.learningRate,r.beta1,r.beta2,r.epsilon,r.decay)},t.className="Adamax",t})(Ec);Tc(Uit);var iP=(function(n){function t(e){var r=n.call(this)||this;return r.learningRate=e,r.setLearningRate(e),r}return co(t,n),t.prototype.applyGradients=function(e){var r=this;(Array.isArray(e)?e.map((function(a){return a.name})):Object.keys(e)).forEach((function(a,s){var o=Array.isArray(e)?e[s].tensor:e[a];if(o!=null){var i=lt.registeredVariables[a];Gt((function(){var u=r.c.mul(o).add(i);i.assign(u)}))}})),this.incrementIterations()},t.prototype.setLearningRate=function(e){this.learningRate=e,this.c!=null&&this.c.dispose(),this.c=unt(Pt(-e))},t.prototype.dispose=function(){this.c.dispose()},t.prototype.getWeights=function(){return Yt(this,void 0,void 0,(function(){return Qt(this,(function(e){switch(e.label){case 0:return[4,this.saveIterations()];case 1:return[2,[e.sent()]]}}))}))},t.prototype.setWeights=function(e){return Yt(this,void 0,void 0,(function(){return Qt(this,(function(r){switch(r.label){case 0:return[4,this.extractIterations(e)];case 1:if((e=r.sent()).length!==0)throw new Error("SGD optimizer does not have settable weights.");return[2]}}))}))},t.prototype.getConfig=function(){return{learningRate:this.learningRate}},t.fromConfig=function(e,r){return new e(r.learningRate)},t.className="SGD",t})(Ec);Tc(iP);var Wit=(function(n){function t(e,r,a){a===void 0&&(a=!1);var s=n.call(this,e)||this;return s.learningRate=e,s.momentum=r,s.useNesterov=a,s.accumulations=[],s.m=Pt(s.momentum),s}return co(t,n),t.prototype.applyGradients=function(e){var r=this;(Array.isArray(e)?e.map((function(a){return a.name})):Object.keys(e)).forEach((function(a,s){var o=lt.registeredVariables[a];r.accumulations[s]==null&&(r.accumulations[s]={originalName:a+"/momentum",variable:Gt((function(){return He(o).variable(!1)}))});var i=r.accumulations[s].variable,u=Array.isArray(e)?e[s].tensor:e[a];u!=null&&Gt((function(){var l,h=r.m.mul(i).add(u);l=r.useNesterov?r.c.mul(u.add(h.mul(r.m))).add(o):r.c.mul(h).add(o),i.assign(h),o.assign(l)}))})),this.incrementIterations()},t.prototype.dispose=function(){this.m.dispose(),this.accumulations!=null&&Ua(this.accumulations.map((function(e){return e.variable})))},t.prototype.setMomentum=function(e){this.momentum=e},t.prototype.getWeights=function(){return Yt(this,void 0,void 0,(function(){return Qt(this,(function(e){switch(e.label){case 0:return[4,this.saveIterations()];case 1:return[2,[e.sent()].concat(this.accumulations.map((function(r){return{name:r.originalName,tensor:r.variable}})))]}}))}))},t.prototype.setWeights=function(e){return Yt(this,void 0,void 0,(function(){return Qt(this,(function(r){switch(r.label){case 0:return[4,this.extractIterations(e)];case 1:return e=r.sent(),this.accumulations=e.map((function(a){return{originalName:a.name,variable:a.tensor.variable(!1)}})),[2]}}))}))},t.prototype.getConfig=function(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}},t.fromConfig=function(e,r){return new e(r.learningRate,r.momentum,r.useNesterov)},t.className="Momentum",t})(iP);Tc(Wit);var Git=(function(n){function t(e,r,a,s,o){r===void 0&&(r=.9),a===void 0&&(a=0),s===void 0&&(s=null),o===void 0&&(o=!1);var i=n.call(this)||this;if(i.learningRate=e,i.decay=r,i.momentum=a,i.epsilon=s,i.accumulatedMeanSquares=[],i.accumulatedMoments=[],i.accumulatedMeanGrads=[],i.centered=o,s==null&&(i.epsilon=lt.backend.epsilon()),e==null)throw new Error("learningRate for RMSPropOptimizer must be defined.");return i}return co(t,n),t.prototype.applyGradients=function(e){var r=this;(Array.isArray(e)?e.map((function(a){return a.name})):Object.keys(e)).forEach((function(a,s){var o=lt.registeredVariables[a];r.accumulatedMeanSquares[s]==null&&(r.accumulatedMeanSquares[s]={originalName:a+"/rms",variable:Gt((function(){return He(o).variable(!1)}))}),r.accumulatedMoments[s]==null&&(r.accumulatedMoments[s]={originalName:a+"/momentum",variable:Gt((function(){return He(o).variable(!1)}))}),r.accumulatedMeanGrads[s]==null&&r.centered&&(r.accumulatedMeanGrads[s]={originalName:a+"/mg",variable:Gt((function(){return He(o).variable(!1)}))});var i=Array.isArray(e)?e[s].tensor:e[a];if(i!=null){var u=r.accumulatedMeanSquares[s].variable,l=r.accumulatedMoments[s].variable;Gt((function(){var h=u.mul(r.decay).add(i.square().mul(1-r.decay));if(r.centered){var d=r.accumulatedMeanGrads[s].variable,f=d.mul(r.decay).add(i.mul(1-r.decay)),m=l.mul(r.momentum).add(i.mul(r.learningRate).div(h.sub(f.square().add(r.epsilon)).sqrt()));u.assign(h),d.assign(f),l.assign(m);var v=o.sub(m);o.assign(v)}else{var y=u.mul(r.decay).add(i.square().mul(1-r.decay));m=l.mul(r.momentum).add(i.mul(r.learningRate).div(y.add(r.epsilon).sqrt())),u.assign(y),l.assign(m),v=o.sub(m),o.assign(v)}}))}})),this.incrementIterations()},t.prototype.dispose=function(){this.accumulatedMeanSquares!=null&&Ua(this.accumulatedMeanSquares.map((function(e){return e.variable}))),this.accumulatedMeanGrads!=null&&this.centered&&Ua(this.accumulatedMeanGrads.map((function(e){return e.variable}))),this.accumulatedMoments!=null&&Ua(this.accumulatedMoments.map((function(e){return e.variable})))},t.prototype.getWeights=function(){return Yt(this,void 0,void 0,(function(){var e;return Qt(this,(function(r){switch(r.label){case 0:return e=this.accumulatedMeanSquares.concat(this.accumulatedMoments),this.centered&&e.push.apply(e,this.accumulatedMeanGrads),[4,this.saveIterations()];case 1:return[2,[r.sent()].concat(e.map((function(a){return{name:a.originalName,tensor:a.variable}})))]}}))}))},t.prototype.setWeights=function(e){return Yt(this,void 0,void 0,(function(){var r;return Qt(this,(function(a){switch(a.label){case 0:return[4,this.extractIterations(e)];case 1:return e=a.sent(),r=this.centered?e.length/3:e.length/2,this.accumulatedMeanSquares=e.slice(0,r).map((function(s){return{originalName:s.name,variable:s.tensor.variable(!1)}})),this.accumulatedMoments=e.slice(r,2*r).map((function(s){return{originalName:s.name,variable:s.tensor.variable(!1)}})),this.centered&&(this.accumulatedMeanGrads=e.slice(2*r,3*r).map((function(s){return{originalName:s.name,variable:s.tensor.variable(!1)}}))),[2]}}))}))},t.prototype.getConfig=function(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}},t.fromConfig=function(e,r){return new e(r.learningRate,r.decay,r.momentum,r.epsilon,r.centered)},t.className="RMSProp",t})(Ec);Tc(Git);$n.prototype.squaredDifference=function(n){return Sz(this,n)},St=git;var ek=function(n,t){return ek=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,r){e.__proto__=r}||function(e,r){for(var a in r)r.hasOwnProperty(a)&&(e[a]=r[a])},ek(n,t)};function ve(n,t){ek(n,t);function e(){this.constructor=n}n.prototype=t===null?Object.create(t):(e.prototype=t.prototype,new e)}var oa=function(){return oa=Object.assign||function(t){for(var e,r=1,a=arguments.length;r<a;r++){e=arguments[r];for(var s in e)Object.prototype.hasOwnProperty.call(e,s)&&(t[s]=e[s])}return t},oa.apply(this,arguments)};function re(n,t,e,r){function a(s){return s instanceof e?s:new e(function(o){o(s)})}return new(e||(e=Promise))(function(s,o){function i(h){try{l(r.next(h))}catch(d){o(d)}}function u(h){try{l(r.throw(h))}catch(d){o(d)}}function l(h){h.done?s(h.value):a(h.value).then(i,u)}l((r=r.apply(n,[])).next())})}function ae(n,t){var e={label:0,sent:function(){if(s[0]&1)throw s[1];return s[1]},trys:[],ops:[]},r,a,s,o;return o={next:i(0),throw:i(1),return:i(2)},typeof Symbol=="function"&&(o[Symbol.iterator]=function(){return this}),o;function i(l){return function(h){return u([l,h])}}function u(l){if(r)throw new TypeError("Generator is already executing.");for(;e;)try{if(r=1,a&&(s=l[0]&2?a.return:l[0]?a.throw||((s=a.return)&&s.call(a),0):a.next)&&!(s=s.call(a,l[1])).done)return s;switch(a=0,s&&(l=[l[0]&2,s.value]),l[0]){case 0:case 1:s=l;break;case 4:return e.label++,{value:l[1],done:!1};case 5:e.label++,a=l[1],l=[0];continue;case 7:l=e.ops.pop(),e.trys.pop();continue;default:if(s=e.trys,!(s=s.length>0&&s[s.length-1])&&(l[0]===6||l[0]===2)){e=0;continue}if(l[0]===3&&(!s||l[1]>s[0]&&l[1]<s[3])){e.label=l[1];break}if(l[0]===6&&e.label<s[1]){e.label=s[1],s=l;break}if(s&&e.label<s[2]){e.label=s[2],e.ops.push(l);break}s[2]&&e.ops.pop(),e.trys.pop();continue}l=t.call(n,e)}catch(h){l=[6,h],a=0}finally{r=s=0}if(l[0]&5)throw l[1];return{value:l[0]?l[1]:void 0,done:!0}}}function Uf(){for(var n=0,t=0,e=arguments.length;t<e;t++)n+=arguments[t].length;for(var r=Array(n),a=0,t=0;t<e;t++)for(var s=arguments[t],o=0,i=s.length;o<i;o++,a++)r[a]=s[o];return r}var Wh=(function(){function n(t,e){if(!Xl(t)||!Xl(e))throw new Error("Dimensions.constructor - expected width and height to be valid numbers, instead have "+JSON.stringify({width:t,height:e}));this._width=t,this._height=e}return Object.defineProperty(n.prototype,"width",{get:function(){return this._width},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"height",{get:function(){return this._height},enumerable:!0,configurable:!0}),n.prototype.reverse=function(){return new n(1/this.width,1/this.height)},n})();function V1(n,t){return n instanceof $n&&n.shape.length===t}function Hit(n){return V1(n,2)}function U1(n){return V1(n,3)}function Au(n){return V1(n,4)}function jit(n){return n%1!==0}function P3(n){return n%2===0}function qit(n,t){t===void 0&&(t=2);var e=Math.pow(10,t);return Math.floor(n*e)/e}function V3(n){return n&&n.width&&n.height}function Kit(n,t){var e=n.width,r=n.height,a=t/Math.max(r,e);return new Wh(Math.round(e*a),Math.round(r*a))}function cI(n){return n.reduce(function(t,e){return t.add(e)},new Qe(0,0)).div(new Qe(n.length,n.length))}function lm(n,t,e){return Array(n).fill(0).map(function(r,a){return t+a*e})}function Xl(n){return!!n&&n!==1/0&&n!==-1/0&&!isNaN(n)||n===0}function U3(n){return Xl(n)&&0<=n&&n<=1}var Qe=(function(){function n(t,e){this._x=t,this._y=e}return Object.defineProperty(n.prototype,"x",{get:function(){return this._x},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"y",{get:function(){return this._y},enumerable:!0,configurable:!0}),n.prototype.add=function(t){return new n(this.x+t.x,this.y+t.y)},n.prototype.sub=function(t){return new n(this.x-t.x,this.y-t.y)},n.prototype.mul=function(t){return new n(this.x*t.x,this.y*t.y)},n.prototype.div=function(t){return new n(this.x/t.x,this.y/t.y)},n.prototype.abs=function(){return new n(Math.abs(this.x),Math.abs(this.y))},n.prototype.magnitude=function(){return Math.sqrt(Math.pow(this.x,2)+Math.pow(this.y,2))},n.prototype.floor=function(){return new n(Math.floor(this.x),Math.floor(this.y))},n})(),Wu=(function(){function n(t,e){e===void 0&&(e=!0);var r=t||{},a=[r.left,r.top,r.right,r.bottom].every(Xl),s=[r.x,r.y,r.width,r.height].every(Xl);if(!s&&!a)throw new Error("Box.constructor - expected box to be IBoundingBox | IRect, instead have "+JSON.stringify(r));var o=s?[r.x,r.y,r.width,r.height]:[r.left,r.top,r.right-r.left,r.bottom-r.top],i=o[0],u=o[1],l=o[2],h=o[3];n.assertIsValidBox({x:i,y:u,width:l,height:h},"Box.constructor",e),this._x=i,this._y=u,this._width=l,this._height=h}return n.isRect=function(t){return!!t&&[t.x,t.y,t.width,t.height].every(Xl)},n.assertIsValidBox=function(t,e,r){if(r===void 0&&(r=!1),!n.isRect(t))throw new Error(e+" - invalid box: "+JSON.stringify(t)+", expected object with properties x, y, width, height");if(!r&&(t.width<0||t.height<0))throw new Error(e+" - width ("+t.width+") and height ("+t.height+") must be positive numbers")},Object.defineProperty(n.prototype,"x",{get:function(){return this._x},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"y",{get:function(){return this._y},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"width",{get:function(){return this._width},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"height",{get:function(){return this._height},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"left",{get:function(){return this.x},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"top",{get:function(){return this.y},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"right",{get:function(){return this.x+this.width},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"bottom",{get:function(){return this.y+this.height},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"area",{get:function(){return this.width*this.height},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"topLeft",{get:function(){return new Qe(this.left,this.top)},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"topRight",{get:function(){return new Qe(this.right,this.top)},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"bottomLeft",{get:function(){return new Qe(this.left,this.bottom)},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"bottomRight",{get:function(){return new Qe(this.right,this.bottom)},enumerable:!0,configurable:!0}),n.prototype.round=function(){var t=[this.x,this.y,this.width,this.height].map(function(o){return Math.round(o)}),e=t[0],r=t[1],a=t[2],s=t[3];return new n({x:e,y:r,width:a,height:s})},n.prototype.floor=function(){var t=[this.x,this.y,this.width,this.height].map(function(o){return Math.floor(o)}),e=t[0],r=t[1],a=t[2],s=t[3];return new n({x:e,y:r,width:a,height:s})},n.prototype.toSquare=function(){var t=this,e=t.x,r=t.y,a=t.width,s=t.height,o=Math.abs(a-s);return a<s&&(e-=o/2,a+=o),s<a&&(r-=o/2,s+=o),new n({x:e,y:r,width:a,height:s})},n.prototype.rescale=function(t){var e=V3(t)?t.width:t,r=V3(t)?t.height:t;return new n({x:this.x*e,y:this.y*r,width:this.width*e,height:this.height*r})},n.prototype.pad=function(t,e){var r=[this.x-t/2,this.y-e/2,this.width+t,this.height+e],a=r[0],s=r[1],o=r[2],i=r[3];return new n({x:a,y:s,width:o,height:i})},n.prototype.clipAtImageBorders=function(t,e){var r=this,a=r.x,s=r.y,o=r.right,i=r.bottom,u=Math.max(a,0),l=Math.max(s,0),h=o-u,d=i-l,f=Math.min(h,t-u),m=Math.min(d,e-l);return new n({x:u,y:l,width:f,height:m}).floor()},n.prototype.shift=function(t,e){var r=this,a=r.width,s=r.height,o=this.x+t,i=this.y+e;return new n({x:o,y:i,width:a,height:s})},n.prototype.padAtBorders=function(t,e){var r=this.width+1,a=this.height+1,s=1,o=1,i=r,u=a,l=this.left,h=this.top,d=this.right,f=this.bottom;return d>e&&(i=-d+e+r,d=e),f>t&&(u=-f+t+a,f=t),l<1&&(u=2-l,l=1),h<1&&(u=2-h,h=1),{dy:o,edy:u,dx:s,edx:i,y:h,ey:f,x:l,ex:d,w:r,h:a}},n.prototype.calibrate=function(t){return new n({left:this.left+t.left*this.width,top:this.top+t.top*this.height,right:this.right+t.right*this.width,bottom:this.bottom+t.bottom*this.height}).toSquare().round()},n})(),W1=(function(n){ve(t,n);function t(e,r,a,s,o){return o===void 0&&(o=!1),n.call(this,{left:e,top:r,right:a,bottom:s},o)||this}return t})(Wu),uP=(function(){function n(t,e,r,a,s){this._imageDims=new Wh(s.width,s.height),this._score=t,this._classScore=e,this._className=r,this._box=new Wu(a).rescale(this._imageDims)}return Object.defineProperty(n.prototype,"score",{get:function(){return this._score},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"classScore",{get:function(){return this._classScore},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"className",{get:function(){return this._className},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"box",{get:function(){return this._box},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"imageDims",{get:function(){return this._imageDims},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"imageWidth",{get:function(){return this.imageDims.width},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"imageHeight",{get:function(){return this.imageDims.height},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"relativeBox",{get:function(){return new Wu(this._box).rescale(this.imageDims.reverse())},enumerable:!0,configurable:!0}),n.prototype.forSize=function(t,e){return new n(this.score,this.classScore,this.className,this.relativeBox,{width:t,height:e})},n})(),Zo=(function(n){ve(t,n);function t(e,r,a){return n.call(this,e,e,"",r,a)||this}return t.prototype.forSize=function(e,r){var a=n.prototype.forSize.call(this,e,r),s=a.score,o=a.relativeBox,i=a.imageDims;return new t(s,o,i)},t})(uP);function Xit(n,t,e){e===void 0&&(e=!0);var r=Math.max(0,Math.min(n.right,t.right)-Math.max(n.left,t.left)),a=Math.max(0,Math.min(n.bottom,t.bottom)-Math.max(n.top,t.top)),s=r*a;return e?s/(n.area+t.area-s):s/Math.min(n.area,t.area)}function Yit(n){var t=n.map(function(i){return i.x}),e=n.map(function(i){return i.y}),r=t.reduce(function(i,u){return u<i?u:i},1/0),a=e.reduce(function(i,u){return u<i?u:i},1/0),s=t.reduce(function(i,u){return i<u?u:i},0),o=e.reduce(function(i,u){return i<u?u:i},0);return new W1(r,a,s,o)}function cm(n,t,e,r){r===void 0&&(r=!0);for(var a=t.map(function(i,u){return{score:i,boxIndex:u}}).sort(function(i,u){return i.score-u.score}).map(function(i){return i.boxIndex}),s=[],o=function(){var i=a.pop();s.push(i);for(var u=a,l=[],h=0;h<u.length;h++){var d=u[h],f=n[i],m=n[d];l.push(Xit(f,m,r))}a=a.filter(function(v,y){return l[y]<=e})};a.length>0;)o();return s}function ev(n,t){return Gt(function(){var e=t[0],r=t[1],a=t[2],s=Bo(Uf(n.shape.slice(0,3),[1]),e),o=Bo(Uf(n.shape.slice(0,3),[1]),r),i=Bo(Uf(n.shape.slice(0,3),[1]),a),u=yr([s,o,i],3);return Cr(n,u)})}function Qit(n,t){return t===void 0&&(t=!1),Gt(function(){var e=n.shape.slice(1),r=e[0],a=e[1];if(r===a)return n;var s=Math.abs(r-a),o=Math.round(s*(t?.5:1)),i=r>a?2:1,u=function(m){var v=n.shape.slice();return v[i]=m,Bo(v,0)},l=u(o),h=s-l.shape[i],d=t&&h?u(h):null,f=[d,n,l].filter(function(m){return!!m}).map(function(m){return m.toFloat()});return yr(f,i)})}function mC(n){return 1/(1+Math.exp(-n))}var hI=(function(n){ve(t,n);function t(e,r,a,s,o){return o===void 0&&(o=!1),n.call(this,{x:e,y:r,width:a,height:s},o)||this}return t})(Wu),Zit=.5,Jit=.43,tut=.45,cb=(function(){function n(t,e,r){r===void 0&&(r=new Qe(0,0));var a=e.width,s=e.height;this._imgDims=new Wh(a,s),this._shift=r,this._positions=t.map(function(o){return o.mul(new Qe(a,s)).add(r)})}return Object.defineProperty(n.prototype,"shift",{get:function(){return new Qe(this._shift.x,this._shift.y)},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"imageWidth",{get:function(){return this._imgDims.width},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"imageHeight",{get:function(){return this._imgDims.height},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"positions",{get:function(){return this._positions},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"relativePositions",{get:function(){var t=this;return this._positions.map(function(e){return e.sub(t._shift).div(new Qe(t.imageWidth,t.imageHeight))})},enumerable:!0,configurable:!0}),n.prototype.forSize=function(t,e){return new this.constructor(this.relativePositions,{width:t,height:e})},n.prototype.shiftBy=function(t,e){return new this.constructor(this.relativePositions,this._imgDims,new Qe(t,e))},n.prototype.shiftByPoint=function(t){return this.shiftBy(t.x,t.y)},n.prototype.align=function(t,e){if(e===void 0&&(e={}),t){var r=t instanceof Zo?t.box.floor():new Wu(t);return this.shiftBy(r.x,r.y).align(null,e)}var a=Object.assign({},{useDlibAlignment:!1,minBoxPadding:.2},e),s=a.useDlibAlignment,o=a.minBoxPadding;return s?this.alignDlib():this.alignMinBbox(o)},n.prototype.alignDlib=function(){var t=this.getRefPointsForAlignment(),e=t[0],r=t[1],a=t[2],s=function(d){return a.sub(d).magnitude()},o=(s(e)+s(r))/2,i=Math.floor(o/tut),u=cI(t),l=Math.floor(Math.max(0,u.x-Zit*i)),h=Math.floor(Math.max(0,u.y-Jit*i));return new hI(l,h,Math.min(i,this.imageWidth+l),Math.min(i,this.imageHeight+h))},n.prototype.alignMinBbox=function(t){var e=Yit(this.positions);return e.pad(e.width*t,e.height*t)},n.prototype.getRefPointsForAlignment=function(){throw new Error("getRefPointsForAlignment not implemented by base class")},n})(),eut=(function(n){ve(t,n);function t(){return n!==null&&n.apply(this,arguments)||this}return t.prototype.getRefPointsForAlignment=function(){var e=this.positions;return[e[0],e[1],cI([e[3],e[4]])]},t})(cb),nut=(function(n){ve(t,n);function t(){return n!==null&&n.apply(this,arguments)||this}return t.prototype.getJawOutline=function(){return this.positions.slice(0,17)},t.prototype.getLeftEyeBrow=function(){return this.positions.slice(17,22)},t.prototype.getRightEyeBrow=function(){return this.positions.slice(22,27)},t.prototype.getNose=function(){return this.positions.slice(27,36)},t.prototype.getLeftEye=function(){return this.positions.slice(36,42)},t.prototype.getRightEye=function(){return this.positions.slice(42,48)},t.prototype.getMouth=function(){return this.positions.slice(48,68)},t.prototype.getRefPointsForAlignment=function(){return[this.getLeftEye(),this.getRightEye(),this.getMouth()].map(cI)},t})(cb),W3=(function(){function n(t,e){this._label=t,this._distance=e}return Object.defineProperty(n.prototype,"label",{get:function(){return this._label},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"distance",{get:function(){return this._distance},enumerable:!0,configurable:!0}),n.prototype.toString=function(t){return t===void 0&&(t=!0),""+this.label+(t?" ("+qit(this.distance)+")":"")},n})(),G3=(function(n){ve(t,n);function t(e,r){var a=n.call(this,e)||this;return a._label=r,a}return t.assertIsValidLabeledBox=function(e,r){if(Wu.assertIsValidBox(e,r),!Xl(e.label))throw new Error(r+" - expected property label ("+e.label+") to be a number")},Object.defineProperty(t.prototype,"label",{get:function(){return this._label},enumerable:!0,configurable:!0}),t})(Wu),t0=(function(){function n(t,e){if(typeof t!="string")throw new Error("LabeledFaceDescriptors - constructor expected label to be a string");if(!Array.isArray(e)||e.some(function(r){return!(r instanceof Float32Array)}))throw new Error("LabeledFaceDescriptors - constructor expected descriptors to be an array of Float32Array");this._label=t,this._descriptors=e}return Object.defineProperty(n.prototype,"label",{get:function(){return this._label},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"descriptors",{get:function(){return this._descriptors},enumerable:!0,configurable:!0}),n.prototype.toJSON=function(){return{label:this.label,descriptors:this.descriptors.map(function(t){return Array.from(t)})}},n.fromJSON=function(t){var e=t.descriptors.map(function(r){return new Float32Array(r)});return new n(t.label,e)},n})();(function(n){ve(t,n);function t(e,r,a,s){var o=n.call(this,e,r)||this;return o._score=a,o._classScore=s,o}return t.assertIsValidPredictedBox=function(e,r){if(G3.assertIsValidLabeledBox(e,r),!U3(e.score)||!U3(e.classScore))throw new Error(r+" - expected properties score ("+e.score+") and ("+e.classScore+") to be a number between [0, 1]")},Object.defineProperty(t.prototype,"score",{get:function(){return this._score},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"classScore",{get:function(){return this._classScore},enumerable:!0,configurable:!0}),t})(G3);function rut(n){return n.detection instanceof Zo}function dI(n,t){var e={detection:t};return Object.assign({},n,e)}function lP(){var n=window.fetch||function(){throw new Error("fetch - missing fetch implementation for browser environment")},t=function(){throw new Error("readFile - filesystem not available for browser environment")};return{Canvas:HTMLCanvasElement,CanvasRenderingContext2D,Image:HTMLImageElement,ImageData,Video:HTMLVideoElement,createCanvasElement:function(){return document.createElement("canvas")},createImageElement:function(){return document.createElement("img")},fetch:n,readFile:t}}function cP(n){var t="";if(!n)try{n=require("fs")}catch(r){t=r.toString()}var e=n?function(r){return new Promise(function(a,s){n.readFile(r,function(o,i){return o?s(o):a(i)})})}:function(){throw new Error("readFile - failed to require fs in nodejs environment with error: "+t)};return{readFile:e}}function hP(){var n=global.Canvas||global.HTMLCanvasElement,t=global.Image||global.HTMLImageElement,e=function(){if(n)return new n;throw new Error("createCanvasElement - missing Canvas implementation for nodejs environment")},r=function(){if(t)return new t;throw new Error("createImageElement - missing Image implementation for nodejs environment")},a=global.fetch||function(){throw new Error("fetch - missing fetch implementation for nodejs environment")},s=cP();return oa({Canvas:n||(function(){function o(){}return o})(),CanvasRenderingContext2D:global.CanvasRenderingContext2D||(function(){function o(){}return o})(),Image:t||(function(){function o(){}return o})(),ImageData:global.ImageData||(function(){function o(){}return o})(),Video:global.HTMLVideoElement||(function(){function o(){}return o})(),createCanvasElement:e,createImageElement:r,fetch:a},s)}function dP(){return typeof window=="object"&&typeof document<"u"&&typeof HTMLImageElement<"u"&&typeof HTMLCanvasElement<"u"&&typeof HTMLVideoElement<"u"&&typeof ImageData<"u"&&typeof CanvasRenderingContext2D<"u"}function pP(){return typeof global=="object"&&typeof require=="function"&&typeof pH<"u"&&typeof process<"u"&&!!process.version}var fr;function aut(){if(!fr)throw new Error("getEnv - environment is not defined, check isNodejs() and isBrowser()");return fr}function nk(n){fr=n}function pI(){dP()&&nk(lP()),pP()&&nk(hP())}function sut(n){if(fr||pI(),!fr)throw new Error("monkeyPatch - environment is not defined, check isNodejs() and isBrowser()");var t=n.Canvas,e=t===void 0?fr.Canvas:t,r=n.Image,a=r===void 0?fr.Image:r;fr.Canvas=e,fr.Image=a,fr.createCanvasElement=n.createCanvasElement||(function(){return new e}),fr.createImageElement=n.createImageElement||(function(){return new a}),fr.ImageData=n.ImageData||fr.ImageData,fr.Video=n.Video||fr.Video,fr.fetch=n.fetch||fr.fetch,fr.readFile=n.readFile||fr.readFile}var pa={getEnv:aut,setEnv:nk,initialize:pI,createBrowserEnv:lP,createFileSystem:cP,createNodejsEnv:hP,monkeyPatch:sut,isBrowser:dP,isNodejs:pP};pI();function fP(n){return!pa.isNodejs()&&typeof n=="string"?document.getElementById(n):n}function lc(n){var t=pa.getEnv(),e=t.Canvas,r=t.CanvasRenderingContext2D;if(n instanceof r)return n;var a=fP(n);if(!(a instanceof e))throw new Error("resolveContext2d - expected canvas to be of instance of Canvas");var s=a.getContext("2d");if(!s)throw new Error("resolveContext2d - canvas 2d context is null");return s}var H3;(function(n){n.TOP_LEFT="TOP_LEFT",n.TOP_RIGHT="TOP_RIGHT",n.BOTTOM_LEFT="BOTTOM_LEFT",n.BOTTOM_RIGHT="BOTTOM_RIGHT"})(H3||(H3={}));function mP(n){var t=pa.getEnv(),e=t.Image,r=t.Video;return n instanceof e&&n.complete||n instanceof r&&n.readyState>=3}function out(n){return new Promise(function(t,e){if(n instanceof pa.getEnv().Canvas||mP(n))return t();function r(s){s.currentTarget&&(s.currentTarget.removeEventListener("load",r),s.currentTarget.removeEventListener("error",a),t(s))}function a(s){s.currentTarget&&(s.currentTarget.removeEventListener("load",r),s.currentTarget.removeEventListener("error",a),e(s))}n.addEventListener("load",r),n.addEventListener("error",a)})}function gP(n){var t=pa.getEnv(),e=t.Image,r=t.Video;return n instanceof e?new Wh(n.naturalWidth,n.naturalHeight):n instanceof r?new Wh(n.videoWidth,n.videoHeight):new Wh(n.width,n.height)}function G1(n){var t=n.width,e=n.height,r=pa.getEnv().createCanvasElement,a=r();return a.width=t,a.height=e,a}function fI(n,t){var e=pa.getEnv().ImageData;if(!(n instanceof e)&&!mP(n))throw new Error("createCanvasFromMedia - media has not finished loading yet");var r=gP(n),a=r.width,s=r.height,o=G1({width:a,height:s});return n instanceof e?lc(o).putImageData(n,0,0):lc(o).drawImage(n,0,0,a,s),o}function iut(n,t){return re(this,void 0,void 0,function(){var e,r,a,s,o,i;return ae(this,function(u){switch(u.label){case 0:return e=pa.getEnv().createCanvasElement(),r=n.shape.slice(Au(n)?1:0),a=r[0],s=r[1],o=r[2],i=Gt(function(){return n.as3D(a,s,o).toInt()}),[4,lI.toPixels(i,e)];case 1:return u.sent(),i.dispose(),[2,e]}})})}function j3(n){var t=pa.getEnv(),e=t.Image,r=t.Canvas,a=t.Video;return n instanceof e||n instanceof r||n instanceof a}function uut(n,t,e){e===void 0&&(e=!1);var r=pa.getEnv(),a=r.Image,s=r.Canvas;if(!(n instanceof a||n instanceof s))throw new Error("imageToSquare - expected arg0 to be HTMLImageElement | HTMLCanvasElement");var o=gP(n),i=t/Math.max(o.height,o.width),u=i*o.width,l=i*o.height,h=G1({width:t,height:t}),d=n instanceof s?n:fI(n),f=Math.abs(u-l)/2,m=e&&u<l?f:0,v=e&&l<u?f:0;return lc(h).drawImage(d,m,v,u,l),h}var hb=(function(){function n(t,e){var r=this;if(e===void 0&&(e=!1),this._imageTensors=[],this._canvases=[],this._treatAsBatchInput=!1,this._inputDimensions=[],!Array.isArray(t))throw new Error("NetInput.constructor - expected inputs to be an Array of TResolvedNetInput or to be instanceof tf.Tensor4D, instead have "+t);this._treatAsBatchInput=e,this._batchSize=t.length,t.forEach(function(a,s){if(U1(a)){r._imageTensors[s]=a,r._inputDimensions[s]=a.shape;return}if(Au(a)){var o=a.shape[0];if(o!==1)throw new Error("NetInput - tf.Tensor4D with batchSize "+o+" passed, but not supported in input array");r._imageTensors[s]=a,r._inputDimensions[s]=a.shape.slice(1);return}var i=a instanceof pa.getEnv().Canvas?a:fI(a);r._canvases[s]=i,r._inputDimensions[s]=[i.height,i.width,3]})}return Object.defineProperty(n.prototype,"imageTensors",{get:function(){return this._imageTensors},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"canvases",{get:function(){return this._canvases},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"isBatchInput",{get:function(){return this.batchSize>1||this._treatAsBatchInput},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"batchSize",{get:function(){return this._batchSize},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"inputDimensions",{get:function(){return this._inputDimensions},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"inputSize",{get:function(){return this._inputSize},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"reshapedInputDimensions",{get:function(){var t=this;return lm(this.batchSize,0,1).map(function(e,r){return t.getReshapedInputDimensions(r)})},enumerable:!0,configurable:!0}),n.prototype.getInput=function(t){return this.canvases[t]||this.imageTensors[t]},n.prototype.getInputDimensions=function(t){return this._inputDimensions[t]},n.prototype.getInputHeight=function(t){return this._inputDimensions[t][0]},n.prototype.getInputWidth=function(t){return this._inputDimensions[t][1]},n.prototype.getReshapedInputDimensions=function(t){if(typeof this.inputSize!="number")throw new Error("getReshapedInputDimensions - inputSize not set, toBatchTensor has not been called yet");var e=this.getInputWidth(t),r=this.getInputHeight(t);return Kit({width:e,height:r},this.inputSize)},n.prototype.toBatchTensor=function(t,e){var r=this;return e===void 0&&(e=!0),this._inputSize=t,Gt(function(){var a=lm(r.batchSize,0,1).map(function(o){var i=r.getInput(o);if(i instanceof $n){var u=Au(i)?i:i.expandDims();return u=Qit(u,e),(u.shape[1]!==t||u.shape[2]!==t)&&(u=rI.resizeBilinear(u,[t,t])),u.as3D(t,t,3)}if(i instanceof pa.getEnv().Canvas)return lI.fromPixels(uut(i,t,e));throw new Error("toBatchTensor - at batchIdx "+o+", expected input to be instanceof tf.Tensor or instanceof HTMLCanvasElement, instead have "+i)}),s=ys(a.map(function(o){return o.toFloat()})).as4D(r.batchSize,t,t,3);return s})},n})();function Lr(n){return re(this,void 0,void 0,function(){var t,e,r;return ae(this,function(a){switch(a.label){case 0:if(n instanceof hb)return[2,n];if(t=Array.isArray(n)?n:[n],!t.length)throw new Error("toNetInput - empty array passed as input");return e=function(s){return Array.isArray(n)?" at input index "+s+":":""},r=t.map(fP),r.forEach(function(s,o){if(!j3(s)&&!U1(s)&&!Au(s))throw typeof t[o]=="string"?new Error("toNetInput -"+e(o)+" string passed, but could not resolve HTMLElement for element id "+t[o]):new Error("toNetInput -"+e(o)+" expected media to be of type HTMLImageElement | HTMLVideoElement | HTMLCanvasElement | tf.Tensor3D, or to be an element id");if(Au(s)){var i=s.shape[0];if(i!==1)throw new Error("toNetInput -"+e(o)+" tf.Tensor4D with batchSize "+i+" passed, but not supported in input array")}}),[4,Promise.all(r.map(function(s){return j3(s)&&out(s)}))];case 1:return a.sent(),[2,new hb(r,Array.isArray(n))]}})})}function mI(n,t){return re(this,void 0,void 0,function(){var e,r,a,s,o,i,u;return ae(this,function(l){switch(l.label){case 0:return e=pa.getEnv().Canvas,r=n,n instanceof e?[3,5]:[4,Lr(n)];case 1:if(a=l.sent(),a.batchSize>1)throw new Error("extractFaces - batchSize > 1 not supported");return s=a.getInput(0),s instanceof e?(o=s,[3,4]):[3,2];case 2:return[4,iut(s)];case 3:o=l.sent(),l.label=4;case 4:r=o,l.label=5;case 5:return i=lc(r),u=t.map(function(h){return h instanceof Zo?h.forSize(r.width,r.height).box.floor():h}).map(function(h){return h.clipAtImageBorders(r.width,r.height)}),[2,u.map(function(h){var d=h.x,f=h.y,m=h.width,v=h.height,y=G1({width:m,height:v});return lc(y).putImageData(i.getImageData(d,f,m,v),0,0),y})]}})})}function gI(n,t){return re(this,void 0,void 0,function(){return ae(this,function(e){if(!U1(n)&&!Au(n))throw new Error("extractFaceTensors - expected image tensor to be 3D or 4D");if(Au(n)&&n.shape[0]>1)throw new Error("extractFaceTensors - batchSize > 1 not supported");return[2,Gt(function(){var r=n.shape.slice(Au(n)?1:0),a=r[0],s=r[1],o=r[2],i=t.map(function(l){return l instanceof Zo?l.forSize(s,a).box:l}).map(function(l){return l.clipAtImageBorders(s,a)}),u=i.map(function(l){var h=l.x,d=l.y,f=l.width,m=l.height;return Wz(n.as3D(a,s,o),[d,h,0],[m,f,o])});return u})]})})}function lut(n,t){return re(this,void 0,void 0,function(){var e,r;return ae(this,function(a){switch(a.label){case 0:return e=pa.getEnv().fetch,[4,e(n,t)];case 1:if(r=a.sent(),!(r.status<400))throw new Error("failed to fetch: ("+r.status+") "+r.statusText+", from url: "+r.url);return[2,r]}})})}function cut(n){return re(this,void 0,void 0,function(){return ae(this,function(t){switch(t.label){case 0:return[4,lut(n)];case 1:return[2,t.sent().json()]}})})}function vP(n,t){var e=t+"-weights_manifest.json";if(!n)return{modelBaseUri:"",manifestUri:e};if(n==="/")return{modelBaseUri:"/",manifestUri:"/"+e};var r=n.startsWith("http://")?"http://":n.startsWith("https://")?"https://":"";n=n.replace(r,"");var a=n.split("/").filter(function(i){return i}),s=n.endsWith(".json")?a[a.length-1]:e,o=r+(n.endsWith(".json")?a.slice(0,a.length-1):a).join("/");return o=n.startsWith("/")?"/"+o:o,{modelBaseUri:o,manifestUri:o==="/"?"/"+s:o+"/"+s}}function hut(n,t){return re(this,void 0,void 0,function(){var e,r,a,s;return ae(this,function(o){switch(o.label){case 0:return e=vP(n,t),r=e.manifestUri,a=e.modelBaseUri,[4,cut(r)];case 1:return s=o.sent(),[2,oP.loadWeights(s,a)]}})})}var Hi=(function(){function n(t){this._name=t,this._params=void 0,this._paramMappings=[]}return Object.defineProperty(n.prototype,"params",{get:function(){return this._params},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"paramMappings",{get:function(){return this._paramMappings},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"isLoaded",{get:function(){return!!this.params},enumerable:!0,configurable:!0}),n.prototype.getParamFromPath=function(t){var e=this.traversePropertyPath(t),r=e.obj,a=e.objProp;return r[a]},n.prototype.reassignParamFromPath=function(t,e){var r=this.traversePropertyPath(t),a=r.obj,s=r.objProp;a[s].dispose(),a[s]=e},n.prototype.getParamList=function(){var t=this;return this._paramMappings.map(function(e){var r=e.paramPath;return{path:r,tensor:t.getParamFromPath(r)}})},n.prototype.getTrainableParams=function(){return this.getParamList().filter(function(t){return t.tensor instanceof nd})},n.prototype.getFrozenParams=function(){return this.getParamList().filter(function(t){return!(t.tensor instanceof nd)})},n.prototype.variable=function(){var t=this;this.getFrozenParams().forEach(function(e){var r=e.path,a=e.tensor;t.reassignParamFromPath(r,a.variable())})},n.prototype.freeze=function(){var t=this;this.getTrainableParams().forEach(function(e){var r=e.path,a=e.tensor,s=Zr(a.dataSync());a.dispose(),t.reassignParamFromPath(r,s)})},n.prototype.dispose=function(t){t===void 0&&(t=!0),this.getParamList().forEach(function(e){if(t&&e.tensor.isDisposed)throw new Error("param tensor has already been disposed for path "+e.path);e.tensor.dispose()}),this._params=void 0},n.prototype.serializeParams=function(){return new Float32Array(this.getParamList().map(function(t){var e=t.tensor;return Array.from(e.dataSync())}).reduce(function(t,e){return t.concat(e)}))},n.prototype.load=function(t){return re(this,void 0,void 0,function(){return ae(this,function(e){switch(e.label){case 0:return t instanceof Float32Array?(this.extractWeights(t),[2]):[4,this.loadFromUri(t)];case 1:return e.sent(),[2]}})})},n.prototype.loadFromUri=function(t){return re(this,void 0,void 0,function(){var e;return ae(this,function(r){switch(r.label){case 0:if(t&&typeof t!="string")throw new Error(this._name+".loadFromUri - expected model uri");return[4,hut(t,this.getDefaultModelName())];case 1:return e=r.sent(),this.loadFromWeightMap(e),[2]}})})},n.prototype.loadFromDisk=function(t){return re(this,void 0,void 0,function(){var e,r,a,s,o,i,u,l,h,d;return ae(this,function(f){switch(f.label){case 0:if(t&&typeof t!="string")throw new Error(this._name+".loadFromDisk - expected model file path");return e=pa.getEnv().readFile,r=vP(t,this.getDefaultModelName()),a=r.manifestUri,s=r.modelBaseUri,o=function(m){return Promise.all(m.map(function(v){return e(v).then(function(y){return y.buffer})}))},i=oP.weightsLoaderFactory(o),h=(l=JSON).parse,[4,e(a)];case 1:return u=h.apply(l,[f.sent().toString()]),[4,i(u,s)];case 2:return d=f.sent(),this.loadFromWeightMap(d),[2]}})})},n.prototype.loadFromWeightMap=function(t){var e=this.extractParamsFromWeigthMap(t),r=e.paramMappings,a=e.params;this._paramMappings=r,this._params=a},n.prototype.extractWeights=function(t){var e=this.extractParams(t),r=e.paramMappings,a=e.params;this._paramMappings=r,this._params=a},n.prototype.traversePropertyPath=function(t){if(!this.params)throw new Error("traversePropertyPath - model has no loaded params");var e=t.split("/").reduce(function(s,o){if(!s.nextObj.hasOwnProperty(o))throw new Error("traversePropertyPath - object does not have property "+o+", for path "+t);return{obj:s.nextObj,objProp:o,nextObj:s.nextObj[o]}},{nextObj:this.params}),r=e.obj,a=e.objProp;if(!r||!a||!(r[a]instanceof $n))throw new Error("traversePropertyPath - parameter is not a tensor, for path "+t);return{obj:r,objProp:a}},n})();function ds(n,t,e){return Gt(function(){var r=ZE(n,t.depthwise_filter,t.pointwise_filter,e,"same");return r=$e(r,t.bias),r})}function gC(n,t,e){return e===void 0&&(e=!1),Gt(function(){var r=Fn(e?$e(Us(n,t.conv0.filters,[2,2],"same"),t.conv0.bias):ds(n,t.conv0,[2,2])),a=ds(r,t.conv1,[1,1]),s=Fn($e(r,a)),o=ds(s,t.conv2,[1,1]);return Fn($e(r,$e(a,o)))})}function e0(n,t,e,r){return e===void 0&&(e=!1),r===void 0&&(r=!0),Gt(function(){var a=Fn(e?$e(Us(n,t.conv0.filters,r?[2,2]:[1,1],"same"),t.conv0.bias):ds(n,t.conv0,r?[2,2]:[1,1])),s=ds(a,t.conv1,[1,1]),o=Fn($e(a,s)),i=ds(o,t.conv2,[1,1]),u=Fn($e(a,$e(s,i))),l=ds(u,t.conv3,[1,1]);return Fn($e(a,$e(s,$e(i,l))))})}function no(n,t,e,r){return e===void 0&&(e="same"),r===void 0&&(r=!1),Gt(function(){var a=$e(Us(n,t.filters,[1,1],e),t.bias);return r?Fn(a):a})}function ji(n,t){Object.keys(n).forEach(function(e){t.some(function(r){return r.originalPath===e})||n[e].dispose()})}function H1(n,t){return function(e,r,a,s){var o=Ba(n(e*r*a*a),[a,a,e,r]),i=rr(n(r));return t.push({paramPath:s+"/filters"},{paramPath:s+"/bias"}),{filters:o,bias:i}}}function vI(n,t){return function(e,r,a){var s=_u(n(e*r),[e,r]),o=rr(n(r));return t.push({paramPath:a+"/weights"},{paramPath:a+"/bias"}),{weights:s,bias:o}}}var yP=(function(){function n(t,e,r){this.depthwise_filter=t,this.pointwise_filter=e,this.bias=r}return n})();function yI(n,t){return function(e,r,a){var s=Ba(n(9*e),[3,3,e,1]),o=Ba(n(e*r),[1,1,e,r]),i=rr(n(r));return t.push({paramPath:a+"/depthwise_filter"},{paramPath:a+"/pointwise_filter"},{paramPath:a+"/bias"}),new yP(s,o,i)}}function bI(n){return function(t){var e=n(t+"/depthwise_filter",4),r=n(t+"/pointwise_filter",4),a=n(t+"/bias",1);return new yP(e,r,a)}}function sl(n,t){return function(e,r,a){var s=n[e];if(!V1(s,r))throw new Error("expected weightMap["+e+"] to be a Tensor"+r+"D, instead have "+s);return t.push({originalPath:e,paramPath:a||e}),s}}function qi(n){var t=n;function e(a){var s=t.slice(0,a);return t=t.slice(a),s}function r(){return t}return{extractWeights:e,getRemainingWeights:r}}function bP(n,t){var e=H1(n,t),r=yI(n,t);function a(o,i,u,l){l===void 0&&(l=!1);var h=l?e(o,i,3,u+"/conv0"):r(o,i,u+"/conv0"),d=r(i,i,u+"/conv1"),f=r(i,i,u+"/conv2");return{conv0:h,conv1:d,conv2:f}}function s(o,i,u,l){l===void 0&&(l=!1);var h=a(o,i,u,l),d=h.conv0,f=h.conv1,m=h.conv2,v=r(i,i,u+"/conv3");return{conv0:d,conv1:f,conv2:m,conv3:v}}return{extractDenseBlock3Params:a,extractDenseBlock4Params:s}}function dut(n){var t=[],e=qi(n),r=e.extractWeights,a=e.getRemainingWeights,s=bP(r,t).extractDenseBlock4Params,o=s(3,32,"dense0",!0),i=s(32,64,"dense1"),u=s(64,128,"dense2"),l=s(128,256,"dense3");if(a().length!==0)throw new Error("weights remaing after extract: "+a().length);return{paramMappings:t,params:{dense0:o,dense1:i,dense2:u,dense3:l}}}function xP(n){return function(t){var e=n(t+"/filters",4),r=n(t+"/bias",1);return{filters:e,bias:r}}}function wP(n,t){var e=sl(n,t),r=xP(e),a=bI(e);function s(i,u){u===void 0&&(u=!1);var l=u?r(i+"/conv0"):a(i+"/conv0"),h=a(i+"/conv1"),d=a(i+"/conv2");return{conv0:l,conv1:h,conv2:d}}function o(i,u){u===void 0&&(u=!1);var l=u?r(i+"/conv0"):a(i+"/conv0"),h=a(i+"/conv1"),d=a(i+"/conv2"),f=a(i+"/conv3");return{conv0:l,conv1:h,conv2:d,conv3:f}}return{extractDenseBlock3Params:s,extractDenseBlock4Params:o}}function put(n){var t=[],e=wP(n,t).extractDenseBlock4Params,r={dense0:e("dense0",!0),dense1:e("dense1"),dense2:e("dense2"),dense3:e("dense3")};return ji(n,t),{params:r,paramMappings:t}}var SP=(function(n){ve(t,n);function t(){return n.call(this,"FaceFeatureExtractor")||this}return t.prototype.forwardInput=function(e){var r=this.params;if(!r)throw new Error("FaceFeatureExtractor - load model before inference");return Gt(function(){var a=e.toBatchTensor(112,!0),s=[122.782,117.001,104.298],o=ev(a,s).div(Pt(255)),i=e0(o,r.dense0,!0);return i=e0(i,r.dense1),i=e0(i,r.dense2),i=e0(i,r.dense3),i=Jg(i,[7,7],[2,2],"valid"),i})},t.prototype.forward=function(e){return re(this,void 0,void 0,function(){var r;return ae(this,function(a){switch(a.label){case 0:return r=this.forwardInput,[4,Lr(e)];case 1:return[2,r.apply(this,[a.sent()])]}})})},t.prototype.getDefaultModelName=function(){return"face_feature_extractor_model"},t.prototype.extractParamsFromWeigthMap=function(e){return put(e)},t.prototype.extractParams=function(e){return dut(e)},t})(Hi);function Ao(n,t){return Gt(function(){return $e(B1(n,t.weights),t.bias)})}function fut(n,t,e){var r=[],a=qi(n),s=a.extractWeights,o=a.getRemainingWeights,i=vI(s,r),u=i(t,e,"fc");if(o().length!==0)throw new Error("weights remaing after extract: "+o().length);return{paramMappings:r,params:{fc:u}}}function mut(n){var t=[],e=sl(n,t);function r(s){var o=e(s+"/weights",2),i=e(s+"/bias",1);return{weights:o,bias:i}}var a={fc:r("fc")};return ji(n,t),{params:a,paramMappings:t}}function CP(n){var t={},e={};return Object.keys(n).forEach(function(r){var a=r.startsWith("fc")?e:t;a[r]=n[r]}),{featureExtractorMap:t,classifierMap:e}}var NP=(function(n){ve(t,n);function t(e,r){var a=n.call(this,e)||this;return a._faceFeatureExtractor=r,a}return Object.defineProperty(t.prototype,"faceFeatureExtractor",{get:function(){return this._faceFeatureExtractor},enumerable:!0,configurable:!0}),t.prototype.runNet=function(e){var r=this,a=this.params;if(!a)throw new Error(this._name+" - load model before inference");return Gt(function(){var s=e instanceof hb?r.faceFeatureExtractor.forwardInput(e):e;return Ao(s.as2D(s.shape[0],-1),a.fc)})},t.prototype.dispose=function(e){e===void 0&&(e=!0),this.faceFeatureExtractor.dispose(e),n.prototype.dispose.call(this,e)},t.prototype.loadClassifierParams=function(e){var r=this.extractClassifierParams(e),a=r.params,s=r.paramMappings;this._params=a,this._paramMappings=s},t.prototype.extractClassifierParams=function(e){return fut(e,this.getClassifierChannelsIn(),this.getClassifierChannelsOut())},t.prototype.extractParamsFromWeigthMap=function(e){var r=CP(e),a=r.featureExtractorMap,s=r.classifierMap;return this.faceFeatureExtractor.loadFromWeightMap(a),mut(s)},t.prototype.extractParams=function(e){var r=this.getClassifierChannelsIn(),a=this.getClassifierChannelsOut(),s=a*r+a,o=e.slice(0,e.length-s),i=e.slice(e.length-s);return this.faceFeatureExtractor.extractWeights(o),this.extractClassifierParams(i)},t})(Hi),q3=["neutral","happy","sad","angry","fearful","disgusted","surprised"],gut=(function(){function n(t){var e=this;if(t.length!==7)throw new Error("FaceExpressions.constructor - expected probabilities.length to be 7, have: "+t.length);q3.forEach(function(r,a){e[r]=t[a]})}return n.prototype.asSortedArray=function(){var t=this;return q3.map(function(e){return{expression:e,probability:t[e]}}).sort(function(e,r){return r.probability-e.probability})},n})(),vut=(function(n){ve(t,n);function t(e){return e===void 0&&(e=new SP),n.call(this,"FaceExpressionNet",e)||this}return t.prototype.forwardInput=function(e){var r=this;return Gt(function(){return Wi(r.runNet(e))})},t.prototype.forward=function(e){return re(this,void 0,void 0,function(){var r;return ae(this,function(a){switch(a.label){case 0:return r=this.forwardInput,[4,Lr(e)];case 1:return[2,r.apply(this,[a.sent()])]}})})},t.prototype.predictExpressions=function(e){return re(this,void 0,void 0,function(){var r,a,s,o,i=this;return ae(this,function(u){switch(u.label){case 0:return[4,Lr(e)];case 1:return r=u.sent(),[4,this.forwardInput(r)];case 2:return a=u.sent(),[4,Promise.all(br(a).map(function(l){return re(i,void 0,void 0,function(){var h;return ae(this,function(d){switch(d.label){case 0:return[4,l.data()];case 1:return h=d.sent(),l.dispose(),[2,h]}})})}))];case 3:return s=u.sent(),a.dispose(),o=s.map(function(l){return new gut(l)}),[2,r.isBatchInput?o:o[0]]}})})},t.prototype.getDefaultModelName=function(){return"face_expression_model"},t.prototype.getClassifierChannelsIn=function(){return 256},t.prototype.getClassifierChannelsOut=function(){return 7},t})(NP);function kP(n,t){var e={expressions:t};return Object.assign({},n,e)}function yut(n){return rut(n)&&n.landmarks instanceof cb&&n.unshiftedLandmarks instanceof cb&&n.alignedRect instanceof Zo}function xI(n,t){var e=n.detection.box,r=t.shiftBy(e.x,e.y),a=r.align(),s=n.detection.imageDims,o=new Zo(n.detection.score,a.rescale(s.reverse()),s),i={landmarks:r,unshiftedLandmarks:t,alignedRect:o};return Object.assign({},n,i)}function but(n,t){var e=H1(n,t),r=yI(n,t);function a(o,i,u){var l=r(o,i,u+"/separable_conv0"),h=r(i,i,u+"/separable_conv1"),d=e(o,i,1,u+"/expansion_conv");return{separable_conv0:l,separable_conv1:h,expansion_conv:d}}function s(o,i){var u=r(o,o,i+"/separable_conv0"),l=r(o,o,i+"/separable_conv1"),h=r(o,o,i+"/separable_conv2");return{separable_conv0:u,separable_conv1:l,separable_conv2:h}}return{extractConvParams:e,extractSeparableConvParams:r,extractReductionBlockParams:a,extractMainBlockParams:s}}function xut(n,t){var e=[],r=qi(n),a=r.extractWeights,s=r.getRemainingWeights,o=but(a,e),i=o.extractConvParams,u=o.extractSeparableConvParams,l=o.extractReductionBlockParams,h=o.extractMainBlockParams,d=i(3,32,3,"entry_flow/conv_in"),f=l(32,64,"entry_flow/reduction_block_0"),m=l(64,128,"entry_flow/reduction_block_1"),v={conv_in:d,reduction_block_0:f,reduction_block_1:m},y={};lm(t,0,1).forEach(function(N){y["main_block_"+N]=h(128,"middle_flow/main_block_"+N)});var b=l(128,256,"exit_flow/reduction_block"),w=u(256,512,"exit_flow/separable_conv"),S={reduction_block:b,separable_conv:w};if(s().length!==0)throw new Error("weights remaing after extract: "+s().length);return{paramMappings:e,params:{entry_flow:v,middle_flow:y,exit_flow:S}}}function wut(n,t){var e=sl(n,t),r=xP(e),a=bI(e);function s(i){var u=a(i+"/separable_conv0"),l=a(i+"/separable_conv1"),h=r(i+"/expansion_conv");return{separable_conv0:u,separable_conv1:l,expansion_conv:h}}function o(i){var u=a(i+"/separable_conv0"),l=a(i+"/separable_conv1"),h=a(i+"/separable_conv2");return{separable_conv0:u,separable_conv1:l,separable_conv2:h}}return{extractConvParams:r,extractSeparableConvParams:a,extractReductionBlockParams:s,extractMainBlockParams:o}}function Sut(n,t){var e=[],r=wut(n,e),a=r.extractConvParams,s=r.extractSeparableConvParams,o=r.extractReductionBlockParams,i=r.extractMainBlockParams,u=a("entry_flow/conv_in"),l=o("entry_flow/reduction_block_0"),h=o("entry_flow/reduction_block_1"),d={conv_in:u,reduction_block_0:l,reduction_block_1:h},f={};lm(t,0,1).forEach(function(b){f["main_block_"+b]=i("middle_flow/main_block_"+b)});var m=o("exit_flow/reduction_block"),v=s("exit_flow/separable_conv"),y={reduction_block:m,separable_conv:v};return ji(n,e),{params:{entry_flow:d,middle_flow:f,exit_flow:y},paramMappings:e}}function TP(n,t,e){return $e(Us(n,t.filters,e,"same"),t.bias)}function vC(n,t,e){e===void 0&&(e=!0);var r=e?Fn(n):n;return r=ds(r,t.separable_conv0,[1,1]),r=ds(Fn(r),t.separable_conv1,[1,1]),r=Rr(r,[3,3],[2,2],"same"),r=$e(r,TP(n,t.expansion_conv,[2,2])),r}function Cut(n,t){var e=ds(Fn(n),t.separable_conv0,[1,1]);return e=ds(Fn(e),t.separable_conv1,[1,1]),e=ds(Fn(e),t.separable_conv2,[1,1]),e=$e(e,n),e}var Nut=(function(n){ve(t,n);function t(e){var r=n.call(this,"TinyXception")||this;return r._numMainBlocks=e,r}return t.prototype.forwardInput=function(e){var r=this,a=this.params;if(!a)throw new Error("TinyXception - load model before inference");return Gt(function(){var s=e.toBatchTensor(112,!0),o=[122.782,117.001,104.298],i=ev(s,o).div(Pt(256)),u=Fn(TP(i,a.entry_flow.conv_in,[2,2]));return u=vC(u,a.entry_flow.reduction_block_0,!1),u=vC(u,a.entry_flow.reduction_block_1),lm(r._numMainBlocks,0,1).forEach(function(l){u=Cut(u,a.middle_flow["main_block_"+l])}),u=vC(u,a.exit_flow.reduction_block),u=Fn(ds(u,a.exit_flow.separable_conv,[1,1])),u})},t.prototype.forward=function(e){return re(this,void 0,void 0,function(){var r;return ae(this,function(a){switch(a.label){case 0:return r=this.forwardInput,[4,Lr(e)];case 1:return[2,r.apply(this,[a.sent()])]}})})},t.prototype.getDefaultModelName=function(){return"tiny_xception_model"},t.prototype.extractParamsFromWeigthMap=function(e){return Sut(e,this._numMainBlocks)},t.prototype.extractParams=function(e){return xut(e,this._numMainBlocks)},t})(Hi);function kut(n){var t=[],e=qi(n),r=e.extractWeights,a=e.getRemainingWeights,s=vI(r,t),o=s(512,1,"fc/age"),i=s(512,2,"fc/gender");if(a().length!==0)throw new Error("weights remaing after extract: "+a().length);return{paramMappings:t,params:{fc:{age:o,gender:i}}}}function Tut(n){var t=[],e=sl(n,t);function r(s){var o=e(s+"/weights",2),i=e(s+"/bias",1);return{weights:o,bias:i}}var a={fc:{age:r("fc/age"),gender:r("fc/gender")}};return ji(n,t),{params:a,paramMappings:t}}var db;(function(n){n.FEMALE="female",n.MALE="male"})(db||(db={}));var Eut=(function(n){ve(t,n);function t(e){e===void 0&&(e=new Nut(2));var r=n.call(this,"AgeGenderNet")||this;return r._faceFeatureExtractor=e,r}return Object.defineProperty(t.prototype,"faceFeatureExtractor",{get:function(){return this._faceFeatureExtractor},enumerable:!0,configurable:!0}),t.prototype.runNet=function(e){var r=this,a=this.params;if(!a)throw new Error(this._name+" - load model before inference");return Gt(function(){var s=e instanceof hb?r.faceFeatureExtractor.forwardInput(e):e,o=Jg(s,[7,7],[2,2],"valid").as2D(s.shape[0],-1),i=Ao(o,a.fc.age).as1D(),u=Ao(o,a.fc.gender);return{age:i,gender:u}})},t.prototype.forwardInput=function(e){var r=this;return Gt(function(){var a=r.runNet(e),s=a.age,o=a.gender;return{age:s,gender:Wi(o)}})},t.prototype.forward=function(e){return re(this,void 0,void 0,function(){var r;return ae(this,function(a){switch(a.label){case 0:return r=this.forwardInput,[4,Lr(e)];case 1:return[2,r.apply(this,[a.sent()])]}})})},t.prototype.predictAgeAndGender=function(e){return re(this,void 0,void 0,function(){var r,a,s,o,i,u,l=this;return ae(this,function(h){switch(h.label){case 0:return[4,Lr(e)];case 1:return r=h.sent(),[4,this.forwardInput(r)];case 2:return a=h.sent(),s=br(a.age),o=br(a.gender),i=s.map(function(d,f){return{ageTensor:d,genderTensor:o[f]}}),[4,Promise.all(i.map(function(d){var f=d.ageTensor,m=d.genderTensor;return re(l,void 0,void 0,function(){var v,y,b,w,S;return ae(this,function(N){switch(N.label){case 0:return[4,f.data()];case 1:return v=N.sent()[0],[4,m.data()];case 2:return y=N.sent()[0],b=y>.5,w=b?db.MALE:db.FEMALE,S=b?y:1-y,f.dispose(),m.dispose(),[2,{age:v,gender:w,genderProbability:S}]}})})}))];case 3:return u=h.sent(),a.age.dispose(),a.gender.dispose(),[2,r.isBatchInput?u:u[0]]}})})},t.prototype.getDefaultModelName=function(){return"age_gender_model"},t.prototype.dispose=function(e){e===void 0&&(e=!0),this.faceFeatureExtractor.dispose(e),n.prototype.dispose.call(this,e)},t.prototype.loadClassifierParams=function(e){var r=this.extractClassifierParams(e),a=r.params,s=r.paramMappings;this._params=a,this._paramMappings=s},t.prototype.extractClassifierParams=function(e){return kut(e)},t.prototype.extractParamsFromWeigthMap=function(e){var r=CP(e),a=r.featureExtractorMap,s=r.classifierMap;return this.faceFeatureExtractor.loadFromWeightMap(a),Tut(s)},t.prototype.extractParams=function(e){var r=1539,a=e.slice(0,e.length-r),s=e.slice(e.length-r);return this.faceFeatureExtractor.extractWeights(a),this.extractClassifierParams(s)},t})(Hi),EP=(function(n){ve(t,n);function t(){return n!==null&&n.apply(this,arguments)||this}return t.prototype.postProcess=function(e,r,a){var s=a.map(function(i){var u=i.width,l=i.height,h=r/Math.max(l,u);return{width:u*h,height:l*h}}),o=s.length;return Gt(function(){var i=function(f,m){return ys([Bo([68],f),Bo([68],m)],1).as2D(1,136).as1D()},u=function(f,m){var v=s[f],y=v.width,b=v.height;return m(y,b)?Math.abs(y-b)/2:0},l=function(f){return u(f,function(m,v){return m<v})},h=function(f){return u(f,function(m,v){return v<m})},d=e.mul(Bo([o,136],r)).sub(ys(Array.from(Array(o),function(f,m){return i(l(m),h(m))}))).div(ys(Array.from(Array(o),function(f,m){return i(s[m].width,s[m].height)})));return d})},t.prototype.forwardInput=function(e){var r=this;return Gt(function(){var a=r.runNet(e);return r.postProcess(a,e.inputSize,e.inputDimensions.map(function(s){var o=s[0],i=s[1];return{height:o,width:i}}))})},t.prototype.forward=function(e){return re(this,void 0,void 0,function(){var r;return ae(this,function(a){switch(a.label){case 0:return r=this.forwardInput,[4,Lr(e)];case 1:return[2,r.apply(this,[a.sent()])]}})})},t.prototype.detectLandmarks=function(e){return re(this,void 0,void 0,function(){var r,a,s,o=this;return ae(this,function(i){switch(i.label){case 0:return[4,Lr(e)];case 1:return r=i.sent(),a=Gt(function(){return br(o.forwardInput(r))}),[4,Promise.all(a.map(function(u,l){return re(o,void 0,void 0,function(){var h,d,f,m,v;return ae(this,function(y){switch(y.label){case 0:return f=(d=Array).from,[4,u.data()];case 1:return h=f.apply(d,[y.sent()]),m=h.filter(function(b,w){return P3(w)}),v=h.filter(function(b,w){return!P3(w)}),[2,new nut(Array(68).fill(0).map(function(b,w){return new Qe(m[w],v[w])}),{height:r.getInputHeight(l),width:r.getInputWidth(l)})]}})})}))];case 2:return s=i.sent(),a.forEach(function(u){return u.dispose()}),[2,r.isBatchInput?s:s[0]]}})})},t.prototype.getClassifierChannelsOut=function(){return 136},t})(NP),IP=(function(n){ve(t,n);function t(e){return e===void 0&&(e=new SP),n.call(this,"FaceLandmark68Net",e)||this}return t.prototype.getDefaultModelName=function(){return"face_landmark_68_model"},t.prototype.getClassifierChannelsIn=function(){return 256},t})(EP);function Iut(n){var t=[],e=wP(n,t).extractDenseBlock3Params,r={dense0:e("dense0",!0),dense1:e("dense1"),dense2:e("dense2")};return ji(n,t),{params:r,paramMappings:t}}function _ut(n){var t=[],e=qi(n),r=e.extractWeights,a=e.getRemainingWeights,s=bP(r,t).extractDenseBlock3Params,o=s(3,32,"dense0",!0),i=s(32,64,"dense1"),u=s(64,128,"dense2");if(a().length!==0)throw new Error("weights remaing after extract: "+a().length);return{paramMappings:t,params:{dense0:o,dense1:i,dense2:u}}}var Rut=(function(n){ve(t,n);function t(){return n.call(this,"TinyFaceFeatureExtractor")||this}return t.prototype.forwardInput=function(e){var r=this.params;if(!r)throw new Error("TinyFaceFeatureExtractor - load model before inference");return Gt(function(){var a=e.toBatchTensor(112,!0),s=[122.782,117.001,104.298],o=ev(a,s).div(Pt(255)),i=gC(o,r.dense0,!0);return i=gC(i,r.dense1),i=gC(i,r.dense2),i=Jg(i,[14,14],[2,2],"valid"),i})},t.prototype.forward=function(e){return re(this,void 0,void 0,function(){var r;return ae(this,function(a){switch(a.label){case 0:return r=this.forwardInput,[4,Lr(e)];case 1:return[2,r.apply(this,[a.sent()])]}})})},t.prototype.getDefaultModelName=function(){return"face_feature_extractor_tiny_model"},t.prototype.extractParamsFromWeigthMap=function(e){return Iut(e)},t.prototype.extractParams=function(e){return _ut(e)},t})(Hi),Aut=(function(n){ve(t,n);function t(e){return e===void 0&&(e=new Rut),n.call(this,"FaceLandmark68TinyNet",e)||this}return t.prototype.getDefaultModelName=function(){return"face_landmark_68_tiny_model"},t.prototype.getClassifierChannelsIn=function(){return 128},t})(EP);(function(n){ve(t,n);function t(){return n!==null&&n.apply(this,arguments)||this}return t})(IP);function Dut(n,t){return $e(da(n,t.weights),t.biases)}function wI(n,t,e,r,a){a===void 0&&(a="same");var s=t.conv,o=s.filters,i=s.bias,u=Us(n,o,e,a);return u=$e(u,i),u=Dut(u,t.scale),r?Fn(u):u}function $ut(n,t){return wI(n,t,[1,1],!0)}function _P(n,t){return wI(n,t,[1,1],!1)}function RP(n,t){return wI(n,t,[2,2],!0,"valid")}function Out(n,t){function e(i,u,l){var h=n(i),d=h.length/(u*l*l);if(jit(d))throw new Error("depth has to be an integer: "+d+", weights.length: "+h.length+", numFilters: "+u+", filterSize: "+l);return Gt(function(){return Uu(Ba(h,[u,d,l,l]),[2,3,1,0])})}function r(i,u,l,h){var d=e(i,u,l),f=rr(n(u));return t.push({paramPath:h+"/filters"},{paramPath:h+"/bias"}),{filters:d,bias:f}}function a(i,u){var l=rr(n(i)),h=rr(n(i));return t.push({paramPath:u+"/weights"},{paramPath:u+"/biases"}),{weights:l,biases:h}}function s(i,u,l,h){var d=r(i,u,l,h+"/conv"),f=a(u,h+"/scale");return{conv:d,scale:f}}function o(i,u,l,h,d){d===void 0&&(d=!1);var f=s((d?.5:1)*i,u,l,h+"/conv1"),m=s(i,u,l,h+"/conv2");return{conv1:f,conv2:m}}return{extractConvLayerParams:s,extractResidualLayerParams:o}}function Fut(n){var t=qi(n),e=t.extractWeights,r=t.getRemainingWeights,a=[],s=Out(e,a),o=s.extractConvLayerParams,i=s.extractResidualLayerParams,u=o(4704,32,7,"conv32_down"),l=i(9216,32,3,"conv32_1"),h=i(9216,32,3,"conv32_2"),d=i(9216,32,3,"conv32_3"),f=i(36864,64,3,"conv64_down",!0),m=i(36864,64,3,"conv64_1"),v=i(36864,64,3,"conv64_2"),y=i(36864,64,3,"conv64_3"),b=i(147456,128,3,"conv128_down",!0),w=i(147456,128,3,"conv128_1"),S=i(147456,128,3,"conv128_2"),N=i(589824,256,3,"conv256_down",!0),C=i(589824,256,3,"conv256_1"),T=i(589824,256,3,"conv256_2"),I=i(589824,256,3,"conv256_down_out"),_=Gt(function(){return Uu(_u(e(256*128),[128,256]),[1,0])});if(a.push({paramPath:"fc"}),r().length!==0)throw new Error("weights remaing after extract: "+r().length);var $={conv32_down:u,conv32_1:l,conv32_2:h,conv32_3:d,conv64_down:f,conv64_1:m,conv64_2:v,conv64_3:y,conv128_down:b,conv128_1:w,conv128_2:S,conv256_down:N,conv256_1:C,conv256_2:T,conv256_down_out:I,fc:_};return{params:$,paramMappings:a}}function Mut(n,t){var e=sl(n,t);function r(o){var i=e(o+"/scale/weights",1),u=e(o+"/scale/biases",1);return{weights:i,biases:u}}function a(o){var i=e(o+"/conv/filters",4),u=e(o+"/conv/bias",1),l=r(o);return{conv:{filters:i,bias:u},scale:l}}function s(o){return{conv1:a(o+"/conv1"),conv2:a(o+"/conv2")}}return{extractConvLayerParams:a,extractResidualLayerParams:s}}function Lut(n){var t=[],e=Mut(n,t),r=e.extractConvLayerParams,a=e.extractResidualLayerParams,s=r("conv32_down"),o=a("conv32_1"),i=a("conv32_2"),u=a("conv32_3"),l=a("conv64_down"),h=a("conv64_1"),d=a("conv64_2"),f=a("conv64_3"),m=a("conv128_down"),v=a("conv128_1"),y=a("conv128_2"),b=a("conv256_down"),w=a("conv256_1"),S=a("conv256_2"),N=a("conv256_down_out"),C=n.fc;if(t.push({originalPath:"fc",paramPath:"fc"}),!Hit(C))throw new Error("expected weightMap[fc] to be a Tensor2D, instead have "+C);var T={conv32_down:s,conv32_1:o,conv32_2:i,conv32_3:u,conv64_down:l,conv64_1:h,conv64_2:d,conv64_3:f,conv128_down:m,conv128_1:v,conv128_2:y,conv256_down:b,conv256_1:w,conv256_2:S,conv256_down_out:N,fc:C};return ji(n,t),{params:T,paramMappings:t}}function bo(n,t){var e=$ut(n,t.conv1);return e=_P(e,t.conv2),e=$e(e,n),e=Fn(e),e}function n0(n,t){var e=RP(n,t.conv1);e=_P(e,t.conv2);var r=Jg(n,2,2,"valid"),a=Sn(r.shape),s=r.shape[3]!==e.shape[3],o=r.shape[1]!==e.shape[1]||r.shape[2]!==e.shape[2];if(o){var i=Uf(e.shape);i[1]=1;var u=Sn(i);e=yr([e,u],1);var l=Uf(e.shape);l[2]=1;var h=Sn(l);e=yr([e,h],2)}return r=s?yr([r,a],3):r,e=$e(r,e),e=Fn(e),e}var But=(function(n){ve(t,n);function t(){return n.call(this,"FaceRecognitionNet")||this}return t.prototype.forwardInput=function(e){var r=this.params;if(!r)throw new Error("FaceRecognitionNet - load model before inference");return Gt(function(){var a=e.toBatchTensor(150,!0).toFloat(),s=[122.782,117.001,104.298],o=ev(a,s).div(Pt(256)),i=RP(o,r.conv32_down);i=Rr(i,3,2,"valid"),i=bo(i,r.conv32_1),i=bo(i,r.conv32_2),i=bo(i,r.conv32_3),i=n0(i,r.conv64_down),i=bo(i,r.conv64_1),i=bo(i,r.conv64_2),i=bo(i,r.conv64_3),i=n0(i,r.conv128_down),i=bo(i,r.conv128_1),i=bo(i,r.conv128_2),i=n0(i,r.conv256_down),i=bo(i,r.conv256_1),i=bo(i,r.conv256_2),i=n0(i,r.conv256_down_out);var u=i.mean([1,2]),l=B1(u,r.fc);return l})},t.prototype.forward=function(e){return re(this,void 0,void 0,function(){var r;return ae(this,function(a){switch(a.label){case 0:return r=this.forwardInput,[4,Lr(e)];case 1:return[2,r.apply(this,[a.sent()])]}})})},t.prototype.computeFaceDescriptor=function(e){return re(this,void 0,void 0,function(){var r,a,s,o=this;return ae(this,function(i){switch(i.label){case 0:return[4,Lr(e)];case 1:return r=i.sent(),a=Gt(function(){return br(o.forwardInput(r))}),[4,Promise.all(a.map(function(u){return u.data()}))];case 2:return s=i.sent(),a.forEach(function(u){return u.dispose()}),[2,r.isBatchInput?s:s[0]]}})})},t.prototype.getDefaultModelName=function(){return"face_recognition_model"},t.prototype.extractParamsFromWeigthMap=function(e){return Lut(e)},t.prototype.extractParams=function(e){return Fut(e)},t})(Hi);function AP(n,t){var e={descriptor:t};return Object.assign({},n,e)}function DP(n,t){var e={age:t};return Object.assign({},n,e)}function $P(n,t,e){var r={gender:t,genderProbability:e};return Object.assign({},n,r)}var OP=(function(){function n(t){var e=t===void 0?{}:t,r=e.minFaceSize,a=e.scaleFactor,s=e.maxNumScales,o=e.scoreThresholds,i=e.scaleSteps;if(this._name="MtcnnOptions",this._minFaceSize=r||20,this._scaleFactor=a||.709,this._maxNumScales=s||10,this._scoreThresholds=o||[.6,.7,.7],this._scaleSteps=i,typeof this._minFaceSize!="number"||this._minFaceSize<0)throw new Error(this._name+" - expected minFaceSize to be a number > 0");if(typeof this._scaleFactor!="number"||this._scaleFactor<=0||this._scaleFactor>=1)throw new Error(this._name+" - expected scaleFactor to be a number between 0 and 1");if(typeof this._maxNumScales!="number"||this._maxNumScales<0)throw new Error(this._name+" - expected maxNumScales to be a number > 0");if(!Array.isArray(this._scoreThresholds)||this._scoreThresholds.length!==3||this._scoreThresholds.some(function(u){return typeof u!="number"}))throw new Error(this._name+" - expected scoreThresholds to be an array of numbers of length 3");if(this._scaleSteps&&(!Array.isArray(this._scaleSteps)||this._scaleSteps.some(function(u){return typeof u!="number"})))throw new Error(this._name+" - expected scaleSteps to be an array of numbers")}return Object.defineProperty(n.prototype,"minFaceSize",{get:function(){return this._minFaceSize},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"scaleFactor",{get:function(){return this._scaleFactor},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"maxNumScales",{get:function(){return this._maxNumScales},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"scoreThresholds",{get:function(){return this._scoreThresholds},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"scaleSteps",{get:function(){return this._scaleSteps},enumerable:!0,configurable:!0}),n})();function zut(n,t){function e(u,l){var h=Ba(n(9*u),[3,3,u,1]),d=rr(n(u)),f=rr(n(u)),m=rr(n(u)),v=rr(n(u));return t.push({paramPath:l+"/filters"},{paramPath:l+"/batch_norm_scale"},{paramPath:l+"/batch_norm_offset"},{paramPath:l+"/batch_norm_mean"},{paramPath:l+"/batch_norm_variance"}),{filters:h,batch_norm_scale:d,batch_norm_offset:f,batch_norm_mean:m,batch_norm_variance:v}}function r(u,l,h,d,f){var m=Ba(n(u*l*h*h),[h,h,u,l]),v=rr(n(l));return t.push({paramPath:d+"/filters"},{paramPath:d+"/"+(f?"batch_norm_offset":"bias")}),{filters:m,bias:v}}function a(u,l,h,d){var f=r(u,l,h,d,!0),m=f.filters,v=f.bias;return{filters:m,batch_norm_offset:v}}function s(u,l,h){var d=e(u,h+"/depthwise_conv"),f=a(u,l,1,h+"/pointwise_conv");return{depthwise_conv:d,pointwise_conv:f}}function o(){var u=a(3,32,3,"mobilenetv1/conv_0"),l=s(32,64,"mobilenetv1/conv_1"),h=s(64,128,"mobilenetv1/conv_2"),d=s(128,128,"mobilenetv1/conv_3"),f=s(128,256,"mobilenetv1/conv_4"),m=s(256,256,"mobilenetv1/conv_5"),v=s(256,512,"mobilenetv1/conv_6"),y=s(512,512,"mobilenetv1/conv_7"),b=s(512,512,"mobilenetv1/conv_8"),w=s(512,512,"mobilenetv1/conv_9"),S=s(512,512,"mobilenetv1/conv_10"),N=s(512,512,"mobilenetv1/conv_11"),C=s(512,1024,"mobilenetv1/conv_12"),T=s(1024,1024,"mobilenetv1/conv_13");return{conv_0:u,conv_1:l,conv_2:h,conv_3:d,conv_4:f,conv_5:m,conv_6:v,conv_7:y,conv_8:b,conv_9:w,conv_10:S,conv_11:N,conv_12:C,conv_13:T}}function i(){var u=a(1024,256,1,"prediction_layer/conv_0"),l=a(256,512,3,"prediction_layer/conv_1"),h=a(512,128,1,"prediction_layer/conv_2"),d=a(128,256,3,"prediction_layer/conv_3"),f=a(256,128,1,"prediction_layer/conv_4"),m=a(128,256,3,"prediction_layer/conv_5"),v=a(256,64,1,"prediction_layer/conv_6"),y=a(64,128,3,"prediction_layer/conv_7"),b=r(512,12,1,"prediction_layer/box_predictor_0/box_encoding_predictor"),w=r(512,9,1,"prediction_layer/box_predictor_0/class_predictor"),S=r(1024,24,1,"prediction_layer/box_predictor_1/box_encoding_predictor"),N=r(1024,18,1,"prediction_layer/box_predictor_1/class_predictor"),C=r(512,24,1,"prediction_layer/box_predictor_2/box_encoding_predictor"),T=r(512,18,1,"prediction_layer/box_predictor_2/class_predictor"),I=r(256,24,1,"prediction_layer/box_predictor_3/box_encoding_predictor"),_=r(256,18,1,"prediction_layer/box_predictor_3/class_predictor"),$=r(256,24,1,"prediction_layer/box_predictor_4/box_encoding_predictor"),R=r(256,18,1,"prediction_layer/box_predictor_4/class_predictor"),D=r(128,24,1,"prediction_layer/box_predictor_5/box_encoding_predictor"),A=r(128,18,1,"prediction_layer/box_predictor_5/class_predictor"),L={box_encoding_predictor:b,class_predictor:w},H={box_encoding_predictor:S,class_predictor:N},G={box_encoding_predictor:C,class_predictor:T},q={box_encoding_predictor:I,class_predictor:_},B={box_encoding_predictor:$,class_predictor:R},j={box_encoding_predictor:D,class_predictor:A};return{conv_0:u,conv_1:l,conv_2:h,conv_3:d,conv_4:f,conv_5:m,conv_6:v,conv_7:y,box_predictor_0:L,box_predictor_1:H,box_predictor_2:G,box_predictor_3:q,box_predictor_4:B,box_predictor_5:j}}return{extractMobilenetV1Params:o,extractPredictionLayerParams:i}}function Put(n){var t=[],e=qi(n),r=e.extractWeights,a=e.getRemainingWeights,s=zut(r,t),o=s.extractMobilenetV1Params,i=s.extractPredictionLayerParams,u=o(),l=i(),h=LE(r(5118*4),[1,5118,4]),d={extra_dim:h};if(t.push({paramPath:"output_layer/extra_dim"}),a().length!==0)throw new Error("weights remaing after extract: "+a().length);return{params:{mobilenetv1:u,prediction_layer:l,output_layer:d},paramMappings:t}}function Vut(n,t){var e=sl(n,t);function r(l,h,d){var f=e(l+"/Conv2d_"+h+"_pointwise/weights",4,d+"/filters"),m=e(l+"/Conv2d_"+h+"_pointwise/convolution_bn_offset",1,d+"/batch_norm_offset");return{filters:f,batch_norm_offset:m}}function a(l){var h="mobilenetv1/conv_"+l,d="MobilenetV1/Conv2d_"+l+"_depthwise",f=h+"/depthwise_conv",m=h+"/pointwise_conv",v=e(d+"/depthwise_weights",4,f+"/filters"),y=e(d+"/BatchNorm/gamma",1,f+"/batch_norm_scale"),b=e(d+"/BatchNorm/beta",1,f+"/batch_norm_offset"),w=e(d+"/BatchNorm/moving_mean",1,f+"/batch_norm_mean"),S=e(d+"/BatchNorm/moving_variance",1,f+"/batch_norm_variance");return{depthwise_conv:{filters:v,batch_norm_scale:y,batch_norm_offset:b,batch_norm_mean:w,batch_norm_variance:S},pointwise_conv:r("MobilenetV1",l,m)}}function s(){return{conv_0:r("MobilenetV1",0,"mobilenetv1/conv_0"),conv_1:a(1),conv_2:a(2),conv_3:a(3),conv_4:a(4),conv_5:a(5),conv_6:a(6),conv_7:a(7),conv_8:a(8),conv_9:a(9),conv_10:a(10),conv_11:a(11),conv_12:a(12),conv_13:a(13)}}function o(l,h){var d=e(l+"/weights",4,h+"/filters"),f=e(l+"/biases",1,h+"/bias");return{filters:d,bias:f}}function i(l){var h=o("Prediction/BoxPredictor_"+l+"/BoxEncodingPredictor","prediction_layer/box_predictor_"+l+"/box_encoding_predictor"),d=o("Prediction/BoxPredictor_"+l+"/ClassPredictor","prediction_layer/box_predictor_"+l+"/class_predictor");return{box_encoding_predictor:h,class_predictor:d}}function u(){return{conv_0:r("Prediction",0,"prediction_layer/conv_0"),conv_1:r("Prediction",1,"prediction_layer/conv_1"),conv_2:r("Prediction",2,"prediction_layer/conv_2"),conv_3:r("Prediction",3,"prediction_layer/conv_3"),conv_4:r("Prediction",4,"prediction_layer/conv_4"),conv_5:r("Prediction",5,"prediction_layer/conv_5"),conv_6:r("Prediction",6,"prediction_layer/conv_6"),conv_7:r("Prediction",7,"prediction_layer/conv_7"),box_predictor_0:i(0),box_predictor_1:i(1),box_predictor_2:i(2),box_predictor_3:i(3),box_predictor_4:i(4),box_predictor_5:i(5)}}return{extractMobilenetV1Params:s,extractPredictionLayerParams:u}}function Uut(n){var t=[],e=Vut(n,t),r=e.extractMobilenetV1Params,a=e.extractPredictionLayerParams,s=n["Output/extra_dim"];if(t.push({originalPath:"Output/extra_dim",paramPath:"output_layer/extra_dim"}),!U1(s))throw new Error("expected weightMap['Output/extra_dim'] to be a Tensor3D, instead have "+s);var o={mobilenetv1:r(),prediction_layer:a(),output_layer:{extra_dim:s}};return ji(n,t),{params:o,paramMappings:t}}function wo(n,t,e){return Gt(function(){var r=Us(n,t.filters,e,"same");return r=$e(r,t.batch_norm_offset),KE(r,0,6)})}var Wut=.0010000000474974513;function Gut(n,t,e){return Gt(function(){var r=L1(n,t.filters,e,"same");return r=Iz(r,t.batch_norm_mean,t.batch_norm_variance,t.batch_norm_offset,t.batch_norm_scale,Wut),KE(r,0,6)})}function Hut(n){return[2,4,6,12].some(function(t){return t===n})?[2,2]:[1,1]}function jut(n,t){return Gt(function(){var e=null,r=wo(n,t.conv_0,[2,2]),a=[t.conv_1,t.conv_2,t.conv_3,t.conv_4,t.conv_5,t.conv_6,t.conv_7,t.conv_8,t.conv_9,t.conv_10,t.conv_11,t.conv_12,t.conv_13];if(a.forEach(function(s,o){var i=o+1,u=Hut(i);r=Gut(r,s.depthwise_conv,u),r=wo(r,s.pointwise_conv,[1,1]),i===11&&(e=r)}),e===null)throw new Error("mobileNetV1 - output of conv layer 11 is null");return{out:r,conv11:e}})}function qut(n,t,e,r,a){var s=n.shape[0],o=Math.min(e,s),i=t.map(function(h,d){return{score:h,boxIndex:d}}).filter(function(h){return h.score>a}).sort(function(h,d){return d.score-h.score}),u=function(h){return h<=r?1:0},l=[];return i.forEach(function(h){if(!(l.length>=o)){for(var d=h.score,f=l.length-1;f>=0;--f){var m=Kut(n,h.boxIndex,l[f]);if(m!==0&&(h.score*=u(m),h.score<=a))break}d===h.score&&l.push(h.boxIndex)}}),l}function Kut(n,t,e){var r=n.arraySync(),a=Math.min(r[t][0],r[t][2]),s=Math.min(r[t][1],r[t][3]),o=Math.max(r[t][0],r[t][2]),i=Math.max(r[t][1],r[t][3]),u=Math.min(r[e][0],r[e][2]),l=Math.min(r[e][1],r[e][3]),h=Math.max(r[e][0],r[e][2]),d=Math.max(r[e][1],r[e][3]),f=(o-a)*(i-s),m=(h-u)*(d-l);if(f<=0||m<=0)return 0;var v=Math.max(a,u),y=Math.max(s,l),b=Math.min(o,h),w=Math.min(i,d),S=Math.max(b-v,0)*Math.max(w-y,0);return S/(f+m-S)}function Xut(n){var t=br(Uu(n,[1,0])),e=[Cr(t[2],t[0]),Cr(t[3],t[1])],r=[$e(t[0],Js(e[0],Pt(2))),$e(t[1],Js(e[1],Pt(2)))];return{sizes:e,centers:r}}function Yut(n,t){var e=Xut(n),r=e.sizes,a=e.centers,s=br(Uu(t,[1,0])),o=Js(da(XN(Js(s[2],Pt(5))),r[0]),Pt(2)),i=$e(da(Js(s[0],Pt(10)),r[0]),a[0]),u=Js(da(XN(Js(s[3],Pt(5))),r[1]),Pt(2)),l=$e(da(Js(s[1],Pt(10)),r[1]),a[1]);return Uu(ys([Cr(i,o),Cr(l,u),$e(i,o),$e(l,u)]),[1,0])}function Qut(n,t,e){return Gt(function(){var r=n.shape[0],a=Yut(to(Bh(e.extra_dim,[r,1,1]),[-1,4]),to(n,[-1,4]));a=to(a,[r,a.shape[0]/r,4]);var s=Nz(Ho(t,[0,0,1],[-1,-1,-1])),o=Ho(s,[0,0,0],[-1,-1,1]);o=to(o,[r,o.shape[1]]);var i=br(a),u=br(o);return{boxes:i,scores:u}})}function Nh(n,t){return Gt(function(){var e=n.shape[0],r=to(no(n,t.box_encoding_predictor),[e,-1,1,4]),a=to(no(n,t.class_predictor),[e,-1,3]);return{boxPredictionEncoding:r,classPrediction:a}})}function Zut(n,t,e){return Gt(function(){var r=wo(n,e.conv_0,[1,1]),a=wo(r,e.conv_1,[2,2]),s=wo(a,e.conv_2,[1,1]),o=wo(s,e.conv_3,[2,2]),i=wo(o,e.conv_4,[1,1]),u=wo(i,e.conv_5,[2,2]),l=wo(u,e.conv_6,[1,1]),h=wo(l,e.conv_7,[2,2]),d=Nh(t,e.box_predictor_0),f=Nh(n,e.box_predictor_1),m=Nh(a,e.box_predictor_2),v=Nh(o,e.box_predictor_3),y=Nh(u,e.box_predictor_4),b=Nh(h,e.box_predictor_5),w=yr([d.boxPredictionEncoding,f.boxPredictionEncoding,m.boxPredictionEncoding,v.boxPredictionEncoding,y.boxPredictionEncoding,b.boxPredictionEncoding],1),S=yr([d.classPrediction,f.classPrediction,m.classPrediction,v.classPrediction,y.classPrediction,b.classPrediction],1);return{boxPredictions:w,classPredictions:S}})}var nv=(function(){function n(t){var e=t===void 0?{}:t,r=e.minConfidence,a=e.maxResults;if(this._name="SsdMobilenetv1Options",this._minConfidence=r||.5,this._maxResults=a||100,typeof this._minConfidence!="number"||this._minConfidence<=0||this._minConfidence>=1)throw new Error(this._name+" - expected minConfidence to be a number between 0 and 1");if(typeof this._maxResults!="number")throw new Error(this._name+" - expected maxResults to be a number")}return Object.defineProperty(n.prototype,"minConfidence",{get:function(){return this._minConfidence},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"maxResults",{get:function(){return this._maxResults},enumerable:!0,configurable:!0}),n})(),FP=(function(n){ve(t,n);function t(){return n.call(this,"SsdMobilenetv1")||this}return t.prototype.forwardInput=function(e){var r=this.params;if(!r)throw new Error("SsdMobilenetv1 - load model before inference");return Gt(function(){var a=e.toBatchTensor(512,!1).toFloat(),s=Cr(da(a,Pt(.007843137718737125)),Pt(1)),o=jut(s,r.mobilenetv1),i=Zut(o.out,o.conv11,r.prediction_layer),u=i.boxPredictions,l=i.classPredictions;return Qut(u,l,r.output_layer)})},t.prototype.forward=function(e){return re(this,void 0,void 0,function(){var r;return ae(this,function(a){switch(a.label){case 0:return r=this.forwardInput,[4,Lr(e)];case 1:return[2,r.apply(this,[a.sent()])]}})})},t.prototype.locateFaces=function(e,r){return r===void 0&&(r={}),re(this,void 0,void 0,function(){var a,s,o,i,u,l,h,d,f,m,v,y,b,w,S,N,C,T,I,_,$;return ae(this,function(R){switch(R.label){case 0:return a=new nv(r),s=a.maxResults,o=a.minConfidence,[4,Lr(e)];case 1:for(i=R.sent(),u=this.forwardInput(i),l=u.boxes,h=u.scores,d=l[0],f=h[0],m=1;m<l.length;m++)l[m].dispose(),h[m].dispose();return b=(y=Array).from,[4,f.data()];case 2:return v=b.apply(y,[R.sent()]),w=.5,S=qut(d,v,s,w,o),N=i.getReshapedInputDimensions(0),C=i.inputSize,T=C/N.width,I=C/N.height,_=d.arraySync(),$=S.map(function(D){var A=[Math.max(0,_[D][0]),Math.min(1,_[D][2])].map(function(j){return j*I}),L=A[0],H=A[1],G=[Math.max(0,_[D][1]),Math.min(1,_[D][3])].map(function(j){return j*T}),q=G[0],B=G[1];return new Zo(v[D],new hI(q,L,B-q,H-L),{height:i.getInputHeight(0),width:i.getInputWidth(0)})}),d.dispose(),f.dispose(),[2,$]}})})},t.prototype.getDefaultModelName=function(){return"ssd_mobilenetv1_model"},t.prototype.extractParamsFromWeigthMap=function(e){return Uut(e)},t.prototype.extractParams=function(e){return Put(e)},t})(Hi);(function(n){ve(t,n);function t(){return n!==null&&n.apply(this,arguments)||this}return t})(FP);var Jut=.4,tlt=[new Qe(.738768,.874946),new Qe(2.42204,2.65704),new Qe(4.30971,7.04493),new Qe(10.246,4.59428),new Qe(12.6868,11.8741)],elt=[new Qe(1.603231,2.094468),new Qe(6.041143,7.080126),new Qe(2.882459,3.518061),new Qe(4.266906,5.178857),new Qe(9.041765,10.66308)],nlt=[117.001,114.697,97.404],rlt="tiny_yolov2_model",alt="tiny_yolov2_separable_conv_model",r0=function(n){return typeof n=="number"};function slt(n){if(!n)throw new Error("invalid config: "+n);if(typeof n.withSeparableConvs!="boolean")throw new Error("config.withSeparableConvs has to be a boolean, have: "+n.withSeparableConvs);if(!r0(n.iouThreshold)||n.iouThreshold<0||n.iouThreshold>1)throw new Error("config.iouThreshold has to be a number between [0, 1], have: "+n.iouThreshold);if(!Array.isArray(n.classes)||!n.classes.length||!n.classes.every(function(t){return typeof t=="string"}))throw new Error("config.classes has to be an array class names: string[], have: "+JSON.stringify(n.classes));if(!Array.isArray(n.anchors)||!n.anchors.length||!n.anchors.map(function(t){return t||{}}).every(function(t){return r0(t.x)&&r0(t.y)}))throw new Error("config.anchors has to be an array of { x: number, y: number }, have: "+JSON.stringify(n.anchors));if(n.meanRgb&&(!Array.isArray(n.meanRgb)||n.meanRgb.length!==3||!n.meanRgb.every(r0)))throw new Error("config.meanRgb has to be an array of shape [number, number, number], have: "+JSON.stringify(n.meanRgb))}function SI(n){return Gt(function(){var t=da(n,Pt(.10000000149011612));return $e(Fn(Cr(n,t)),t)})}function bu(n,t){return Gt(function(){var e=Nc(n,[[0,0],[1,1],[1,1],[0,0]]);return e=Us(e,t.conv.filters,[1,1],"valid"),e=Cr(e,t.bn.sub),e=da(e,t.bn.truediv),e=$e(e,t.conv.bias),SI(e)})}function xu(n,t){return Gt(function(){var e=Nc(n,[[0,0],[1,1],[1,1],[0,0]]);return e=ZE(e,t.depthwise_filter,t.pointwise_filter,[1,1],"valid"),e=$e(e,t.bias),SI(e)})}function olt(n,t){var e=H1(n,t);function r(o,i){var u=rr(n(o)),l=rr(n(o));return t.push({paramPath:i+"/sub"},{paramPath:i+"/truediv"}),{sub:u,truediv:l}}function a(o,i,u){var l=e(o,i,3,u+"/conv"),h=r(i,u+"/bn");return{conv:l,bn:h}}var s=yI(n,t);return{extractConvParams:e,extractConvWithBatchNormParams:a,extractSeparableConvParams:s}}function ilt(n,t,e,r){var a=qi(n),s=a.extractWeights,o=a.getRemainingWeights,i=[],u=olt(s,i),l=u.extractConvParams,h=u.extractConvWithBatchNormParams,d=u.extractSeparableConvParams,f;if(t.withSeparableConvs){var m=r[0],v=r[1],y=r[2],b=r[3],w=r[4],S=r[5],N=r[6],C=r[7],T=r[8],I=t.isFirstLayerConv2d?l(m,v,3,"conv0"):d(m,v,"conv0"),_=d(v,y,"conv1"),$=d(y,b,"conv2"),R=d(b,w,"conv3"),D=d(w,S,"conv4"),A=d(S,N,"conv5"),L=C?d(N,C,"conv6"):void 0,H=T?d(C,T,"conv7"):void 0,G=l(T||C||N,5*e,1,"conv8");f={conv0:I,conv1:_,conv2:$,conv3:R,conv4:D,conv5:A,conv6:L,conv7:H,conv8:G}}else{var m=r[0],v=r[1],y=r[2],b=r[3],w=r[4],S=r[5],N=r[6],C=r[7],T=r[8],I=h(m,v,"conv0"),_=h(v,y,"conv1"),$=h(y,b,"conv2"),R=h(b,w,"conv3"),D=h(w,S,"conv4"),A=h(S,N,"conv5"),L=h(N,C,"conv6"),H=h(C,T,"conv7"),G=l(T,5*e,1,"conv8");f={conv0:I,conv1:_,conv2:$,conv3:R,conv4:D,conv5:A,conv6:L,conv7:H,conv8:G}}if(o().length!==0)throw new Error("weights remaing after extract: "+o().length);return{params:f,paramMappings:i}}function ult(n,t){var e=sl(n,t);function r(i){var u=e(i+"/sub",1),l=e(i+"/truediv",1);return{sub:u,truediv:l}}function a(i){var u=e(i+"/filters",4),l=e(i+"/bias",1);return{filters:u,bias:l}}function s(i){var u=a(i+"/conv"),l=r(i+"/bn");return{conv:u,bn:l}}var o=bI(e);return{extractConvParams:a,extractConvWithBatchNormParams:s,extractSeparableConvParams:o}}function llt(n,t){var e=[],r=ult(n,e),a=r.extractConvParams,s=r.extractConvWithBatchNormParams,o=r.extractSeparableConvParams,i;if(t.withSeparableConvs){var u=t.filterSizes&&t.filterSizes.length||9;i={conv0:t.isFirstLayerConv2d?a("conv0"):o("conv0"),conv1:o("conv1"),conv2:o("conv2"),conv3:o("conv3"),conv4:o("conv4"),conv5:o("conv5"),conv6:u>7?o("conv6"):void 0,conv7:u>8?o("conv7"):void 0,conv8:a("conv8")}}else i={conv0:s("conv0"),conv1:s("conv1"),conv2:s("conv2"),conv3:s("conv3"),conv4:s("conv4"),conv5:s("conv5"),conv6:s("conv6"),conv7:s("conv7"),conv8:a("conv8")};return ji(n,e),{params:i,paramMappings:e}}var K3;(function(n){n[n.XS=224]="XS",n[n.SM=320]="SM",n[n.MD=416]="MD",n[n.LG=608]="LG"})(K3||(K3={}));var CI=(function(){function n(t){var e=t===void 0?{}:t,r=e.inputSize,a=e.scoreThreshold;if(this._name="TinyYolov2Options",this._inputSize=r||416,this._scoreThreshold=a||.5,typeof this._inputSize!="number"||this._inputSize%32!==0)throw new Error(this._name+" - expected inputSize to be a number divisible by 32");if(typeof this._scoreThreshold!="number"||this._scoreThreshold<=0||this._scoreThreshold>=1)throw new Error(this._name+" - expected scoreThreshold to be a number between 0 and 1")}return Object.defineProperty(n.prototype,"inputSize",{get:function(){return this._inputSize},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"scoreThreshold",{get:function(){return this._scoreThreshold},enumerable:!0,configurable:!0}),n})(),MP=(function(n){ve(t,n);function t(e){var r=n.call(this,"TinyYolov2")||this;return slt(e),r._config=e,r}return Object.defineProperty(t.prototype,"config",{get:function(){return this._config},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"withClassScores",{get:function(){return this.config.withClassScores||this.config.classes.length>1},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"boxEncodingSize",{get:function(){return 5+(this.withClassScores?this.config.classes.length:0)},enumerable:!0,configurable:!0}),t.prototype.runTinyYolov2=function(e,r){var a=bu(e,r.conv0);return a=Rr(a,[2,2],[2,2],"same"),a=bu(a,r.conv1),a=Rr(a,[2,2],[2,2],"same"),a=bu(a,r.conv2),a=Rr(a,[2,2],[2,2],"same"),a=bu(a,r.conv3),a=Rr(a,[2,2],[2,2],"same"),a=bu(a,r.conv4),a=Rr(a,[2,2],[2,2],"same"),a=bu(a,r.conv5),a=Rr(a,[2,2],[1,1],"same"),a=bu(a,r.conv6),a=bu(a,r.conv7),no(a,r.conv8,"valid",!1)},t.prototype.runMobilenet=function(e,r){var a=this.config.isFirstLayerConv2d?SI(no(e,r.conv0,"valid",!1)):xu(e,r.conv0);return a=Rr(a,[2,2],[2,2],"same"),a=xu(a,r.conv1),a=Rr(a,[2,2],[2,2],"same"),a=xu(a,r.conv2),a=Rr(a,[2,2],[2,2],"same"),a=xu(a,r.conv3),a=Rr(a,[2,2],[2,2],"same"),a=xu(a,r.conv4),a=Rr(a,[2,2],[2,2],"same"),a=xu(a,r.conv5),a=Rr(a,[2,2],[1,1],"same"),a=r.conv6?xu(a,r.conv6):a,a=r.conv7?xu(a,r.conv7):a,no(a,r.conv8,"valid",!1)},t.prototype.forwardInput=function(e,r){var a=this,s=this.params;if(!s)throw new Error("TinyYolov2 - load model before inference");return Gt(function(){var o=e.toBatchTensor(r,!1).toFloat();return o=a.config.meanRgb?ev(o,a.config.meanRgb):o,o=o.div(Pt(256)),a.config.withSeparableConvs?a.runMobilenet(o,s):a.runTinyYolov2(o,s)})},t.prototype.forward=function(e,r){return re(this,void 0,void 0,function(){var a;return ae(this,function(s){switch(s.label){case 0:return a=this.forwardInput,[4,Lr(e)];case 1:return[4,a.apply(this,[s.sent(),r])];case 2:return[2,s.sent()]}})})},t.prototype.detect=function(e,r){return r===void 0&&(r={}),re(this,void 0,void 0,function(){var a,s,o,i,u,l,h,d,f,m,v,y,b,w,S=this;return ae(this,function(N){switch(N.label){case 0:return a=new CI(r),s=a.inputSize,o=a.scoreThreshold,[4,Lr(e)];case 1:return i=N.sent(),[4,this.forwardInput(i,s)];case 2:return u=N.sent(),l=Gt(function(){return br(u)[0].expandDims()}),h={width:i.getInputWidth(0),height:i.getInputHeight(0)},[4,this.extractBoxes(l,i.getReshapedInputDimensions(0),o)];case 3:return d=N.sent(),u.dispose(),l.dispose(),f=d.map(function(C){return C.box}),m=d.map(function(C){return C.score}),v=d.map(function(C){return C.classScore}),y=d.map(function(C){return S.config.classes[C.label]}),b=cm(f.map(function(C){return C.rescale(s)}),m,this.config.iouThreshold,!0),w=b.map(function(C){return new uP(m[C],v[C],y[C],f[C],h)}),[2,w]}})})},t.prototype.getDefaultModelName=function(){return""},t.prototype.extractParamsFromWeigthMap=function(e){return llt(e,this.config)},t.prototype.extractParams=function(e){var r=this.config.filterSizes||t.DEFAULT_FILTER_SIZES,a=r?r.length:void 0;if(a!==7&&a!==8&&a!==9)throw new Error("TinyYolov2 - expected 7 | 8 | 9 convolutional filters, but found "+a+" filterSizes in config");return ilt(e,this.config,this.boxEncodingSize,r)},t.prototype.extractBoxes=function(e,r,a){return re(this,void 0,void 0,function(){var s,o,i,u,l,h,d,f,m,v,y,b,w,S,N,C,T,I,_,$,R,D,A,L,H,G,q,B,j,K=this;return ae(this,function(z){switch(z.label){case 0:return s=r.width,o=r.height,i=Math.max(s,o),u=i/s,l=i/o,h=e.shape[1],d=this.config.anchors.length,f=Gt(function(){var U=e.reshape([h,h,d,K.boxEncodingSize]),M=U.slice([0,0,0,0],[h,h,d,4]),X=U.slice([0,0,0,4],[h,h,d,1]),Q=K.withClassScores?Wi(U.slice([0,0,0,5],[h,h,d,K.config.classes.length]),3):Pt(0);return[M,X,Q]}),m=f[0],v=f[1],y=f[2],b=[],[4,v.array()];case 1:return w=z.sent(),[4,m.array()];case 2:S=z.sent(),N=0,z.label=3;case 3:if(!(N<h))return[3,12];C=0,z.label=4;case 4:if(!(C<h))return[3,11];T=0,z.label=5;case 5:return T<d?(I=mC(w[N][C][T][0]),!a||I>a?(_=(C+mC(S[N][C][T][0]))/h*u,$=(N+mC(S[N][C][T][1]))/h*l,R=Math.exp(S[N][C][T][2])*this.config.anchors[T].x/h*u,D=Math.exp(S[N][C][T][3])*this.config.anchors[T].y/h*l,A=_-R/2,L=$-D/2,H={row:N,col:C,anchor:T},this.withClassScores?[4,this.extractPredictedClass(y,H)]:[3,7]):[3,9]):[3,10];case 6:return j=z.sent(),[3,8];case 7:j={classScore:1,label:0},z.label=8;case 8:G=j,q=G.classScore,B=G.label,b.push(oa({box:new W1(A,L,A+R,L+D),score:I,classScore:I*q,label:B},H)),z.label=9;case 9:return T++,[3,5];case 10:return C++,[3,4];case 11:return N++,[3,3];case 12:return m.dispose(),v.dispose(),y.dispose(),[2,b]}})})},t.prototype.extractPredictedClass=function(e,r){return re(this,void 0,void 0,function(){var a,s,o,i;return ae(this,function(u){switch(u.label){case 0:return a=r.row,s=r.col,o=r.anchor,[4,e.array()];case 1:return i=u.sent(),[2,Array(this.config.classes.length).fill(0).map(function(l,h){return i[a][s][o][h]}).map(function(l,h){return{classScore:l,label:h}}).reduce(function(l,h){return l.classScore>h.classScore?l:h})]}})})},t.DEFAULT_FILTER_SIZES=[3,16,32,64,128,256,512,1024,1024],t})(Hi),clt=(function(n){ve(t,n);function t(e){e===void 0&&(e=!0);var r=this,a=Object.assign({},{withSeparableConvs:e,iouThreshold:Jut,classes:["face"]},e?{anchors:elt,meanRgb:nlt}:{anchors:tlt,withClassScores:!0});return r=n.call(this,a)||this,r}return Object.defineProperty(t.prototype,"withSeparableConvs",{get:function(){return this.config.withSeparableConvs},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"anchors",{get:function(){return this.config.anchors},enumerable:!0,configurable:!0}),t.prototype.locateFaces=function(e,r){return re(this,void 0,void 0,function(){var a;return ae(this,function(s){switch(s.label){case 0:return[4,this.detect(e,r)];case 1:return a=s.sent(),[2,a.map(function(o){return new Zo(o.score,o.relativeBox,{width:o.imageWidth,height:o.imageHeight})})]}})})},t.prototype.getDefaultModelName=function(){return this.withSeparableConvs?alt:rlt},t.prototype.extractParamsFromWeigthMap=function(e){return n.prototype.extractParamsFromWeigthMap.call(this,e)},t})(MP),hlt=(function(n){ve(t,n);function t(){var e=n!==null&&n.apply(this,arguments)||this;return e._name="TinyFaceDetectorOptions",e}return t})(CI),rv=(function(){function n(){}return n.prototype.then=function(t){return re(this,void 0,void 0,function(){var e;return ae(this,function(r){switch(r.label){case 0:return e=t,[4,this.run()];case 1:return[2,e.apply(void 0,[r.sent()])]}})})},n.prototype.run=function(){return re(this,void 0,void 0,function(){return ae(this,function(t){throw new Error("ComposableTask - run is not implemented")})})},n})();function j1(n,t,e,r,a){return a===void 0&&(a=function(s){var o=s.alignedRect;return o}),re(this,void 0,void 0,function(){var s,o,i,u,l;return ae(this,function(h){switch(h.label){case 0:return s=n.map(function(d){return yut(d)?a(d):d.detection}),i=r,i?[3,5]:t instanceof $n?[4,gI(t,s)]:[3,2];case 1:return u=h.sent(),[3,4];case 2:return[4,mI(t,s)];case 3:u=h.sent(),h.label=4;case 4:i=u,h.label=5;case 5:return o=i,[4,e(o)];case 6:return l=h.sent(),o.forEach(function(d){return d instanceof $n&&d.dispose()}),[2,l]}})})}function NI(n,t,e,r,a){return re(this,void 0,void 0,function(){var s=this;return ae(this,function(o){return[2,j1([n],t,function(i){return re(s,void 0,void 0,function(){return ae(this,function(u){return[2,e(i[0])]})})},r,a)]})})}function dlt(n){return Gt(function(){return ys(br(n,3).reverse(),3)})}var a0=2,pb=12;function plt(n,t){var e=H1(n,t),r=vI(n,t);function a(l,h){var d=rr(n(l));return t.push({paramPath:h}),d}function s(l,h,d){d===void 0&&(d=!1);var f=e(l[0],l[1],3,h+"/conv1"),m=a(l[1],h+"/prelu1_alpha"),v=e(l[1],l[2],3,h+"/conv2"),y=a(l[2],h+"/prelu2_alpha"),b=e(l[2],l[3],d?2:3,h+"/conv3"),w=a(l[3],h+"/prelu3_alpha");return{conv1:f,prelu1_alpha:m,conv2:v,prelu2_alpha:y,conv3:b,prelu3_alpha:w}}function o(){var l=s([3,10,16,32],"pnet"),h=e(32,2,1,"pnet/conv4_1"),d=e(32,4,1,"pnet/conv4_2");return oa(oa({},l),{conv4_1:h,conv4_2:d})}function i(){var l=s([3,28,48,64],"rnet",!0),h=r(576,128,"rnet/fc1"),d=a(128,"rnet/prelu4_alpha"),f=r(128,2,"rnet/fc2_1"),m=r(128,4,"rnet/fc2_2");return oa(oa({},l),{fc1:h,prelu4_alpha:d,fc2_1:f,fc2_2:m})}function u(){var l=s([3,32,64,64],"onet"),h=e(64,128,2,"onet/conv4"),d=a(128,"onet/prelu4_alpha"),f=r(1152,256,"onet/fc1"),m=a(256,"onet/prelu5_alpha"),v=r(256,2,"onet/fc2_1"),y=r(256,4,"onet/fc2_2"),b=r(256,10,"onet/fc2_3");return oa(oa({},l),{conv4:h,prelu4_alpha:d,fc1:f,prelu5_alpha:m,fc2_1:v,fc2_2:y,fc2_3:b})}return{extractPNetParams:o,extractRNetParams:i,extractONetParams:u}}function flt(n){var t=qi(n),e=t.extractWeights,r=t.getRemainingWeights,a=[],s=plt(e,a),o=s.extractPNetParams,i=s.extractRNetParams,u=s.extractONetParams,l=o(),h=i(),d=u();if(r().length!==0)throw new Error("weights remaing after extract: "+r().length);return{params:{pnet:l,rnet:h,onet:d},paramMappings:a}}function mlt(n,t){var e=sl(n,t);function r(h){var d=e(h+"/weights",4,h+"/filters"),f=e(h+"/bias",1);return{filters:d,bias:f}}function a(h){var d=e(h+"/weights",2),f=e(h+"/bias",1);return{weights:d,bias:f}}function s(h){return e(h,1)}function o(h){var d=r(h+"/conv1"),f=s(h+"/prelu1_alpha"),m=r(h+"/conv2"),v=s(h+"/prelu2_alpha"),y=r(h+"/conv3"),b=s(h+"/prelu3_alpha");return{conv1:d,prelu1_alpha:f,conv2:m,prelu2_alpha:v,conv3:y,prelu3_alpha:b}}function i(){var h=o("pnet"),d=r("pnet/conv4_1"),f=r("pnet/conv4_2");return oa(oa({},h),{conv4_1:d,conv4_2:f})}function u(){var h=o("rnet"),d=a("rnet/fc1"),f=s("rnet/prelu4_alpha"),m=a("rnet/fc2_1"),v=a("rnet/fc2_2");return oa(oa({},h),{fc1:d,prelu4_alpha:f,fc2_1:m,fc2_2:v})}function l(){var h=o("onet"),d=r("onet/conv4"),f=s("onet/prelu4_alpha"),m=a("onet/fc1"),v=s("onet/prelu5_alpha"),y=a("onet/fc2_1"),b=a("onet/fc2_2"),w=a("onet/fc2_3");return oa(oa({},h),{conv4:d,prelu4_alpha:f,fc1:m,prelu5_alpha:v,fc2_1:y,fc2_2:b,fc2_3:w})}return{extractPNetParams:i,extractRNetParams:u,extractONetParams:l}}function glt(n){var t=[],e=mlt(n,t),r=e.extractPNetParams,a=e.extractRNetParams,s=e.extractONetParams,o=r(),i=a(),u=s();return ji(n,t),{params:{pnet:o,rnet:i,onet:u},paramMappings:t}}function rk(n,t){var e=t[0],r=t[1];return{height:Math.floor(e*n),width:Math.floor(r*n)}}function vlt(n,t,e){for(var r=e[0],a=e[1],s=pb/n,o=[],i=Math.min(r,a)*s,u=0;i>=12;)o.push(s*Math.pow(t,u)),i=i*t,u+=1;return o}var kI=(function(n){ve(t,n);function t(e,r,a,s){return n.call(this,{left:e,top:r,right:a,bottom:s},!0)||this}return t})(Wu);function LP(n){return Gt(function(){return da(Cr(n,Pt(127.5)),Pt(.0078125))})}function Gh(n,t){return Gt(function(){return $e(Fn(n),da(t,ob(Fn(ob(n)))))})}function TI(n,t,e){return e===void 0&&(e=!1),Gt(function(){var r=no(n,t.conv1,"valid");return r=Gh(r,t.prelu1_alpha),r=Rr(r,e?[2,2]:[3,3],[2,2],"same"),r=no(r,t.conv2,"valid"),r=Gh(r,t.prelu2_alpha),r=e?r:Rr(r,[3,3],[2,2],"valid"),r=no(r,t.conv3,"valid"),r=Gh(r,t.prelu3_alpha),r})}function ylt(n,t){return Gt(function(){var e=TI(n,t,!0),r=no(e,t.conv4_1,"valid"),a=Ms(z1(r,3),3),s=Wi(Cr(r,a),3),o=no(e,t.conv4_2,"valid");return{prob:s,regions:o}})}function blt(n,t){return Gt(function(){var e=rk(t,n.shape.slice(1)),r=e.height,a=e.width,s=rI.resizeBilinear(n,[r,a]),o=LP(s);return Uu(o,[0,2,1,3])})}function xlt(n,t,e,r){for(var a=[],s=n.arraySync(),o=0;o<n.shape[0];o++)for(var i=0;i<n.shape[1];i++)s[o][i]>=r&&a.push(new Qe(i,o));var u=a.map(function(l){var h=new W1(Math.round((l.y*a0+1)/e),Math.round((l.x*a0+1)/e),Math.round((l.y*a0+pb)/e),Math.round((l.x*a0+pb)/e)),d=s[l.y][l.x],f=t.arraySync(),m=new kI(f[l.y][l.x][0],f[l.y][l.x][1],f[l.y][l.x][2],f[l.y][l.x][3]);return{cell:h,score:d,region:m}});return u}function wlt(n,t,e,r,a){a.stage1=[];var s=t.map(function(f){return Gt(function(){var m={scale:f},v=blt(n,f),y=Date.now(),b=ylt(v,r),w=b.prob,S=b.regions;m.pnet=Date.now()-y;var N=br(br(w,3)[1])[0],C=br(S)[0];return{scoresTensor:N,regionsTensor:C,scale:f,statsForScale:m}})}),o=s.map(function(f){var m=f.scoresTensor,v=f.regionsTensor,y=f.scale,b=f.statsForScale,w=xlt(m,v,y,e);if(m.dispose(),v.dispose(),!w.length)return a.stage1.push(b),[];var S=Date.now(),N=cm(w.map(function(C){return C.cell}),w.map(function(C){return C.score}),.5);return b.nms=Date.now()-S,b.numBoxes=N.length,a.stage1.push(b),N.map(function(C){return w[C]})}),i=o.reduce(function(f,m){return f.concat(m)},[]),u=[],l=[];if(i.length>0){var h=Date.now(),d=cm(i.map(function(f){return f.cell}),i.map(function(f){return f.score}),.7);a.stage1_nms=Date.now()-h,l=d.map(function(f){return i[f].score}),u=d.map(function(f){return i[f]}).map(function(f){var m=f.cell,v=f.region;return new W1(m.left+v.left*m.width,m.top+v.top*m.height,m.right+v.right*m.width,m.bottom+v.bottom*m.height).toSquare().round()})}return{boxes:u,scores:l}}function BP(n,t,e){var r=e.width,a=e.height;return re(this,void 0,void 0,function(){var s,o,i,u=this;return ae(this,function(l){switch(l.label){case 0:return s=lc(n),[4,Promise.all(t.map(function(h){return re(u,void 0,void 0,function(){var d,f,m,v,y,b,w,S;return ae(this,function(N){return d=h.padAtBorders(n.height,n.width),f=d.y,m=d.ey,v=d.x,y=d.ex,b=v-1,w=f-1,S=s.getImageData(b,w,y-b,m-w),[2,pa.isNodejs()?fI(S):createImageBitmap(S)]})})}))];case 1:return o=l.sent(),i=[],o.forEach(function(h){var d=G1({width:r,height:a}),f=lc(d);f.drawImage(h,0,0,r,a);for(var m=f.getImageData(0,0,r,a).data,v=[],y=0;y<m.length;y+=4)v.push(m[y+2]),v.push(m[y+1]),v.push(m[y]);i.push(v)}),[2,i.map(function(h){var d=Gt(function(){var f=Uu(Ba(h,[1,r,a,3]),[0,2,1,3]).toFloat();return LP(f)});return d})]}})})}function Slt(n,t){return Gt(function(){var e=TI(n,t),r=to(e,[e.shape[0],t.fc1.weights.shape[0]]),a=Ao(r,t.fc1),s=Gh(a,t.prelu4_alpha),o=Ao(s,t.fc2_1),i=Ms(z1(o,1),1),u=Wi(Cr(o,i),1),l=Ao(s,t.fc2_2),h=br(u,1)[1];return{scores:h,regions:l}})}function Clt(n,t,e,r,a){return re(this,void 0,void 0,function(){var s,o,i,u,l,h,d,f,m,v,y,b,w,S;return ae(this,function(N){switch(N.label){case 0:return s=Date.now(),[4,BP(n,t,{width:24,height:24})];case 1:return o=N.sent(),a.stage2_extractImagePatches=Date.now()-s,s=Date.now(),i=o.map(function(C){var T=Slt(C,r);return C.dispose(),T}),a.stage2_rnet=Date.now()-s,u=i.length>1?yr(i.map(function(C){return C.scores})):i[0].scores,d=(h=Array).from,[4,u.data()];case 2:return l=d.apply(h,[N.sent()]),u.dispose(),f=l.map(function(C,T){return{score:C,idx:T}}).filter(function(C){return C.score>e}).map(function(C){var T=C.idx;return T}),m=f.map(function(C){return t[C]}),v=f.map(function(C){return l[C]}),y=[],b=[],m.length>0&&(s=Date.now(),w=cm(m,v,.7),a.stage2_nms=Date.now()-s,S=w.map(function(C){var T=i[f[C]].regions.arraySync();return new kI(T[0][0],T[0][1],T[0][2],T[0][3])}),b=w.map(function(C){return v[C]}),y=w.map(function(C,T){return m[C].calibrate(S[T])})),i.forEach(function(C){C.regions.dispose(),C.scores.dispose()}),[2,{boxes:y,scores:b}]}})})}function Nlt(n,t){return Gt(function(){var e=TI(n,t);e=Rr(e,[2,2],[2,2],"same"),e=no(e,t.conv4,"valid"),e=Gh(e,t.prelu4_alpha);var r=to(e,[e.shape[0],t.fc1.weights.shape[0]]),a=Ao(r,t.fc1),s=Gh(a,t.prelu5_alpha),o=Ao(s,t.fc2_1),i=Ms(z1(o,1),1),u=Wi(Cr(o,i),1),l=Ao(s,t.fc2_2),h=Ao(s,t.fc2_3),d=br(u,1)[1];return{scores:d,regions:l,points:h}})}function klt(n,t,e,r,a){return re(this,void 0,void 0,function(){var s,o,i,u,l,h,d,f,m,v,y,b,w,S,N;return ae(this,function(C){switch(C.label){case 0:return s=Date.now(),[4,BP(n,t,{width:48,height:48})];case 1:return o=C.sent(),a.stage3_extractImagePatches=Date.now()-s,s=Date.now(),i=o.map(function(T){var I=Nlt(T,r);return T.dispose(),I}),a.stage3_onet=Date.now()-s,u=i.length>1?yr(i.map(function(T){return T.scores})):i[0].scores,d=(h=Array).from,[4,u.data()];case 2:return l=d.apply(h,[C.sent()]),u.dispose(),f=l.map(function(T,I){return{score:T,idx:I}}).filter(function(T){return T.score>e}).map(function(T){var I=T.idx;return I}),m=f.map(function(T){var I=i[T].regions.arraySync();return new kI(I[0][0],I[0][1],I[0][2],I[0][3])}),v=f.map(function(T,I){return t[T].calibrate(m[I])}),y=f.map(function(T){return l[T]}),b=[],w=[],S=[],v.length>0&&(s=Date.now(),N=cm(v,y,.7,!1),a.stage3_nms=Date.now()-s,b=N.map(function(T){return v[T]}),w=N.map(function(T){return y[T]}),S=N.map(function(T,I){return Array(5).fill(0).map(function(_,$){var R=i[T].points.arraySync();return new Qe(R[0][$]*(b[I].width+1)+b[I].left,R[0][$+5]*(b[I].height+1)+b[I].top)})})),i.forEach(function(T){T.regions.dispose(),T.scores.dispose(),T.points.dispose()}),[2,{boxes:b,scores:w,points:S}]}})})}var Tlt=(function(n){ve(t,n);function t(){return n.call(this,"Mtcnn")||this}return t.prototype.load=function(e){return re(this,void 0,void 0,function(){return ae(this,function(r){return console.warn("mtcnn is deprecated and will be removed soon"),[2,n.prototype.load.call(this,e)]})})},t.prototype.loadFromDisk=function(e){return re(this,void 0,void 0,function(){return ae(this,function(r){return console.warn("mtcnn is deprecated and will be removed soon"),[2,n.prototype.loadFromDisk.call(this,e)]})})},t.prototype.forwardInput=function(e,r){return r===void 0&&(r={}),re(this,void 0,void 0,function(){var a,s,o,i,u,l,h,d,f,m,v,y,b,w,S,N,C,T,I,_,$;return ae(this,function(R){switch(R.label){case 0:if(a=this.params,!a)throw new Error("Mtcnn - load model before inference");if(s=e.canvases[0],!s)throw new Error("Mtcnn - inputCanvas is not defined, note that passing tensors into Mtcnn.forwardInput is not supported yet.");return o={},i=Date.now(),u=Gt(function(){return dlt(Ms(lI.fromPixels(s)).toFloat())}),l=function(D){return u.dispose(),o.total=Date.now()-i,D},h=u.shape.slice(1),d=h[0],f=h[1],m=new OP(r),v=m.minFaceSize,y=m.scaleFactor,b=m.maxNumScales,w=m.scoreThresholds,S=m.scaleSteps,N=(S||vlt(v,y,[d,f])).filter(function(D){var A=rk(D,[d,f]);return Math.min(A.width,A.height)>pb}).slice(0,b),o.scales=N,o.pyramid=N.map(function(D){return rk(D,[d,f])}),C=Date.now(),[4,wlt(u,N,w[0],a.pnet,o)];case 1:return T=R.sent(),o.total_stage1=Date.now()-C,T.boxes.length?(o.stage2_numInputBoxes=T.boxes.length,C=Date.now(),[4,Clt(s,T.boxes,w[1],a.rnet,o)]):[2,l({results:[],stats:o})];case 2:return I=R.sent(),o.total_stage2=Date.now()-C,I.boxes.length?(o.stage3_numInputBoxes=I.boxes.length,C=Date.now(),[4,klt(s,I.boxes,w[2],a.onet,o)]):[2,l({results:[],stats:o})];case 3:return _=R.sent(),o.total_stage3=Date.now()-C,$=_.boxes.map(function(D,A){return xI(dI({},new Zo(_.scores[A],new hI(D.left/f,D.top/d,D.width/f,D.height/d),{height:d,width:f})),new eut(_.points[A].map(function(L){return L.sub(new Qe(D.left,D.top)).div(new Qe(D.width,D.height))}),{width:D.width,height:D.height}))}),[2,l({results:$,stats:o})]}})})},t.prototype.forward=function(e,r){return r===void 0&&(r={}),re(this,void 0,void 0,function(){var a;return ae(this,function(s){switch(s.label){case 0:return a=this.forwardInput,[4,Lr(e)];case 1:return[4,a.apply(this,[s.sent(),r])];case 2:return[2,s.sent().results]}})})},t.prototype.forwardWithStats=function(e,r){return r===void 0&&(r={}),re(this,void 0,void 0,function(){var a;return ae(this,function(s){switch(s.label){case 0:return a=this.forwardInput,[4,Lr(e)];case 1:return[2,a.apply(this,[s.sent(),r])]}})})},t.prototype.getDefaultModelName=function(){return"mtcnn_model"},t.prototype.extractParamsFromWeigthMap=function(e){return glt(e)},t.prototype.extractParams=function(e){return flt(e)},t})(Hi),Elt=.4,Ilt=[new Qe(1.603231,2.094468),new Qe(6.041143,7.080126),new Qe(2.882459,3.518061),new Qe(4.266906,5.178857),new Qe(9.041765,10.66308)],_lt=[117.001,114.697,97.404],Rlt=(function(n){ve(t,n);function t(){var e=this,r={withSeparableConvs:!0,iouThreshold:Elt,classes:["face"],anchors:Ilt,meanRgb:_lt,isFirstLayerConv2d:!0,filterSizes:[3,16,32,64,128,256,512]};return e=n.call(this,r)||this,e}return Object.defineProperty(t.prototype,"anchors",{get:function(){return this.config.anchors},enumerable:!0,configurable:!0}),t.prototype.locateFaces=function(e,r){return re(this,void 0,void 0,function(){var a;return ae(this,function(s){switch(s.label){case 0:return[4,this.detect(e,r)];case 1:return a=s.sent(),[2,a.map(function(o){return new Zo(o.score,o.relativeBox,{width:o.imageWidth,height:o.imageHeight})})]}})})},t.prototype.getDefaultModelName=function(){return"tiny_face_detector_model"},t.prototype.extractParamsFromWeigthMap=function(e){return n.prototype.extractParamsFromWeigthMap.call(this,e)},t})(MP),ps={ssdMobilenetv1:new FP,tinyFaceDetector:new Rlt,tinyYolov2:new clt,mtcnn:new Tlt,faceLandmark68Net:new IP,faceLandmark68TinyNet:new Aut,faceRecognitionNet:new But,faceExpressionNet:new vut,ageGenderNet:new Eut},zP=(function(n){ve(t,n);function t(e,r,a){var s=n.call(this)||this;return s.parentTask=e,s.input=r,s.extractedFaces=a,s}return t})(rv),EI=(function(n){ve(t,n);function t(){return n!==null&&n.apply(this,arguments)||this}return t.prototype.run=function(){return re(this,void 0,void 0,function(){var e,r,a=this;return ae(this,function(s){switch(s.label){case 0:return[4,this.parentTask];case 1:return e=s.sent(),[4,j1(e,this.input,function(o){return re(a,void 0,void 0,function(){return ae(this,function(i){switch(i.label){case 0:return[4,Promise.all(o.map(function(u){return ps.faceExpressionNet.predictExpressions(u)}))];case 1:return[2,i.sent()]}})})},this.extractedFaces)];case 2:return r=s.sent(),[2,e.map(function(o,i){return kP(o,r[i])})]}})})},t.prototype.withAgeAndGender=function(){return new AI(this,this.input)},t})(zP),II=(function(n){ve(t,n);function t(){return n!==null&&n.apply(this,arguments)||this}return t.prototype.run=function(){return re(this,void 0,void 0,function(){var e,r;return ae(this,function(a){switch(a.label){case 0:return[4,this.parentTask];case 1:return e=a.sent(),e?[4,NI(e,this.input,function(s){return ps.faceExpressionNet.predictExpressions(s)},this.extractedFaces)]:[2];case 2:return r=a.sent(),[2,kP(e,r)]}})})},t.prototype.withAgeAndGender=function(){return new DI(this,this.input)},t})(zP),_I=(function(n){ve(t,n);function t(){return n!==null&&n.apply(this,arguments)||this}return t.prototype.withAgeAndGender=function(){return new $I(this,this.input)},t.prototype.withFaceDescriptors=function(){return new FI(this,this.input)},t})(EI),RI=(function(n){ve(t,n);function t(){return n!==null&&n.apply(this,arguments)||this}return t.prototype.withAgeAndGender=function(){return new OI(this,this.input)},t.prototype.withFaceDescriptor=function(){return new MI(this,this.input)},t})(II),PP=(function(n){ve(t,n);function t(e,r,a){var s=n.call(this)||this;return s.parentTask=e,s.input=r,s.extractedFaces=a,s}return t})(rv),AI=(function(n){ve(t,n);function t(){return n!==null&&n.apply(this,arguments)||this}return t.prototype.run=function(){return re(this,void 0,void 0,function(){var e,r,a=this;return ae(this,function(s){switch(s.label){case 0:return[4,this.parentTask];case 1:return e=s.sent(),[4,j1(e,this.input,function(o){return re(a,void 0,void 0,function(){return ae(this,function(i){switch(i.label){case 0:return[4,Promise.all(o.map(function(u){return ps.ageGenderNet.predictAgeAndGender(u)}))];case 1:return[2,i.sent()]}})})},this.extractedFaces)];case 2:return r=s.sent(),[2,e.map(function(o,i){var u=r[i],l=u.age,h=u.gender,d=u.genderProbability;return DP($P(o,h,d),l)})]}})})},t.prototype.withFaceExpressions=function(){return new EI(this,this.input)},t})(PP),DI=(function(n){ve(t,n);function t(){return n!==null&&n.apply(this,arguments)||this}return t.prototype.run=function(){return re(this,void 0,void 0,function(){var e,r,a,s,o;return ae(this,function(i){switch(i.label){case 0:return[4,this.parentTask];case 1:return e=i.sent(),e?[4,NI(e,this.input,function(u){return ps.ageGenderNet.predictAgeAndGender(u)},this.extractedFaces)]:[2];case 2:return r=i.sent(),a=r.age,s=r.gender,o=r.genderProbability,[2,DP($P(e,s,o),a)]}})})},t.prototype.withFaceExpressions=function(){return new II(this,this.input)},t})(PP),$I=(function(n){ve(t,n);function t(){return n!==null&&n.apply(this,arguments)||this}return t.prototype.withFaceExpressions=function(){return new _I(this,this.input)},t.prototype.withFaceDescriptors=function(){return new FI(this,this.input)},t})(AI),OI=(function(n){ve(t,n);function t(){return n!==null&&n.apply(this,arguments)||this}return t.prototype.withFaceExpressions=function(){return new RI(this,this.input)},t.prototype.withFaceDescriptor=function(){return new MI(this,this.input)},t})(DI),VP=(function(n){ve(t,n);function t(e,r){var a=n.call(this)||this;return a.parentTask=e,a.input=r,a}return t})(rv),FI=(function(n){ve(t,n);function t(){return n!==null&&n.apply(this,arguments)||this}return t.prototype.run=function(){return re(this,void 0,void 0,function(){var e,r;return ae(this,function(a){switch(a.label){case 0:return[4,this.parentTask];case 1:return e=a.sent(),[4,j1(e,this.input,function(s){return Promise.all(s.map(function(o){return ps.faceRecognitionNet.computeFaceDescriptor(o)}))},null,function(s){return s.landmarks.align(null,{useDlibAlignment:!0})})];case 2:return r=a.sent(),[2,r.map(function(s,o){return AP(e[o],s)})]}})})},t.prototype.withFaceExpressions=function(){return new _I(this,this.input)},t.prototype.withAgeAndGender=function(){return new $I(this,this.input)},t})(VP),MI=(function(n){ve(t,n);function t(){return n!==null&&n.apply(this,arguments)||this}return t.prototype.run=function(){return re(this,void 0,void 0,function(){var e,r;return ae(this,function(a){switch(a.label){case 0:return[4,this.parentTask];case 1:return e=a.sent(),e?[4,NI(e,this.input,function(s){return ps.faceRecognitionNet.computeFaceDescriptor(s)},null,function(s){return s.landmarks.align(null,{useDlibAlignment:!0})})]:[2];case 2:return r=a.sent(),[2,AP(e,r)]}})})},t.prototype.withFaceExpressions=function(){return new RI(this,this.input)},t.prototype.withAgeAndGender=function(){return new OI(this,this.input)},t})(VP),UP=(function(n){ve(t,n);function t(e,r,a){var s=n.call(this)||this;return s.parentTask=e,s.input=r,s.useTinyLandmarkNet=a,s}return Object.defineProperty(t.prototype,"landmarkNet",{get:function(){return this.useTinyLandmarkNet?ps.faceLandmark68TinyNet:ps.faceLandmark68Net},enumerable:!0,configurable:!0}),t})(rv),Alt=(function(n){ve(t,n);function t(){return n!==null&&n.apply(this,arguments)||this}return t.prototype.run=function(){return re(this,void 0,void 0,function(){var e,r,a,s,o,i=this;return ae(this,function(u){switch(u.label){case 0:return[4,this.parentTask];case 1:return e=u.sent(),r=e.map(function(l){return l.detection}),this.input instanceof $n?[4,gI(this.input,r)]:[3,3];case 2:return s=u.sent(),[3,5];case 3:return[4,mI(this.input,r)];case 4:s=u.sent(),u.label=5;case 5:return a=s,[4,Promise.all(a.map(function(l){return i.landmarkNet.detectLandmarks(l)}))];case 6:return o=u.sent(),a.forEach(function(l){return l instanceof $n&&l.dispose()}),[2,e.map(function(l,h){return xI(l,o[h])})]}})})},t.prototype.withFaceExpressions=function(){return new _I(this,this.input)},t.prototype.withAgeAndGender=function(){return new $I(this,this.input)},t.prototype.withFaceDescriptors=function(){return new FI(this,this.input)},t})(UP),Dlt=(function(n){ve(t,n);function t(){return n!==null&&n.apply(this,arguments)||this}return t.prototype.run=function(){return re(this,void 0,void 0,function(){var e,r,a,s,o;return ae(this,function(i){switch(i.label){case 0:return[4,this.parentTask];case 1:return e=i.sent(),e?(r=e.detection,this.input instanceof $n?[4,gI(this.input,[r])]:[3,3]):[2];case 2:return s=i.sent(),[3,5];case 3:return[4,mI(this.input,[r])];case 4:s=i.sent(),i.label=5;case 5:return a=s,[4,this.landmarkNet.detectLandmarks(a[0])];case 6:return o=i.sent(),a.forEach(function(u){return u instanceof $n&&u.dispose()}),[2,xI(e,o)]}})})},t.prototype.withFaceExpressions=function(){return new RI(this,this.input)},t.prototype.withAgeAndGender=function(){return new OI(this,this.input)},t.prototype.withFaceDescriptor=function(){return new MI(this,this.input)},t})(UP),WP=(function(n){ve(t,n);function t(e,r){r===void 0&&(r=new nv);var a=n.call(this)||this;return a.input=e,a.options=r,a}return t})(rv),GP=(function(n){ve(t,n);function t(){return n!==null&&n.apply(this,arguments)||this}return t.prototype.run=function(){return re(this,void 0,void 0,function(){var e,r,a,s;return ae(this,function(o){switch(o.label){case 0:return e=this,r=e.input,a=e.options,a instanceof OP?[4,ps.mtcnn.forward(r,a)]:[3,2];case 1:return[2,o.sent().map(function(i){return i.detection})];case 2:if(s=a instanceof hlt?function(i){return ps.tinyFaceDetector.locateFaces(i,a)}:a instanceof nv?function(i){return ps.ssdMobilenetv1.locateFaces(i,a)}:a instanceof CI?function(i){return ps.tinyYolov2.locateFaces(i,a)}:null,!s)throw new Error("detectFaces - expected options to be instance of TinyFaceDetectorOptions | SsdMobilenetv1Options | MtcnnOptions | TinyYolov2Options");return[2,s(r)]}})})},t.prototype.runAndExtendWithFaceDetections=function(){var e=this;return new Promise(function(r){return re(e,void 0,void 0,function(){var a;return ae(this,function(s){switch(s.label){case 0:return[4,this.run()];case 1:return a=s.sent(),[2,r(a.map(function(o){return dI({},o)}))]}})})})},t.prototype.withFaceLandmarks=function(e){return e===void 0&&(e=!1),new Alt(this.runAndExtendWithFaceDetections(),this.input,e)},t.prototype.withFaceExpressions=function(){return new EI(this.runAndExtendWithFaceDetections(),this.input)},t.prototype.withAgeAndGender=function(){return new AI(this.runAndExtendWithFaceDetections(),this.input)},t})(WP);(function(n){ve(t,n);function t(){return n!==null&&n.apply(this,arguments)||this}return t.prototype.run=function(){return re(this,void 0,void 0,function(){var e,r;return ae(this,function(a){switch(a.label){case 0:return[4,new GP(this.input,this.options)];case 1:return e=a.sent(),r=e[0],e.forEach(function(s){s.score>r.score&&(r=s)}),[2,r]}})})},t.prototype.runAndExtendWithFaceDetection=function(){var e=this;return new Promise(function(r){return re(e,void 0,void 0,function(){var a;return ae(this,function(s){switch(s.label){case 0:return[4,this.run()];case 1:return a=s.sent(),[2,r(a?dI({},a):void 0)]}})})})},t.prototype.withFaceLandmarks=function(e){return e===void 0&&(e=!1),new Dlt(this.runAndExtendWithFaceDetection(),this.input,e)},t.prototype.withFaceExpressions=function(){return new II(this.runAndExtendWithFaceDetection(),this.input)},t.prototype.withAgeAndGender=function(){return new DI(this.runAndExtendWithFaceDetection(),this.input)},t})(WP);function $lt(n,t){return t===void 0&&(t=new nv),new GP(n,t)}function Olt(n,t){if(n.length!==t.length)throw new Error("euclideanDistance: arr1.length !== arr2.length");var e=Array.from(n),r=Array.from(t);return Math.sqrt(e.map(function(a,s){return a-r[s]}).reduce(function(a,s){return a+Math.pow(s,2)},0))}(function(){function n(t,e){e===void 0&&(e=.6),this._distanceThreshold=e;var r=Array.isArray(t)?t:[t];if(!r.length)throw new Error("FaceRecognizer.constructor - expected atleast one input");var a=1,s=function(){return"person "+a++};this._labeledDescriptors=r.map(function(o){if(o instanceof t0)return o;if(o instanceof Float32Array)return new t0(s(),[o]);if(o.descriptor&&o.descriptor instanceof Float32Array)return new t0(s(),[o.descriptor]);throw new Error("FaceRecognizer.constructor - expected inputs to be of type LabeledFaceDescriptors | WithFaceDescriptor<any> | Float32Array | Array<LabeledFaceDescriptors | WithFaceDescriptor<any> | Float32Array>")})}return Object.defineProperty(n.prototype,"labeledDescriptors",{get:function(){return this._labeledDescriptors},enumerable:!0,configurable:!0}),Object.defineProperty(n.prototype,"distanceThreshold",{get:function(){return this._distanceThreshold},enumerable:!0,configurable:!0}),n.prototype.computeMeanDistance=function(t,e){return e.map(function(r){return Olt(r,t)}).reduce(function(r,a){return r+a},0)/(e.length||1)},n.prototype.matchDescriptor=function(t){var e=this;return this.labeledDescriptors.map(function(r){var a=r.descriptors,s=r.label;return new W3(s,e.computeMeanDistance(t,a))}).reduce(function(r,a){return r.distance<a.distance?r:a})},n.prototype.findBestMatch=function(t){var e=this.matchDescriptor(t);return e.distance<this.distanceThreshold?e:new W3("unknown",e.distance)},n.prototype.toJSON=function(){return{distanceThreshold:this.distanceThreshold,labeledDescriptors:this.labeledDescriptors.map(function(t){return t.toJSON()})}},n.fromJSON=function(t){var e=t.labeledDescriptors.map(function(r){return t0.fromJSON(r)});return new n(e,t.distanceThreshold)},n})();var yC={exports:{}},X3;function Flt(){return X3||(X3=1,(function(n){var t=(function(e){var r=Object.prototype,a=r.hasOwnProperty,s=Object.defineProperty||function(z,U,M){z[U]=M.value},o,i=typeof Symbol=="function"?Symbol:{},u=i.iterator||"@@iterator",l=i.asyncIterator||"@@asyncIterator",h=i.toStringTag||"@@toStringTag";function d(z,U,M){return Object.defineProperty(z,U,{value:M,enumerable:!0,configurable:!0,writable:!0}),z[U]}try{d({},"")}catch{d=function(U,M,X){return U[M]=X}}function f(z,U,M,X){var Q=U&&U.prototype instanceof N?U:N,rt=Object.create(Q.prototype),ct=new B(X||[]);return s(rt,"_invoke",{value:L(z,M,ct)}),rt}e.wrap=f;function m(z,U,M){try{return{type:"normal",arg:z.call(U,M)}}catch(X){return{type:"throw",arg:X}}}var v="suspendedStart",y="suspendedYield",b="executing",w="completed",S={};function N(){}function C(){}function T(){}var I={};d(I,u,function(){return this});var _=Object.getPrototypeOf,$=_&&_(_(j([])));$&&$!==r&&a.call($,u)&&(I=$);var R=T.prototype=N.prototype=Object.create(I);C.prototype=T,s(R,"constructor",{value:T,configurable:!0}),s(T,"constructor",{value:C,configurable:!0}),C.displayName=d(T,h,"GeneratorFunction");function D(z){["next","throw","return"].forEach(function(U){d(z,U,function(M){return this._invoke(U,M)})})}e.isGeneratorFunction=function(z){var U=typeof z=="function"&&z.constructor;return U?U===C||(U.displayName||U.name)==="GeneratorFunction":!1},e.mark=function(z){return Object.setPrototypeOf?Object.setPrototypeOf(z,T):(z.__proto__=T,d(z,h,"GeneratorFunction")),z.prototype=Object.create(R),z},e.awrap=function(z){return{__await:z}};function A(z,U){function M(rt,ct,pt,yt){var Tt=m(z[rt],z,ct);if(Tt.type==="throw")yt(Tt.arg);else{var gt=Tt.arg,Rt=gt.value;return Rt&&typeof Rt=="object"&&a.call(Rt,"__await")?U.resolve(Rt.__await).then(function(At){M("next",At,pt,yt)},function(At){M("throw",At,pt,yt)}):U.resolve(Rt).then(function(At){gt.value=At,pt(gt)},function(At){return M("throw",At,pt,yt)})}}var X;function Q(rt,ct){function pt(){return new U(function(yt,Tt){M(rt,ct,yt,Tt)})}return X=X?X.then(pt,pt):pt()}s(this,"_invoke",{value:Q})}D(A.prototype),d(A.prototype,l,function(){return this}),e.AsyncIterator=A,e.async=function(z,U,M,X,Q){Q===void 0&&(Q=Promise);var rt=new A(f(z,U,M,X),Q);return e.isGeneratorFunction(U)?rt:rt.next().then(function(ct){return ct.done?ct.value:rt.next()})};function L(z,U,M){var X=v;return function(rt,ct){if(X===b)throw new Error("Generator is already running");if(X===w){if(rt==="throw")throw ct;return K()}for(M.method=rt,M.arg=ct;;){var pt=M.delegate;if(pt){var yt=H(pt,M);if(yt){if(yt===S)continue;return yt}}if(M.method==="next")M.sent=M._sent=M.arg;else if(M.method==="throw"){if(X===v)throw X=w,M.arg;M.dispatchException(M.arg)}else M.method==="return"&&M.abrupt("return",M.arg);X=b;var Tt=m(z,U,M);if(Tt.type==="normal"){if(X=M.done?w:y,Tt.arg===S)continue;return{value:Tt.arg,done:M.done}}else Tt.type==="throw"&&(X=w,M.method="throw",M.arg=Tt.arg)}}}function H(z,U){var M=U.method,X=z.iterator[M];if(X===o)return U.delegate=null,M==="throw"&&z.iterator.return&&(U.method="return",U.arg=o,H(z,U),U.method==="throw")||M!=="return"&&(U.method="throw",U.arg=new TypeError("The iterator does not provide a '"+M+"' method")),S;var Q=m(X,z.iterator,U.arg);if(Q.type==="throw")return U.method="throw",U.arg=Q.arg,U.delegate=null,S;var rt=Q.arg;if(!rt)return U.method="throw",U.arg=new TypeError("iterator result is not an object"),U.delegate=null,S;if(rt.done)U[z.resultName]=rt.value,U.next=z.nextLoc,U.method!=="return"&&(U.method="next",U.arg=o);else return rt;return U.delegate=null,S}D(R),d(R,h,"Generator"),d(R,u,function(){return this}),d(R,"toString",function(){return"[object Generator]"});function G(z){var U={tryLoc:z[0]};1 in z&&(U.catchLoc=z[1]),2 in z&&(U.finallyLoc=z[2],U.afterLoc=z[3]),this.tryEntries.push(U)}function q(z){var U=z.completion||{};U.type="normal",delete U.arg,z.completion=U}function B(z){this.tryEntries=[{tryLoc:"root"}],z.forEach(G,this),this.reset(!0)}e.keys=function(z){var U=Object(z),M=[];for(var X in U)M.push(X);return M.reverse(),function Q(){for(;M.length;){var rt=M.pop();if(rt in U)return Q.value=rt,Q.done=!1,Q}return Q.done=!0,Q}};function j(z){if(z){var U=z[u];if(U)return U.call(z);if(typeof z.next=="function")return z;if(!isNaN(z.length)){var M=-1,X=function Q(){for(;++M<z.length;)if(a.call(z,M))return Q.value=z[M],Q.done=!1,Q;return Q.value=o,Q.done=!0,Q};return X.next=X}}return{next:K}}e.values=j;function K(){return{value:o,done:!0}}return B.prototype={constructor:B,reset:function(z){if(this.prev=0,this.next=0,this.sent=this._sent=o,this.done=!1,this.delegate=null,this.method="next",this.arg=o,this.tryEntries.forEach(q),!z)for(var U in this)U.charAt(0)==="t"&&a.call(this,U)&&!isNaN(+U.slice(1))&&(this[U]=o)},stop:function(){this.done=!0;var z=this.tryEntries[0],U=z.completion;if(U.type==="throw")throw U.arg;return this.rval},dispatchException:function(z){if(this.done)throw z;var U=this;function M(yt,Tt){return rt.type="throw",rt.arg=z,U.next=yt,Tt&&(U.method="next",U.arg=o),!!Tt}for(var X=this.tryEntries.length-1;X>=0;--X){var Q=this.tryEntries[X],rt=Q.completion;if(Q.tryLoc==="root")return M("end");if(Q.tryLoc<=this.prev){var ct=a.call(Q,"catchLoc"),pt=a.call(Q,"finallyLoc");if(ct&&pt){if(this.prev<Q.catchLoc)return M(Q.catchLoc,!0);if(this.prev<Q.finallyLoc)return M(Q.finallyLoc)}else if(ct){if(this.prev<Q.catchLoc)return M(Q.catchLoc,!0)}else if(pt){if(this.prev<Q.finallyLoc)return M(Q.finallyLoc)}else throw new Error("try statement without catch or finally")}}},abrupt:function(z,U){for(var M=this.tryEntries.length-1;M>=0;--M){var X=this.tryEntries[M];if(X.tryLoc<=this.prev&&a.call(X,"finallyLoc")&&this.prev<X.finallyLoc){var Q=X;break}}Q&&(z==="break"||z==="continue")&&Q.tryLoc<=U&&U<=Q.finallyLoc&&(Q=null);var rt=Q?Q.completion:{};return rt.type=z,rt.arg=U,Q?(this.method="next",this.next=Q.finallyLoc,S):this.complete(rt)},complete:function(z,U){if(z.type==="throw")throw z.arg;return z.type==="break"||z.type==="continue"?this.next=z.arg:z.type==="return"?(this.rval=this.arg=z.arg,this.method="return",this.next="end"):z.type==="normal"&&U&&(this.next=U),S},finish:function(z){for(var U=this.tryEntries.length-1;U>=0;--U){var M=this.tryEntries[U];if(M.finallyLoc===z)return this.complete(M.completion,M.afterLoc),q(M),S}},catch:function(z){for(var U=this.tryEntries.length-1;U>=0;--U){var M=this.tryEntries[U];if(M.tryLoc===z){var X=M.completion;if(X.type==="throw"){var Q=X.arg;q(M)}return Q}}throw new Error("illegal catch attempt")},delegateYield:function(z,U,M){return this.delegate={iterator:j(z),resultName:U,nextLoc:M},this.method==="next"&&(this.arg=o),S}},e})(n.exports);try{regeneratorRuntime=t}catch{typeof globalThis=="object"?globalThis.regeneratorRuntime=t:Function("r","regeneratorRuntime = r")(t)}})(yC)),yC.exports}var bC,Y3;function LI(){return Y3||(Y3=1,bC=(n,t)=>`${n}-${t}-${Math.random().toString(16).slice(3,8)}`),bC}var xC,Q3;function HP(){if(Q3)return xC;Q3=1;const n=LI();let t=0;return xC=({id:e,action:r,payload:a={}})=>{let s=e;return typeof s>"u"&&(s=n("Job",t),t+=1),{id:s,action:r,payload:a}},xC}var If={},Z3;function BI(){if(Z3)return If;Z3=1;let n=!1;return If.logging=n,If.setLogging=t=>{n=t},If.log=(...t)=>n?console.log.apply(this,t):null,If}var wC,J3;function Mlt(){if(J3)return wC;J3=1;const n=HP(),{log:t}=BI(),e=LI();let r=0;return wC=()=>{const a=e("Scheduler",r),s={},o={};let i=[];r+=1;const u=()=>i.length,l=()=>Object.keys(s).length,h=()=>{if(i.length!==0){const y=Object.keys(s);for(let b=0;b<y.length;b+=1)if(typeof o[y[b]]>"u"){i[0](s[y[b]]);break}}},d=(y,b)=>new Promise((w,S)=>{const N=n({action:y,payload:b});i.push(async C=>{i.shift(),o[C.id]=N;try{w(await C[y].apply(this,[...b,N.id]))}catch(T){S(T)}finally{delete o[C.id],h()}}),t(`[${a}]: Add ${N.id} to JobQueue`),t(`[${a}]: JobQueue length=${i.length}`),h()});return{addWorker:y=>(s[y.id]=y,t(`[${a}]: Add ${y.id}`),t(`[${a}]: Number of workers=${l()}`),h(),y.id),addJob:async(y,...b)=>{if(l()===0)throw Error(`[${a}]: You need to have at least one worker before adding jobs`);return d(y,b)},terminate:async()=>{Object.keys(s).forEach(async y=>{await s[y].terminate()}),i=[]},getQueueLen:u,getNumWorkers:l}},wC}function Llt(n){throw new Error('Could not dynamically require "'+n+'". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.')}var SC,tF;function Blt(){return tF||(tF=1,SC=n=>{const t={};return typeof WorkerGlobalScope<"u"?t.type="webworker":typeof document=="object"?t.type="browser":typeof process=="object"&&typeof Llt=="function"&&(t.type="node"),typeof n>"u"?t:t[n]}),SC}var CC,eF;function zlt(){if(eF)return CC;eF=1;const t=Blt()("type")==="browser"?e=>new URL(e,window.location.href).href:e=>e;return CC=e=>{const r={...e};return["corePath","workerPath","langPath"].forEach(a=>{e[a]&&(r[a]=t(r[a]))}),r},CC}var NC,nF;function jP(){return nF||(nF=1,NC={TESSERACT_ONLY:0,LSTM_ONLY:1,TESSERACT_LSTM_COMBINED:2,DEFAULT:3}),NC}const Plt="7.0.0",Vlt={version:Plt};var kC,rF;function Ult(){return rF||(rF=1,kC={workerBlobURL:!0,logger:()=>{}}),kC}var TC,aF;function Wlt(){if(aF)return TC;aF=1;const n=Vlt.version;return TC={...Ult(),workerPath:`https://cdn.jsdelivr.net/npm/tesseract.js@v${n}/dist/worker.min.js`},TC}var EC,sF;function Glt(){return sF||(sF=1,EC=({workerPath:n,workerBlobURL:t})=>{let e;if(Blob&&URL&&t){const r=new Blob([`importScripts("${n}");`],{type:"application/javascript"});e=new Worker(URL.createObjectURL(r))}else e=new Worker(n);return e}),EC}var IC,oF;function Hlt(){return oF||(oF=1,IC=n=>{n.terminate()}),IC}var _C,iF;function jlt(){return iF||(iF=1,_C=(n,t)=>{n.onmessage=({data:e})=>{t(e)}}),_C}var RC,uF;function qlt(){return uF||(uF=1,RC=async(n,t)=>{n.postMessage(t)}),RC}var AC,lF;function Klt(){if(lF)return AC;lF=1;const n=e=>new Promise((r,a)=>{const s=new FileReader;s.onload=()=>{r(s.result)},s.onerror=({target:{error:{code:o}}})=>{a(Error(`File could not be read! Code=${o}`))},s.readAsArrayBuffer(e)}),t=async e=>{let r=e;if(typeof e>"u")return"undefined";if(typeof e=="string")/data:image\/([a-zA-Z]*);base64,([^"]*)/.test(e)?r=atob(e.split(",")[1]).split("").map(a=>a.charCodeAt(0)):r=await(await fetch(e)).arrayBuffer();else if(typeof HTMLElement<"u"&&e instanceof HTMLElement)e.tagName==="IMG"&&(r=await t(e.src)),e.tagName==="VIDEO"&&(r=await t(e.poster)),e.tagName==="CANVAS"&&await new Promise(a=>{e.toBlob(async s=>{r=await n(s),a()})});else if(typeof OffscreenCanvas<"u"&&e instanceof OffscreenCanvas){const a=await e.convertToBlob();r=await n(a)}else(e instanceof File||e instanceof Blob)&&(r=await n(e));return new Uint8Array(r)};return AC=t,AC}var DC,cF;function Xlt(){if(cF)return DC;cF=1;const n=Wlt(),t=Glt(),e=Hlt(),r=jlt(),a=qlt(),s=Klt();return DC={defaultOptions:n,spawnWorker:t,terminateWorker:e,onMessage:r,send:a,loadImage:s},DC}var $C,hF;function qP(){if(hF)return $C;hF=1;const n=zlt(),t=HP(),{log:e}=BI(),r=LI(),a=jP(),{defaultOptions:s,spawnWorker:o,terminateWorker:i,onMessage:u,loadImage:l,send:h}=Xlt();let d=0;return $C=async(f="eng",m=a.LSTM_ONLY,v={},y={})=>{const b=r("Worker",d),{logger:w,errorHandler:S,...N}=n({...s,...v}),C={},T=typeof f=="string"?f.split("+"):f;let I=m,_=y;const $=[a.DEFAULT,a.LSTM_ONLY].includes(m)&&!N.legacyCore;let R,D;const A=new Promise((gt,Rt)=>{D=gt,R=Rt}),L=gt=>{R(gt.message)};let H=o(N);H.onerror=L,d+=1;const G=({id:gt,action:Rt,payload:At})=>new Promise((Lt,Mt)=>{e(`[${b}]: Start ${gt}, action=${Rt}`);const Wt=`${Rt}-${gt}`;C[Wt]={resolve:Lt,reject:Mt},h(H,{workerId:b,jobId:gt,action:Rt,payload:At})}),q=()=>console.warn("`load` is depreciated and should be removed from code (workers now come pre-loaded)"),B=gt=>G(t({id:gt,action:"load",payload:{options:{lstmOnly:$,corePath:N.corePath,logging:N.logging}}})),j=(gt,Rt,At)=>G(t({id:At,action:"FS",payload:{method:"writeFile",args:[gt,Rt]}})),K=(gt,Rt)=>G(t({id:Rt,action:"FS",payload:{method:"readFile",args:[gt,{encoding:"utf8"}]}})),z=(gt,Rt)=>G(t({id:Rt,action:"FS",payload:{method:"unlink",args:[gt]}})),U=(gt,Rt,At)=>G(t({id:At,action:"FS",payload:{method:gt,args:Rt}})),M=(gt,Rt)=>G(t({id:Rt,action:"loadLanguage",payload:{langs:gt,options:{langPath:N.langPath,dataPath:N.dataPath,cachePath:N.cachePath,cacheMethod:N.cacheMethod,gzip:N.gzip,lstmOnly:[a.DEFAULT,a.LSTM_ONLY].includes(I)&&!N.legacyLang}}})),X=(gt,Rt,At,Lt)=>G(t({id:Lt,action:"initialize",payload:{langs:gt,oem:Rt,config:At}})),Q=(gt="eng",Rt,At,Lt)=>{if($&&[a.TESSERACT_ONLY,a.TESSERACT_LSTM_COMBINED].includes(Rt))throw Error("Legacy model requested but code missing.");const Mt=Rt||I;I=Mt;const Wt=At||_;_=Wt;const Xt=(typeof gt=="string"?gt.split("+"):gt).filter(Se=>!T.includes(Se));return T.push(...Xt),Xt.length>0?M(Xt,Lt).then(()=>X(gt,Mt,Wt,Lt)):X(gt,Mt,Wt,Lt)},rt=(gt={},Rt)=>G(t({id:Rt,action:"setParameters",payload:{params:gt}})),ct=async(gt,Rt={},At={text:!0},Lt)=>G(t({id:Lt,action:"recognize",payload:{image:await l(gt),options:Rt,output:At}})),pt=async(gt,Rt)=>{if($)throw Error("`worker.detect` requires Legacy model, which was not loaded.");return G(t({id:Rt,action:"detect",payload:{image:await l(gt)}}))},yt=async()=>(H!==null&&(i(H),H=null),Promise.resolve());u(H,({workerId:gt,jobId:Rt,status:At,action:Lt,data:Mt})=>{const Wt=`${Lt}-${Rt}`;if(At==="resolve")e(`[${gt}]: Complete ${Rt}`),C[Wt].resolve({jobId:Rt,data:Mt}),delete C[Wt];else if(At==="reject")if(C[Wt].reject(Mt),delete C[Wt],Lt==="load"&&R(Mt),S)S(Mt);else throw Error(Mt);else At==="progress"&&w({...Mt,userJobId:Rt})});const Tt={id:b,worker:H,load:q,writeText:j,readText:K,removeFile:z,FS:U,reinitialize:Q,setParameters:rt,recognize:ct,detect:pt,terminate:yt};return B().then(()=>M(f)).then(()=>X(f,m,y)).then(()=>D(Tt)).catch(()=>{}),A},$C}var OC,dF;function Ylt(){if(dF)return OC;dF=1;const n=qP();return OC={recognize:async(r,a,s)=>{const o=await n(a,1,s);return o.recognize(r).finally(async()=>{await o.terminate()})},detect:async(r,a)=>{const s=await n("osd",0,a);return s.detect(r).finally(async()=>{await s.terminate()})}},OC}var FC,pF;function Qlt(){return pF||(pF=1,FC={AFR:"afr",AMH:"amh",ARA:"ara",ASM:"asm",AZE:"aze",AZE_CYRL:"aze_cyrl",BEL:"bel",BEN:"ben",BOD:"bod",BOS:"bos",BUL:"bul",CAT:"cat",CEB:"ceb",CES:"ces",CHI_SIM:"chi_sim",CHI_TRA:"chi_tra",CHR:"chr",CYM:"cym",DAN:"dan",DEU:"deu",DZO:"dzo",ELL:"ell",ENG:"eng",ENM:"enm",EPO:"epo",EST:"est",EUS:"eus",FAS:"fas",FIN:"fin",FRA:"fra",FRK:"frk",FRM:"frm",GLE:"gle",GLG:"glg",GRC:"grc",GUJ:"guj",HAT:"hat",HEB:"heb",HIN:"hin",HRV:"hrv",HUN:"hun",IKU:"iku",IND:"ind",ISL:"isl",ITA:"ita",ITA_OLD:"ita_old",JAV:"jav",JPN:"jpn",KAN:"kan",KAT:"kat",KAT_OLD:"kat_old",KAZ:"kaz",KHM:"khm",KIR:"kir",KOR:"kor",KUR:"kur",LAO:"lao",LAT:"lat",LAV:"lav",LIT:"lit",MAL:"mal",MAR:"mar",MKD:"mkd",MLT:"mlt",MSA:"msa",MYA:"mya",NEP:"nep",NLD:"nld",NOR:"nor",ORI:"ori",PAN:"pan",POL:"pol",POR:"por",PUS:"pus",RON:"ron",RUS:"rus",SAN:"san",SIN:"sin",SLK:"slk",SLV:"slv",SPA:"spa",SPA_OLD:"spa_old",SQI:"sqi",SRP:"srp",SRP_LATN:"srp_latn",SWA:"swa",SWE:"swe",SYR:"syr",TAM:"tam",TEL:"tel",TGK:"tgk",TGL:"tgl",THA:"tha",TIR:"tir",TUR:"tur",UIG:"uig",UKR:"ukr",URD:"urd",UZB:"uzb",UZB_CYRL:"uzb_cyrl",VIE:"vie",YID:"yid"}),FC}var MC,fF;function Zlt(){return fF||(fF=1,MC={OSD_ONLY:"0",AUTO_OSD:"1",AUTO_ONLY:"2",AUTO:"3",SINGLE_COLUMN:"4",SINGLE_BLOCK_VERT_TEXT:"5",SINGLE_BLOCK:"6",SINGLE_LINE:"7",SINGLE_WORD:"8",CIRCLE_WORD:"9",SINGLE_CHAR:"10",SPARSE_TEXT:"11",SPARSE_TEXT_OSD:"12",RAW_LINE:"13"}),MC}var LC,mF;function Jlt(){if(mF)return LC;mF=1,Flt();const n=Mlt(),t=qP(),e=Ylt(),r=Qlt(),a=jP(),s=Zlt(),{setLogging:o}=BI();return LC={languages:r,OEM:a,PSM:s,createScheduler:n,createWorker:t,setLogging:o,...e},LC}var tct=Jlt();const ect=bm(tct);const KP={kernelName:xm,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>et(n,wc(Ft(e,"float32"),-1))}}};const nct={kernelName:hd,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>{const r=an(Ft(e,"float32")),a=wr(zt(Jt(1),r));return mn(Ut(n,a))}}}};const rct={kernelName:dd,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>{const r=wr(zt(an(Ft(e,"float32")),1));return Ut(n,r)}}}};const act={kernelName:yc,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,r]=t,a=me(e.shape,r.shape);return{a:()=>{let i=n;const u=Zn(e.shape,a);return u.length>0&&(i=jt(i,u)),at(i,e.shape)},b:()=>{let i=n;const u=Zn(r.shape,a);return u.length>0&&(i=jt(i,u)),at(i,r.shape)}}}};const sct={kernelName:wm,saveAllInputs:!0,gradFunc:(n,t)=>{const e={};return t.forEach((r,a)=>{e[a]=()=>n.clone()}),e}};const oct={kernelName:Sm,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Be(e)}}};const ict={kernelName:Cm,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Be(e)}}};const uct={kernelName:pd,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Ut(n,wr(zt(Jt(1),an(Ft(e,"float32")))))}}};const lct={kernelName:fd,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>{const r=wr(It(Jt(1),an(Ft(e,"float32"))));return Ut(n,r)}}}};const cct={kernelName:vd,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,r]=t,a=me(e.shape,r.shape);return{a:()=>{const i=It(an(e),an(r));let u=et(n,Ut(r,i));const l=Zn(e.shape,a);return l.length>0&&(u=jt(u,l)),at(u,e.shape)},b:()=>{const i=It(an(e),an(r));let u=mn(et(n,Ut(e,i)));const l=Zn(r.shape,a);return l.length>0&&(u=jt(u,l)),at(u,r.shape)}}}};const hct={kernelName:md,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Ut(n,It(an(Ft(e,"float32")),1))}}};const dct={kernelName:gd,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Ut(n,zt(Jt(1),an(Ft(e,"float32"))))}}};function pct(n,t,e,r,a,s){const o=V(n,"dy","avgPool3dGrad"),i=V(t,"input","avgPool3dGrad");let u=o,l=i,h=!1;i.rank===4&&(h=!0,u=at(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),l=at(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),P(u.rank===5,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${u.rank}.`),P(l.rank===5,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${l.rank}.`),ma("avgPool3dGrad",a,s);const d={dy:u,input:l},f={filterSize:e,strides:r,pad:a,dimRoundingMode:s},m=J.runKernel(Bb,d,f);return h?at(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}const fct=tt({avgPool3dGrad_:pct});const mct={kernelName:km,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[r]=t,{filterSize:a,strides:s,pad:o,dimRoundingMode:i}=e;return{x:()=>fct(n,r,a,s,o,i)}}};function gct(n,t,e,r,a){const s=V(n,"dy","avgPoolGrad"),o=V(t,"input","avgPoolGrad");P(o.rank===s.rank,()=>`Rank of input (${o.rank}) does not match rank of dy (${s.rank})`);let i=o,u=s,l=!1;o.rank===3&&(l=!0,i=at(o,[1,o.shape[0],o.shape[1],o.shape[2]]),u=at(s,[1,s.shape[0],s.shape[1],s.shape[2]])),P(u.rank===4,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${u.rank}.`),P(i.rank===4,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${i.rank}.`);const h={dy:u,input:i},d={filterSize:e,strides:r,pad:a},f=J.runKernel(Lb,h,d);return l?at(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const vct=tt({avgPoolGrad_:gct});const yct={kernelName:Nm,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[r]=t,{filterSize:a,strides:s,pad:o}=e;return{x:()=>vct(n,r,a,s,o)}}};const bct={kernelName:Tm,inputsToSave:["a","b"],gradFunc:(n,t,e)=>{const[r,a]=t,{transposeA:s,transposeB:o}=e;return!s&&!o?{a:()=>xe(n,a,!1,!0),b:()=>xe(r,n,!0,!1)}:!s&&o?{a:()=>xe(n,a,!1,!1),b:()=>xe(n,r,!0,!1)}:s&&!o?{a:()=>xe(a,n,!1,!0),b:()=>xe(r,n,!1,!1)}:{a:()=>xe(a,n,!0,!0),b:()=>xe(n,r,!0,!0)}}};const xct={kernelName:Em,gradFunc:(n,t,e)=>{const{blockShape:r,crops:a}=e;return{x:()=>Lg(n,r,a)}}};const wct={kernelName:jM,gradFunc:(n,t,e)=>{const r=e,a=r.inputShape,s=r.shape,o=Array.from(s);for(let u=a.length-1;u>=0;u--)if(a[u]===s[u])o[u]=1;else if(a[u]!==1)throw new Error(`broadcastTo(): [${a}] cannot be broadcast to [${s}].`);const i=[];for(let u=0;u<o.length;u++)o[u]>1&&i.push(u);return{x:()=>jt(n,i,!0)}}};const Sct={kernelName:yd,gradFunc:n=>({x:()=>n.clone()})};const Cct={kernelName:bd,gradFunc:n=>({x:()=>Be(n)})};const Nct={kernelName:xd,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[r]=t,{clipValueMin:a,clipValueMax:s}=e;return{x:()=>Or(ao(Bi(r,a),tl(r,s)),n,Be(n))}}};const kct={kernelName:_m,inputsToSave:["x"],gradFunc:KP.gradFunc};const Tct={kernelName:Rm,saveAllInputs:!0,gradFunc:(n,t,e)=>{const r=t.map(u=>u.shape),{axis:a}=e,s=_e(a,t[0].shape)[0],o=r.map(u=>u[s]);return wa(n,o,s).map(u=>()=>u)}};const Ect={kernelName:Am,inputsToSave:["x","filter"],gradFunc:(n,t,e)=>{const[r,a]=t,{dilations:s,strides:o,pad:i,dataFormat:u}=e;return P(zu(s),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`),{x:()=>uT(r.shape,n,a,o,i,u),filter:()=>HT(r,n,a.shape,o,i,u)}}};const Ict={kernelName:Dm,inputsToSave:["dy","filter"],gradFunc:(n,t,e)=>{const[r,a]=t,{strides:s,pad:o,dataFormat:i,dimRoundingMode:u}=e;return{dy:()=>Ri(n,a,s,o,i,1,u),filter:()=>HT(n,r,a.shape,s,o,i,u)}}};function _ct(n,t,e,r,a){let s=n;n.rank===4&&(s=at(n,[1,n.shape[0],n.shape[1],n.shape[2],n.shape[3]]));let o=t;o.rank===4&&(o=at(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),P(s.rank===5,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${s.shape}.`),P(o.rank===5,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${o.shape}.`),P(e.length===5,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${e}.`),P(s.shape[4]===e[3],()=>`Error in conv3dDerFilter: depth of input ${s.shape[4]}) must match input depth in filter (${e[3]}.`),P(o.shape[4]===e[4],()=>`Error in conv3dDerFilter: depth of dy (${o.shape[4]}) must match output depth for filter (${e[4]}).`);const i={x:s,dy:o},u={strides:r,pad:a,filterShape:e};return J.runKernel(Wb,i,u)}const Rct=tt({conv3DBackpropFilter_:_ct});const Act={kernelName:$m,inputsToSave:["x","filter"],gradFunc:(n,t,e)=>{const{dilations:r,strides:a,pad:s}=e;P(zu(r),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`);const[o,i]=t;return{x:()=>kL(o.shape,n,i,a,s),filter:()=>Rct(o,n,i.shape,a,s)}}};const Dct={kernelName:wd,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>et(mn(u1(Ft(e,"float32"))),n)}}};const $ct={kernelName:Sd,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>et(l1(Ft(e,"float32")),n)}}};const Oct={kernelName:Om,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[r]=t,{axis:a,exclusive:s,reverse:o}=e;return{x:()=>{const i=An([a],r.rank);let u=Kx(n,a,s,!o);return i!=null&&(u=Oe(u,i)),u}}}};const Fct={kernelName:Fm,inputsToSave:["x","filter"],gradFunc:(n,t,e)=>{const{dilations:r,strides:a,pad:s,dimRoundingMode:o}=e,i=r??[1,1];P(zu(i),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${i}'`);const[u,l]=t;return P(u.rank===4,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${u.rank}.`),P(l.rank===4,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${l.rank}.`),P(u.shape[3]===l.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${u.shape[3]}) must match the inChannels dimension in filter ${l.shape[2]}.`),P(zr(a,i),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${a} and dilations '${i}'.`),ma("depthwiseConv2d",s,o),{x:()=>f4(u.shape,n,l,a,s,i,o),filter:()=>p4(u,n,l.shape,a,s,i,o)}}};const Mct={kernelName:Mm,inputsToSave:["x","filter"],gradFunc:(n,t,e)=>{const[r,a]=t,s={x:r,filter:a,dy:n},o={x:r,filter:a,dy:n};return{x:()=>J.runKernel(F0,s,e),filter:()=>J.runKernel(M0,o,e)}}};const Lct={kernelName:Nd,outputsToSave:[!0],gradFunc:(n,t)=>{const[e]=t,r={dy:n,y:e};return{x:()=>J.runKernel(tx,r)}}};const Bct={kernelName:kd,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t,r=et(ka(mn(an(e))),2/Math.sqrt(Math.PI));return{x:()=>et(n,r)}}};const zct={kernelName:Td,outputsToSave:[!0],gradFunc:(n,t)=>{const[e]=t;return{x:()=>et(n,e)}}};const Pct={kernelName:Bm,inputsToSave:["input"],gradFunc:(n,t)=>{const[e]=t;return{input:()=>at(n,e.shape)}}};const Vct={kernelName:Ed,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>et(n,ka(e))}}};const Uct={kernelName:Id,gradFunc:n=>({x:()=>Be(n)})};const Wct={kernelName:_d,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,r]=t,a=me(e.shape,r.shape);return{a:()=>{const i=Ut(n,Ft(r,"float32")),u=Zn(e.shape,a);return u.length>0?at(jt(i,u),e.shape):i},b:()=>{let i=et(n,Ft(e,"float32"));const u=Zn(r.shape,a);u.length>0&&(i=at(jt(i,u),r.shape));const l=an(r);return mn(Ut(i,Ft(l,"float32")))}}}};const Gct={kernelName:zm,inputsToSave:["x","mean","variance","scale"],gradFunc:(n,t,e)=>{const{varianceEpsilon:r}=e,[a,s,o,i]=t,u=i??Jt(1),l=Zn(s.shape,a.shape),h=[];if(s.rank===1){for(let C=0;C<a.shape.length-1;++C)h.push(a.shape[C]);h.push(1)}const d=zt(a,s),f=et(n,u),m=s1(It(o,Jt(r))),v=et(et(et(m,m),m),Jt(-.5));return{x:()=>s.rank===1?at(et(et(n,ls(at(m,[1,1,1,s.shape[0]]),h)),u),a.shape):at(et(et(n,m),u),a.shape),mean:()=>{let C=et(et(m,Jt(-1)),f);return s.rank===1&&(C=jt(C,l)),at(C,s.shape)},variance:()=>{let C=et(et(v,d),f);return s.rank===1&&(C=jt(C,l)),at(C,s.shape)},scale:()=>{const C=et(d,m);let T=et(n,C);return s.rank===1&&(T=jt(T,l)),at(T,s.shape)},offset:()=>{let C=n;return s.rank===1&&(C=jt(C,l)),at(C,s.shape)}}}};const Hct={kernelName:Pm,inputsToSave:["x","indices"],gradFunc:(n,t,e)=>{const[r,a]=t,{axis:s,batchDims:o}=e,i=_e(s,r.shape)[0],u=(l,h,d)=>()=>{const f=l.shape,m=h.size,v=f.slice(0,i),y=v.length,b=f.slice(s,f.length).slice(1),w=b.length,S=gF(0,y),N=gF(y+1,y+1+w),C=vF([v,[m],b]),T=at(d,C),I=at(h,[m]),_=vF([[y],S,N]),$=Oe(T,_);let R=m1($,I,l.shape[i]);const D=Ju(_);return R=Oe(R,D),R};if(o===1){const l=r.shape[0],h=r.split(l,0);return{x:()=>Ta(h.map((m,v)=>u(m,a.slice(v,1),n.slice(v,1))())).reshape(r.shape),indices:()=>a}}else return{x:u(r,a,n),indices:()=>a}}};function gF(n,t){const e=[];for(let r=n;r<t;++r)e.push(r);return e}function vF(n){const t=[];for(let e=0;e<n.length;++e)for(let r=0;r<n[e].length;++r)t.push(n[e][r]);return t}const jct={kernelName:Rd,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,r]=t;return{a:()=>Be(e),b:()=>Be(r)}}};const qct={kernelName:Ad,gradFunc:n=>({x:()=>Ft(n,"float32")})};const Kct={kernelName:Dd,gradFunc:n=>({x:()=>Be(n)})};const Xct={kernelName:$d,gradFunc:n=>({x:()=>Be(n)})};const Yct={kernelName:Od,gradFunc:n=>({x:()=>Be(n)})};const Qct={kernelName:Um,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[r]=t,{alpha:a}=e,s=ga(r,0);return{x:()=>Or(s,n,et(n,a))}}};const Zct={kernelName:Md,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Ut(n,It(e,1))}}};const Jct={kernelName:Fd,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Ut(n,Ft(e,"float32"))}}};const tht={kernelName:qM,inputsToSave:[],outputsToSave:[!0],gradFunc:(n,t,e)=>{const[r]=t,{axis:a}=e;return{logits:()=>{const o=ka(r);return zt(n,et(jt(n,a,!0),o))}}}};function eht(n,t,e,r=5,a=1,s=1,o=.5){const i={x:n,y:t,dy:e},u={depthRadius:r,bias:a,alpha:s,beta:o};return J.runKernel(ux,i,u)}const nht=tt({localResponseNormalizationBackprop_:eht});const rht={kernelName:Km,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const[r,a]=t,{depthRadius:s,bias:o,alpha:i,beta:u}=e;return{x:()=>nht(r,a,n,s,o,i,u)}}};function XP(n,t,e,r){return t.rank<e.rank&&(t=at(t,Vn(t.shape,r))),n.rank<e.rank&&(n=at(n,Vn(n.shape,r))),{x:()=>et(n,Ft(Wa(e,t),n.dtype))}}const yF={kernelName:Xm,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const r=e,{reductionIndices:a}=r,s=t[0],o=t[1],i=_e(a,s.shape),u=XP(n,o,s,i);return{x:()=>u.x()}}};const aht={kernelName:Ld,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,r]=t;return{a:()=>et(n,Ft(Bi(e,r),"float32")),b:()=>et(n,Ft(Qh(e,r),"float32"))}}};function sht(n,t,e,r,a,s,o){const i=V(n,"dy","maxPool3dGrad"),u=V(t,"input","maxPool3dGrad"),l=V(e,"output","maxPool3dGrad");let h=i,d=u,f=l,m=!1;u.rank===4&&(m=!0,h=at(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]]),d=at(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]]),f=at(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]])),P(h.rank===5,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${h.rank}.`),P(d.rank===5,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${d.rank}.`),P(f.rank===5,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${f.rank}.`),ma("maxPool3dGrad",s,o);const v={dy:h,input:d,output:f},y={filterSize:r,strides:a,pad:s,dimRoundingMode:o},b=J.runKernel(cx,v,y);return m?at(b,[b.shape[1],b.shape[2],b.shape[3],b.shape[4]]):b}const oht=tt({maxPool3dGrad_:sht});const iht={kernelName:Qm,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const[r,a]=t,{filterSize:s,strides:o,pad:i,dimRoundingMode:u}=e;return{x:()=>oht(n,r,a,s,o,i,u)}}};function uht(n,t,e,r,a,s,o){const i=V(n,"dy","maxPoolGrad"),u=V(t,"input","maxPoolGrad"),l=V(e,"output","maxPoolGrad");P(u.rank===i.rank,()=>`Rank of input (${u.rank}) does not match rank of dy (${i.rank})`),P(i.rank===4,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${i.rank}.`),P(u.rank===4,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${u.rank}.`),ma("maxPoolGrad",s,o);const h={dy:i,input:u,output:l},d={filterSize:r,strides:a,pad:s,dimRoundingMode:o};return J.runKernel(lx,h,d)}const lht=tt({maxPoolGrad_:uht});const cht={kernelName:Ym,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const[r,a]=t,{filterSize:s,strides:o,pad:i}=e;return{x:()=>lht(n,r,a,s,o,i)}}};const hht={kernelName:Zm,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[r]=t,{axis:a}=e,s=_e(a,r.shape),i=kr(r.shape,s)[1],u=xt(i);return{x:()=>{const h=r.shape.slice();s.forEach(m=>{h[m]=1});const d=at(n,h);return Ut(et(d,xa(r.shape,"float32")),u)}}}};const dht={kernelName:Jm,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,t,e)=>{const r=e,{axis:a}=r,[s,o]=t,i=_e(a,s.shape),u=XP(n,o,s,i);return{x:()=>u.x()}}};const pht={kernelName:Bd,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,r]=t;return{a:()=>et(n,Ft(tl(e,r),"float32")),b:()=>et(n,Ft(ga(e,r),"float32"))}}};const fht={kernelName:tg,inputsToSave:["x"],gradFunc:(n,t,e)=>{const r=t[0],{paddings:a}=e,s=a.map(o=>o[0]);return{x:()=>ue(n,s,r.shape)}}};const mht={kernelName:zd,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,r]=t,a=me(e.shape,r.shape);return{a:()=>{const i=Zn(e.shape,a);return i.length>0?at(jt(n,i),e.shape):n},b:()=>{const i=et(n,mn(cp(Ut(e,r)))),u=Zn(r.shape,a);return u.length>0?at(jt(i,u),r.shape):i}}}};const ght={kernelName:Pd,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,r]=t,a=me(e.shape,r.shape);return{a:()=>{const i=et(n,Ft(r,"float32")),u=Zn(e.shape,a);return u.length>0?at(jt(i,u),e.shape):i},b:()=>{const i=et(n,Ft(e,"float32")),u=Zn(r.shape,a);return u.length>0?at(jt(i,u),r.shape):i}}}};const vht={kernelName:eg,gradFunc:n=>({x:()=>mn(n)})};const yht={kernelName:ag,inputsToSave:["indices"],gradFunc:(n,t)=>{const e=t[0];return{indices:()=>Xn(e.shape,"float32")}}};const bht={kernelName:rg,gradFunc:n=>({x:()=>Be(n)})};const xht={kernelName:sg,saveAllInputs:!0,gradFunc:(n,t,e)=>{const{axis:r}=e;return xs(n,r).map(s=>()=>s)}};const bF={kernelName:og,inputsToSave:["x"],gradFunc:(n,t,e)=>{const r=t[0],{paddings:a}=e,s=a.map(o=>o[0]);return{x:()=>ue(n,s,r.shape)}}};const wht={kernelName:Vd,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(n,t)=>{const[e,r,a]=t,s=e,o=r,i=me(s.shape,o.shape);return{a:()=>{const h=Ft(o,"float32");let d=et(n,et(h,Wo(s,zt(h,Jt(1)))));const f=Zn(s.shape,i);return f.length>0&&(d=jt(d,f)),at(d,s.shape)},b:()=>{const h=ga(s,0),d=Or(h,Ga(s),Be(s));let f=et(n,et(a,d));const m=Zn(o.shape,i);return m.length>0&&(f=jt(f,m)),at(f,o.shape)}}}};const Sht={kernelName:ig,inputsToSave:["x","alpha"],gradFunc:(n,t)=>{const[e,r]=t,a=ga(e,0);return{x:()=>Or(a,n,et(n,r)),alpha:()=>{let s=Or(a,Be(n),et(n,e));const o=Zn(r.shape,n.shape);return o.length>0&&(s=jt(s,o)),at(s,r.shape)}}}};function Cht(n,t,e){const r=n.shape.slice();r[e]=1;const a=at(t,r),s=nm(n,e,!0,!1),o=nm(n,e,!0,!0),i=et(s,o);return et(a,i)}function Nht(n,t,e){const r=n.shape.length,a=r-e.length,s=An(e,r);let o=n;s!=null&&(o=Oe(n,s));const i=o.shape.slice(),l=i.splice(r-e.length,e.length).reduce((f,m)=>f*m,1);i.push(l);const h=o.reshape(i);let d=Cht(h,t,a);if(d=d.reshape(o.shape),s!=null){const f=Ju(s);d=Oe(d,f)}return d}const kht={kernelName:ug,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[r]=t,{axis:a}=e;let s=[];return a==null?s=r.shape.map((o,i)=>i):typeof a=="number"?s=[a]:s=a,{x:()=>Nht(r,n,s)}}};const Tht={kernelName:Cd,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,r]=t,a=me(e.shape,r.shape);return{a:()=>{const i=Ut(n,Ft(r,"float32")),u=Zn(e.shape,a);return u.length>0?at(jt(i,u),e.shape):i},b:()=>{let i=et(n,Ft(e,"float32"));const u=Zn(r.shape,a);u.length>0&&(i=at(jt(i,u),r.shape));const l=an(r);return mn(Ut(i,Ft(l,"float32")))}}}};const Eht={kernelName:Ud,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Ut(n,mn(an(e)))}}};const Iht={kernelName:Gd,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t,r=et(tl(e,6),wc(e));return{x:()=>et(n,Ft(r,"float32"))}}};const _ht={kernelName:Wd,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>et(n,Ft(wc(e),"float32"))}}};const Rht={kernelName:lg,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>at(n,e.shape)}}};const Aht={kernelName:hg,inputsToSave:["images"],gradFunc:(n,t,e)=>{const[r]=t,a={dy:n,images:r};return{images:()=>J.runKernel(Sx,a,e)}}};const Dht={kernelName:cg,inputsToSave:["images"],gradFunc:(n,t,e)=>{const[r]=t,a={dy:n,images:r};return{images:()=>J.runKernel(wx,a,e)}}};const $ht={kernelName:dg,gradFunc:(n,t,e)=>{const{dims:r}=e,a=_e(r,n.shape);return{x:()=>bs(n,a)}}};const Oht={kernelName:Hd,gradFunc:n=>({x:()=>Be(n)})};const Fht={kernelName:jd,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>mn(Ut(n,et(Wo(e,1.5),2)))}}};const Mht={kernelName:pg,inputsToSave:["condition"],gradFunc:(n,t)=>{const[e]=t;return{condition:()=>Ft(Be(e),"float32"),t:()=>et(n,Ft(e,n.dtype)),e:()=>et(n,Ft(Og(e),n.dtype))}}};const Lht={kernelName:qd,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>{const r=ga(e,Jt(0)),a=Jt(_1),s=Jt(R1),o=et(n,s),i=et(et(n,a),ka(Ft(e,"float32")));return Or(r,o,i)}}}};const Bht={kernelName:Qd,outputsToSave:[!0],gradFunc:(n,t)=>{const[e]=t;return{x:()=>et(n,et(e,zt(Jt(1),e)))}}};const zht={kernelName:Yd,gradFunc:n=>({x:()=>Be(n)})};const Pht={kernelName:Kd,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>et(_g(Ft(e,"float32")),n)}}};const Vht={kernelName:Xd,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>et(qx(Ft(e,"float32")),n)}}};const Uht={kernelName:fg,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[r]=t,{begin:a,size:s}=e,o=r.shape,[i,u]=E1(r,a,s),l=[];for(let h=0;h<n.rank;h++)l.push([i[h],o[h]-i[h]-u[h]]);return{x:()=>zi(n,l)}}};const Wht={kernelName:yg,outputsToSave:[!0],gradFunc:(n,t,e)=>{const[r]=t,{dim:a}=e,s=!0,o=et(n,r);return{logits:()=>zt(o,et(jt(o,[a],s),r))}}};const Ght={kernelName:Zd,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>et(n,Va(e))}}};const xF={kernelName:gg,gradFunc:(n,t,e)=>{const{blockShape:r,paddings:a}=e;return{x:()=>Eg(n,r,a)}}};const wF={kernelName:vg,gradFunc:(n,t,e)=>{const{axis:r}=e;return{x:()=>_n(n,r)}}};const Hht={kernelName:Jd,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Ut(n,et(wr(Ft(e,"float32")),2))}}};const jht={kernelName:Ax,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>et(n,et(Ft(e,"float32"),2))}}};const qht={kernelName:tp,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,r]=t,a=Jt(2);return{a:()=>et(n,et(a,zt(e,r))),b:()=>et(n,et(a,zt(r,e)))}}};const Kht={kernelName:sp,gradFunc:n=>({x:()=>Be(n)})};const Xht={kernelName:ep,inputsToSave:["a","b"],gradFunc:(n,t)=>{const[e,r]=t,a=me(e.shape,r.shape);return{a:()=>{let i=n;const u=Zn(e.shape,a);return u.length>0&&(i=jt(i,u)),at(i,e.shape)},b:()=>{let i=n;const u=Zn(r.shape,a);return u.length>0&&(i=jt(i,u)),at(mn(i),r.shape)}}}};const Yht={kernelName:mg,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[r]=t,a=r.shape.slice(),{axis:s}=e;_e(s,r.shape).forEach(l=>{a[l]=1});const i=at(n,a),u=et(i,xa(r.shape,"float32"));return{x:()=>u}}};const Qht={kernelName:np,inputsToSave:["x"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>Ut(n,an(_g(e)))}}};const Zht={kernelName:rp,outputsToSave:[!0],gradFunc:(n,t)=>{const[e]=t;return{x:()=>et(zt(Jt(1),an(e)),n)}}};const Jht={kernelName:ap,inputsToSave:["x"],gradFunc:(n,t,e)=>{const[r]=t,{reps:a}=e;return{x:()=>{let o=Be(r);if(r.rank===1)for(let i=0;i<a[0];++i)o=It(o,ue(n,[i*r.shape[0]],[r.shape[0]]));else if(r.rank===2)for(let i=0;i<a[0];++i)for(let u=0;u<a[1];++u)o=It(o,ue(n,[i*r.shape[0],u*r.shape[1]],[r.shape[0],r.shape[1]]));else if(r.rank===3)for(let i=0;i<a[0];++i)for(let u=0;u<a[1];++u)for(let l=0;l<a[2];++l)o=It(o,ue(n,[i*r.shape[0],u*r.shape[1],l*r.shape[2]],[r.shape[0],r.shape[1],r.shape[2]]));else if(r.rank===4)for(let i=0;i<a[0];++i)for(let u=0;u<a[1];++u)for(let l=0;l<a[2];++l)for(let h=0;h<a[3];++h)o=It(o,ue(n,[i*r.shape[0],u*r.shape[1],l*r.shape[2],h*r.shape[3]],[r.shape[0],r.shape[1],r.shape[2],r.shape[3]]));else throw new Error(`Gradient for tile operation is not implemented for rank-${r.rank} tensors yet.`);return o}}}};const tdt={kernelName:ql,gradFunc:(n,t,e)=>{const r=e,{perm:a}=r,s=Ju(a);return{x:()=>Oe(n,s)}}};const edt={kernelName:xg,gradFunc:(n,t,e)=>{const r=e,{axis:a}=r;return{value:()=>Ta(n,a)}}};const ndt={kernelName:wg,inputsToSave:["segmentIds"],gradFunc:(n,t)=>{const[e]=t;return{x:()=>rdt(n,e)}}};function rdt(n,t){const e=Ko(t,Be(t)),r=hp(n,e);let a=Bi(t,Jt(0,"int32"));const s=r.rank-a.rank;for(let i=0;i<s;++i)a=Pn(a,i+1);a=ao(a,xa(r.shape,"bool"));const o=Be(r);return Or(a,r,o)}const adt={kernelName:Sg,gradFunc:n=>({x:()=>Be(n)})};const sdt=[KP,nct,rct,act,sct,oct,ict,uct,lct,cct,hct,dct,mct,yct,bct,xct,wct,Sct,Cct,Nct,kct,Tct,Ict,Ect,Act,Dct,$ct,Oct,Fct,Mct,Tht,Lct,Bct,zct,Pct,Vct,Wct,Uct,Gct,Hct,jct,qct,Kct,Xct,Yct,Qct,Zct,Jct,tht,rht,yF,yF,aht,iht,cht,hht,dht,pht,fht,mht,ght,vht,yht,bht,xht,bF,bF,wht,Sht,kht,Eht,Iht,_ht,Rht,Aht,Dht,$ht,Oht,Fht,Mht,Lht,Bht,zht,Pht,Vht,Uht,Wht,Ght,xF,xF,wF,wF,Hht,qht,jht,Kht,Xht,Yht,Qht,Zht,Jht,tdt,edt,ndt,adt];for(const n of sdt)KM(n);Ct().prototype.abs=function(){return this.throwIfDisposed(),Kn(this)};Ct().prototype.acos=function(){return this.throwIfDisposed(),Gk(this)};Ct().prototype.acosh=function(){return this.throwIfDisposed(),Hk(this)};Ct().prototype.add=function(n){return this.throwIfDisposed(),It(this,n)};Ct().prototype.all=function(n,t){return this.throwIfDisposed(),Gx(this,n,t)};Ct().prototype.any=function(n,t){return this.throwIfDisposed(),Jf(this,n,t)};Ct().prototype.argMax=function(n){return this.throwIfDisposed(),Bu(this,n)};Ct().prototype.argMin=function(n){return this.throwIfDisposed(),jk(this,n)};Ct().prototype.asScalar=function(){return this.throwIfDisposed(),P(this.size===1,()=>"The array must have only 1 element."),at(this,[])};Ct().prototype.asType=function(n){return this.throwIfDisposed(),Ft(this,n)};Ct().prototype.as1D=function(){return this.throwIfDisposed(),at(this,[this.size])};Ct().prototype.as2D=function(n,t){return this.throwIfDisposed(),at(this,[n,t])};Ct().prototype.as3D=function(n,t,e){return this.throwIfDisposed(),at(this,[n,t,e])};Ct().prototype.as4D=function(n,t,e,r){return this.throwIfDisposed(),at(this,[n,t,e,r])};Ct().prototype.as5D=function(n,t,e,r,a){return this.throwIfDisposed(),at(this,[n,t,e,r,a])};Ct().prototype.asin=function(){return this.throwIfDisposed(),qk(this)};Ct().prototype.asinh=function(){return this.throwIfDisposed(),Kk(this)};Ct().prototype.atan=function(){return this.throwIfDisposed(),Xk(this)};Ct().prototype.atan2=function(n){return this.throwIfDisposed(),Yk(this,n)};Ct().prototype.atanh=function(){return this.throwIfDisposed(),Qk(this)};Ct().prototype.avgPool=function(n,t,e,r){return this.throwIfDisposed(),Tg(this,n,t,e,r)};Ct().prototype.batchToSpaceND=function(n,t){return this.throwIfDisposed(),Eg(this,n,t)};Ct().prototype.batchNorm=function(n,t,e,r,a){return this.throwIfDisposed(),op(this,n,t,e,r,a)};Ct().prototype.broadcastTo=function(n){return this.throwIfDisposed(),Kl(this,n)};Ct().prototype.cast=function(n){return this.throwIfDisposed(),Ft(this,n)};Ct().prototype.ceil=function(){return this.throwIfDisposed(),aT(this)};Ct().prototype.clipByValue=function(n,t){return this.throwIfDisposed(),Na(this,n,t)};Ct().prototype.concat=function(n,t){return this.throwIfDisposed(),n instanceof Ae&&(n=[n]),_n([this,...n],t)};Ct().prototype.conv1d=function(n,t,e,r,a,s){return this.throwIfDisposed(),Hx(this,n,t,e,r,a,s)};Ct().prototype.conv2dTranspose=function(n,t,e,r,a){return this.throwIfDisposed(),jx(this,n,t,e,r,a)};Ct().prototype.conv2d=function(n,t,e,r,a,s){return this.throwIfDisposed(),Ri(this,n,t,e,r,a,s)};Ct().prototype.cos=function(){return this.throwIfDisposed(),_g(this)};Ct().prototype.cosh=function(){return this.throwIfDisposed(),qx(this)};Ct().prototype.cumprod=function(n,t,e){return this.throwIfDisposed(),nm(this,n,t,e)};Ct().prototype.cumsum=function(n,t,e){return this.throwIfDisposed(),Kx(this,n,t,e)};Ct().prototype.depthToSpace=function(n,t){return this.throwIfDisposed(),hT(this,n,t)};Ct().prototype.depthwiseConv2d=function(n,t,e,r,a,s){return this.throwIfDisposed(),ip(this,n,t,e,r,a,s)};Ct().prototype.dilation2d=function(n,t,e,r,a){return this.throwIfDisposed(),dT(this,n,t,e,r,a)};Ct().prototype.divNoNan=function(n){return this.throwIfDisposed(),pT(this,n)};Ct().prototype.div=function(n){return this.throwIfDisposed(),Ut(this,n)};Ct().prototype.dot=function(n){return this.throwIfDisposed(),fT(this,n)};Ct().prototype.elu=function(){return this.throwIfDisposed(),up(this)};Ct().prototype.equal=function(n){return this.throwIfDisposed(),Wa(this,n)};Ct().prototype.erf=function(){return this.throwIfDisposed(),Xx(this)};Ct().prototype.euclideanNorm=function(n,t){return this.throwIfDisposed(),gT(this,n,t)};Ct().prototype.exp=function(){return this.throwIfDisposed(),ka(this)};Ct().prototype.expandDims=function(n){return this.throwIfDisposed(),Pn(this,n)};Ct().prototype.expm1=function(){return this.throwIfDisposed(),vT(this)};Ct().prototype.fft=function(){return this.throwIfDisposed(),Ug(this)};Ct().prototype.flatten=function(){return this.throwIfDisposed(),at(this,[this.size])};Ct().prototype.floor=function(){return this.throwIfDisposed(),cp(this)};Ct().prototype.floorDiv=function(n){return this.throwIfDisposed(),Wx(this,n)};Ct().prototype.gather=function(n,t,e){return this.throwIfDisposed(),hp(this,n,t,e)};Ct().prototype.greaterEqual=function(n){return this.throwIfDisposed(),Bi(this,n)};Ct().prototype.greater=function(n){return this.throwIfDisposed(),ga(this,n)};Ct().prototype.ifft=function(){return this.throwIfDisposed(),td(this)};Ct().prototype.irfft=function(){return this.throwIfDisposed(),h1(this)};Ct().prototype.isFinite=function(){return this.throwIfDisposed(),yT(this)};Ct().prototype.isInf=function(){return this.throwIfDisposed(),bT(this)};Ct().prototype.isNaN=function(){return this.throwIfDisposed(),xT(this)};Ct().prototype.leakyRelu=function(n){return this.throwIfDisposed(),Ag(this,n)};Ct().prototype.lessEqual=function(n){return this.throwIfDisposed(),tl(this,n)};Ct().prototype.less=function(n){return this.throwIfDisposed(),Qh(this,n)};Ct().prototype.localResponseNormalization=function(n,t,e,r){return this.throwIfDisposed(),wT(this,n,t,e,r)};Ct().prototype.logSigmoid=function(){return this.throwIfDisposed(),ST(this)};Ct().prototype.logSoftmax=function(n){return this.throwIfDisposed(),Zx(this,n)};Ct().prototype.logSumExp=function(n,t){return this.throwIfDisposed(),$g(this,n,t)};Ct().prototype.log=function(){return this.throwIfDisposed(),Ga(this)};Ct().prototype.log1p=function(){return this.throwIfDisposed(),Dg(this)};Ct().prototype.logicalAnd=function(n){return this.throwIfDisposed(),ao(this,n)};Ct().prototype.logicalNot=function(){return this.throwIfDisposed(),Og(this)};Ct().prototype.logicalOr=function(n){return this.throwIfDisposed(),Jx(this,n)};Ct().prototype.logicalXor=function(n){return this.throwIfDisposed(),CT(this,n)};Ct().prototype.matMul=function(n,t,e){return this.throwIfDisposed(),xe(this,n,t,e)};Ct().prototype.maxPool=function(n,t,e,r){return this.throwIfDisposed(),Fg(this,n,t,e,r)};Ct().prototype.max=function(n,t){return this.throwIfDisposed(),vs(this,n,t)};Ct().prototype.maximum=function(n){return this.throwIfDisposed(),Ko(this,n)};Ct().prototype.mean=function(n,t){return this.throwIfDisposed(),En(this,n,t)};Ct().prototype.min=function(n,t){return this.throwIfDisposed(),Yh(this,n,t)};Ct().prototype.minimum=function(n){return this.throwIfDisposed(),Vu(this,n)};Ct().prototype.mirrorPad=function(n,t){return this.throwIfDisposed(),kT(this,n,t)};Ct().prototype.mod=function(n){return this.throwIfDisposed(),TT(this,n)};Ct().prototype.mul=function(n){return this.throwIfDisposed(),et(this,n)};Ct().prototype.neg=function(){return this.throwIfDisposed(),mn(this)};Ct().prototype.norm=function(n,t,e){return this.throwIfDisposed(),lp(this,n,t,e)};Ct().prototype.notEqual=function(n){return this.throwIfDisposed(),ac(this,n)};Ct().prototype.oneHot=function(n,t=1,e=0){return this.throwIfDisposed(),sc(this,n,t,e)};Ct().prototype.onesLike=function(){return this.throwIfDisposed(),Ha(this)};Ct().prototype.pad=function(n,t){return this.throwIfDisposed(),zi(this,n,t)};Ct().prototype.pool=function(n,t,e,r,a,s){return this.throwIfDisposed(),IT(this,n,t,e,r,a,s)};Ct().prototype.pow=function(n){return this.throwIfDisposed(),Wo(this,n)};Ct().prototype.prelu=function(n){return this.throwIfDisposed(),Bg(this,n)};Ct().prototype.prod=function(n,t){return this.throwIfDisposed(),_T(this,n,t)};Ct().prototype.reciprocal=function(){return this.throwIfDisposed(),$T(this)};Ct().prototype.relu=function(){return this.throwIfDisposed(),lo(this)};Ct().prototype.relu6=function(){return this.throwIfDisposed(),r1(this)};Ct().prototype.reshapeAs=function(n){return this.throwIfDisposed(),at(this,n.shape)};Ct().prototype.reshape=function(n){return this.throwIfDisposed(),at(this,n)};Ct().prototype.resizeBilinear=function(n,t,e){return this.throwIfDisposed(),y4(this,n,t,e)};Ct().prototype.resizeNearestNeighbor=function(n,t,e){return this.throwIfDisposed(),b4(this,n,t,e)};Ct().prototype.reverse=function(n){return this.throwIfDisposed(),bs(this,n)};Ct().prototype.rfft=function(){return this.throwIfDisposed(),Wg(this)};Ct().prototype.round=function(){return this.throwIfDisposed(),a1(this)};Ct().prototype.rsqrt=function(){return this.throwIfDisposed(),s1(this)};Ct().prototype.selu=function(){return this.throwIfDisposed(),o1(this)};Ct().prototype.separableConv2d=function(n,t,e,r,a,s){return this.throwIfDisposed(),i1(this,n,t,e,r,a,s)};Ct().prototype.sigmoid=function(){return this.throwIfDisposed(),Va(this)};Ct().prototype.sign=function(){return this.throwIfDisposed(),OT(this)};Ct().prototype.sin=function(){return this.throwIfDisposed(),u1(this)};Ct().prototype.sinh=function(){return this.throwIfDisposed(),l1(this)};Ct().prototype.slice=function(n,t){return this.throwIfDisposed(),ue(this,n,t)};Ct().prototype.softmax=function(n){return this.throwIfDisposed(),Vg(this,n)};Ct().prototype.softplus=function(){return this.throwIfDisposed(),xc(this)};Ct().prototype.spaceToBatchND=function(n,t){return this.throwIfDisposed(),Lg(this,n,t)};Ct().prototype.split=function(n,t){return this.throwIfDisposed(),wa(this,n,t)};Ct().prototype.sqrt=function(){return this.throwIfDisposed(),wr(this)};Ct().prototype.square=function(){return this.throwIfDisposed(),an(this)};Ct().prototype.squaredDifference=function(n){return this.throwIfDisposed(),d1(this,n)};Ct().prototype.squeeze=function(n){return this.throwIfDisposed(),$r(this,n)};Ct().prototype.stack=function(n,t){this.throwIfDisposed();const e=n instanceof Ae?[this,n]:[this,...n];return Ta(e,t)};Ct().prototype.step=function(n){return this.throwIfDisposed(),wc(this,n)};Ct().prototype.stridedSlice=function(n,t,e,r,a,s,o,i){return this.throwIfDisposed(),FT(this,n,t,e,r,a,s,o,i)};Ct().prototype.sub=function(n){return this.throwIfDisposed(),zt(this,n)};Ct().prototype.sum=function(n,t){return this.throwIfDisposed(),jt(this,n,t)};Ct().prototype.tan=function(){return this.throwIfDisposed(),MT(this)};Ct().prototype.tanh=function(){return this.throwIfDisposed(),Pu(this)};Ct().prototype.tile=function(n){return this.throwIfDisposed(),ls(this,n)};Ct().prototype.toBool=function(){return this.throwIfDisposed(),Ft(this,"bool")};Ct().prototype.toFloat=function(){return this.throwIfDisposed(),Ft(this,"float32")};Ct().prototype.toInt=function(){return this.throwIfDisposed(),Ft(this,"int32")};Ct().prototype.topk=function(n,t){return this.throwIfDisposed(),zT(this,n,t)};Ct().prototype.transpose=function(n){return this.throwIfDisposed(),Oe(this,n)};Ct().prototype.unique=function(n){return this.throwIfDisposed(),PT(this,n)};Ct().prototype.unsortedSegmentSum=function(n,t){return this.throwIfDisposed(),m1(this,n,t)};Ct().prototype.unstack=function(n){return this.throwIfDisposed(),xs(this,n)};Ct().prototype.where=function(n,t){return this.throwIfDisposed(),Or(n,this,t)};Ct().prototype.zerosLike=function(){return this.throwIfDisposed(),Be(this)};class Co extends Error{constructor(t){super(t),Object.setPrototypeOf(this,Co.prototype)}}class zs extends Error{constructor(t){super(t),Object.setPrototypeOf(this,zs.prototype)}}class ot extends Error{constructor(t){super(t),Object.setPrototypeOf(this,ot.prototype)}}class ke extends Error{constructor(t){super(t),Object.setPrototypeOf(this,ke.prototype)}}class zI extends Error{constructor(t){super(t),Object.setPrototypeOf(this,zI.prototype)}}class YP{constructor(t){this.maxEntries=t||100,this.cache=new Map}get(t){let e;return this.cache.has(t)&&(e=this.cache.get(t),this.cache.delete(t),this.cache.set(t,e)),e}put(t,e){if(this.cache.has(t))this.cache.delete(t);else if(this.cache.size>=this.maxEntries){const r=this.cache.keys().next().value;this.cache.delete(r)}this.cache.set(t,e)}getMaxEntries(){return this.maxEntries}setMaxEntries(t){if(t<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${t}.`);if(this.maxEntries>t)for(let e=0;e<this.maxEntries-t;e++){const r=this.cache.keys().next().value;this.cache.delete(r)}this.maxEntries=t}}function cc(n,t){if(Array.isArray(n)){let e=[];for(let r=0;r<t;r++)e=e.concat(n);return e}else{const e=new Array(t);return e.fill(n),e}}function No(n,t){if(!n)throw new zI(t)}function SF(n,t){let e=0;for(const r of n)r===t&&e++;return e}function ba(n){return n.length===1?n[0]:n}function Ze(n){return Array.isArray(n)?n:[n]}function Ci(n){const e=n.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return e[0]!=="_"?e:"private"+e}function Pl(n){return n.length<=1||n.indexOf("_")===-1?n:n.replace(/[_]+(\w|$)/g,(t,e)=>e.toUpperCase())}let Ds={};function PI(n){if(n==null)return null;const t={};return t.className=n.getClassName(),t.config=n.getConfig(),t}function ak(n){if(!(n==null||typeof n!="object"))if(Array.isArray(n))n.forEach(t=>ak(t));else{const t=Object.keys(n);for(const e of t){const r=n[e];r!=null&&typeof r=="object"&&(!Array.isArray(r)&&r.type==="ndarray"&&typeof r.value=="number"?n[e]=r.value:ak(r))}}}function av(n,t={},e={},r="object",a=!1){if(typeof n=="string"){const s=n;let o;if(s in e)o=e[s];else if(s in Ds)o=Ds[s];else if(o=t[s],o==null)throw new ot(`Unknown ${r}: ${n}. This may be due to one of the following reasons:
1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return o}else{const s=n;if(s.className==null||s.config==null)throw new ot(`${r}: Improper config format: ${JSON.stringify(s)}.
'className' and 'config' must set.`);const o=s.className;let i,u;if(o in e?[i,u]=e[o]:o in Ds?[i,u]=Ds.className:o in t&&([i,u]=t[o]),i==null)throw new ot(`Unknown ${r}: ${o}. This may be due to one of the following reasons:
1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(u!=null){const l={};for(const m of Object.keys(Ds))l[m]=Ds[m];for(const m of Object.keys(e))l[m]=e[m];const h=s.config;h.customObjects=l;const d=Object.assign({},Ds);for(const m of Object.keys(e))Ds[m]=e[m];ak(s.config);const f=u(i,s.config,e,a);return Ds=Object.assign({},d),f}else{const l=Object.assign({},Ds);for(const d of Object.keys(e))Ds[d]=e[d];const h=new i(s.config);return Ds=Object.assign({},l),h}}}function odt(n,t){return n<t?-1:n>t?1:0}function s0(n,t){return-1*odt(n,t)}function Du(n){if(n==null)return n;const t=[];for(const e of n)t.indexOf(e)===-1&&t.push(e);return t}function idt(n){if(n==null)throw new ot(`Invalid value in obj: ${JSON.stringify(n)}`);for(const t in n)if(n.hasOwnProperty(t))return!1;return!0}function Ic(n,t,e){if(e!=null&&n.indexOf(e)<0)throw new ot(`${e} is not a valid ${t}.  Valid values are ${n} or null/undefined.`)}function VI(n,t,e=0,r=1/0){return No(e>=0),No(r>=e),Array.isArray(n)&&n.length>=e&&n.length<=r&&n.every(a=>typeof a===t)}function vr(n,t){Array.isArray(n)?(P(n.length>0,()=>`${t} is unexpectedly an empty array.`),n.forEach((e,r)=>vr(e,`element ${r+1} of ${t}`))):P(Number.isInteger(n)&&n>0,()=>`Expected ${t} to be a positive integer, but got ${QP(n)}.`)}function QP(n){return n===null?"null":Array.isArray(n)?"["+n.map(t=>QP(t)).join(",")+"]":typeof n=="string"?`"${n}"`:`${n}`}function udt(n,t,e){let r=e!=null?e():ra(),a;return(...o)=>{const i=e!=null?e():ra();return i-r<t||(r=i,a=n(...o)),a}}function ZP(n){return n==="relu"?"relu":n==="linear"?"linear":n==="elu"?"elu":null}let ldt=0;function JP(){return ldt++}const o0={};function q1(n=""){return n in o0||(o0[n]=0),o0[n]+=1,n+o0[n].toString()}const cdt=["channelsFirst","channelsLast"],hdt=["nearest","bilinear"],ddt=["valid","same","causal"],pdt=["max","avg"],fdt=["sum","mul","concat","ave"];const kh=new Map;function Wn(n){Ic(cdt,"DataFormat",n)}function mdt(n){Ic(hdt,"InterpolationFormat",n)}function ws(n){Ic(ddt,"PaddingMode",n)}function tV(n){Ic(pdt,"PoolMode",n)}const Wf=[],CF="/";function Yl(n,t){Wf.push(n);try{const e=t();return Wf.pop(),e}catch(e){throw Wf.pop(),e}}function gdt(){return Wf.length===0?"":Wf.join(CF)+CF}function eV(n){if(!rV(n))throw new Error("Not a valid tensor name: '"+n+"'");return gdt()+n}function nV(n){if(!rV(n))throw new Error("Not a valid tensor name: '"+n+"'");kh.has(n)||kh.set(n,0);const t=kh.get(n);if(kh.set(n,kh.get(n)+1),t>0){const e=`${n}_${t}`;return kh.set(e,1),e}else return n}const vdt=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function rV(n){return!!n.match(vdt)}function ydt(n){return n===parseInt(n.toString(),10)}function $u(n,t,e){t==null&&(t=0),e==null&&(e=n.length);let r=1;for(let a=t;a<e;++a)r*=n[a];return r}function sd(n){if(n.length===0)return Number.NaN;let t=Number.POSITIVE_INFINITY;for(let e=0;e<n.length;e++){const r=n[e];r<t&&(t=r)}return t}function Gu(n){if(n.length===0)return Number.NaN;let t=Number.NEGATIVE_INFINITY;for(let e=0;e<n.length;e++){const r=n[e];r>t&&(t=r)}return t}function so(n,t){if(t<n)throw new ot(`end (${t}) < begin (${n}) is forbidden.`);const e=[];for(let r=n;r<t;++r)e.push(r);return e}let BC;function or(){return BC==null&&(BC=Ux().epsilon()),BC}function oo(){return"channelsLast"}function zo(n,t){return Ft(n,t)}function sv(n,t=-1){const e=n.shape.slice();return t<0&&(t=e.length+t+1),e.splice(t,0,1),at(n,e)}function bdt(n,t){return ut(()=>{if(n.shape.length!==2)throw new ot(`repeat() expects a rank-2 tensor, but received a rank-${n.shape.length} tensor.`);const e=sv(n,1);return sk(e,[1,t,1])})}function xdt(n){const t=[$u(n.shape)];return at(n,t)}function wdt(n){if(n.rank<=1)throw new ot(`batchFlatten requires a minimum rank of 2. Got rank: ${n.rank}.`);const t=[n.shape[0],$u(n.shape,1)];return at(n,t)}function Ql(n,t,e){return ut(()=>{switch(n.rank){case 1:return zg(n,t,e);case 2:return c1(n,[t,0],[e,n.shape[1]]);case 3:return Pg(n,[t,0,0],[e,n.shape[1],n.shape[2]]);case 4:return Jh(n,[t,0,0,0],[e,n.shape[1],n.shape[2],n.shape[3]]);case 5:return ue(n,[t,0,0,0,0],[e,n.shape[1],n.shape[2],n.shape[3],n.shape[4]]);case 6:return ue(n,[t,0,0,0,0,0],[e,n.shape[1],n.shape[2],n.shape[3],n.shape[4],n.shape[5]]);default:throw new ot(`sliceAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`)}})}function zC(n,t,e){return ut(()=>{switch(n.rank){case 1:return zg(n,t,e);case 2:return c1(n,[0,t],[n.shape[0],e]);case 3:return Pg(n,[0,0,t],[n.shape[0],n.shape[1],e]);case 4:return Jh(n,[0,0,0,t],[n.shape[0],n.shape[1],n.shape[2],e]);default:throw new ot(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`)}})}function i0(n,t,e,r){return ut(()=>{switch(n.rank){case 1:return zg(n,t,e);case 2:switch(r){case 1:return Ql(n,t,e);case 2:return zC(n,t,e);default:throw new ot(`The axis is not within the rank of the tensor ${r}`)}case 3:switch(r){case 1:return Ql(n,t,e);case 2:return Pg(n,[0,t,0],[n.shape[0],e,n.shape[2]]);case 3:return zC(n,t,e);default:throw new ot(`The axis is not within the rank of the tensor ${r}`)}case 4:switch(r){case 1:return Ql(n,t,e);case 2:return Jh(n,[0,t,0,0],[n.shape[0],e,n.shape[2],n.shape[3]]);case 3:return Jh(n,[0,0,t,0],[n.shape[0],n.shape[1],e,n.shape[3]]);case 4:return zC(n,t,e);default:throw new ot(`The axis is not within the rank of the tensor ${r}`)}default:throw new ot(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`)}})}function UI(n,t=-1){let e;return t<0&&(e=n[0].rank,e!==0?t=e:t=0),t===n[0].rank&&(t=-1),_n(n,t)}function NF(n,t){switch(n.rank){case 1:return sT([n,t]);case 2:return Ig([n,t],0);case 3:return oT([n,t],0);case 4:return iT([n,t],0);default:throw new ot(`concatAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`)}}function sk(n,t){if(Array.isArray(t)||(t=[t]),n.rank!==t.length)throw new ot(`The length of input n (${t.length}) does not match the number of dimensions in input x (${n.rank})`);return ls(n,t)}function K1(n,t=0,e=1,r,a){return n1(n,t,e,r,a)}function Po(n,t,e,r){if(n.rank<2||t.rank<2)throw new ke(`dot requires both inputs to be rank >= 2 but got x shape = ${n.shape} and y shape = ${t.shape}`);if(t.rank>=3){const a=n.shape.slice(-1)[0],s=t.shape.slice(-2)[0];if(a!==s)throw new ke(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${n.shape} and  y shape = ${t.shape}`)}if(n.rank===2&&t.rank===2)return vN({a:n,b:t,transposeA:!1,transposeB:!1,bias:r?ok(n.rank,r,oo()):null,activation:e});{const a=n.shape.slice(),s=a.pop();n=at(n,[-1,s]);const o=t.shape.slice(),i=o.pop(),u=o.pop(),l=[...o,i],h=Array.from({length:t.rank},(v,y)=>y===0?t.rank-2:y<=t.rank-2?y-1:y);t=at(Oe(t,h),[u,-1]);const d=[...a,...l];return at(vN({a:n,b:t,transposeA:!1,transposeB:!1,bias:r?ok(n.rank,r,oo()):null,activation:e}),d)}}function aV(n,t,e){return ut(()=>(Array.isArray(t)?t=sr(t,"int32"):t=Ft(t,"int32"),hp(n,t,e)))}function ov(n){return et(n,n)}function ok(n,t,e){const r=t.shape;if(t.rank!==1&&t.rank!==n)throw new ot(`Unexpected bias dimensions: ${t.rank}; expected it to be 1 or ${n}`);if(n===5){if(e==="channelsFirst")return r.length===1?at(t,[1,r[0],1,1,1]):at(t,[1,r[3],r[0],r[1],r[2]]);if(e==="channelsLast")return r.length===1?at(t,[1,1,1,1,r[0]]):at(t,[1].concat(r))}else if(n===4){if(e==="channelsFirst")return r.length===1?at(t,[1,r[0],1,1]):at(t,[1,r[2],r[0],r[1]]);if(e==="channelsLast")return r.length===1?at(t,[1,1,1,r[0]]):at(t,[1].concat(r))}else if(n===3){if(e==="channelsFirst")return r.length===1?at(t,[1,r[0],1]):at(t,[1,r[1],r[0]]);if(e==="channelsLast")return r.length===1?at(t,[1,1,r[0]]):at(t,[1].concat(r))}else if(n<3)return t;throw new ot(`Unsupported input rank by biasAdd: ${t.rank}`)}function po(n,t,e){return ut(()=>(e==null&&(e=oo()),Wn(e),It(n,ok(n.rank,t,e))))}function Sdt(n,t=1){if(t!==1)throw new ke(`Support for alpha values other than 1 (${t}) is not implemented yet.`);return up(n)}function Cdt(n){return ut(()=>Ut(n,It(Kn(n),1)))}function sV(n,t,e,r){return ut(()=>WT(n,t,e,r))}function Ndt(n){return ut(()=>{const t=It(.5,et(.2,n));return Na(t,0,1)})}function iv(n,t,e=!1){return e?n():t()}const kdt=["fanIn","fanOut","fanAvg"],Tdt=["normal","uniform","truncatedNormal"];function Edt(n){Ic(kdt,"FanMode",n)}function Idt(n){Ic(Tdt,"Distribution",n)}class Ws extends Sc{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}class oV extends Ws{apply(t,e){return Xn(t,e)}}oV.className="Zeros";$t(oV);class WI extends Ws{apply(t,e){return xa(t,e)}}WI.className="Ones";$t(WI);class iV extends Ws{constructor(t){if(super(),typeof t!="object")throw new ot(`Expected argument of type ConstantConfig but got ${t}`);if(t.value===void 0)throw new ot(`config must have value set but got ${t}`);this.value=t.value}apply(t,e){return ut(()=>et(Jt(this.value),xa(t,e)))}getConfig(){return{value:this.value}}}iV.className="Constant";$t(iV);class uV extends Ws{constructor(t){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=t.minval||this.DEFAULT_MINVAL,this.maxval=t.maxval||this.DEFAULT_MAXVAL,this.seed=t.seed}apply(t,e){return el(t,this.minval,this.maxval,e,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}uV.className="RandomUniform";$t(uV);class lV extends Ws{constructor(t){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=t.mean||this.DEFAULT_MEAN,this.stddev=t.stddev||this.DEFAULT_STDDEV,this.seed=t.seed}apply(t,e){if(e=e||"float32",e!=="float32"&&e!=="int32")throw new ke(`randomNormal does not support dType ${e}.`);return K1(t,this.mean,this.stddev,e,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}lV.className="RandomNormal";$t(lV);class cV extends Ws{constructor(t){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=t.mean||this.DEFAULT_MEAN,this.stddev=t.stddev||this.DEFAULT_STDDEV,this.seed=t.seed}apply(t,e){if(e=e||"float32",e!=="float32"&&e!=="int32")throw new ke(`truncatedNormal does not support dType ${e}.`);return f1(t,this.mean,this.stddev,e,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}cV.className="TruncatedNormal";$t(cV);class hV extends Ws{constructor(t){super(),this.gain=t.gain!=null?t.gain:1}apply(t,e){return ut(()=>{if(t.length!==2||t[0]!==t[1])throw new ot("Identity matrix initializer can only be used for 2D square matrices.");return et(this.gain,Yx(t[0]))})}getConfig(){return{gain:this.gain}}}hV.className="Identity";$t(hV);function _dt(n,t="channelsLast"){let e,r;if(Wn(t),n.length===2)e=n[0],r=n[1];else if([3,4,5].indexOf(n.length)!==-1){if(t==="channelsFirst"){const a=$u(n,2);e=n[1]*a,r=n[0]*a}else if(t==="channelsLast"){const a=$u(n,0,n.length-2);e=n[n.length-2]*a,r=n[n.length-1]*a}}else{const a=$u(n);e=Math.sqrt(a),r=Math.sqrt(a)}return[e,r]}class Ka extends Ws{constructor(t){if(super(),t.scale<0)throw new ot(`scale must be a positive float. Got: ${t.scale}`);this.scale=t.scale==null?1:t.scale,this.mode=t.mode==null?"fanIn":t.mode,Edt(this.mode),this.distribution=t.distribution==null?"normal":t.distribution,Idt(this.distribution),this.seed=t.seed}apply(t,e){const r=_dt(t),a=r[0],s=r[1];let o=this.scale;if(this.mode==="fanIn"?o/=Math.max(1,a):this.mode==="fanOut"?o/=Math.max(1,s):o/=Math.max(1,(a+s)/2),this.distribution==="normal"){const i=Math.sqrt(o);if(e=e||"float32",e!=="float32"&&e!=="int32")throw new ke(`${this.getClassName()} does not support dType ${e}.`);return f1(t,0,i,e,this.seed)}else{const i=Math.sqrt(3*o);return el(t,-i,i,e,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}Ka.className="VarianceScaling";$t(Ka);class GI extends Ka{constructor(t){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:t==null?null:t.seed})}getClassName(){return Ka.className}}GI.className="GlorotUniform";$t(GI);class HI extends Ka{constructor(t){super({scale:1,mode:"fanAvg",distribution:"normal",seed:t==null?null:t.seed})}getClassName(){return Ka.className}}HI.className="GlorotNormal";$t(HI);class jI extends Ka{constructor(t){super({scale:2,mode:"fanIn",distribution:"normal",seed:t==null?null:t.seed})}getClassName(){return Ka.className}}jI.className="HeNormal";$t(jI);class qI extends Ka{constructor(t){super({scale:2,mode:"fanIn",distribution:"uniform",seed:t==null?null:t.seed})}getClassName(){return Ka.className}}qI.className="HeUniform";$t(qI);class KI extends Ka{constructor(t){super({scale:1,mode:"fanIn",distribution:"normal",seed:t==null?null:t.seed})}getClassName(){return Ka.className}}KI.className="LeCunNormal";$t(KI);class XI extends Ka{constructor(t){super({scale:1,mode:"fanIn",distribution:"uniform",seed:t==null?null:t.seed})}getClassName(){return Ka.className}}XI.className="LeCunUniform";$t(XI);class dV extends Ws{constructor(t){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=t.gain==null?this.DEFAULT_GAIN:t.gain,this.seed=t.seed}apply(t,e){return ut(()=>{if(t.length<2)throw new ke("Shape must be at least 2D.");if(e!=="int32"&&e!=="float32"&&e!==void 0)throw new TypeError(`Unsupported data type ${e}.`);e=e;const r=xt(t.slice(0,-1)),a=t[t.length-1],s=r*a;s>this.ELEMENTS_WARN_SLOW&&console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${s}) elements: Slowness may result.`);const o=[Math.max(a,r),Math.min(a,r)],i=K1(o,0,1,e,this.seed),u=qT.qr(i,!1);let l=u[0];const d=u[1].flatten().stridedSlice([0],[Math.min(a,r)*Math.min(a,r)],[Math.min(a,r)+1]);return l=et(l,d.sign()),r<a&&(l=l.transpose()),et(Jt(this.gain),l.reshape(t))})}getConfig(){return{gain:this.gain,seed:this.seed}}}dV.className="Orthogonal";$t(dV);const kF={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function TF(n,t={}){return av(n,us.getMap().classNameMap,t,"initializer")}function In(n){return PI(n)}function Cn(n){if(typeof n=="string"){const t=n in kF?kF[n]:n;if(t==="GlorotNormal")return new HI;if(t==="GlorotUniform")return new GI;if(t==="HeNormal")return new jI;if(t==="HeUniform")return new qI;if(t==="LeCunNormal")return new KI;if(t==="LeCunUniform")return new XI;{const e={};return e.className=t,e.config={},TF(e)}}else return n instanceof Ws?n:TF(n)}function ik(n){return Array.isArray(n)&&Array.isArray(n[0])}function fb(n){return n.length===0?[]:Array.isArray(n[0])?n:[n]}function he(n){let t;if(Array.isArray(n)){if(n.length!==1)throw new ot(`Expected Tensor length to be 1; got ${n.length}`);t=n[0]}else t=n;return t}function je(n){if(Array.isArray(n)&&Array.isArray(n[0])){if(n.length===1)return n=n,n[0];throw new ot(`Expected exactly 1 Shape; got ${n.length}`)}else return n}function mb(n){let t=0;for(const e of n)e.shape.length===0?t+=1:t+=e.shape.reduce((r,a)=>r*a);return t}const EF="Variable";class Rdt{constructor(t,e="float32",r=EF,a=!0,s=null){this.dtype=e??"float32",this.shape=t.shape,this.id=JP(),r=r??EF,this.originalName=eV(r),this.name=nV(this.originalName),this.trainable_=a,this.constraint=s,this.val=VT(t,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(t){return this.assertNotDisposed(),Adt(this.val,t),this.val.id!==t.id&&(this.val.assign(t),this.constraint!=null&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(t){this.trainable_=t,this.val.trainable=t}}function Adt(n,t){if(n.shape.toString()!==t.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(n.shape)+" vs. "+JSON.stringify(t.shape))}function uk(n){return n.map(t=>t.read())}function YI(n){n.forEach(t=>{t[0].write(t[1])})}class ir{constructor(t){this.dtype=t.dtype,this.shape=t.shape,t.shape!=null?this.ndim=t.shape.length:this.ndim=t.ndim,this.maxNDim=t.maxNDim,this.minNDim=t.minNDim,this.axes=t.axes||{}}}class jo{constructor(t,e,r,a,s,o,i){this.dtype=t,this.shape=e,this.sourceLayer=r,this.inputs=a,this.callArgs=s,this.outputTensorIndex=i,this.id=JP(),o!=null&&(this.originalName=eV(o),this.name=nV(this.originalName)),this.rank=e.length}}let Ddt=0;class X1{constructor(t,e){this.callArgs=e,this.id=Ddt++,this.outboundLayer=t.outboundLayer,this.inboundLayers=t.inboundLayers,this.nodeIndices=t.nodeIndices,this.tensorIndices=t.tensorIndices,this.inputTensors=t.inputTensors,this.outputTensors=t.outputTensors,this.inputMasks=t.inputMasks,this.outputMasks=t.outputMasks,this.inputShapes=t.inputShapes,this.outputShapes=t.outputShapes;for(const r of t.inboundLayers)r?.outboundNodes.push(this);t.outboundLayer.inboundNodes.push(this)}getConfig(){const t=[];for(const e of this.inboundLayers)e!=null?t.push(e.name):t.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:t,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let $dt=0;class Re extends Sc{constructor(t={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=$dt++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let e=t.name;if(!e){const r=this.getClassName();e=Ci(r)+"_"+q1(r)}if(this.name=e,this.trainable_=t.trainable==null?!0:t.trainable,t.inputShape!=null||t.batchInputShape!=null){let r;if(t.batchInputShape!=null)r=t.batchInputShape;else if(t.inputShape!=null){let s=null;t.batchSize!=null&&(s=t.batchSize),r=[s].concat(t.inputShape)}this.batchInputShape=r;let a=t.dtype;a==null&&(a=t.inputDType),a==null&&(a="float32"),this.dtype=a}t.weights!=null?this.initialWeights=t.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(t,e){return t.name+"_ib-"+e.toString()}getNodeAtIndex(t,e){if(this.inboundNodes.length===0)throw new zs(`The layer has never been called and thus has no defined ${e}.`);if(this.inboundNodes.length<=t)throw new ot(`Asked to get ${e} at node ${t}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[t]}getInputAt(t){return ba(this.getNodeAtIndex(t,"input").inputTensors)}getOutputAt(t){return ba(this.getNodeAtIndex(t,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new Co(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(this.inboundNodes.length===0)throw new Co(`Layer ${this.name} is not connected, no input to return.`);return ba(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(this.inboundNodes.length===0)throw new Co(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new Co(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return ba(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(t=>t())}get updates(){return this._updates}get built(){return this._built}set built(t){this._built=t}get trainable(){return this.trainable_}set trainable(t){this._trainableWeights.forEach(e=>e.trainable=t),this.trainable_=t}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(t=>t.trainable):[]}set trainableWeights(t){this._trainableWeights=t}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(t=>!t.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(t){this._nonTrainableWeights=t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(t){const e=Ze(t);if(this.inputSpec==null||this.inputSpec.length===0)return;const r=Ze(this.inputSpec);if(e.length!==r.length)throw new ot(`Layer ${this.name} expects ${r.length} inputs, but it received ${e.length} input tensors. Input received: ${t}`);for(let a=0;a<e.length;a++){const s=e[a],o=r[a];if(o==null)continue;const i=s.rank;if(o.ndim!=null&&i!==o.ndim)throw new ot(`Input ${a} is incompatible with layer ${this.name}: expected ndim=${o.ndim}, found ndim=${i}`);if(o.maxNDim!=null&&i>o.maxNDim)throw new ot(`Input ${a} is incompatible with layer ${this.name}: expected max_ndim=${o.maxNDim}, found ndim=${i}`);if(o.minNDim!=null&&i<o.minNDim)throw new ot(`Input ${a} is incompatible with layer ${this.name}: expected min_ndim=${o.minNDim}, found ndim=${i}.`);if(o.dtype!=null&&s.dtype!==o.dtype)throw new ot(`Input ${a} is incompatible with layer ${this.name} : expected dtype=${o.dtype}, found dtype=${s.dtype}.`);if(o.axes){const u=s.shape;for(const l in o.axes){const h=Number(l),d=o.axes[l],f=h>=0?u[h]:u[u.length+h];if(d!=null&&[d,null].indexOf(f)===-1)throw new ot(`Input ${a} is incompatible with layer ${this.name}: expected axis ${h} of input shape to have value ${d} but got shape ${u}.`)}}if(o.shape!=null)for(let u=0;u<o.shape.length;++u){const l=o.shape[u],h=s.shape[u];if(l!=null&&h!=null&&l!==h)throw new ot(`Input ${a} is incompatible with layer ${this.name}: expected shape=${o.shape}, found shape=${s.shape}.`)}}}call(t,e){return t}invokeCallHook(t,e){this._callHook!=null&&this._callHook(t,e)}setCallHook(t){this._callHook=t}clearCallHook(){this._callHook=null}apply(t,e){e=e||{},this.assertNotDisposed();const r=Ze(t),a=Mdt(t),s=Ldt(t);if(a===s)throw new ot("Arguments to apply() must be all SymbolicTensors or all Tensors");return Yl(this.name,()=>{if(!this.built){this.assertInputCompatibility(t);const o=[];for(const i of Ze(t))o.push(i.shape);this.build(ba(o)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),this._refCount===null&&s&&(this._refCount=1)}if(this.assertInputCompatibility(t),s){let o=this.call(t,e);this.supportsMasking&&this.setMaskMetadata(t,o);const i=Ze(o),u=[];for(let l of i)r.indexOf(l)!==-1&&(l=l.clone()),u.push(l);if(o=ba(u),this.activityRegularizer!=null)throw new ke("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return o}else{const o=Odt(t),i=this.computeOutputShape(o);let u;const l=Fdt(t);if(this.warnOnIncompatibleInputShape(Array.isArray(t)?o[0]:o),i!=null&&i.length>0&&Array.isArray(i[0])?u=i.map((h,d)=>new jo(l,h,this,Ze(t),e,this.name,d)):u=new jo(l,i,this,Ze(t),e,this.name),this.addInboundNode(t,u,null,null,o,i,e),this._refCount++,this.activityRegularizer!=null)throw new ke("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return u}})}warnOnIncompatibleInputShape(t){if(this.batchInputShape!=null)if(t.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(t)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let e=!1;this.batchInputShape.forEach((r,a)=>{r!=null&&t[a]!=null&&t[a]!==r&&(e=!0)}),e&&console.warn(`The shape of the input tensor (${JSON.stringify(t)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(this.inboundNodes==null||this.inboundNodes.length===0)throw new Co(`The layer ${this.name} has never been called and thus has no defined output shape.`);const t=[];for(const e of this.inboundNodes){const r=JSON.stringify(e.outputShapes);t.indexOf(r)===-1&&t.push(r)}if(t.length===1){const e=this.inboundNodes[0].outputShapes;return Array.isArray(e)&&Array.isArray(e[0])&&e.length===1?e[0]:e}else throw new Co(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new zs(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return mb(this.weights)}build(t){this.built=!0}getWeights(t=!1){return uk(t?this.trainableWeights:this.weights)}setWeights(t){ut(()=>{const e=this.weights;if(e.length!==t.length)throw new ot(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${t.length}, but the layer was expecting ${e.length} weights. Provided weights: ${t}...`);if(e.length===0)return;const r=[],a=uk(e);for(let s=0;s<a.length;++s){const o=a[s],i=e[s],u=t[s];if(!De(o.shape,u.shape))throw new ot(`Layer weight shape ${o.shape} not compatible with provided weight shape ${u.shape}`);r.push([i,u])}YI(r)})}addWeight(t,e,r,a,s,o,i,u){if(this._addedWeightNames.indexOf(t)!==-1)throw new ot(`Duplicate weight name ${t} for layer ${this.name}`);this._addedWeightNames.push(t),r==null&&(r="float32"),this.fastWeightInitDuringBuild&&(a=u!=null?u():Cn("zeros"));const l=a.apply(e,r),h=new Rdt(l,r,t,o,i);return l.dispose(),s!=null&&this.addLoss(()=>s.apply(h.read())),o==null&&(o=!0),o?this._trainableWeights.push(h):this._nonTrainableWeights.push(h),h}setFastWeightInitDuringBuild(t){this.fastWeightInitDuringBuild=t}addLoss(t){t==null||Array.isArray(t)&&t.length===0||(t=Ze(t),this._losses!==void 0&&this._losses!==null&&this.losses.push(...t))}computeOutputShape(t){return t}computeMask(t,e){if(!this.supportsMasking){if(e!=null)if(Array.isArray(e))e.forEach(r=>{if(r!=null)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)});else throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);return null}return e}setMaskMetadata(t,e,r){if(!this.supportsMasking)return;const a=this.computeMask(t,r),s=Ze(e),o=Ze(a);if(s.length!==o.length)throw new Error(`${this.name} outputs ${s.length} tensors but ${s.length} masks for those tensors`);for(let i=0;i<s.length;i++)s[i].kerasMask=o[i]}addInboundNode(t,e,r,a,s,o,i=null){const u=Ze(t);e=Ze(e),r=Ze(r),a=Ze(a),s=fb(s),o=fb(o);const l=[],h=[],d=[];for(const f of u)l.push(f.sourceLayer),h.push(f.nodeIndex),d.push(f.tensorIndex);new X1({outboundLayer:this,inboundLayers:l,nodeIndices:h,tensorIndices:d,inputTensors:u,outputTensors:e,inputMasks:r,outputMasks:a,inputShapes:s,outputShapes:o},i);for(let f=0;f<e.length;f++)e[f].sourceLayer=this,e[f].nodeIndex=this.inboundNodes.length-1,e[f].tensorIndex=f}getConfig(){const t={name:this.name,trainable:this.trainable};return this.batchInputShape!=null&&(t.batchInputShape=this.batchInputShape),this.dtype!=null&&(t.dtype=this.dtype),t}disposeWeights(){return this.weights.forEach(t=>t.dispose()),this.weights.length}assertNotDisposed(){if(this._refCount===0)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(this._refCount===null)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let t=0;return--this._refCount===0&&(t=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:t}}}function Odt(n){n=Ze(n);const t=[];for(const e of n)t.push(e.shape);return ba(t)}function Fdt(n){return"float32"}function pV(n,t,e){if((t==null||e!=null&&e>0)&&(t=n.sourceLayer,e=n.nodeIndex),t.inboundNodes.length===0)return[n];{const r=t.inboundNodes[e];if(r.inboundLayers.length===0)return r.inputTensors;{const a=[];for(let s=0;s<r.inboundLayers.length;s++){const o=r.inputTensors[s],i=r.inboundLayers[s],u=r.nodeIndices[s],l=pV(o,i,u);for(const h of l)a.indexOf(h)===-1&&a.push(h)}return a}}}function Mdt(n){let t=!0;for(const e of Ze(n))if(!(e instanceof jo)){t=!1;break}return t}function Ldt(n){let t=!0;for(const e of Ze(n))if(e instanceof jo){t=!1;break}return t}class uv extends Re{constructor(t){if(super({dtype:t.dtype,name:t.name!=null?t.name:q1("input").toString()}),t.batchSize==null&&(t.batchSize=null),t.sparse==null&&(t.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=t.sparse,t.inputShape!=null&&t.batchInputShape!=null)throw new ot("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let e=t.batchInputShape;if(e==null){if(t.inputShape==null)throw new ot("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");e=[t.batchSize].concat(t.inputShape)}else if(t.batchSize!=null)throw new ot("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const r=t.dtype||"float32";this.batchInputShape=e,this.dtype=r,this.inputSpec=[{shape:e}];const a=new jo(this.dtype,this.batchInputShape,this,[],{},this.name);a.nodeIndex=0,a.tensorIndex=0,new X1({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[a],outputTensors:[a],inputMasks:[null],outputMasks:[null],inputShapes:[e],outputShapes:[e]})}apply(t,e){throw new ot(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}uv.className="InputLayer";$t(uv);function Bdt(n){if(n.batchShape==null&&n.shape==null)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(n.batchShape!=null&&n.shape!=null)throw new ot("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let t=n.batchShape;n.shape!=null&&t==null&&(t=[null].concat(n.shape));let e=n.dtype;return e==null&&(e="float32"),new uv({batchInputShape:t,name:n.name,dtype:e,sparse:n.sparse}).inboundNodes[0].outputTensors[0]}function zdt(n,t){if(n.dtype==null||n.dtype===t.dtype)return t;try{return Ft(t,n.dtype)}catch{throw new ot(`The dtype of the feed (${t.dtype}) can not be cast to the dtype of the key '${n.name}' (${n.dtype}).`)}}class ku{constructor(t){if(this.id2Value={},this.id2Mask={},this.name2Id={},t instanceof ku)for(const e in t.id2Value)this.id2Value[e]=t.id2Value[e],e in t.id2Mask&&(this.id2Mask[e]=t.id2Mask[e]);else{if(t==null)return;for(const e of t)this.add(e.key,e.value)}}add(t,e,r){if(this.id2Value[t.id]==null)this.id2Value[t.id]=zdt(t,e),this.name2Id[t.name]=t.id,r!=null&&(this.id2Mask[t.id]=r);else throw new ot(`Duplicate key: name=${t.name}, id=${t.id}`);return this}addFeed(t){this.add(t.key,t.value)}hasKey(t){return this.id2Value[t.id]!=null}names(){return Object.keys(this.name2Id)}getValue(t){if(t instanceof jo){if(this.id2Value[t.id]==null)throw new ot(`Nonexistent key: ${t.name}`);return this.id2Value[t.id]}else{const e=this.name2Id[t];if(e==null)throw new ot(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Value[e]}}getMask(t){if(t instanceof jo){if(this.id2Value[t.id]==null)throw new ot(`Nonexistent key: ${t.name}`);return this.id2Mask[t.id]}else{const e=this.name2Id[t];if(e==null)throw new ot(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Mask[e]}}disposeMasks(){this.id2Mask!=null&&Ie(this.id2Mask)}}const gb=new YP,vb=new YP;function Pdt(n){gb?.setMaxEntries(n),vb?.setMaxEntries(n)}function Mf(n,t,e,r){const a=e==null?!1:e.training,s=Array.isArray(n),o=s?n:[n],i=o.map(v=>v.name),u=[],l=t.names();for(const v of i)l.indexOf(v)!==-1?u.push(t.getValue(v)):u.push(null);const h=i.join(",")+"|"+t.names().sort().join(",");let d=gb.get(h),f;if(d==null){const v=Vdt(o,t);d=v.sorted,f=v.recipientCounts,gb.put(h,d),vb.put(h,f)}f={},a||Object.assign(f,vb.get(h));const m=new ku(t);for(let v=0;v<d.length;++v){const y=d[v],b=y.sourceLayer;if(b instanceof uv)continue;const w=[],S=[],N=[];let C=!1;for(const R of y.inputs){const D=m.getValue(R),A=m.getMask(R);w.push(D),S.push(A),A!=null&&(C=!0),a||(f[R.name]--,f[R.name]===0&&!t.hasKey(R)&&i.indexOf(R.name)===-1&&!D.isDisposed&&R.sourceLayer.stateful!==!0&&N.push(D))}C&&(e=e||{},e.mask=S[0]);const T=Ze(b.apply(w,e));let I=null;b.supportsMasking&&(I=b.computeMask(w,S));const _=Wdt(y),$=Array.isArray(_)?_:[_];for(let R=0;R<$.length;++R){m.hasKey($[R])||m.add($[R],T[R],Array.isArray(I)?I[0]:I);const D=i.indexOf($[R].name);D!==-1&&(u[D]=T[R])}a||Ie(N)}return m.disposeMasks(),s?u:u[0]}function Vdt(n,t){P(n!=null&&n.length>0,()=>"Expected at least one fetch, got none");let e=[],r={};if(n.length===1){const a=IF(n[0],t);e=a.sorted,r=a.recipientMap}else{const a=new Set;for(const s of n){const{sorted:o,recipientMap:i}=IF(s,t);for(const u of o)a.has(u.name)||(e.push(u),a.add(u.name));for(const u in i)r[u]==null&&(r[u]=new Set),i[u].forEach(l=>r[u].add(l))}}return{sorted:e,recipientCounts:Udt(r)}}function Udt(n){const t={};for(const e in n)t[e]=n[e].size;return t}function IF(n,t){const e=new Set,r=[],a={};for(const i of t.names())e.add(i);const s=[],o=[];for(s.push(n);s.length>0;){const i=s[s.length-1];if(e.has(i.name)){s.pop();continue}const u=o[o.length-1]===s.length-1;if(i.inputs.length===0||u)s.pop(),r.push(i),e.add(i.name),u&&o.pop();else{o.push(s.length-1);for(const l of i.inputs)a[l.name]==null&&(a[l.name]=new Set),a[l.name].add(i.name),!e.has(l.name)&&s.push(l)}}return{sorted:r,recipientMap:a}}function Wdt(n){let t;if(n.sourceLayer.inboundNodes.length===1)t=n.sourceLayer.output;else{let e=null;for(let r=0;r<n.sourceLayer.inboundNodes.length;++r)for(const a of n.sourceLayer.inboundNodes[r].outputTensors)if(a.id===n.id){e=r;break}t=n.sourceLayer.getOutputAt(e)}return t}const Gdt=dt();Gdt.registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,Pdt);function QI(n,t){return ut(()=>wr(jt(et(n,n),t,!0)))}class lv extends Sc{getConfig(){return{}}}class fV extends lv{constructor(t){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=t.maxValue!=null?t.maxValue:this.defaultMaxValue,this.axis=t.axis!=null?t.axis:this.defaultAxis}apply(t){return ut(()=>{const e=QI(t,this.axis),r=Na(e,0,this.maxValue);return et(t,Ut(r,It(or(),e)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}fV.className="MaxNorm";$t(fV);class mV extends lv{constructor(t){super(),this.defaultAxis=0,this.axis=t.axis!=null?t.axis:this.defaultAxis}apply(t){return ut(()=>Ut(t,It(or(),QI(t,this.axis))))}getConfig(){return{axis:this.axis}}}mV.className="UnitNorm";$t(mV);class gV extends lv{apply(t){return lo(t)}}gV.className="NonNeg";$t(gV);class vV extends lv{constructor(t){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=t.minValue!=null?t.minValue:this.defaultMinValue,this.maxValue=t.maxValue!=null?t.maxValue:this.defaultMaxValue,this.rate=t.rate!=null?t.rate:this.defaultRate,this.axis=t.axis!=null?t.axis:this.defaultAxis}apply(t){return ut(()=>{const e=QI(t,this.axis),r=It(et(this.rate,Na(e,this.minValue,this.maxValue)),et(1-this.rate,e));return et(t,Ut(r,It(or(),e)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}vV.className="MinMaxNorm";$t(vV);const _F={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function ur(n){return PI(n)}function RF(n,t={}){return av(n,us.getMap().classNameMap,t,"constraint")}function lr(n){if(n==null)return null;if(typeof n=="string"){const e={className:n in _F?_F[n]:n,config:{}};return RF(e)}else return n instanceof lv?n:RF(n)}async function _l(n){if(n==null)return;const t=[],e=[],r=[];for(const a in n){const s=n[a];if(typeof s!="number"){const o=s;t.push(o.data()),e.push(a),r.push(o)}}if(t.length>0){const a=await Promise.all(t);for(let s=0;s<a.length;++s)n[e[s]]=a[s][0];Ie(r)}}function yV(n){if(n!=null)for(const t in n){const e=n[t];typeof e!="number"&&e.dispose()}}var AF;(function(n){n[n.SILENT=0]="SILENT",n[n.VERBOSE=1]="VERBOSE"})(AF||(AF={}));const Hdt=125;class hm{constructor(){this.validationData=null}setParams(t){this.params=t}async onEpochBegin(t,e){}async onEpochEnd(t,e){}async onBatchBegin(t,e){}async onBatchEnd(t,e){}async onTrainBegin(t){}async onTrainEnd(t){}setModel(t){}}class jdt{constructor(t,e=10){t==null&&(t=[]),this.callbacks=t,this.queueLength=e}append(t){this.callbacks.push(t)}setParams(t){for(const e of this.callbacks)e.setParams(t)}setModel(t){for(const e of this.callbacks)e.setModel(t)}async onEpochBegin(t,e){e==null&&(e={});for(const r of this.callbacks)await r.onEpochBegin(t,e)}async onEpochEnd(t,e){e==null&&(e={});for(const r of this.callbacks)await r.onEpochEnd(t,e)}async onBatchBegin(t,e){e==null&&(e={});for(const r of this.callbacks)await r.onBatchBegin(t,e)}async onBatchEnd(t,e){e==null&&(e={});for(const r of this.callbacks)await r.onBatchEnd(t,e)}async onTrainBegin(t){t==null&&(t={});for(const e of this.callbacks)await e.onTrainBegin(t)}async onTrainEnd(t){t==null&&(t={});for(const e of this.callbacks)await e.onTrainEnd(t)}}class qdt extends hm{constructor(){super()}async onEpochBegin(t){this.seen=0,this.totals={}}async onBatchEnd(t,e){e==null&&(e={});const r=e.size==null?0:e.size;this.seen+=r;for(const a in e){const s=e[a];if(typeof s=="number")this.totals.hasOwnProperty(a)||(this.totals[a]=0),this.totals[a]=this.totals[a]+s*r;else{let o;a in this.totals?o=this.totals[a]:this.totals[a]=0;const i=ut(()=>It(this.totals[a],et(s,r)));this.totals[a]=i,o?.dispose()}}}async onEpochEnd(t,e){if(e!=null)for(const r of this.params.metrics)this.totals[r]!=null&&(typeof this.totals[r]=="number"?e[r]=this.totals[r]/this.seen:ut(()=>{const a=et(Ut(1,this.seen),this.totals[r]);e[r]=a,this.totals[r].dispose(),ar(e[r])}))}}class Kdt extends hm{async onTrainBegin(t){this.epoch=[],this.history={}}async onEpochEnd(t,e){e==null&&(e={}),this.epoch.push(t);for(const r in e)this.history[r]==null&&(this.history[r]=[]),this.history[r].push(e[r])}async syncData(){const t=[],e=[],r=[];for(const s in this.history){const o=this.history[s];for(let i=0;i<o.length;++i)if(typeof o[i]!="number"){const u=o[i];t.push(u.data()),e.push(s),r.push(i)}}const a=await Promise.all(t);for(let s=0;s<a.length;++s)this.history[e[s]][r[s]].dispose(),this.history[e[s]][r[s]]=a[s][0]}}class Xdt extends hm{constructor(t,e){if(super(),this.currentEpoch=0,this.nowFunc=t.nowFunc,this.nextFrameFunc=t.nextFrameFunc||lE,this.yieldEvery=e||"auto",this.yieldEvery==="auto"&&(this.yieldEvery=Hdt),this.yieldEvery==="never"&&t.onYield!=null)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");$0(this.yieldEvery)&&(this.maybeWait=udt(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=t.onTrainBegin,this.trainEnd=t.onTrainEnd,this.epochBegin=t.onEpochBegin,this.epochEnd=t.onEpochEnd,this.batchBegin=t.onBatchBegin,this.batchEnd=t.onBatchEnd,this.yield=t.onYield}async maybeWait(t,e,r){const a=[];this.yield!=null&&(await _l(r),a.push(this.yield(t,e,r))),a.push(this.nextFrameFunc()),await Promise.all(a)}async onEpochBegin(t,e){this.currentEpoch=t,this.epochBegin!=null&&(await _l(e),await this.epochBegin(t,e))}async onEpochEnd(t,e){const r=[];this.epochEnd!=null&&(await _l(e),r.push(this.epochEnd(t,e))),this.yieldEvery==="epoch"&&r.push(this.nextFrameFunc()),await Promise.all(r)}async onBatchBegin(t,e){this.batchBegin!=null&&(await _l(e),await this.batchBegin(t,e))}async onBatchEnd(t,e){const r=[];this.batchEnd!=null&&(await _l(e),r.push(this.batchEnd(t,e))),this.yieldEvery==="batch"?r.push(this.nextFrameFunc()):$0(this.yieldEvery)&&r.push(this.maybeWait(this.currentEpoch,t,e)),await Promise.all(r)}async onTrainBegin(t){this.trainBegin!=null&&(await _l(t),await this.trainBegin(t))}async onTrainEnd(t){this.trainEnd!=null&&(await _l(t),await this.trainEnd(t))}}function bV(n,t){return n==null&&(n={}),n instanceof hm?[n]:Array.isArray(n)&&n[0]instanceof hm?n:Ze(n).map(r=>new Xdt(r,t))}class Os{constructor(){}static registerCallbackConstructor(t,e){P(t>=0&&Number.isInteger(t),()=>`Verbosity level is expected to be an integer >= 0, but got ${t}`),Os.checkForDuplicate(e),Os.constructors[t]==null&&(Os.constructors[t]=[]),Os.constructors[t].push(e)}static checkForDuplicate(t){for(const e in Os.constructors)Os.constructors[+e].forEach(a=>{if(a===t)throw new ot("Duplicate callback constructor.")})}static clear(){Os.constructors={}}static createCallbacks(t){const e=[];for(const r in Os.constructors){const a=+r;t>=a&&e.push(...Os.constructors[a])}return e.map(r=>new r)}}Os.constructors={};function xV(n,t,e,r,a,s,o,i,u){const l=new Kdt,h=[new qdt,...Os.createCallbacks(t)];n!=null&&h.push(...n),h.push(l);const d=new jdt(h);return d.setParams({epochs:e,initialEpoch:r,samples:a,steps:s,batchSize:o,verbose:t,doValidation:i,metrics:u}),{callbackList:d,history:l}}function Ei(n,t={},e=!1){return av(n,us.getMap().classNameMap,t,"layer",e)}function yb(n,t){return ut(()=>{n.dtype!=="float32"&&(n=Ft(n,"float32"));const e=jt(ov(n),t,!0),r=bc(e.shape,or()),a=wr(Ko(e,r));return Ut(n,a)})}function Y1(n,t){return ut(()=>En(ov(zt(t,n)),-1))}function ZI(n,t){return ut(()=>En(Kn(zt(t,n)),-1))}function JI(n,t){return ut(()=>{const e=zt(n,t),r=Na(Kn(n),or(),Number.MAX_VALUE),a=Kn(Ut(e,r));return et(100,En(a,-1))})}function Ydt(n,t){return ut(()=>{const e=Na(t,or(),Number.MAX_VALUE),r=Ga(It(1,e)),a=Na(n,or(),Number.MAX_VALUE),s=Ga(It(1,a));return En(ov(zt(r,s)),-1)})}function Qdt(n,t){return ut(()=>{const e=Ko(0,zt(1,et(n,t)));return En(ov(e),-1)})}function Zdt(n,t){return ut(()=>{const e=Ko(0,zt(1,et(n,t)));return En(e,-1)})}function Jdt(n,t){return ut(()=>{const e=jt(et(n,t),-1),r=vs(et(zt(1,n),t),-1);return Ko(0,It(1,zt(r,e)))})}function tpt(n,t){return ut(()=>{const e=Math.log(2),r=zt(t,n),a=zt(It(r,xc(et(-2,r))),e);return En(a,-1)})}function dm(n,t,e=!1){return ut(()=>{if(e)t=Vg(t);else{const r=jt(t,t.shape.length-1,!0);t=Ut(t,r)}return t=Na(t,or(),1-or()),mn(jt(et(Ft(n,"float32"),Ga(t)),t.shape.length-1))})}function bb(n,t,e=!1){return ut(()=>{const r=Ft(cp(xdt(n)),"int32");t=Na(t,or(),1-or());const a=t.shape,s=at(sc(r,a[a.length-1]),a);return dm(s,t,e)})}function ept(n,t){if(!De(n.shape,t.shape))throw new ot(`logits and labels must have the same shape, but got shapes ${JSON.stringify(n.shape)} and ${JSON.stringify(t.shape)}`);return ut(()=>{const e=lo(t),r=mn(Kn(t));return It(zt(e,et(t,n)),Dg(ka(r)))})}function Q1(n,t){return ut(()=>{let e;return e=Na(t,or(),1-or()),e=Ga(Ut(e,zt(1,e))),En(ept(n,e),-1)})}function npt(n,t){return ut(()=>{const e=Na(n,or(),1),r=Na(t,or(),1);return jt(et(n,Ga(Ut(e,r))),-1)})}function rpt(n,t){return ut(()=>{const e=Ga(It(or(),t));return En(zt(t,et(n,e)),-1)})}function wV(n,t){return ut(()=>{const e=yb(n,-1),r=yb(t,-1),a=et(e,r);return mn(jt(a,-1))})}const xb={meanSquaredError:Y1,meanAbsoluteError:ZI,meanAbsolutePercentageError:JI,meanSquaredLogarithmicError:Ydt,squaredHinge:Qdt,hinge:Zdt,categoricalHinge:Jdt,logcosh:tpt,categoricalCrossentropy:dm,sparseCategoricalCrossentropy:bb,binaryCrossentropy:Q1,kullbackLeiblerDivergence:npt,poisson:rpt,cosineProximity:wV};function PC(n){if(typeof n=="string"){if(n in xb)return xb[n];let t=`Unknown loss ${n}`;throw n.toLowerCase().includes("softmaxcrossentropy")&&(t=`Unknown loss ${n}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new ot(t)}else return n}function SV(n,t){return ut(()=>{const e=et(.5,Ha(t)),r=zo(ga(t,e),n.dtype);return En(Wa(n,r),-1)})}function CV(n,t){return ut(()=>zo(Wa(Bu(n,-1),Bu(t,-1)),"float32"))}function apt(n,t){return ut(()=>Ft(jt(ao(Wa(n,1),Wa(t,1))),"float32"))}function spt(n,t){return ut(()=>Ft(jt(ao(Wa(n,0),Wa(t,1))),"float32"))}function opt(n,t){return ut(()=>{const e=apt(n,t),r=spt(n,t),a=It(e,r);return Ft(Or(ga(a,0),Ut(e,a),0),"float32")})}function ipt(n,t){return Q1(n,t)}function upt(n,t){return n.rank===t.rank&&(n=$r(n,[n.rank-1])),t=Bu(t,-1),t.dtype!==n.dtype&&(t=Ft(t,n.dtype)),Ft(Wa(n,t),"float32")}const lpt=Y1,cpt=Y1,hpt=ZI,dpt=ZI,ppt=JI,fpt=JI,NV=dm,mpt=wV,kV=bb,wb={binaryAccuracy:SV,categoricalAccuracy:CV,precision:opt,categoricalCrossentropy:NV,sparseCategoricalCrossentropy:kV,mse:lpt,MSE:cpt,mae:hpt,MAE:dpt,mape:ppt,MAPE:fpt,cosine:mpt};function gpt(n){if(typeof n=="string"&&n in wb)return wb[n];if(typeof n!="string"&&n!=null)return n;throw new ot(`Unknown metric ${n}`)}function u0(n){if(No(n!==null,`Unknown LossOrMetricFn ${n}`),typeof n=="string")return n;{let t;for(const e of Object.keys(xb))if(xb[e]===n){t=e;break}if(t!==void 0)return t;for(const e of Object.keys(wb))if(wb[e]===n){t=e;break}return t!==void 0?t:n.name}}function vpt(n){const t={Adagrad:()=>Dl.adagrad(.01),Adadelta:()=>Dl.adadelta(1,.95,or()),Adam:()=>Dl.adam(.001,.9,.999,or()),Adamax:()=>Dl.adamax(.002,.9,.999,or(),0),RMSProp:()=>Dl.rmsprop(.001,.9,0,or()),SGD:()=>Dl.sgd(.01)};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,n in t)return t[n]();throw new ot(`Unknown Optimizer ${n}`)}const DF=1*1024*1024;function $F(n,t,e=!1){if(n==null||typeof n!="object"||Object.getPrototypeOf(n)!==Object.prototype||!lk(n))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(e){const r=JSON.stringify(n);r.length>DF&&console.warn(`User-defined metadata of model "${t}" is too large in size (length=${r.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= ${DF}.`)}}function lk(n){if(n===null)return!0;if(typeof n=="object")if(Object.getPrototypeOf(n)===Object.prototype){const t=Object.keys(n);for(const e of t)if(typeof e!="string"||!lk(n[e]))return!1;return!0}else if(Array.isArray(n)){for(const t of n)if(!lk(t))return!1;return!0}else return!1;else{const t=typeof n;return t==="string"||t==="number"||t==="boolean"}}function ypt(n,t,e,r=console.log){const a=xpt(n),s=["Layer (type)","Input Shape","Output shape","Param #"];a?(t=t||90,e=e||[.32,.61,.89,1]):(t=t||115,e=e||[.24,.48,.7,.8,1]),e[e.length-1]<=1&&(e=e.map(h=>Math.floor(t*h)));let o;if(!a){s.push("Receives inputs"),o=[];for(const h in n.nodesByDepth)o.push(...n.nodesByDepth[h])}r("_".repeat(t)),Sb(s,e,r),r("=".repeat(t));const i=n.layers;for(let h=0;h<i.length;++h)a?wpt(i[h],e,r):Spt(i[h],e,o,r),r((h===i.length-1?"=":"_").repeat(t));n.checkTrainableWeightsConsistency();const u=bpt(n),l=mb(n.nonTrainableWeights);r(`Total params: ${u+l}`),r(`Trainable params: ${u}`),r(`Non-trainable params: ${l}`),r("_".repeat(t))}function bpt(n){let t;return n.collectedTrainableWeights!=null?t=mb(n.collectedTrainableWeights):t=mb(n.trainableWeights),t}function xpt(n){let t=!0;const e=[],r=[];for(const a in n.nodesByDepth)e.push(n.nodesByDepth[a]);for(const a of e){if(a.length>1||a.length===1&&a[0].inboundLayers.length>1){t=!1;break}r.push(...a)}if(t)for(const a of n.layers){let s=!1;for(const o of a.inboundNodes)if(r.indexOf(o)!==-1)if(s){t=!1;break}else s=!0;if(!t)break}return t}function Sb(n,t,e=console.log){let r="";for(let a=0;a<n.length;++a)a>0&&(r=r.slice(0,r.length-1)+" "),r+=n[a],r=r.slice(0,t[a]),r+=" ".repeat(t[a]-r.length);e(r)}function wpt(n,t,e){let r,a;try{a=n.inboundNodes.map(u=>JSON.stringify(u.inputShapes)).join(",")}catch{a="multiple"}try{r=JSON.stringify(n.outputShape)}catch{r="multiple"}const s=n.name,o=n.getClassName(),i=[`${s} (${o})`,a,r,n.countParams().toString()];Sb(i,t,e)}function Spt(n,t,e,r){let a,s;try{s=n.inboundNodes.map(d=>JSON.stringify(d.inputShapes)).join(",")}catch{s="multiple"}try{a=JSON.stringify(n.outputShape)}catch{a="multiple"}const o=[];for(const d of n.inboundNodes)if(!(e!=null&&e.length>0&&e.indexOf(d)===-1))for(let f=0;f<d.inboundLayers.length;++f){const m=d.inboundLayers[f].name,v=d.nodeIndices[f],y=d.tensorIndices[f];o.push(`${m}[${v}][${y}]`)}const i=n.name,u=n.getClassName(),l=o.length===0?"":o[0],h=[`${i} (${u})`,s,a,n.countParams().toString(),l];Sb(h,t,r);for(let d=1;d<o.length;++d)Sb(["","","","",o[d]],t,r)}function TV(n,t,e){return(n==="inboundNodes"||n==="outputLayers"||n==="inputLayers")&&t===0&&typeof e=="string"}function ck(n,t){if(n===null)return null;if(typeof n=="string")return Pl(n);if(typeof n=="number"||typeof n=="boolean")return n;if(n instanceof Array){const e=[],r=n.length;for(let a=0;a<r;++a){const s=n[a];TV(t,a,s)?e.push(s):e.push(ck(s,t))}return e}else{const e={};for(const r of Object.keys(n)){const a=n[r];if(r==="name"&&typeof a=="string")e[r]=a;else{const s=Pl(r);e[s]=ck(a,s)}}return e}}function hk(n,t){if(n==null)return null;if(typeof n=="string")return Ci(n);if(typeof n=="number"||typeof n=="boolean")return n;if(n instanceof Array){const e=[],r=n.length;for(let a=0;a<r;++a){const s=n[a];TV(t,a,s)?e.push(s):e.push(hk(s,t))}return e}else{const e={};for(const r of Object.keys(n)){const a=n[r],s=Ci(r);(r==="name"||r==="className")&&typeof a=="string"?e[s]=a:e[s]=hk(a,r)}return e}}const EV="4.22.0";const Cpt=n=>{const t=Object.keys(n);if(t.length===0)return!1;const e=t[0].split("/");return!isNaN(parseInt(e[e.length-1],10))};class Xs extends Re{constructor(t){if(super({}),this.containerNodes=new Set,this.name=t.name,this.name==null){const S=this.getClassName().toLowerCase();this.name=q1(S)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(t.inputs)?this.inputs=t.inputs.slice():this.inputs=[t.inputs],Array.isArray(t.outputs)?this.outputs=t.outputs.slice():this.outputs=[t.outputs],Du(this.inputs).length!==this.inputs.length)throw new ot(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(S=>S.name)}`);Du(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(S=>S.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const S of this.outputs){const N=S.sourceLayer,C=S.nodeIndex,T=S.tensorIndex;this.outputLayers.push(N),this.outputLayersNodeIndices.push(C),this.outputLayersTensorIndices.push(T)}for(const S of this.inputs){const N=S.sourceLayer,C=S.nodeIndex,T=S.tensorIndex;No(C===0,"input layer has >1 nodes"),No(T===0,"input layer has >1 tensors"),this.inputLayers.push(N),this.inputLayersNodeIndices.push(C),this.inputLayersTensorIndices.push(T)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let S=0;S<this.inputLayers.length;S++){const N=this.inputLayers[S];if(!(N instanceof uv))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${t.inputs}. Input ${S} (0-based) originates from layer type ${N.getClassName()}.`);this.inputNames.push(N.name),this.feedInputShapes.push(N.batchInputShape),this.feedInputNames.push(N.name)}for(const S of this.outputLayers)this.outputNames.push(S.name);this.internalInputShapes=this.inputs.map(S=>S.shape),this.internalOutputShapes=this.outputs.map(S=>S.shape);const e={},r={},a={},s={},o={},i=[],u=(S,N,C,T,I,_)=>{(T==null||I==null||_==null)&&(T=S.sourceLayer,I=S.nodeIndex,_=S.tensorIndex);const $=T.inboundNodes[I];if(C.indexOf($)!==-1)throw new zs(`The tensor ${S.name} at layer "${T.name}" is part of a cycle.`);if(N.indexOf($)!==-1)return;this.containerNodes.add(Xs.nodeKey(T,I)),T.id in o||(o[T.id]=Object.keys(o).length),C.indexOf($)===-1&&C.push($);const R=$.inboundLayers.length;for(let D=0;D<R;D++){const A=$.inputTensors[D],L=$.inboundLayers[D],H=$.nodeIndices[D],G=$.tensorIndices[D];u(A,N,C,L,H,G)}for(N.push($);C.indexOf($)>=0;)C.splice(C.indexOf($),1);i.push($)},l=[],h=[];for(const S of this.outputs)u(S,l,h);const d=i.slice().reverse();for(const S of d){r[S.id]=S,S.id in e||(e[S.id]=0);let N=e[S.id];const C=a[S.outboundLayer.id]==null?0:a[S.outboundLayer.id];N=Math.max(N,C),a[S.outboundLayer.id]=N,s[S.outboundLayer.id]=S.outboundLayer,e[S.id]=N;for(let T=0;T<S.inboundLayers.length;T++){const I=S.inboundLayers[T],_=S.nodeIndices[T],$=I.inboundNodes[_],R=e[$.id]==null?0:e[$.id];e[$.id]=Math.max(N+1,R),r[$.id]=$}}const f={};for(const S in e){const N=e[S];N in f||(f[N]=[]),f[N].push(r[S])}const m={};for(const S in a){const N=a[S];N in m||(m[N]=[]),m[N].push(s[S])}let v=Object.keys(m).map(S=>parseInt(S,10)).sort(s0);this.layers=[];for(const S of v){const N=m[S];N.sort((C,T)=>{const I=o[C.id],_=o[T.id];return I<_?-1:I>_?1:0});for(const C of N)C instanceof Xs&&this.internalContainerRefs.push(C),this.layers.push(C)}this.layersByDepth=m,v=Object.keys(f).map(S=>parseInt(S,10)).sort(s0);const y=this.inputs.slice(),b=[];for(const S of v)for(const N of f[S]){const C=N.outboundLayer;if(C!=null){for(const T of N.inputTensors)if(y.indexOf(T)===-1)throw new zs(`Graph disconnected: cannot obtain value for tensor ${T} at layer "${C.name}". The following previous layers were accessed without issue: ${b}`);for(const T of N.outputTensors)y.push(T);b.push(C.name)}}this.nodesByDepth=f;const w=this.layers.map(S=>S.name);for(const S of w){const N=w.filter(C=>C===S).length;if(N!==1)throw new zs(`The name "${S}" is used ${N} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(w))}this.outboundNodes=[],this.inboundNodes=[],new X1({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(S=>null),outputMasks:this.outputs.map(S=>null),inputShapes:this.inputs.map(S=>S.shape),outputShapes:this.outputs.map(S=>S.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(this._refCount===0)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const t={refCountAfterDispose:null,numDisposedVariables:0};if(--this._refCount===0){for(const e of this.layers)t.numDisposedVariables+=e.dispose().numDisposedVariables;for(const e of this.internalContainerRefs)t.numDisposedVariables+=e.dispose().numDisposedVariables}return t.refCountAfterDispose=this._refCount,t}get trainable(){return this.trainable_}set trainable(t){this.layers.forEach(e=>{e._trainableWeights.forEach(r=>r.trainable=t)}),this.trainable_=t}get trainableWeights(){if(this._trainableWeights.length>0)throw new ot("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let t=[];for(const e of this.layers)t=t.concat(e.trainableWeights);return t}get nonTrainableWeights(){const t=[];for(const e of this.layers)t.push(...e.nonTrainableWeights);if(!this.trainable){const e=[];for(const r of this.layers)e.push(...r.trainableWeights);return e.concat(t)}return t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(t,e=!0){const r={};let a=0;const s=Cpt(t);s&&this.parseWeights(t);for(const i of this.layers)for(const[u,l]of i.weights.entries()){const h=s?`${l.name.split("/").slice(0,-1).join("/")+"/"}${u}`:l.originalName;if(r[h]!=null)throw new ot(`Duplicate weight name: ${h}`);r[h]=l,a++}const o=[];for(const i in t){let u=i;if(r[i]==null){const l=i.split("/");u=l.slice(0,-2).concat([l[l.length-1]]).join("/")}if(r[u]!=null)o.push([r[u],t[i]]);else if(e)throw new ot(`Provided weight data has no target variable: ${i}`);delete r[u]}if(e){const i=[];for(const u in r)i.push(u);if(i.length>0)throw new ot(`${i.length} of ${a} weights are not set: ${i}`)}YI(o)}parseWeights(t){for(const e in Object.keys(t)){const r=e.split("/"),a=["vars","layer_checkpoint_dependencies"],s=r.map(o=>o.startsWith("_")?o.slice(1):o).filter(o=>!a.includes(o)).join("/");s!==e&&(t[s]=t[e],delete t[e])}}updatedConfig(){const t=this.getConfig(),e={};return e.className=this.getClassName(),e.config=t,e.kerasVersion=`tfjs-layers ${EV}`,e.backend="TensorFlow.js",e}toJSON(t,e=!0){const r=hk(this.updatedConfig());return e?JSON.stringify(r):r}call(t,e){return ut(()=>{t=Ze(t);const r=new ku;for(let a=0;a<this.inputs.length;++a)r.add(this.inputs[a],t[a]);return Mf(this.outputs,r,e)})}computeMask(t,e){return ut(()=>{t=Ze(t);let r;return e==null?r=cc(null,t.length):r=Ze(e),this.runInternalGraph(t,r)[1]})}computeOutputShape(t){const e=fb(t);if(e.length!==this.inputLayers.length)throw new ot(`Invalid inputShape argument ${t}: model has ${this.inputLayers.length} tensor inputs.`);const r={};for(let i=0;i<e.length;i++){const u=this.inputLayers[i],l=e[i],h=u.name+"_0_0";r[h]=l}const a=Object.keys(this.nodesByDepth).map(i=>parseInt(i,10)).sort(s0);if(a.length>1)for(const i of a){const u=this.nodesByDepth[i];for(const l of u){const h=l.outboundLayer;if(this.inputLayers.map(y=>y.id).indexOf(h.id)!==-1)continue;const d=[];for(let y=0;y<l.inboundLayers.length;y++){const b=l.inboundLayers[y],w=l.nodeIndices[y],S=l.tensorIndices[y],N=`${b.name}_${w}_${S}`,C=r[N];d.push(C)}const f=h.computeOutputShape(ba(d)),m=fb(f),v=h.inboundNodes.indexOf(l);for(let y=0;y<m.length;y++){const b=`${h.name}_${v}_${y}`;r[b]=m[y]}}}const s=[],o=[];for(let i=0;i<this.outputLayers.length;i++){const u=this.outputLayers[i],l=this.outputLayersNodeIndices[i],h=this.outputLayersTensorIndices[i],d=`${u.name}_${l}_${h}`;o.push(d)}for(let i=0;i<o.length;i++){const u=o[i];No(u in r),s.push(r[u])}return ba(s)}runInternalGraph(t,e){e==null&&(e=cc(null,t.length));const r={};for(let u=0;u<this.inputs.length;++u){const l=this.inputs[u],h=t[u],d=e[u];r[l.id]=[h,d]}const a=Object.keys(this.nodesByDepth).map(u=>parseInt(u,10)).sort(s0);for(const u of a){const l=this.nodesByDepth[u];for(const h of l){const d=h.outboundLayer,f=h.inputTensors,m=h.outputTensors,v=new Array;for(const y of f)y.id in r&&v.push(r[y.id]);if(v.length===f.length){let y={},b,w,S,N;if(h.callArgs!=null&&(y=h.callArgs),v.length===1){const[C,T]=v[0];y.mask==null&&(y.mask=T),S=Ze(d.call(C,y)),N=Ze(d.computeMask(C,T)),b=[C],w=[T]}else b=v.map(C=>C[0]),w=v.map(C=>C[1]),y.mask==null&&(y.mask=w),S=Ze(d.call(b,y)),N=Ze(d.computeMask(b,w));if(d.activityRegularizer)throw new ke("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let C=0;C<m.length;++C){const T=m[C],I=S[C],_=N[C];r[T.id]=[I,_]}}}}const s=[],o=[],i=[];for(const u of this.outputs){No(u.id in r,`Could not compute output ${u.name} : ${u.id}`);const[l,h]=r[u.id];i.push(l.shape),s.push(l),o.push(h)}return[s,o,i]}buildNodeConversionMap(t){const e={};let r;for(const a of this.layers){r=a instanceof Xs?1:0;for(let s=0;s<a.inboundNodes.length;s++){const o=Xs.nodeKey(a,s);this.containerNodes.has(o)&&(e[o]=r,r+=1)}}return e}getLayer(t,e){if(e!=null)return this.findLayer(e);if(t==null)throw new ot("Provide either a layer name or layer index");if(typeof t=="number")return this.findLayer(t);for(const r of this.layers)if(r.name===t)return r;throw new ot(`No such layer: ${t}`)}findLayer(t){if(this.layers.length<=t)throw new ot(`Was asked to retrieve layer at index ${t}, but model only has ${this.layers.length} layer(s).`);return this.layers[t]}calculateLosses(){return ut(()=>{const t=[];for(const e of this.layers)for(let r=0;r<e.inboundNodes.length;++r){const a=Xs.nodeKey(e,r);this.containerNodes.has(a)&&t.push(...e.calculateLosses())}return t})}getConfig(){const t={name:this.name},e=this.buildNodeConversionMap(this.layers),r=[];for(const o of this.layers){const i=o.getClassName(),u=o.getConfig(),l=[];for(let d=0;d<o.inboundNodes.length;d++){const f=o.inboundNodes[d],m=Xs.nodeKey(o,d);let v={};if(this.containerNodes.has(m)){if(f.callArgs)try{JSON.stringify(f.callArgs),v=f.callArgs}catch{console.warn(`Layer ${o.name} was passed non-serializable keyword arguments: ${f.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),v={}}if(f.inboundLayers.length>0){const y=[];for(let b=0;b<f.inboundLayers.length;b++){const w=f.inboundLayers[b],S=f.nodeIndices[b],N=f.tensorIndices[b],C=Xs.nodeKey(w,S);let T=e[C];T==null&&(T=0),y.push([w.name,T,N,v])}l.push(y)}}}const h={};h.name=o.name,h.className=i,h.config=u,h.inboundNodes=l,r.push(h)}t.layers=r;const a=[];for(let o=0;o<this.inputLayers.length;o++){const i=this.inputLayers[o],u=this.inputLayersNodeIndices[o],l=Xs.nodeKey(i,u);if(!this.containerNodes.has(l))continue;let h=e[l];h==null&&(h=0);const d=this.inputLayersTensorIndices[o];a.push([i.name,h,d])}t.inputLayers=a;const s=[];for(let o=0;o<this.outputLayers.length;o++){const i=this.outputLayers[o],u=this.outputLayersNodeIndices[o],l=Xs.nodeKey(i,u);if(!this.containerNodes.has(l))continue;let h=e[l];h==null&&(h=0);const d=this.outputLayersTensorIndices[o];s.push([i.name,h,d])}return t.outputLayers=s,t}static fromConfig(t,e,r={},a=!1){const s={},o={};function i(b,w){b.name in o?o[b.name].push(w):o[b.name]=[w]}function u(b,w){const S=[];let N;for(const C of w){const T=C[0],I=C[1],_=C[2];if(N=C[3]==null?{}:C[3],!(T in s)){i(b,w);return}const $=s[T];if($.inboundNodes.length<=I){i(b,w);return}const R=$.inboundNodes[I];S.push(R.outputTensors[_])}S.length>0&&b.apply(ba(S),N)}function l(b){const w=b.name,S=Ei(b,e.customObjects!=null?e.customObjects:{});S.setFastWeightInitDuringBuild(a),s[w]=S,b.inboundNodes.forEach(C=>{if(!(C instanceof Array))throw new ot(`Corrupted configuration, expected array for nodeData: ${C}`);i(S,C)})}const h=e.name,d=e.layers;for(const b of d)l(b);for(;!idt(o);)for(const b of d){const w=s[b.name];if(w.name in o){const S=o[w.name];delete o[w.name];for(const N of S)u(w,N)}}const f=[],m=[],v=e.inputLayers;for(const b of v){const w=b[0],S=b[1],N=b[2];No(w in s);const T=s[w].inboundNodes[S].outputTensors;f.push(T[N])}const y=e.outputLayers;for(const b of y){const w=b[0],S=b[1],N=b[2];No(w in s);const T=s[w].inboundNodes[S].outputTensors;m.push(T[N])}return new t({inputs:f,outputs:m,name:h})}get stateful(){if(this._stateful)throw new ot("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const t of this.layers)if(t.stateful)return!0;return!1}resetStates(){ut(()=>{this.layers.forEach(t=>{t.stateful&&t.resetStates()})})}}function Npt(n,t,e){const r=t.length;if(n==null||Array.isArray(n)&&n.length===0)return t.map(a=>null);if(r===1)return Array.isArray(n)&&n.length===1?n:typeof n=="object"&&t[0]in n?[n[t[0]]]:[n];if(Array.isArray(n)){if(n.length!==r)throw new Error(`Provided ${e} is an array of ${n.length} element(s), but the model has ${r} outputs. Make sure a set of weights is provided for each model output.`);return n}else if(typeof n=="object"&&Object.keys(n).length>0&&typeof n[Object.keys(n)[0]]=="object"){const a=[];return t.forEach(s=>{s in n?a.push(n[s]):a.push(null)}),a}else throw new Error(`The model has multiple (${r}) outputs, so ${e} must be either an array with ${r} elements or an object with ${t} keys. Provided ${e} not understood: ${JSON.stringify(n)}`)}function IV(n,t){return Npt(n,t,"classWeight")}async function _V(n,t,e,r){if(e!=null){const a=ut(()=>{if(n.shape.length===1)return Oo(n);if(n.shape.length===2){if(n.shape[1]>1)return Bu(n,1);if(n.shape[1]===1)return at(n,[n.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${n.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}else throw new Error(`Unexpected rank of target (y) tensor (${n.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),s=Array.from(await a.data());Ie(a);const o=[];return s.forEach(i=>{if(e[i]==null)throw new Error(`classWeight must contain all classes in the training data. The class ${i} exists in the data but not in classWeight`);o.push(e[i])}),sr(o,"float32")}else return null}function kpt(n,t){return et(n,t)}const Tpt=32;function RV(n,t){let e,r;const a=t;e=a.xs,r=a.ys,P(e!=null&&r!=null,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${t}`);const s=OF("input",n.inputNames,e),o=OF("output",n.outputNames,r),i=s[0].shape[0];P(s.length===n.inputs.length,()=>`LayersModel has ${n.inputs.length} inputs, but the dataset provides ${s.length} inputs.  (Expected input keys: ${JSON.stringify(n.inputNames)})`),P(o.length===n.outputs.length,()=>`LayersModel has ${n.outputs.length} outputs, but the dataset provides ${o.length} outputs.  (Expected output keys: ${JSON.stringify(n.outputNames)})`);for(let u=0;u<s.length;u++)P(s[u].shape[0]===i,()=>`Batch size mismatch: input ${n.inputNames[u]} has ${s[u].shape[0]}; expected  ${i} based on input ${n.inputNames[0]}.`);for(let u=0;u<o.length;u++)P(o[u].shape[0]===i,()=>`Batch size mismatch: output ${n.outputNames[u]} has ${o[u].shape[0]}; expected  ${i} based on input ${n.inputNames[0]}.`);return{xs:s,ys:o}}function OF(n,t,e){if(e instanceof Ae)return[e];if(Array.isArray(e))return P(e.length===t.length,()=>`Received an array of ${e.length} Tensors, but expected ${t.length} to match the ${n} keys ${t}.`),e;{const r=[];for(const a of t){if(e[a]==null)throw new ot(`The feature data generated by the dataset lacks the required ${n} key '${a}'.`);r.push(e[a])}return r}}function Ept(n){if(n.length===3)throw new ke("Validation with sample weights is not implemented yet.");return{xs:n[0],ys:n[1]}}async function Ipt(n,t,e){const r=e.batchesPerEpoch!=null;if(P(n.optimizer!=null,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),P(e!=null,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),P(e.epochs!=null&&e.epochs>0&&Number.isInteger(e.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${e.epochs}`),P(!r||e.batchesPerEpoch>0&&Number.isInteger(e.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${e.batchesPerEpoch}`),P(e.validationSplit==null,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),n.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");n.isTraining=!0;try{const a=e.validationData!=null;let s,o;if(a)if(FF(e.validationData))P(e.validationBatches==null||e.validationBatches>0&&Number.isInteger(e.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${e.validationBatches}`);else{const b=Ept(e.validationData);s=b.xs,o=b.ys}const i=n.makeTrainFunction(),u=n.getDedupedMetricsNames();let l;a?l=u.slice().concat(u.map(b=>"val_"+b)):l=u.slice();const h=bV(e.callbacks,e.yieldEvery),d=e.verbose==null?1:e.verbose,{callbackList:f,history:m}=xV(h,d,e.epochs,null,null,_pt(t,e),null,a,l);f.setModel(n),n.history=m,await f.onTrainBegin(),n.stopTraining_=!1;let v=e.initialEpoch==null?0:e.initialEpoch,y=await t.iterator();for(;v<e.epochs;){const b={};await f.onEpochBegin(v);let w=0,S=0;for(r||(y=await t.iterator());!r||w<e.batchesPerEpoch;){const N=await y.next();if(r&&N.done){console.warn(`You provided \`batchesPerEpoch\` as ${e.batchesPerEpoch}, but your dataset iterator ran out of data after ${w} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${e.batchesPerEpoch*e.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(N.value!=null){const{xs:C,ys:T}=RV(n,N.value),I={};I.batch=S,I.size=C[0].shape[0],await f.onBatchBegin(S,I);const _=[];if(e.classWeight!=null){const D=IV(e.classWeight,n.outputNames);for(let A=0;A<D.length;++A)_.push(await _V(T[A],null,D[A]))}const $=C.concat(T).concat(_),R=i($);Ie($);for(let D=0;D<u.length;++D){const A=u[D],L=R[D];I[A]=L,ar(L)}await f.onBatchEnd(S,I),yV(I),S++,w++}if(r?w>=e.batchesPerEpoch:N.done){if(a){let C;FF(e.validationData)?C=Ze(await n.evaluateDataset(e.validationData,{batches:e.validationBatches})):C=Ze(n.evaluate(s,o,{batchSize:e.validationBatchSize==null?Tpt:e.validationBatchSize,verbose:0}));for(let T=0;T<n.metricsNames.length;++T)b[`val_${n.metricsNames[T]}`]=C[T]}break}if(n.stopTraining_)break}if(await f.onEpochEnd(v,b),v++,n.stopTraining_)break}return await f.onTrainEnd(),await n.history.syncData(),n.history}finally{n.isTraining=!1}}function _pt(n,t){let e=null;return t.batchesPerEpoch!=null?e=t.batchesPerEpoch:Number.isFinite(n.size)&&(e=n.size),e}function FF(n){return typeof n.iterator=="function"}function Rpt(n){return typeof n.next=="function"}async function Apt(n,t,e){e=e||{};const r=e.batches!=null,a=n.testFunction;let s=[];if(e.verbose>0)throw new ke("Verbose mode is not implemented yet.");P(!r||e.batches>0&&Number.isInteger(e.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(e.batches)}`);const o=Rpt(t)?t:await t.iterator();let i=0,u=0;for(;!r||u<e.batches;){const l=await o.next();if(s=ut(()=>{if(l.value){const{xs:h,ys:d}=RV(n,l.value),f=h.concat(d),m=ut(()=>a(f));if(Ie(f),u===0)for(let y=0;y<m.length;++y)s.push(Jt(0));const v=f[0].shape[0];for(let y=0;y<m.length;++y){const b=m[y],w=s[y];s[y]=ut(()=>It(s[y],et(v,b))),u>0&&Ie(w)}Ie(m),i+=v,++u}return s}),l.done){r&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${e.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let l=0;l<s.length;++l){const h=s[l];s[l]=Ut(s[l],i),Ie(h)}return ba(s)}function VC(n){P(n>0&&Number.isInteger(n),()=>`batchSize is required to be a positive integer, but got ${n}`)}function _f(n,t,e){return n==null?[null]:Array.isArray(n)?n.map(r=>Ql(r,t,e-t)):Ql(n,t,e-t)}function dk(n,t){return ut(()=>n==null?null:Array.isArray(n)?n.map(e=>dk(e,t)):aV(n,t.dtype==="int32"?t:Ft(t,"int32")))}function UC(n,t){const e=[];let r=0,a=null;for(;r<n;)a=r+t,a>=n&&(a=n),e.push([r,a]),r=a;return e}function AV(n){const t=[];n instanceof Ae&&(n=[n]);for(let e=0;e<n.length;++e){const r=n[e];if(r.rank===1)t.push(sv(r,1));else{if(r.rank===0)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");t.push(r)}}return t}function Ks(n,t){if(n==null)return;const e=[];if(t instanceof Ae)e.push(t.id);else if(Array.isArray(t))t.forEach(a=>e.push(a.id));else if(t!=null)for(const a in t){const s=t[a];e.push(s.id)}const r=[];if(n instanceof Ae)e.indexOf(n.id)===-1&&r.push(n);else if(Array.isArray(n))n.forEach(a=>{e.indexOf(a.id)===-1&&r.push(a)});else if(n!=null)for(const a in n){const s=n[a];e.indexOf(s.id)===-1&&r.push(s)}r.forEach(a=>{a.isDisposed||a.dispose()})}function Dpt(n){return n instanceof Ae}function pk(n){return Array.isArray(n)}function MF(n){return!Dpt(n)&&!pk(n)}function LF(n,t,e,r=!0,a=""){if(t==null||t.length===0){if(n!=null){let o=!1;if(pk(n)&&n.length>0)o=!0;else if(MF(n)){for(const i in n)if(n.hasOwnProperty(i)){o=!0;break}}else o=!0;if(o)throw new ot(`Error when checking model ${a} expected no data, but got ${n}`)}return[]}if(n==null)return t.map(o=>null);let s;if(MF(n)){n=n,s=[];for(const o of t){if(n[o]==null)throw new ot(`No data provided for "${o}". Need data for each key in: ${t}`);s.push(n[o])}}else if(pk(n)){if(n=n,n.length!==t.length)throw new ot(`Error when checking model ${a}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${t.length} Tensor(s), but instead got the following list of Tensor(s): ${n}`);s=n}else{if(n=n,t.length>1)throw new ot(`The model ${a} expects ${t.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${n.shape}`);s=[n]}if(s=AV(s),e!=null)for(let o=0;o<t.length;++o){if(e[o]==null)continue;const i=s[o];if(i.shape.length!==e[o].length)throw new ot(`Error when checking ${a}: expected ${t[o]} to have ${e[o].length} dimension(s). but got array with shape ${i.shape}`);for(let u=0;u<e[o].length;++u){if(u===0&&!r)continue;const l=i.shape[u],h=e[o][u];if(h!=null&&h>=0&&l!==h)throw new ot(`${a} expected a batch of elements where each example has shape [${e[o].slice(1,e[o].length)}] (i.e.,tensor shape [*,${e[o].slice(1,e[o].length)}]) but the ${a} received an input with ${i.shape[0]} examples, each with shape [${i.shape.slice(1,i.shape.length)}] (tensor shape [${i.shape}])`)}}return s}function $pt(n,t,e){const r=Du(n.map(s=>s.shape[0]));r.sort();const a=Du(t.map(s=>s.shape[0]));if(a.sort(),r.length>1)throw new ot(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(n.map(s=>s.shape))}`);if(a.length>1)throw new ot(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map(s=>s.shape))}`);if(r.length>0&&a.length>0&&!De(r,a))throw new ot(`Input Tensors should have the same number of samples as target Tensors. Found ${r[0]} input sample(s) and ${a[0]} target sample(s).`)}function Opt(n,t,e){const r=[Y1,Q1,dm];for(let a=0;a<n.length;++a){const s=n[a],o=t[a],i=e[a];if(o!=null){if(o===dm&&s.shape[s.shape.length-1]===1)throw new ot(`You are passing a target array of shape ${s.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(r.indexOf(o)!==-1){const u=s.shape.slice(1),l=i.slice(1);for(let h=0;h<u.length;++h){const d=u[h],f=l[h];if(f!=null&&d!==f)throw new ot(`A target Tensor with shape ${s.shape} was passed for an output of shape ${i}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}function BF(n,t,e,r=!0,a=""){let s;if(Array.isArray(n)){if(n.length!==t.length)throw new ot(`Error when checking model ${a}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${t.length} Tensor(s), but instead got ${n.length} Tensors(s).`);s=n}else{if(t.length>1)throw new ot(`The model expects ${t.length} ${a} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(n.shape)}.`);s=[n]}if(e!=null)for(let o=0;o<t.length;++o){if(e[o]==null)continue;const i=s[o];if(i.shape.length!==e[o].length)throw new ot(`Error when checking ${a}: expected ${t[o]} to have ${e[o].length} dimension(s), but got array with shape ${JSON.stringify(i.shape)}`);for(let u=0;u<e[o].length;++u){if(u===0&&!r)continue;const l=i.shape[u],h=e[o][u];if(h!=null&&h!==l)throw new ot(`Error when checking ${a}: expected ${t[o]} to have shape ${JSON.stringify(e[o])} but got array with shape ${JSON.stringify(i.shape)}.`)}}}function Fpt(n,t){if(n==null||Array.isArray(n)&&n.length===0)return t.map(r=>[]);let e;if(typeof n=="string"||typeof n=="function")e=[n];else if(Array.isArray(n)||typeof n=="object")e=n;else throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${n}`);if(Array.isArray(e))return t.map(r=>e);{const r=[];for(const a of t){let s=e.hasOwnProperty(a)?e[a]:[];Array.isArray(s)||(s=[s]),r.push(s)}return r}}const Mpt="layers-model";class Hh extends Xs{constructor(t){super(t),this.isTraining=!1}summary(t,e,r=console.log){if(!this.built)throw new ot("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");ypt(this,t,e,r)}compile(t){if(t.loss==null&&(t.loss=[]),this.loss=t.loss,typeof t.optimizer=="string")this.optimizer_=vpt(t.optimizer),this.isOptimizerOwned=!0;else{if(!(t.optimizer instanceof Vi))throw new ot("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=t.optimizer,this.isOptimizerOwned=!1}let e=[];if(!Array.isArray(t.loss)&&typeof t.loss!="string"&&typeof t.loss!="function"){t.loss=t.loss;for(const o in t.loss)if(this.outputNames.indexOf(o)===-1)throw new ot(`Unknown entry in loss dictionary: "${o}". Only expected the following keys: ${this.outputNames}`);for(const o of this.outputNames)t.loss[o]==null&&console.warn(`Output "${o}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${o} during training`),e.push(PC(t.loss[o]))}else if(Array.isArray(t.loss)){if(t.loss.length!==this.outputs.length)throw new ot(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${t.loss}.`);e=t.loss.map(i=>PC(i))}else{const o=PC(t.loss);this.outputs.forEach(i=>{e.push(o)})}this.lossFunctions=e,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let o=0;o<this.outputs.length;++o){const i=this.internalOutputShapes[o],u=this.outputNames[o];this.feedOutputNames.push(u),this.feedOutputShapes.push(i),this.feedLossFns.push(this.lossFunctions[o])}const r=[];this.metrics=t.metrics,this.metricsNames=["loss"],this.metricsTensors=[],Yl("loss",()=>{for(let o=0;o<this.outputs.length;++o){if(r.indexOf(o)!==-1)continue;const i=this.lossFunctions[o];this.outputs.length>1&&(this.metricsTensors.push([i,o]),this.metricsNames.push(this.outputNames[o]+"_loss"))}});const a=Fpt(t.metrics,this.outputNames),s=(o,i,u)=>{this.outputNames.length>1&&(i=this.outputNames[o]+"_"+i),this.metricsNames.push(i),this.metricsTensors.push([u,o])};Yl("metric",()=>{for(let o=0;o<this.outputs.length;++o){if(r.indexOf(o)!==-1)continue;const i=a[o];(l=>{let d,f,m;for(const v of l){if(typeof v=="string"&&["accuracy","acc","crossentropy","ce"].indexOf(v)!==-1){const b=this.internalOutputShapes[o];b[b.length-1]===1||this.lossFunctions[o]===Q1?["accuracy","acc"].indexOf(v)!==-1?f=SV:["crossentropy","ce"].indexOf(v)!==-1&&(f=ipt):this.lossFunctions[o]===bb?["accuracy","acc"].indexOf(v)!==-1?f=upt:["crossentropy","ce"].indexOf(v)!==-1&&(f=kV):["accuracy","acc"].indexOf(v)!==-1?f=CV:["crossentropy","ce"].indexOf(v)!==-1&&(f=NV);let w;["accuracy","acc"].indexOf(v)!==-1?w="acc":["crossentropy","ce"].indexOf(v)!==-1&&(w="ce"),m=f,d=""+w}else m=gpt(v),d=""+u0(v);let y;Yl(d,()=>{y=m}),s(o,d,y)}})(i)}}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){this.collectedTrainableWeights!=null&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(t,e,r={}){const a=r.batchSize==null?32:r.batchSize;VC(a);const o=this.standardizeUserDataXY(t,e,!0,a);try{const i=o[0].concat(o[1]);this.makeTestFunction();const u=this.testFunction,l=this.testLoop(u,i,a,r.verbose,r.steps);return ba(l)}finally{Ks(o[0],t),Ks(o[1],e)}}async evaluateDataset(t,e){return this.makeTestFunction(),Apt(this,t,e)}checkNumSamples(t,e,r,a="steps"){let s;if(r!=null){if(s=null,e!=null)throw new ot(`If ${a} is set, batchSize must be null or undefined.Got batchSize = ${e}`)}else if(t!=null)Array.isArray(t)?s=t[0].shape[0]:s=t.shape[0];else throw new ot(`Either the input data should have a defined shape, or ${a} shoud be specified.`);return s}execute(t,e){if(Array.isArray(e)&&e.length===0)throw new ot("`outputs` is an empty Array, which is not allowed.");const r=Array.isArray(e),a=r?e:[e],s=this.retrieveSymbolicTensors(a),o=new ku;if(t instanceof Ae&&(t=[t]),Array.isArray(t)){if(t.length!==this.inputs.length)throw new ot(`The number of inputs provided (${t.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let u=0;u<this.inputs.length;++u)o.add(this.inputs[u],t[u])}else for(const u of this.inputs){const l=t[u.name];if(l==null)throw new ot(`No value is provided for the model's input ${u.name}`);o.add(u,l)}const i=Mf(s,o);return r?i:i[0]}retrieveSymbolicTensors(t){const e=cc(null,t.length);let r=t.length;for(const a of this.layers){const s=Array.isArray(a.output)?a.output:[a.output],o=s.map(i=>i.name);for(let i=0;i<t.length;++i){const u=o.indexOf(t[i]);if(u!==-1&&(e[i]=s[u],r--),r===0)break}if(r===0)break}if(r>0){const a=[];throw e.forEach((s,o)=>{s==null&&a.push(t[o])}),new ot(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(a)}`)}return e}predictLoop(t,e=32,r=!1){return ut(()=>{const a=this.checkNumSamples(t);if(r)throw new ke("Verbose predictLoop() is not implemented yet.");const s=UC(a,e),o=this.outputs.map(i=>[]);for(let i=0;i<s.length;++i)ut(()=>{const l=s[i][0],h=s[i][1],d=_f(t,l,h),f=[];if(Array.isArray(d))for(let v=0;v<d.length;++v)f.push({key:this.inputs[v],value:d[v]});else f.push({key:this.inputs[0],value:d});const m=new ku(f);return Mf(this.outputs,m)}).forEach((l,h)=>o[h].push(l));return ba(o.map(i=>_n(i,0)))})}predict(t,e={}){const r=AV(t);BF(r,this.inputNames,this.feedInputShapes,!1);try{const a=e.batchSize==null?32:e.batchSize;return VC(a),this.predictLoop(r,a)}finally{Ks(r,t)}}predictOnBatch(t){BF(t,this.inputNames,this.feedInputShapes,!0);const e=(Array.isArray(t)?t[0]:t).shape[0];return this.predictLoop(t,e)}standardizeUserDataXY(t,e,r=!0,a){if(this.optimizer_==null)throw new zs("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const s=[];for(let o=0;o<this.feedOutputShapes.length;++o){const i=this.feedOutputShapes[o];this.feedLossFns[o]===bb?s.push(i.slice(0,i.length-1).concat([1])):s.push(i)}if(t=LF(t,this.feedInputNames,this.feedInputShapes,!1,"input"),e=LF(e,this.feedOutputNames,s,!1,"target"),$pt(t,e),Opt(e,this.feedLossFns,this.feedOutputShapes),this.stateful&&a!=null&&a>0&&t[0].shape[0]%a!==0)throw new ot(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${a}. Found: ${t[0].shape[0]} sample(s).`);return[t,e]}async standardizeUserData(t,e,r,a,s=!0,o){const[i,u]=this.standardizeUserDataXY(t,e,s,o);if(r!=null)throw new Error("sample weight is not supported yet.");let l=null;if(a!=null){const h=IV(a,this.outputNames);l=[];for(let d=0;d<h.length;++d)l.push(await _V(u[d],null,h[d]))}return[i,u,l]}testLoop(t,e,r,a=0,s){return ut(()=>{const o=this.checkNumSamples(e,r,s,"steps"),i=[];if(a>0)throw new ke("Verbose mode is not implemented yet.");if(s!=null)throw new ke("steps mode in testLoop() is not implemented yet");{const u=UC(o,r),l=sr(so(0,o));for(let h=0;h<u.length;++h){const d=u[h][0],f=u[h][1],m=Ql(l,d,f-d),v=dk(e,m),y=t(v);if(h===0)for(let b=0;b<y.length;++b)i.push(Jt(0));for(let b=0;b<y.length;++b){const w=y[b];i[b]=It(i[b],et(f-d,w))}}for(let h=0;h<i.length;++h)i[h]=Ut(i[h],o)}return i})}getDedupedMetricsNames(){const t=this.metricsNames,e=[];for(let r=0;r<t.length;++r){const a=t[r];let s=a;if(SF(t,a)>1){const o=SF(t.slice(0,r),a);s+=`_${o}`}e.push(s)}return e}makeTrainFunction(){return t=>{const e=[],r=t.slice(0,this.inputs.length),a=t.slice(this.inputs.length,this.inputs.length+this.outputs.length),s=t.slice(this.inputs.length+this.outputs.length,this.inputs.length+this.outputs.length*2),o=[],i=()=>{const d=[];for(let y=0;y<this.inputs.length;++y)d.push({key:this.inputs[y],value:r[y]});const f=new ku(d),m=Mf(this.outputs,f,{training:!0});let v;for(let y=0;y<this.lossFunctions.length;++y){const b=this.lossFunctions[y];let w=b(a[y],m[y]);s[y]!=null&&(w=kpt(w,s[y]));const S=En(w);e.push(S),y===0?v=w:v=It(v,w)}for(let y=0;y<this.metricsTensors.length;++y){let b;if(this.outputs.length>1&&y<this.outputs.length)b=e[y];else{const w=this.metricsTensors[y][0],S=this.metricsTensors[y][1];b=En(w(a[S],m[S]))}ar(b),o.push(b)}return v=En(v),this.calculateLosses().forEach(y=>{v=It(v,y)}),v},u=this.collectedTrainableWeights.map(d=>d.read());return[this.optimizer_.minimize(i,!0,u)].concat(o)}}makeTestFunction(){this.testFunction=t=>ut(()=>{const e=[];let r;const a=t.slice(0,this.inputs.length),s=t.slice(this.inputs.length,this.inputs.length+this.outputs.length),o=[];for(let l=0;l<this.inputs.length;++l)o.push({key:this.inputs[l],value:a[l]});const i=new ku(o),u=Mf(this.outputs,i);for(let l=0;l<this.lossFunctions.length;++l){const h=this.lossFunctions[l],d=En(h(s[l],u[l]));l===0?r=d:r=It(r,d),e.push(r)}for(let l=0;l<this.metricsTensors.length;++l){const h=this.metricsTensors[l][0],d=this.metricsTensors[l][1],f=En(h(s[d],u[d]));e.push(f)}return e})}async fit(t,e,r={}){if(this.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");this.isTraining=!0;let a,s,o,i,u,l,h,d,f;try{const m=r.batchSize==null?32:r.batchSize;VC(m);const y=await this.standardizeUserData(t,e,r.sampleWeight,r.classWeight,!1,m);a=y[0],s=y[1],f=y[2];let b=!1,w;if(r.validationData!=null&&r.validationData.length>0){if(b=!0,r.validationData.length===2)u=r.validationData[0],l=r.validationData[1];else throw r.validationData.length===3?new ke("validationData including sample weights is not supported yet."):new ot(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${r.validationData} is invalid.`);const D=await this.standardizeUserData(u,l,null,null,!0,m);h=D[0],d=D[1],w=h.concat(d)}else if(r.validationSplit!=null&&r.validationSplit>0&&r.validationSplit<1){b=!0;const R=Math.floor(a[0].shape[0]*(1-r.validationSplit)),D=a[0].shape[0];h=_f(a,R,D),o=a,a=_f(a,0,R),d=_f(s,R,D),i=s,s=_f(s,0,R),w=h.concat(d)}else r.validationSteps!=null&&(b=!0);const S=a.concat(s).concat(f);this.checkTrainableWeightsConsistency();const N=this.makeTrainFunction(),C=this.getDedupedMetricsNames();let T,I;b?(this.makeTestFunction(),T=this.testFunction,I=C.slice().concat(C.map(R=>"val_"+R))):(T=null,w=[],I=C.slice());const _=bV(r.callbacks,r.yieldEvery);return await this.fitLoop(N,S,C,m,r.epochs,r.verbose,_,T,w,r.shuffle,I,r.initialEpoch,null,null)}finally{this.isTraining=!1,Ks(a,t),Ks(s,e),Ks(o,t),Ks(i,e),Ks(h,u),Ks(d,l),f!=null&&Ie(f)}}async fitLoop(t,e,r,a,s,o,i,u,l,h,d,f,m,v){a==null&&(a=32),s==null&&(s=1),h==null&&(h=!0),f==null&&(f=0);let y=!1;if(u!=null&&l!=null&&(y=!0),v!=null&&(y=!0,m==null))throw new ot("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const b=this.checkNumSamples(e,a,m,"steps_per_epoch");let w;b!=null&&(w=so(0,b)),o==null&&(o=1);const{callbackList:S,history:N}=xV(i,o,s,f,b,m,a,y,d);S.setModel(this),this.history=N,await S.onTrainBegin(),this.stopTraining_=!1;for(let C=f;C<s;++C){await S.onEpochBegin(C);const T={};if(m!=null)throw new ke("stepsPerEpoch mode is not implemented yet.");{if(h==="batch")throw new ke("batch shuffling is not implemneted yet");h&&Ek(w);const I=sr(w),_=UC(b,a);for(let $=0;$<_.length;++$){const R={};if(await S.onBatchBegin($,R),ut(()=>{const D=_[$][0],A=_[$][1],L=Ql(I,D,A-D);R.batch=$,R.size=A-D;const H=dk(e,L),G=t(H);for(let q=0;q<r.length;++q){const B=r[q],j=G[q];R[B]=j,ar(j)}if($===_.length-1&&y){const q=this.testLoop(u,l,a);for(let B=0;B<r.length;++B){const j=r[B],K=q[B];ar(K),T["val_"+j]=K}}}),await S.onBatchEnd($,R),yV(R),this.stopTraining_)break}I.dispose()}if(await S.onEpochEnd(C,T),this.stopTraining_)break}return await S.onTrainEnd(),await this.history.syncData(),this.history}async fitDataset(t,e){return Ipt(this,t,e)}async trainOnBatch(t,e){const r=await this.standardizeUserData(t,e),a=r[0],s=r[1],i=this.makeTrainFunction()(a.concat(s)),u=[];for(const l of i){const h=await l.data();u.push(h[0])}return Ie(i),Ks(r[0],t),Ks(r[1],e),ba(u)}getNamedWeights(t){const e=[],r=t!=null&&t.trainableOnly,a=r?this.trainableWeights:this.weights,s=this.getWeights(r);for(let o=0;o<a.length;++o)r&&!a[o].trainable||e.push({name:a[o].originalName,tensor:s[o]});return e}set stopTraining(t){this.stopTraining_=t}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(t){this.optimizer_!==t&&(this.optimizer_=t,this.isOptimizerOwned=!1)}dispose(){const t=super.dispose();if(t.refCountAfterDispose===0&&this.optimizer!=null&&this.isOptimizerOwned){const e=cN().numTensors;this.optimizer_.dispose(),t.numDisposedVariables+=e-cN().numTensors}return t}getLossIdentifiers(){let t;if(typeof this.loss=="string")t=Ci(this.loss);else if(Array.isArray(this.loss)){for(const e of this.loss)if(typeof e!="string")throw new Error("Serialization of non-string loss is not supported.");t=this.loss.map(e=>Ci(e))}else{const e=Object.keys(this.loss);t={};const r=this.loss;for(const a of e)if(typeof r[a]=="string")t[a]=Ci(r[a]);else throw new Error("Serialization of non-string loss is not supported.")}return t}getMetricIdentifiers(){if(typeof this.metrics=="string"||typeof this.metrics=="function")return[Ci(u0(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(t=>Ci(u0(t)));{const t={};for(const e in this.metrics)t[e]=Ci(u0(this.metrics[e]));return t}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(t){if(t.weighted_metrics!=null)throw new Error("Loading weight_metrics is not supported yet.");if(t.loss_weights!=null)throw new Error("Loading loss_weights is not supported yet.");if(t.sample_weight_mode!=null)throw new Error("Loading sample_weight_mode is not supported yet.");const e=ck(t.optimizer_config),r=Ei(e);let a;if(typeof t.loss=="string")a=Pl(t.loss);else if(Array.isArray(t.loss))a=t.loss.map(o=>Pl(o));else if(t.loss!=null){a={};for(const o in t.loss)a[o]=Pl(t.loss[o])}let s;if(Array.isArray(t.metrics))s=t.metrics.map(o=>Pl(o));else if(t.metrics!=null){s={};for(const o in t.metrics)s[o]=Pl(t.metrics[o])}this.compile({loss:a,metrics:s,optimizer:r})}async save(t,e){if(typeof t=="string"){const l=pL(t);if(l.length===0)throw new ot(`Cannot find any save handlers for URL '${t}'`);if(l.length>1)throw new ot(`Found more than one (${l.length}) save handlers for URL '${t}'`);t=l[0]}if(t.save==null)throw new ot("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const r=await hN(this.getNamedWeights(e)),i={modelTopology:this.toJSON(null,!1),format:Mpt,generatedBy:`TensorFlow.js tfjs-layers v${EV}`,convertedBy:null};if((e==null?!1:e.includeOptimizer)&&this.optimizer!=null){i.trainingConfig=this.getTrainingConfig();const l="optimizer",{data:h,specs:d}=await hN(await this.optimizer.getWeights(),l);r.specs.push(...d),r.data=hL([r.data,h])}return this.userDefinedMetadata!=null&&($F(this.userDefinedMetadata,this.name,!0),i.userDefinedMetadata=this.userDefinedMetadata),i.weightData=r.data,i.weightSpecs=r.specs,t.save(i)}setUserDefinedMetadata(t){$F(t,this.name),this.userDefinedMetadata=t}getUserDefinedMetadata(){return this.userDefinedMetadata}}Hh.className="Model";$t(Hh);class DV extends Hh{}DV.className="Functional";$t(DV);class pm extends Hh{constructor(t){if(super({inputs:[],outputs:[]}),t=t||{},this.trainable=!0,this.built=!1,this.name=t.name!=null?t.name:q1("sequential_"),t.layers!=null)for(const e of t.layers)this.add(e)}checkShape(t){if(t.inboundNodes[0].outputTensors[0].shape.some(r=>r<0))throw new ot(`Negative dimension size caused by adding layer ${t.name} with input shape [${t.inboundNodes[0].inputTensors[0].shape}]`)}add(t){const e=t instanceof pm||t instanceof Hh;let r;if(e){if(r=t,r.outputs.length!==1)throw new ot("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(r.inputs.length!==1)throw new ot("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(this.outputs.length===0){if(t.inboundNodes.length===0){if(t.batchInputShape==null)throw new ot("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const a=Bdt({batchShape:t.batchInputShape,dtype:t.dtype,name:t.name+"_input"});t.apply(a)}if(e)this.outputs=r.outputs,this.inputs=r.inputs;else{if(t.inboundNodes.length!==1)throw new ot(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${t.name} which has ${t.inboundNodes.length} pre-existing inbound connections.`);if(t.inboundNodes[0].outputTensors.length!==1)throw new ot("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[t.inboundNodes[0].outputTensors[0]],this.inputs=pV(this.outputs[0])}this.inboundNodes=[],new X1({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:cc(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(a=>a.shape),outputShapes:this.outputs[0].shape})}else{const a=t.apply(this.outputs[0]);if(Array.isArray(a))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[a],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(t),this.built=!1}pop(){if(this.layers.length===0)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),this.layers.length===0)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const t=this.layers.length-1;this.layers[t].outboundNodes=[],this.outputs=[this.layers[t].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(t,e){return this.model==null&&this.build(),this.model.call(t,e)}build(t){if(je(t),this.inputs.length===0||this.outputs.length===0)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new Hh({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(t,e,r=console.log){this.built||this.build(),super.summary(t,e,r)}setWeights(t){this.model==null&&this.build(),this.model.setWeights(t)}evaluate(t,e,r={}){if(!this.built)throw new zs("The model needs to be compiled before being used.");return this.model.evaluate(t,e,r)}async evaluateDataset(t,e){if(!this.built)throw new zs("The model needs to be compiled before being used.");return this.model.evaluateDataset(t,e)}predict(t,e={}){return this.model==null&&this.build(),this.model.predict(t,e)}predictOnBatch(t){return this.model==null&&this.build(),this.model.predictOnBatch(t)}compile(t){this.build(),this.model.compile(t),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return this.model==null?void 0:this.model.optimizer}set optimizer(t){this.model.optimizer=t}async fit(t,e,r={}){if(!this.built)throw new zs("The model needs to be compiled before being used.");return this.model.fit(t,e,r)}async fitDataset(t,e){if(!this.built)throw new zs("The model needs to be compiled before being used.");return this.model.fitDataset(t,e)}async trainOnBatch(t,e){return this.model.trainOnBatch(t,e)}static fromConfig(t,e,r={},a=!1){let s,o={};if(e instanceof Array){if(e[0].className==null||e[0].className==="Merge")throw new ot("Legacy serialization format not supported yet.");s=e}else P(e.layers!=null,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),s=e.layers,delete e.layers,o=e;const i=new t(o);if(!(i instanceof pm))throw new ke(`Sequential.fromConfig called on non-Sequential input: ${i}`);for(const u of s){const h=Ei(u,void 0,a);a&&h.setFastWeightInitDuringBuild(!0),i.add(h)}return i}set stopTraining(t){if(this.model==null)throw new ot("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=t}get stopTraining(){if(this.model==null)throw new ot("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const t=[];for(const e of this.layers){const r={};r.className=e.getClassName(),r.config=e.getConfig(),t.push(r)}return{name:this.name,layers:t}}}pm.className="Sequential";$t(pm);let Jr=class extends Sc{getConfig(){return{}}};class $V extends Jr{apply(t,e=1){return Sdt(t,e)}}$V.className="elu";$t($V);class OV extends Jr{apply(t){return o1(t)}}OV.className="selu";$t(OV);class FV extends Jr{apply(t){return lo(t)}}FV.className="relu";$t(FV);class MV extends Jr{apply(t){return ut(()=>Vu(6,lo(t)))}}MV.className="relu6";$t(MV);class LV extends Jr{apply(t){return t}}LV.className="linear";$t(LV);class BV extends Jr{apply(t){return Va(t)}}BV.className="sigmoid";$t(BV);class zV extends Jr{apply(t){return Ndt(t)}}zV.className="hardSigmoid";$t(zV);class PV extends Jr{apply(t){return xc(t)}}PV.className="softplus";$t(PV);class VV extends Jr{apply(t){return Cdt(t)}}VV.className="softsign";$t(VV);class UV extends Jr{apply(t){return Pu(t)}}UV.className="tanh";$t(UV);let t_=class extends Jr{apply(t,e=-1){return Vg(t,e)}};t_.className="softmax";$t(t_);class WV extends Jr{apply(t,e=-1){return Zx(t,e)}}WV.className="logSoftmax";$t(WV);class GV extends Jr{apply(t){return ut(()=>ut(()=>{const e=Math.sqrt(2),r=et(.5,It(1,Xx(Ut(t,e))));return et(t,r)}))}}GV.className="gelu";$t(GV);class HV extends Jr{apply(t){return ut(()=>et(.5,et(t,It(1,Pu(et(wr(Ut(2,Math.PI)),It(t,et(.044715,Wo(t,3)))))))))}}HV.className="gelu_new";$t(HV);class jV extends Jr{apply(t){return ut(()=>et(t,Pu(xc(t))))}}jV.className="mish";$t(jV);class qV extends Jr{apply(t,e=1){return ut(()=>et(Va(et(t,e)),t))}}qV.className="swish";$t(qV);function Hu(n){return n.getClassName()}function WC(n,t={}){return av(n,us.getMap().classNameMap,t,"activation")}function ju(n){if(n==null){const t={};return t.className="linear",t.config={},WC(t)}if(typeof n=="string"){const t={};return t.className=n,t.config={},WC(t)}else return n instanceof Jr?n:WC(n)}function Lpt(n){if(n!=null&&typeof n!="object")throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${n}`)}class KV extends Sc{}class XV extends KV{constructor(t){super(),Lpt(t),this.l1=t==null||t.l1==null?.01:t.l1,this.l2=t==null||t.l2==null?.01:t.l2,this.hasL1=this.l1!==0,this.hasL2=this.l2!==0}apply(t){return ut(()=>{let e=Xn([1]);return this.hasL1&&(e=It(e,jt(et(this.l1,Kn(t))))),this.hasL2&&(e=It(e,jt(et(this.l2,ov(t))))),at(e,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(t,e){return new t({l1:e.l1,l2:e.l2})}}XV.className="L1L2";$t(XV);const zF={l1l2:"L1L2"};function cn(n){return PI(n)}function PF(n,t={}){return av(n,us.getMap().classNameMap,t,"regularizer")}function Nn(n){if(n==null)return null;if(typeof n=="string"){const e={className:n in zF?zF[n]:n,config:{}};return PF(e)}else return n instanceof KV?n:PF(n)}class YV extends Re{constructor(t){super(t??{}),this.supportsMasking=!0,t!=null&&(this.maxValue=t.maxValue)}call(t,e){t=he(t);let r=lo(t);return this.maxValue!=null&&(r=Na(r,0,this.maxValue)),r}computeOutputShape(t){return t}getConfig(){const t={maxValue:this.maxValue},e=super.getConfig();return Object.assign(t,e),t}}YV.className="ReLU";$t(YV);class QV extends Re{constructor(t){super(t??{}),this.DEFAULT_ALPHA=.3,t==null&&(t={}),this.alpha=t.alpha==null?this.DEFAULT_ALPHA:t.alpha}call(t,e){const r=he(t);return Ag(r,this.alpha)}computeOutputShape(t){return t}getConfig(){const t={alpha:this.alpha},e=super.getConfig();return Object.assign(t,e),t}}QV.className="LeakyReLU";$t(QV);class ZV extends Re{constructor(t){if(super(t??{}),this.DEFAULT_ALPHA_INITIALIZER="zeros",t==null&&(t={}),this.supportsMasking=!0,this.alphaInitializer=Cn(t.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=Nn(t.alphaRegularizer),this.alphaConstraint=lr(t.alphaConstraint),t.sharedAxes==null)this.sharedAxes=null;else if(Array.isArray(t.sharedAxes))this.sharedAxes=t.sharedAxes;else if(typeof t.sharedAxes=="number")this.sharedAxes=[t.sharedAxes];else throw new ot(`Expected sharedAxes to be a number or an array of numbers, but got ${t.sharedAxes}`)}build(t){t=je(t);const e=t.slice(1);if(this.sharedAxes!=null)for(const a of this.sharedAxes)e[a-1]=1;this.alpha=this.addWeight("alpha",e,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const r={};if(this.sharedAxes!=null)for(let a=1;a<t.length;++a)r[a]=t[a];this.inputSpec=[new ir({ndim:t.length,axes:r})],this.built=!0}call(t,e){return t=he(t),Bg(t,this.alpha.read())}getConfig(){const t={alphaInitializer:In(this.alphaInitializer),alphaRegularizer:cn(this.alphaRegularizer),alphaConstraint:ur(this.alphaConstraint),sharedAxes:this.sharedAxes},e=super.getConfig();return Object.assign(t,e),t}}ZV.className="PReLU";$t(ZV);let JV=class extends Re{constructor(t){if(super(t??{}),this.DEFAULT_ALPHA=1,t==null&&(t={}),t.alpha!=null&&t.alpha!==this.DEFAULT_ALPHA)throw new ke(`Non-default alpha value (${t.alpha}) is not supported by the ELU layer yet.`);this.alpha=t.alpha==null?this.DEFAULT_ALPHA:t.alpha}call(t,e){const r=he(t);return up(r)}computeOutputShape(t){return t}getConfig(){const t={alpha:this.alpha},e=super.getConfig();return Object.assign(t,e),t}};JV.className="ELU";$t(JV);class tU extends Re{constructor(t){super(t??{}),this.DEFAULT_THETA=1,t==null&&(t={}),this.theta=t.theta==null?this.DEFAULT_THETA:t.theta}call(t,e){const r=he(t);return et(r,Ft(ga(r,this.theta),"float32"))}computeOutputShape(t){return t}getConfig(){const t={theta:this.theta},e=super.getConfig();return Object.assign(t,e),t}}tU.className="ThresholdedReLU";$t(tU);class eU extends Re{constructor(t){super(t??{}),this.DEFAULT_AXIS=1,t==null&&(t={}),this.softmax=new t_().apply,this.axis=t.axis==null?this.DEFAULT_AXIS:t.axis}call(t,e){return ut(()=>{let r=he(t);const a=e.mask;if(a!=null){const s=et(zt(xa(r.shape),Ft(a,r.dtype)),Jt(-1e9));r=It(r,s)}return this.axis instanceof Array?this.axis.length>1?ka(zt(r,$g(r,this.axis,!0))):this.softmax(r,this.axis[0]):this.softmax(r,this.axis)})}computeOutputShape(t){return t}getConfig(){const t={axis:this.axis},e=super.getConfig();return Object.assign(t,e),t}}eU.className="Softmax";$t(eU);function jh(n,t,e){if(typeof n=="number")return cc(n,t);if(n.length!==t)throw new ot(`The ${e} argument must be an integer or tuple of ${t} integers. Received: ${n.length} elements.`);for(let r=0;r<t;++r){const a=n[r];if(!ydt(a))throw new ot(`The ${e} argument must be an integer or tuple of ${t} integers. Received: ${JSON.stringify(n)} including a non-integer number ${a}`)}return n}function ro(n,t,e,r,a=1){if(n==null)return n;const s=t+(t-1)*(a-1);let o;return e==="same"?o=n:o=n-s+1,Math.floor((o+r-1)/r)}function ko(n,t,e,r){if(n==null)return null;if(r==="valid")n=n*t+Gu([e-t,0]);else if(r==="same")n=n*t;else throw new ot(`Unsupport padding mode: ${r}.`);return n}function e_(n,t){return ut(()=>(Wn(t),t==="channelsFirst"?Oe(n,[0,2,3,1]):n))}function nU(n,t){return ut(()=>(Wn(t),t==="channelsFirst"?Oe(n,[0,2,3,4,1]):n))}function Bpt(n,t,e,r=1,a="valid",s,o=1){return ut(()=>{if(s==null&&(s=oo()),Wn(s),n.shape.length!==3)throw new ot(`The input of a conv1dWithBias operation should be 3, but is ${n.shape.length} instead.`);if(t.shape.length!==3)throw new ot(`The kernel for a conv1dWithBias operation should be 3, but is ${t.shape.length} instead`);if(e!=null&&e.shape.length!==1)throw new ot(`The bias for a conv1dWithBias operation should be 1, but is ${e.shape.length} instead`);if(s==="channelsFirst"&&(n=Oe(n,[0,2,1])),a==="causal")throw new ke("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let i=Hx(n,t,r,a==="same"?"same":"valid","NWC",o);return e!=null&&(i=po(i,e)),i})}function VF(n,t,e,r=[1,1],a="valid",s,o,i=null){return ut(()=>{if(s==null&&(s=oo()),Wn(s),n.rank!==3&&n.rank!==4)throw new ot(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${n.rank}.`);if(t.rank!==3&&t.rank!==4)throw new ot(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${n.rank}.`);let u=e_(n,s);if(a==="causal")throw new ke("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return u=d4({x:u,filter:t,strides:r,pad:a==="same"?"same":"valid",dilations:o,dataFormat:"NHWC",bias:e,activation:i}),s==="channelsFirst"&&(u=Oe(u,[0,3,1,2])),u})}function zpt(n,t,e,r=[1,1,1],a="valid",s,o){return ut(()=>{if(s==null&&(s=oo()),Wn(s),n.rank!==4&&n.rank!==5)throw new ot(`conv3dWithBias expects input to be of rank 4 or 5, but received ${n.rank}.`);if(t.rank!==4&&t.rank!==5)throw new ot(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${n.rank}.`);let i=nU(n,s);if(a==="causal")throw new ke("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return i=lT(i,t,r,a==="same"?"same":"valid","NDHWC",o),e!=null&&(i=po(i,e)),s==="channelsFirst"&&(i=Oe(i,[0,4,1,2,3])),i})}class Z1 extends Re{constructor(t,e){if(super(e),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",Z1.verifyArgs(e),this.rank=t,vr(this.rank,"rank"),this.rank!==1&&this.rank!==2&&this.rank!==3)throw new ke(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=jh(e.kernelSize,t,"kernelSize"),this.strides=jh(e.strides==null?1:e.strides,t,"strides"),this.padding=e.padding==null?"valid":e.padding,ws(this.padding),this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Wn(this.dataFormat),this.activation=ju(e.activation),this.useBias=e.useBias==null?!0:e.useBias,this.biasInitializer=Cn(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=lr(e.biasConstraint),this.biasRegularizer=Nn(e.biasRegularizer),this.activityRegularizer=Nn(e.activityRegularizer),this.dilationRate=jh(e.dilationRate==null?1:e.dilationRate,t,"dilationRate"),this.rank===1&&Array.isArray(this.dilationRate)&&this.dilationRate.length!==1)throw new ot(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(this.rank===2){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==2)throw new ot(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(this.rank===3){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==3)throw new ot(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}}static verifyArgs(t){if(No("kernelSize"in t,"required key 'kernelSize' not in config"),typeof t.kernelSize!="number"&&!VI(t.kernelSize,"number",1,3))throw new ot(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(t.kernelSize)}.`)}getConfig(){const t={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:Hu(this.activation),useBias:this.useBias,biasInitializer:In(this.biasInitializer),biasRegularizer:cn(this.biasRegularizer),activityRegularizer:cn(this.activityRegularizer),biasConstraint:ur(this.biasConstraint)},e=super.getConfig();return Object.assign(t,e),t}}class mp extends Z1{constructor(t,e){super(t,e),this.kernel=null,mp.verifyArgs(e),this.filters=e.filters,vr(this.filters,"filters"),this.kernelInitializer=Cn(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=lr(e.kernelConstraint),this.kernelRegularizer=Nn(e.kernelRegularizer)}build(t){t=je(t);const e=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[e]==null)throw new ot(`The channel dimension of the input should be defined. Found ${t[e]}`);const r=t[e],a=this.kernelSize.concat([r,this.filters]);this.kernel=this.addWeight("kernel",a,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[e]:r}}],this.built=!0}call(t,e){return ut(()=>{t=he(t);let r;const a=this.bias==null?null:this.bias.read(),s=ZP(this.activation.getClassName());if(s!=null&&this.rank===2)r=VF(t,this.kernel.read(),a,this.strides,this.padding,this.dataFormat,this.dilationRate,s);else{if(this.rank===1)r=Bpt(t,this.kernel.read(),a,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(this.rank===2)r=VF(t,this.kernel.read(),a,this.strides,this.padding,this.dataFormat,this.dilationRate);else if(this.rank===3)r=zpt(t,this.kernel.read(),a,this.strides,this.padding,this.dataFormat,this.dilationRate);else throw new ke("convolutions greater than 3D are not implemented yet.");this.activation!=null&&(r=this.activation.apply(r))}return r})}computeOutputShape(t){t=je(t);const e=[],r=this.dataFormat==="channelsLast"?t.slice(1,t.length-1):t.slice(2);for(let s=0;s<r.length;++s){const o=ro(r[s],this.kernelSize[s],this.padding,this.strides[s],typeof this.dilationRate=="number"?this.dilationRate:this.dilationRate[s]);e.push(o)}let a=[t[0]];return this.dataFormat==="channelsLast"?(a=a.concat(e),a.push(this.filters)):(a.push(this.filters),a=a.concat(e)),a}getConfig(){const t={filters:this.filters,kernelInitializer:In(this.kernelInitializer),kernelRegularizer:cn(this.kernelRegularizer),kernelConstraint:ur(this.kernelConstraint)},e=super.getConfig();return Object.assign(t,e),t}static verifyArgs(t){if(!("filters"in t)||typeof t.filters!="number"||t.filters<1)throw new ot(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(t.filters)}`)}}class cv extends mp{constructor(t){super(2,t),cv.verifyArgs(t)}getConfig(){const t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!VI(t.kernelSize,"number",1,2))throw new ot(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(t.kernelSize)}.`)}}cv.className="Conv2D";$t(cv);class hv extends mp{constructor(t){super(3,t),hv.verifyArgs(t)}getConfig(){const t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!(Array.isArray(t.kernelSize)&&(t.kernelSize.length===1||t.kernelSize.length===3)))throw new ot(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(t.kernelSize)}.`)}}hv.className="Conv3D";$t(hv);class rU extends cv{constructor(t){if(super(t),this.inputSpec=[new ir({ndim:4})],this.padding!=="same"&&this.padding!=="valid")throw new ot(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(t){if(t=je(t),t.length!==4)throw new ot("Input should have rank 4; Received input shape: "+JSON.stringify(t));const e=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[e]==null)throw new ot("The channel dimension of the inputs should be defined. Found `None`.");const r=t[e],a=this.kernelSize.concat([this.filters,r]);this.kernel=this.addWeight("kernel",a,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new ir({ndim:4,axes:{[e]:r}})],this.built=!0}call(t,e){return ut(()=>{let r=he(t);if(r.shape.length!==4)throw new ot(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${r.shape.length}`);const a=r.shape,s=a[0];let o,i;this.dataFormat==="channelsFirst"?(o=2,i=3):(o=1,i=2);const u=a[o],l=a[i],h=this.kernelSize[0],d=this.kernelSize[1],f=this.strides[0],m=this.strides[1],v=ko(u,f,h,this.padding),y=ko(l,m,d,this.padding),b=[s,v,y,this.filters];this.dataFormat!=="channelsLast"&&(r=Oe(r,[0,2,3,1]));let w=jx(r,this.kernel.read(),b,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(w=Oe(w,[0,3,1,2])),this.bias!=null&&(w=po(w,this.bias.read(),this.dataFormat)),this.activation!=null&&(w=this.activation.apply(w)),w})}computeOutputShape(t){t=je(t);const e=t.slice();let r,a,s;this.dataFormat==="channelsFirst"?(r=1,a=2,s=3):(r=3,a=1,s=2);const o=this.kernelSize[0],i=this.kernelSize[1],u=this.strides[0],l=this.strides[1];return e[r]=this.filters,e[a]=ko(e[a],u,o,this.padding),e[s]=ko(e[s],l,i,this.padding),e}getConfig(){const t=super.getConfig();return delete t.dilationRate,t}}rU.className="Conv2DTranspose";$t(rU);class aU extends hv{constructor(t){if(super(t),this.inputSpec=[new ir({ndim:5})],this.padding!=="same"&&this.padding!=="valid")throw new ot(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(t){if(t=je(t),t.length!==5)throw new ot("Input should have rank 5; Received input shape: "+JSON.stringify(t));const e=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[e]==null)throw new ot("The channel dimension of the inputs should be defined. Found `None`.");const r=t[e],a=this.kernelSize.concat([this.filters,r]);this.kernel=this.addWeight("kernel",a,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new ir({ndim:5,axes:{[e]:r}})],this.built=!0}call(t,e){return ut(()=>{let r=he(t);if(r.shape.length!==5)throw new ot(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${r.shape.length}`);const a=r.shape,s=a[0];let o,i,u;this.dataFormat==="channelsFirst"?(u=2,o=3,i=4):(u=1,o=2,i=3);const l=a[u],h=a[o],d=a[i],f=this.kernelSize[0],m=this.kernelSize[1],v=this.kernelSize[2],y=this.strides[0],b=this.strides[1],w=this.strides[2],S=ko(l,y,f,this.padding),N=ko(h,b,m,this.padding),C=ko(d,w,v,this.padding),T=[s,S,N,C,this.filters];this.dataFormat!=="channelsLast"&&(r=Oe(r,[0,2,3,4,1]));let I=cT(r,this.kernel.read(),T,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(I=Oe(I,[0,4,1,2,3])),this.bias!==null&&(I=po(I,this.bias.read(),this.dataFormat)),this.activation!==null&&(I=this.activation.apply(I)),I})}computeOutputShape(t){t=je(t);const e=t.slice();let r,a,s,o;this.dataFormat==="channelsFirst"?(r=1,a=2,s=3,o=4):(r=4,a=1,s=2,o=3);const i=this.kernelSize[0],u=this.kernelSize[1],l=this.kernelSize[2],h=this.strides[0],d=this.strides[1],f=this.strides[2];return e[r]=this.filters,e[a]=ko(e[a],h,i,this.padding),e[s]=ko(e[s],d,u,this.padding),e[o]=ko(e[o],f,l,this.padding),e}getConfig(){const t=super.getConfig();return delete t.dilationRate,t}}aU.className="Conv3DTranspose";$t(aU);class sU extends mp{constructor(t,e){if(super(t,e),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,e.filters==null)throw new ot("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(e.kernelInitializer!=null||e.kernelRegularizer!=null||e.kernelConstraint!=null)throw new ot("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(e.padding!=null&&e.padding!=="same"&&e.padding!=="valid")throw new ot(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(e.padding)}`);this.depthMultiplier=e.depthMultiplier==null?1:e.depthMultiplier,this.depthwiseInitializer=Cn(e.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=Nn(e.depthwiseRegularizer),this.depthwiseConstraint=lr(e.depthwiseConstraint),this.pointwiseInitializer=Cn(e.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=Nn(e.pointwiseRegularizer),this.pointwiseConstraint=lr(e.pointwiseConstraint)}build(t){if(t=je(t),t.length<this.rank+2)throw new ot(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(t)}`);const e=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[e]==null||t[e]<0)throw new ot(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(t[e])}`);const r=t[e],a=this.kernelSize.concat([r,this.depthMultiplier]),s=[];for(let i=0;i<this.rank;++i)s.push(1);s.push(r*this.depthMultiplier,this.filters);const o=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",a,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,o,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",s,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,o,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,o,this.biasConstraint):this.bias=null,this.inputSpec=[new ir({ndim:this.rank+2,axes:{[e]:r}})],this.built=!0}call(t,e){return ut(()=>{t=he(t);let r;if(this.rank===1)throw new ke("1D separable convolution is not implemented yet.");return this.rank===2&&(this.dataFormat==="channelsFirst"&&(t=Oe(t,[0,2,3,1])),r=i1(t,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(r=po(r,this.bias.read(),this.dataFormat)),this.activation!=null&&(r=this.activation.apply(r)),this.dataFormat==="channelsFirst"&&(r=Oe(r,[0,3,1,2])),r})}getConfig(){const t=super.getConfig();return delete t.rank,delete t.kernelInitializer,delete t.kernelRegularizer,delete t.kernelConstraint,t.depthwiseInitializer=In(this.depthwiseInitializer),t.pointwiseInitializer=In(this.pointwiseInitializer),t.depthwiseRegularizer=cn(this.depthwiseRegularizer),t.pointwiseRegularizer=cn(this.pointwiseRegularizer),t.depthwiseConstraint=ur(this.depthwiseConstraint),t.pointwiseConstraint=ur(this.pointwiseConstraint),t}}sU.className="SeparableConv";class oU extends sU{constructor(t){super(2,t)}}oU.className="SeparableConv2D";$t(oU);class J1 extends mp{constructor(t){super(1,t),J1.verifyArgs(t),this.inputSpec=[{ndim:3}]}getConfig(){const t=super.getConfig();return delete t.rank,delete t.dataFormat,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!VI(t.kernelSize,"number",1,1))throw new ot(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(t.kernelSize)}.`)}}J1.className="Conv1D";$t(J1);class iU extends Re{constructor(t){super(t),typeof t.cropping=="number"?this.cropping=[[t.cropping,t.cropping],[t.cropping,t.cropping]]:typeof t.cropping[0]=="number"?this.cropping=[[t.cropping[0],t.cropping[0]],[t.cropping[1],t.cropping[1]]]:this.cropping=t.cropping,this.dataFormat=t.dataFormat===void 0?"channelsLast":t.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(t){return this.dataFormat==="channelsFirst"?[t[0],t[1],t[2]-this.cropping[0][0]-this.cropping[0][1],t[3]-this.cropping[1][0]-this.cropping[1][1]]:[t[0],t[1]-this.cropping[0][0]-this.cropping[0][1],t[2]-this.cropping[1][0]-this.cropping[1][1],t[3]]}call(t,e){return ut(()=>{if(t=he(t),this.dataFormat==="channelsLast"){const r=i0(t,this.cropping[0][0],t.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return i0(r,this.cropping[1][0],t.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}else{const r=i0(t,this.cropping[0][0],t.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return i0(r,this.cropping[1][0],t.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){const t={cropping:this.cropping,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}iU.className="Cropping2D";$t(iU);class uU extends Re{constructor(t){super(t),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=t.size==null?this.DEFAULT_SIZE:t.size,this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,Wn(this.dataFormat),this.interpolation=t.interpolation==null?"nearest":t.interpolation,mdt(this.interpolation)}computeOutputShape(t){if(this.dataFormat==="channelsFirst"){const e=t[2]==null?null:this.size[0]*t[2],r=t[3]==null?null:this.size[1]*t[3];return[t[0],t[1],e,r]}else{const e=t[1]==null?null:this.size[0]*t[1],r=t[2]==null?null:this.size[1]*t[2];return[t[0],e,r,t[3]]}}call(t,e){return ut(()=>{let r=he(t);const a=r.shape;if(this.dataFormat==="channelsFirst"){r=Oe(r,[0,2,3,1]);const s=this.size[0]*a[2],o=this.size[1]*a[3],i=this.interpolation==="nearest"?ha.resizeNearestNeighbor(r,[s,o]):ha.resizeBilinear(r,[s,o]);return Oe(i,[0,3,1,2])}else{const s=this.size[0]*a[1],o=this.size[1]*a[2];return this.interpolation==="nearest"?ha.resizeNearestNeighbor(r,[s,o]):ha.resizeBilinear(r,[s,o])}})}getConfig(){const t={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},e=super.getConfig();return Object.assign(t,e),t}}uU.className="UpSampling2D";$t(uU);function Ppt(n,t,e=[1,1],r="valid",a,s){return ut(()=>{a==null&&(a=oo()),Wn(a);let o=e_(n,a);if(n.rank!==4)throw new ot(`Input for depthwiseConv2d is required to be 4-D, but is instead ${n.rank}-D`);if(t.rank!==4)throw new ot(`depthwiseKernel is required to be 4-D, but is instead ${t.rank}-D`);return o=ip(o,t,e,r==="same"?"same":"valid","NHWC",s),a==="channelsFirst"&&(o=Oe(o,[0,3,1,2])),o})}class lU extends Z1{constructor(t){super(2,t),this.depthwiseKernel=null,this.depthMultiplier=t.depthMultiplier==null?1:t.depthMultiplier,this.depthwiseInitializer=Cn(t.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=lr(t.depthwiseConstraint),this.depthwiseRegularizer=Nn(t.depthwiseRegularizer)}build(t){if(t=je(t),t.length<4)throw new ot(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(t)}.`);const e=this.dataFormat==="channelsFirst"?1:3;if(t[e]==null||t[e]<0)throw new ot(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${t[e]}).`);const r=t[e],a=[this.kernelSize[0],this.kernelSize[1],r,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",a,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[r*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,e){return ut(()=>{t=he(t);let r=Ppt(t,this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(r=po(r,this.bias.read(),this.dataFormat)),this.activation!=null&&(r=this.activation.apply(r)),r})}computeOutputShape(t){t=je(t);const e=this.dataFormat==="channelsFirst"?t[2]:t[1],r=this.dataFormat==="channelsFirst"?t[3]:t[2],a=this.dataFormat==="channelsFirst"?t[1]*this.depthMultiplier:t[3]*this.depthMultiplier,s=ro(e,this.kernelSize[0],this.padding,this.strides[0]),o=ro(r,this.kernelSize[1],this.padding,this.strides[1]);return this.dataFormat==="channelsFirst"?[t[0],a,s,o]:[t[0],s,o,a]}getConfig(){const t=super.getConfig();return t.depthMultiplier=this.depthMultiplier,t.depthwiseInitializer=In(this.depthwiseInitializer),t.depthwiseRegularizer=cn(this.depthwiseRegularizer),t.depthwiseConstraint=ur(this.depthwiseRegularizer),t}}lU.className="DepthwiseConv2D";$t(lU);function cU(n,t,e,r){if(Array.isArray(n)){if(t!=null||e!=null)throw new ot("When inputs is an array, neither initialState or constants should be provided");r!=null&&(e=n.slice(n.length-r,n.length),n=n.slice(0,n.length-r)),n.length>1&&(t=n.slice(1,n.length)),n=n[0]}function a(s){return s==null||Array.isArray(s)?s:[s]}return t=a(t),e=a(e),{inputs:n,initialState:t,constants:e}}function hU(n,t,e,r=!1,a,s,o=!1,i=!1){return ut(()=>{const u=t.shape.length;if(u<3)throw new ot(`Input should be at least 3D, but is ${u}D.`);const l=[1,0].concat(so(2,u));t=Oe(t,l),o&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),a!=null&&(a=Ft(Ft(a,"bool"),"float32"),a.rank===u-1&&(a=Pn(a,-1)),a=Oe(a,l)),r&&(t=bs(t,0),a!=null&&(a=bs(a,0)));const h=[];let d,f=e;const m=t.shape[0],v=xs(t);let y;a!=null&&(y=xs(a));for(let w=0;w<m;++w){const S=v[w],N=ut(()=>n(S,f));if(a==null)d=N[0],f=N[1];else{const C=ut(()=>{const T=y[w],I=zt(Ha(T),T),_=It(et(N[0],T),et(f[0],I)),$=f.map((R,D)=>It(et(N[1][D],T),et(R,I)));return{output:_,newStates:$}});d=C.output,f=C.newStates}i&&h.push(d)}let b;return i&&(b=Ta(h,1)),[d,b,f]})}class ol extends Re{constructor(t){super(t);let e;if(t.cell==null)throw new ot("cell property is missing for the constructor of RNN.");if(Array.isArray(t.cell)?e=new a_({cells:t.cell}):e=t.cell,e.stateSize==null)throw new ot("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=e,this.returnSequences=t.returnSequences==null?!1:t.returnSequences,this.returnState=t.returnState==null?!1:t.returnState,this.goBackwards=t.goBackwards==null?!1:t.goBackwards,this._stateful=t.stateful==null?!1:t.stateful,this.unroll=t.unroll==null?!1:t.unroll,this.supportsMasking=!0,this.inputSpec=[new ir({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(this.states_==null){const t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;return so(0,t).map(e=>null)}else return this.states_}setStates(t){this.states_=t}computeOutputShape(t){ik(t)&&(t=t[0]),t=t;let e=this.cell.stateSize;Array.isArray(e)||(e=[e]);const r=e[0];let a;if(this.returnSequences?a=[t[0],t[1],r]:a=[t[0],r],this.returnState){const s=[];for(const o of e)s.push([t[0],o]);return[a].concat(s)}else return a}computeMask(t,e){return ut(()=>{Array.isArray(e)&&(e=e[0]);const r=this.returnSequences?e:null;if(this.returnState){const a=this.states.map(s=>null);return[r].concat(a)}else return r})}get states(){if(this.states_==null){const t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,e=[];for(let r=0;r<t;++r)e.push(null);return e}else return this.states_}set states(t){this.states_=t}build(t){if(this.numConstants!=null)throw new ke("Constants support is not implemented in RNN yet.");ik(t)&&(t=t[0]),t=t;const e=this.stateful?t[0]:null,r=t.slice(2);this.inputSpec[0]=new ir({shape:[e,null,...r]});const a=[t[0]].concat(t.slice(2));this.cell.build(a);let s;if(Array.isArray(this.cell.stateSize)?s=this.cell.stateSize:s=[this.cell.stateSize],this.stateSpec!=null){if(!De(this.stateSpec.map(o=>o.shape[o.shape.length-1]),s))throw new ot(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=s.map(o=>new ir({shape:[null,o]}));this.stateful&&this.resetStates()}resetStates(t,e=!1){ut(()=>{if(!this.stateful)throw new Co("Cannot call resetStates() on an RNN Layer that is not stateful.");const r=this.inputSpec[0].shape[0];if(r==null)throw new ot("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.states_==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(a=>Xn([r,a])):this.states_=[Xn([r,this.cell.stateSize])];else if(t==null)Ie(this.states_),this.keptStates!=null&&(Ie(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(a=>Xn([r,a])):this.states_[0]=Xn([r,this.cell.stateSize]);else{if(Array.isArray(t)||(t=[t]),t.length!==this.states_.length)throw new ot(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${t.length} state value(s). Input received: ${t}`);e===!0?this.keptStates.push(this.states_.slice()):Ie(this.states_);for(let a=0;a<this.states_.length;++a){const s=t[a],o=Array.isArray(this.cell.stateSize)?this.cell.stateSize[a]:this.cell.stateSize,i=[r,o];if(!De(s.shape,i))throw new ot(`State ${a} is incompatible with layer ${this.name}: expected shape=${i}, received shape=${s.shape}`);this.states_[a]=s}}this.states_=this.states_.map(a=>ar(a.clone()))})}apply(t,e){let r=e==null?null:e.initialState,a=e==null?null:e.constants;e==null&&(e={});const s=cU(t,r,a,this.numConstants);t=s.inputs,r=s.initialState,a=s.constants;let o=[],i=[];if(r!=null){e.initialState=r,o=o.concat(r),this.stateSpec=[];for(const l of r)this.stateSpec.push(new ir({shape:l.shape}));i=i.concat(this.stateSpec)}if(a!=null&&(e.constants=a,o=o.concat(a),this.numConstants=a.length),o[0]instanceof jo){const l=[t].concat(o),h=this.inputSpec.concat(i),d=this.inputSpec;this.inputSpec=h;const f=super.apply(l,e);return this.inputSpec=d,f}else return super.apply(t,e)}call(t,e){return ut(()=>{const r=e==null?null:e.mask,a=e==null?null:e.training;let s=e==null?null:e.initialState;t=he(t),s==null&&(this.stateful?s=this.states_:s=this.getInitialState(t));const o=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(s.length!==o)throw new ot(`RNN Layer has ${o} state(s) but was passed ${s.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const i={training:a},l=hU((v,y)=>{const b=this.cell.call([v].concat(y),i);return[b[0],b.slice(1)]},t,s,this.goBackwards,r,null,this.unroll,this.returnSequences),h=l[0],d=l[1],f=l[2];this.stateful&&this.resetStates(f,a);const m=this.returnSequences?d:h;return this.returnState?[m].concat(f):m})}getInitialState(t){return ut(()=>{let e=Xn(t.shape);return e=jt(e,[1,2]),e=sv(e),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(r=>r>1?sk(e,[1,r]):e):this.cell.stateSize>1?[sk(e,[1,this.cell.stateSize])]:[e]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),this.cell!=null&&this.cell.setFastWeightInitDuringBuild(t)}getConfig(){const t=super.getConfig(),e={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};this.numConstants!=null&&(e.numConstants=this.numConstants);const r=this.cell.getConfig();return this.getClassName()===ol.className&&(e.cell={className:this.cell.getClassName(),config:r}),Object.assign(Object.assign(Object.assign({},r),t),e)}static fromConfig(t,e,r={}){const a=e.cell,s=Ei(a,r);return new t(Object.assign(e,{cell:s}))}}ol.className="RNN";$t(ol);class tw extends Re{}class n_ extends tw{constructor(t){super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=t.units,vr(this.units,"units"),this.activation=ju(t.activation==null?this.DEFAULT_ACTIVATION:t.activation),this.useBias=t.useBias==null?!0:t.useBias,this.kernelInitializer=Cn(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Cn(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Cn(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Nn(t.kernelRegularizer),this.recurrentRegularizer=Nn(t.recurrentRegularizer),this.biasRegularizer=Nn(t.biasRegularizer),this.kernelConstraint=lr(t.kernelConstraint),this.recurrentConstraint=lr(t.recurrentConstraint),this.biasConstraint=lr(t.biasConstraint),this.dropout=sd([1,Gu([0,t.dropout==null?0:t.dropout])]),this.recurrentDropout=sd([1,Gu([0,t.recurrentDropout==null?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){t=je(t),this.kernel=this.addWeight("kernel",[t[t.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,e){return ut(()=>{if(t=t,t.length!==2)throw new ot(`SimpleRNNCell expects 2 input Tensors, got ${t.length}.`);let r=t[1];t=t[0];const a=e.training==null?!1:e.training;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=qu({ones:()=>Ha(t),rate:this.dropout,training:a,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=qu({ones:()=>Ha(r),rate:this.recurrentDropout,training:a,dropoutFunc:this.dropoutFunc}));let s;const o=this.dropoutMask,i=this.recurrentDropoutMask;o!=null?s=Po(et(t,o),this.kernel.read()):s=Po(t,this.kernel.read()),this.bias!=null&&(s=po(s,this.bias.read())),i!=null&&(r=et(r,i));let u=It(s,Po(r,this.recurrentKernel.read()));return this.activation!=null&&(u=this.activation.apply(u)),[u,u]})}getConfig(){const t=super.getConfig(),e={units:this.units,activation:Hu(this.activation),useBias:this.useBias,kernelInitializer:In(this.kernelInitializer),recurrentInitializer:In(this.recurrentInitializer),biasInitializer:In(this.biasInitializer),kernelRegularizer:cn(this.kernelRegularizer),recurrentRegularizer:cn(this.recurrentRegularizer),biasRegularizer:cn(this.biasRegularizer),activityRegularizer:cn(this.activityRegularizer),kernelConstraint:ur(this.kernelConstraint),recurrentConstraint:ur(this.recurrentConstraint),biasConstraint:ur(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},t),e)}}n_.className="SimpleRNNCell";$t(n_);class dU extends ol{constructor(t){t.cell=new n_(t),super(t)}call(t,e){return ut(()=>{this.cell.dropoutMask!=null&&(Ie(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Ie(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const r=e==null?null:e.mask,a=e==null?null:e.training,s=e==null?null:e.initialState;return super.call(t,{mask:r,training:a,initialState:s})})}static fromConfig(t,e){return new t(e)}}dU.className="SimpleRNN";$t(dU);class r_ extends tw{constructor(t){if(super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",t.resetAfter)throw new ot("GRUCell does not support reset_after parameter set to true.");this.units=t.units,vr(this.units,"units"),this.activation=ju(t.activation===void 0?this.DEFAULT_ACTIVATION:t.activation),this.recurrentActivation=ju(t.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),this.useBias=t.useBias==null?!0:t.useBias,this.kernelInitializer=Cn(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Cn(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Cn(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Nn(t.kernelRegularizer),this.recurrentRegularizer=Nn(t.recurrentRegularizer),this.biasRegularizer=Nn(t.biasRegularizer),this.kernelConstraint=lr(t.kernelConstraint),this.recurrentConstraint=lr(t.recurrentConstraint),this.biasConstraint=lr(t.biasConstraint),this.dropout=sd([1,Gu([0,t.dropout==null?0:t.dropout])]),this.recurrentDropout=sd([1,Gu([0,t.recurrentDropout==null?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.implementation=t.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){t=je(t);const e=t[t.length-1];this.kernel=this.addWeight("kernel",[e,this.units*3],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*3],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units*3],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,e){return ut(()=>{if(t=t,t.length!==2)throw new ot(`GRUCell expects 2 input Tensors (inputs, h, c), got ${t.length}.`);const r=e.training==null?!1:e.training;let a=t[1];t=t[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=qu({ones:()=>Ha(t),rate:this.dropout,training:r,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=qu({ones:()=>Ha(a),rate:this.recurrentDropout,training:r,count:3,dropoutFunc:this.dropoutFunc}));const s=this.dropoutMask,o=this.recurrentDropoutMask;let i,u,l;0<this.dropout&&this.dropout<1&&(t=et(t,s[0]));let h=Po(t,this.kernel.read());this.useBias&&(h=po(h,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(a=et(a,o[0]));const d=this.recurrentKernel.read(),[f,m]=wa(d,[2*this.units,this.units],d.rank-1),v=Po(a,f),[y,b,w]=wa(h,3,h.rank-1),[S,N]=wa(v,2,v.rank-1);i=this.recurrentActivation.apply(It(y,S)),u=this.recurrentActivation.apply(It(b,N));const C=Po(et(u,a),m);l=this.activation.apply(It(w,C));const T=It(et(i,a),et(It(1,mn(i)),l));return[T,T]})}getConfig(){const t=super.getConfig(),e={units:this.units,activation:Hu(this.activation),recurrentActivation:Hu(this.recurrentActivation),useBias:this.useBias,kernelInitializer:In(this.kernelInitializer),recurrentInitializer:In(this.recurrentInitializer),biasInitializer:In(this.biasInitializer),kernelRegularizer:cn(this.kernelRegularizer),recurrentRegularizer:cn(this.recurrentRegularizer),biasRegularizer:cn(this.biasRegularizer),activityRegularizer:cn(this.activityRegularizer),kernelConstraint:ur(this.kernelConstraint),recurrentConstraint:ur(this.recurrentConstraint),biasConstraint:ur(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},t),e)}}r_.className="GRUCell";$t(r_);class pU extends ol{constructor(t){t.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new r_(t),super(t)}call(t,e){return ut(()=>{this.cell.dropoutMask!=null&&(Ie(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Ie(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const r=e==null?null:e.mask,a=e==null?null:e.training,s=e==null?null:e.initialState;return super.call(t,{mask:r,training:a,initialState:s})})}static fromConfig(t,e){return e.implmentation===0&&(e.implementation=1),new t(e)}}pU.className="GRU";$t(pU);class ew extends tw{constructor(t){super(t),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=t.units,vr(this.units,"units"),this.activation=ju(t.activation===void 0?this.DEFAULT_ACTIVATION:t.activation),this.recurrentActivation=ju(t.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),this.useBias=t.useBias==null?!0:t.useBias,this.kernelInitializer=Cn(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Cn(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Cn(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=t.unitForgetBias,this.kernelRegularizer=Nn(t.kernelRegularizer),this.recurrentRegularizer=Nn(t.recurrentRegularizer),this.biasRegularizer=Nn(t.biasRegularizer),this.kernelConstraint=lr(t.kernelConstraint),this.recurrentConstraint=lr(t.recurrentConstraint),this.biasConstraint=lr(t.biasConstraint),this.dropout=sd([1,Gu([0,t.dropout==null?0:t.dropout])]),this.recurrentDropout=sd([1,Gu([0,t.recurrentDropout==null?0:t.recurrentDropout])]),this.dropoutFunc=t.dropoutFunc,this.implementation=t.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){var e;t=je(t);const r=t[t.length-1];this.kernel=this.addWeight("kernel",[r,this.units*4],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*4],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint);let a;if(this.useBias){if(this.unitForgetBias){const s=this.biasInitializer,o=this.units;a=new(e=class extends Ws{apply(u,l){const h=s.apply([o]),d=new WI().apply([o]),f=s.apply([o*2]);return NF(NF(h,d),f)}},e.className="CustomInit",e)}else a=this.biasInitializer;this.bias=this.addWeight("bias",[this.units*4],null,a,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(t,e){return ut(()=>{const r=e.training==null?!1:e.training;if(t=t,t.length!==3)throw new ot(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${t.length}.`);let a=t[1];const s=t[2];t=t[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=qu({ones:()=>Ha(t),rate:this.dropout,training:r,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=qu({ones:()=>Ha(a),rate:this.recurrentDropout,training:r,count:4,dropoutFunc:this.dropoutFunc}));const o=this.dropoutMask,i=this.recurrentDropoutMask;let u,l,h,d;0<this.dropout&&this.dropout<1&&(t=et(t,o[0]));let f=Po(t,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(a=et(a,i[0])),f=It(f,Po(a,this.recurrentKernel.read())),this.useBias&&(f=po(f,this.bias.read()));const[m,v,y,b]=wa(f,4,f.rank-1);u=this.recurrentActivation.apply(m),l=this.recurrentActivation.apply(v),h=It(et(l,s),et(u,this.activation.apply(y))),d=this.recurrentActivation.apply(b);const w=et(d,this.activation.apply(h));return[w,w,h]})}getConfig(){const t=super.getConfig(),e={units:this.units,activation:Hu(this.activation),recurrentActivation:Hu(this.recurrentActivation),useBias:this.useBias,kernelInitializer:In(this.kernelInitializer),recurrentInitializer:In(this.recurrentInitializer),biasInitializer:In(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:cn(this.kernelRegularizer),recurrentRegularizer:cn(this.recurrentRegularizer),biasRegularizer:cn(this.biasRegularizer),activityRegularizer:cn(this.activityRegularizer),kernelConstraint:ur(this.kernelConstraint),recurrentConstraint:ur(this.recurrentConstraint),biasConstraint:ur(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},t),e)}}ew.className="LSTMCell";$t(ew);class fU extends ol{constructor(t){t.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new ew(t),super(t)}call(t,e){return ut(()=>{this.cell.dropoutMask!=null&&(Ie(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Ie(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const r=e==null?null:e.mask,a=e==null?null:e.training,s=e==null?null:e.initialState;return super.call(t,{mask:r,training:a,initialState:s})})}static fromConfig(t,e){return e.implmentation===0&&(e.implementation=1),new t(e)}}fU.className="LSTM";$t(fU);class a_ extends tw{constructor(t){super(t),this.cells=t.cells}get stateSize(){const t=[];for(const e of this.cells.slice().reverse())Array.isArray(e.stateSize)?t.push(...e.stateSize):t.push(e.stateSize);return t}call(t,e){return ut(()=>{t=t;let r=t.slice(1);const a=[];for(const i of this.cells.slice().reverse())Array.isArray(i.stateSize)?a.push(r.splice(0,i.stateSize.length)):a.push(r.splice(0,1));a.reverse();const s=[];let o;for(let i=0;i<this.cells.length;++i){const u=this.cells[i];r=a[i],i===0?o=[t[0]].concat(r):o=[o[0]].concat(r),o=u.call(o,e),s.push(o.slice(1))}r=[];for(const i of s.slice().reverse())r.push(...i);return[o[0]].concat(r)})}build(t){ik(t)&&(t=t[0]),t=t;let e;this.cells.forEach((r,a)=>{Yl(`RNNCell_${a}`,()=>{r.build(t),Array.isArray(r.stateSize)?e=r.stateSize[0]:e=r.stateSize,t=[t[0],e]})}),this.built=!0}getConfig(){const t=super.getConfig(),e=s=>({className:s.getClassName(),config:s.getConfig()}),a={cells:this.cells.map(e)};return Object.assign(Object.assign({},t),a)}static fromConfig(t,e,r={}){const a=[];for(const s of e.cells)a.push(Ei(s,r));return new t({cells:a})}get trainableWeights(){if(!this.trainable)return[];const t=[];for(const e of this.cells)t.push(...e.trainableWeights);return t}get nonTrainableWeights(){const t=[];for(const e of this.cells)t.push(...e.nonTrainableWeights);if(!this.trainable){const e=[];for(const r of this.cells)e.push(...r.trainableWeights);return e.concat(t)}return t}getWeights(){const t=[];for(const e of this.cells)t.push(...e.weights);return uk(t)}setWeights(t){const e=[];for(const r of this.cells){const a=r.weights.length,s=t.splice(a);for(let o=0;o<r.weights.length;++o)e.push([r.weights[o],s[o]])}YI(e)}}a_.className="StackedRNNCells";$t(a_);function qu(n){const{ones:t,rate:e,training:r=!1,count:a=1,dropoutFunc:s}=n,o=()=>s!=null?s(t(),e):sV(t(),e),i=()=>iv(o,t,r);return!a||a<=1?ar(i().clone()):Array(a).fill(void 0).map(i).map(l=>ar(l.clone()))}var Vpt=function(n,t){var e={};for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&t.indexOf(r)<0&&(e[r]=n[r]);if(n!=null&&typeof Object.getOwnPropertySymbols=="function")for(var a=0,r=Object.getOwnPropertySymbols(n);a<r.length;a++)t.indexOf(r[a])<0&&Object.prototype.propertyIsEnumerable.call(n,r[a])&&(e[r[a]]=n[r[a]]);return e};class mU extends ol{constructor(t){if(t.unroll)throw new ke("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(t.cell))throw new ke("It is not possible at the moment to stack convolutional cells.");super(t),this.inputSpec=[new ir({ndim:5})]}call(t,e){return ut(()=>{if(this.cell.dropoutMask!=null&&(Ie(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Ie(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),e&&e.constants)throw new ot("ConvRNN2D cell does not support constants");const r=e==null?null:e.mask,a=e==null?null:e.training,s=e==null?null:e.initialState;return super.call(t,{mask:r,training:a,initialState:s})})}computeOutputShape(t){let e=this.computeSingleOutputShape(t);return this.returnSequences||(e=[e[0],...e.slice(2)]),this.returnState&&(e=[e,...Array(2).fill([t[0],...e.slice(-3)])]),e}getInitialState(t){return ut(()=>{const{stateSize:e}=this.cell,r=t.shape,a=this.computeSingleOutputShape(r),s=[a[0],...a.slice(2)],o=Xn(s);return Array.isArray(e)?Array(e.length).fill(o):[o]})}resetStates(t,e=!1){ut(()=>{if(!this.stateful)throw new Co("Cannot call resetStates() on an RNN Layer that is not stateful.");const r=this.inputSpec[0].shape,a=this.computeSingleOutputShape(r),s=[a[0],...a.slice(2)];if(r[0]==null)throw new ot("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.getStates()==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>Xn(s)):this.states_=[Xn(s)];else if(t==null)Ie(this.states_),this.keptStates!=null&&(Ie(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>Xn(s)):this.states_[0]=Xn(s);else{if(Array.isArray(t)||(t=[t]),t.length!==this.states_.length)throw new ot(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${t.length} state value(s). Input received: ${t}`);e?this.keptStates.push(this.states_.slice()):Ie(this.states_);for(let i=0;i<this.states_.length;++i){const u=t[i],l=s;if(!De(u.shape,l))throw new ot(`State ${i} is incompatible with layer ${this.name}: expected shape=${l}, received shape=${u.shape}`);this.states_[i]=u}}this.states_=this.states_.map(i=>ar(i.clone()))})}computeSingleOutputShape(t){const{dataFormat:e,filters:r,kernelSize:a,padding:s,strides:o,dilationRate:i}=this.cell,u=e==="channelsFirst",l=t[u?3:2],h=t[u?4:3],d=ro(l,a[0],s,o[0],i[0]),f=ro(h,a[1],s,o[1],i[1]);return[...t.slice(0,2),...u?[r,d,f]:[d,f,r]]}}mU.className="ConvRNN2D";class s_ extends ew{constructor(t){const{filters:e,kernelSize:r,strides:a,padding:s,dataFormat:o,dilationRate:i}=t;super(Object.assign(Object.assign({},t),{units:e})),this.filters=e,vr(this.filters,"filters"),this.kernelSize=jh(r,2,"kernelSize"),this.kernelSize.forEach(u=>vr(u,"kernelSize")),this.strides=jh(a||1,2,"strides"),this.strides.forEach(u=>vr(u,"strides")),this.padding=s||"valid",ws(this.padding),this.dataFormat=o||"channelsLast",Wn(this.dataFormat),this.dilationRate=jh(i||1,2,"dilationRate"),this.dilationRate.forEach(u=>vr(u,"dilationRate"))}build(t){var e;t=je(t);const r=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[r]==null)throw new ot(`The channel dimension of the input should be defined. Found ${t[r]}`);const a=t[r],s=4,o=this.kernelSize.concat([a,this.filters*s]);this.kernel=this.addWeight("kernel",o,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const i=this.kernelSize.concat([this.filters,this.filters*s]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",i,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let u;if(this.unitForgetBias){const l=this.biasInitializer,h=this.filters;u=new(e=class extends Ws{apply(f,m){const v=l.apply([h]),y=xa([h]),b=l.apply([h*2]);return UI([v,y,b])}},e.className="CustomInit",e)}else u=this.biasInitializer;this.bias=this.addWeight("bias",[this.filters*s],null,u,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(t,e){return ut(()=>{if(t.length!==3)throw new ot(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${t.length}.`);const r=e.training||!1,a=t[0],s=t[1],o=t[2],i=4;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=qu({ones:()=>Ha(a),rate:this.dropout,training:r,count:i,dropoutFunc:this.dropoutFunc}));const u=this.dropoutMask,l=(U,M,X)=>!M||!M[X]?U:et(M[X],U);let h=l(a,u,0),d=l(a,u,1),f=l(a,u,2),m=l(a,u,3);0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=qu({ones:()=>Ha(s),rate:this.recurrentDropout,training:r,count:i,dropoutFunc:this.dropoutFunc}));const v=this.recurrentDropoutMask;let y=l(s,v,0),b=l(s,v,1),w=l(s,v,2),S=l(s,v,3);const N=3,[C,T,I,_]=wa(this.kernel.read(),i,N),[$,R,D,A]=this.useBias?wa(this.bias.read(),i):[null,null,null,null];h=this.inputConv(h,C,$,this.padding),d=this.inputConv(d,T,R,this.padding),f=this.inputConv(f,I,D,this.padding),m=this.inputConv(m,_,A,this.padding);const[L,H,G,q]=wa(this.recurrentKernel.read(),i,N);y=this.recurrentConv(y,L),b=this.recurrentConv(b,H),w=this.recurrentConv(w,G),S=this.recurrentConv(S,q);const B=this.recurrentActivation.apply(It(h,y)),j=this.recurrentActivation.apply(It(d,b)),K=It(et(j,o),et(B,this.activation.apply(It(f,w)))),z=et(this.recurrentActivation.apply(It(m,S)),this.activation.apply(K));return[z,z,K]})}getConfig(){const t=super.getConfig(),{units:e}=t,r=Vpt(t,["units"]),a={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},r),a)}inputConv(t,e,r,a){const s=Ri(t,e,this.strides,a||"valid",this.dataFormat==="channelsFirst"?"NCHW":"NHWC",this.dilationRate);return r?po(s,r,this.dataFormat):s}recurrentConv(t,e){return Ri(t,e,1,"same",this.dataFormat==="channelsFirst"?"NCHW":"NHWC")}}s_.className="ConvLSTM2DCell";$t(s_);class gU extends mU{constructor(t){const e=new s_(t);super(Object.assign(Object.assign({},t),{cell:e}))}static fromConfig(t,e){return new t(e)}}gU.className="ConvLSTM2D";$t(gU);class o_ extends Re{constructor(t){super(t),this.rate=Math.max(Math.min(t.rate,1),0),this.noiseShape=t.noiseShape,this.seed=t.seed,this.supportsMasking=!0}getNoiseShape(t){if(this.noiseShape==null)return this.noiseShape;const e=t.shape,r=[];for(let a=0;a<this.noiseShape.length;++a)r.push(this.noiseShape[a]==null?e[a]:this.noiseShape[a]);return r}call(t,e){return ut(()=>{this.invokeCallHook(t,e);const r=he(t);if(0<this.rate&&this.rate<1){const a=e.training==null?!1:e.training,s=this.getNoiseShape(r);return iv(()=>sV(r,this.rate,s,this.seed),()=>r,a)}return t})}getConfig(){const t={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},e=super.getConfig();return Object.assign(t,e),t}dispose(){return super.dispose()}}o_.className="Dropout";$t(o_);class vU extends o_{constructor(t){super(t),this.inputSpec=[{ndim:3}]}getNoiseShape(t){const e=t.shape;return[e[0],1,e[2]]}}vU.className="SpatialDropout1D";$t(vU);class yU extends Re{constructor(t){if(super(t),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",t.batchInputShape==null&&t.inputShape==null&&t.inputDim!=null){let e=null;t.batchSize!=null&&(e=t.batchSize),this.batchInputShape=[e,t.inputDim]}this.units=t.units,vr(this.units,"units"),this.activation=ju(t.activation),t.useBias!=null&&(this.useBias=t.useBias),this.kernelInitializer=Cn(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=Cn(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=lr(t.kernelConstraint),this.biasConstraint=lr(t.biasConstraint),this.kernelRegularizer=Nn(t.kernelRegularizer),this.biasRegularizer=Nn(t.biasRegularizer),this.activityRegularizer=Nn(t.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(t){t=je(t);const e=t[t.length-1];this.kernel==null&&(this.kernel=this.addWeight("kernel",[e,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:e}}],this.built=!0}computeOutputShape(t){t=je(t);const e=t.slice();return e[e.length-1]=this.units,e}call(t,e){return ut(()=>{this.invokeCallHook(t,e);const r=he(t),a=ZP(this.activation.getClassName());let s;return a!=null?s=Po(r,this.kernel.read(),a,this.bias?this.bias.read():null):(s=Po(r,this.kernel.read()),this.bias!=null&&(s=po(s,this.bias.read())),this.activation!=null&&(s=this.activation.apply(s))),s})}getConfig(){const t={units:this.units,activation:Hu(this.activation),useBias:this.useBias,kernelInitializer:In(this.kernelInitializer),biasInitializer:In(this.biasInitializer),kernelRegularizer:cn(this.kernelRegularizer),biasRegularizer:cn(this.biasRegularizer),activityRegularizer:cn(this.activityRegularizer),kernelConstraint:ur(this.kernelConstraint),biasConstraint:ur(this.biasConstraint)},e=super.getConfig();return Object.assign(t,e),t}}yU.className="Dense";$t(yU);class bU extends Re{constructor(t){t=t||{},super(t),this.inputSpec=[{minNDim:3}],this.dataFormat=t.dataFormat}computeOutputShape(t){t=je(t);for(const e of t.slice(1))if(e==null)throw new ot(`The shape of the input to "Flatten" is not fully defined (got ${t.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[t[0],$u(t,1)]}call(t,e){return ut(()=>{this.invokeCallHook(t,e);let r=he(t);if(this.dataFormat==="channelsFirst"&&r.rank>1){const a=[0];for(let s=2;s<r.rank;++s)a.push(s);a.push(1),r=Oe(r,a)}return wdt(r)})}getConfig(){const t={};this.dataFormat!=null&&(t.dataFormat=this.dataFormat);const e=super.getConfig();return Object.assign(t,e),t}}bU.className="Flatten";$t(bU);class xU extends Re{constructor(t){super(t),this.supportsMasking=!0,this.activation=ju(t.activation)}call(t,e){return ut(()=>{this.invokeCallHook(t,e);const r=he(t);return this.activation.apply(r)})}getConfig(){const t={activation:Hu(this.activation)},e=super.getConfig();return Object.assign(t,e),t}}xU.className="Activation";$t(xU);class wU extends Re{constructor(t){super(t),this.n=t.n,this.inputSpec=[{ndim:2}]}computeOutputShape(t){return[t[0],this.n,t[1]]}call(t,e){return ut(()=>(t=he(t),bdt(t,this.n)))}getConfig(){const t={n:this.n},e=super.getConfig();return Object.assign(t,e),t}}wU.className="RepeatVector";$t(wU);class SU extends Re{constructor(t){super(t),this.targetShape=t.targetShape;for(let e=0;e<this.targetShape.length;++e)this.isUnknown(this.targetShape[e])&&(this.targetShape[e]=null)}isUnknown(t){return t<0||t==null}fixUnknownDimension(t,e){const r="Total size of new array must be unchanged.",a=e.slice();let s=1,o=null;for(let u=0;u<a.length;++u){const l=a[u];if(this.isUnknown(l))if(o===null)o=u;else throw new ot("Can only specifiy one unknown dimension.");else s*=l}const i=$u(t);if(o!==null){if(s===0||i%s!==0)throw new ot(r);a[o]=i/s}else if(i!==s)throw new ot(r);return a}computeOutputShape(t){let e=!1;for(let r=0;r<t.length;++r)if(this.isUnknown(t[r])){e=!0;break}return e?t.slice(0,1).concat(this.targetShape):t.slice(0,1).concat(this.fixUnknownDimension(t.slice(1),this.targetShape))}call(t,e){return ut(()=>{this.invokeCallHook(t,e);const r=he(t),a=r.shape,s=a.slice(0,1).concat(this.fixUnknownDimension(a.slice(1),this.targetShape));return at(r,s)})}getConfig(){const t={targetShape:this.targetShape},e=super.getConfig();return Object.assign(t,e),t}}SU.className="Reshape";$t(SU);class CU extends Re{constructor(t){if(super(t),t.dims==null)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(t.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${t.dims} instead.`);const e=so(1,t.dims.length+1);if(!De(t.dims.slice().sort(),e))throw new Error("Invalid permutation `dims`: "+JSON.stringify(t.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=t.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new ir({ndim:this.dims.length+1})]}computeOutputShape(t){t=je(t);const e=t.slice();return this.dims.forEach((r,a)=>{e[a+1]=t[r]}),e}call(t,e){return Oe(he(t),this.dimsIncludingBatch)}getConfig(){const t={dims:this.dims},e=super.getConfig();return Object.assign(t,e),t}}CU.className="Permute";$t(CU);class NU extends Re{constructor(t){super(t??{}),this.supportsMasking=!0,t!=null?this.maskValue=t.maskValue==null?0:t.maskValue:this.maskValue=0}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={maskValue:this.maskValue};return Object.assign(e,t),e}computeMask(t,e){const r=he(t);return Jf(ac(r,this.maskValue),-1)}call(t,e){return ut(()=>{this.invokeCallHook(t,e);const r=he(t),o=Jf(ac(r,this.maskValue),-1,!0);return et(r,Ft(o,r.dtype))})}}NU.className="Masking";$t(NU);class kU extends Re{constructor(t){if(super(t),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",t.batchInputShape==null&&t.inputShape==null){let e=null;t.batchSize!=null&&(e=t.batchSize),t.inputLength==null?this.batchInputShape=[e,null]:this.batchInputShape=[e].concat(Ze(t.inputLength))}this.inputDim=t.inputDim,vr(this.inputDim,"inputDim"),this.outputDim=t.outputDim,vr(this.outputDim,"outputDim"),this.embeddingsInitializer=Cn(t.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=Nn(t.embeddingsRegularizer),this.activityRegularizer=Nn(t.activityRegularizer),this.embeddingsConstraint=lr(t.embeddingsConstraint),this.maskZero=t.maskZero,this.supportsMasking=t.maskZero,this.inputLength=t.inputLength}build(t){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(t){}computeMask(t,e){return ut(()=>this.maskZero?(t=he(t),ac(t,Be(t))):null)}computeOutputShape(t){if(t=je(t),this.inputLength==null)return[...t,this.outputDim];const e=Ze(this.inputLength);if(e.length!==t.length-1)throw new ot(`"inputLength" is ${this.inputLength}, but received input shape has shape ${t}`);{let r=0;for(let a=0;a<e.length;++a){const s=e[a],o=t[a+1];if(s!=null&&o!=null&&s!==o)throw new ot(`"inputLength" is ${this.inputLength}, but received input shape has shape ${t}`);s==null&&(e[r]=o),r++}}return[t[0],...e,this.outputDim]}call(t,e){return ut(()=>{this.invokeCallHook(t,e);let r=he(t);r.dtype!=="int32"&&(r=zo(r,"int32"));const a=aV(this.embeddings.read(),at(r,[r.size]));return at(a,je(this.computeOutputShape(r.shape)))})}getConfig(){const t={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:In(this.embeddingsInitializer),embeddingsRegularizer:cn(this.embeddingsRegularizer),activityRegularizer:cn(this.activityRegularizer),embeddingsConstraint:ur(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},e=super.getConfig();return Object.assign(t,e),t}}kU.className="Embedding";$t(kU);class _c extends Re{constructor(t){super(t||{}),this.supportsMasking=!0}mergeFunction(t){throw new ke}computeElementwiseOpOutputShape(t,e){if(t==null||e==null)return null;if(t.length<e.length)return this.computeElementwiseOpOutputShape(e,t);if(e.length===0)return t;const r=t.slice(0,t.length-e.length);for(let a=0;a<e.length;++a){const s=t[t.length-e.length+a],o=e[a];if(s==null||o==null||s<0||o<0)r.push(null);else if(s===1)r.push(o);else if(o===1)r.push(s);else{if(s!==o)throw new ot("Operands could not be broadcast together with shapes "+JSON.stringify(t)+" "+JSON.stringify(e));r.push(s)}}return r}build(t){if(Array.isArray(t)&&!Array.isArray(t[0])&&(t=[je(t)]),t=t,t.length<2)throw new ot(`A merge layer should be called on an Array of at least 2 inputs. Got ${t.length} input(s).`);let e=[];for(const s of t)s!=null&&s[0]!==null&&e.push(s[0]);if(e=Du(e),e.length>1)throw new ot(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(t)}.`);let r=t[0]==null?null:t[0].slice(1);for(let s=1;s<t.length;++s){const o=t[s]==null?null:t[s].slice(1);r=this.computeElementwiseOpOutputShape(r,o)}const a=t.map(s=>s.length);t.indexOf(null)===-1&&Du(a).length===1?this.reshapeRequired=!1:this.reshapeRequired=!0}call(t,e){return ut(()=>{if(t=t,this.reshapeRequired){const r=[],a=t.map(s=>s.rank);if(a.indexOf(null)===-1){const s=Gu(a);for(let o of t){const i=o.rank;for(let u=0;u<s-i;++u)o=sv(o,1);r.push(o)}return this.mergeFunction(r)}else{let s=!1;for(const u of t){const l=u.rank;if(l==null){const h=u.shape,d=h[0],f=h.slice(1).concat([d]);let m=at(u,[d].concat($u(h.slice(1))));m=Oe(m,[1,0]),m=at(m,f),r.push(m),s=!0}else if(l>1){const h=so(1,l).concat([0]);r.push(Oe(u,h)),s=!0}else r.push(u)}let o=this.mergeFunction(r);const i=o.rank;if(s){if(i==null){const u=o.shape,l=u.length,h=u[l-1],d=[h].concat(u.slice(0,u.length-1));o=at(Oe(at(o,[-1,h]),[1,0]),d)}else if(i>1){const u=[i-1].concat(so(0,i-1));o=Oe(o,u)}}return o}}else return this.mergeFunction(t)})}computeOutputShape(t){t=t;let e;t[0]==null?e=null:e=t[0].slice(1);for(let a=1;a<t.length;++a){const s=t[a]==null?null:t[a].slice(1);e=this.computeElementwiseOpOutputShape(e,s)}let r=[];for(const a of t)a!=null&&a[0]!==null&&r.push(a[0]);return r=Du(r),r.length===1?e=r.concat(e):e=[null].concat(e),e}computeMask(t,e){return ut(()=>{if(e==null)return null;if(!Array.isArray(e))throw new ot("`mask` should be an Array");if(!Array.isArray(t))throw new ot("`inputs` should be an Array");if(e.length!==t.length)throw new ot(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${t.length} vs ${e.length})`);if(e.every(a=>a==null))return null;e=e.map(a=>a==null?a:Pn(a,0));let r=e[0];for(let a=1;a<e.length-1;++a)r=ao(r,e[a]);return r})}}class TU extends _c{constructor(t){super(t)}mergeFunction(t){return ut(()=>{let e=t[0].clone();for(let r=1;r<t.length;++r)e=It(e,t[r]);return e})}}TU.className="Add";$t(TU);class EU extends _c{constructor(t){super(t)}mergeFunction(t){return ut(()=>{let e=t[0].clone();for(let r=1;r<t.length;++r)e=et(e,t[r]);return e})}}EU.className="Multiply";$t(EU);class IU extends _c{constructor(t){super(t)}mergeFunction(t){return ut(()=>{let e=t[0].clone();for(let r=1;r<t.length;++r)e=It(e,t[r]);return et(1/t.length,e)})}}IU.className="Average";$t(IU);class _U extends _c{constructor(t){super(t)}mergeFunction(t){return ut(()=>{let e=t[0];for(let r=1;r<t.length;++r)e=Ko(e,t[r]);return e})}}_U.className="Maximum";$t(_U);class RU extends _c{constructor(t){super(t)}mergeFunction(t){return ut(()=>{let e=t[0];for(let r=1;r<t.length;++r)e=Vu(e,t[r]);return e})}}RU.className="Minimum";$t(RU);class AU extends _c{constructor(t){super(t),this.DEFAULT_AXIS=-1,t==null&&(t={}),this.axis=t.axis==null?this.DEFAULT_AXIS:t.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(t){if(!(Array.isArray(t)&&Array.isArray(t[0]))||t.length===1)throw new ot("A `Concatenate` layer should be called on a list of at least 2 inputs");t=t;let e=!0;for(const a of t)if(a!=null){e=!1;break}if(e)return;const r=[];for(let a=0;a<t.length;++a){const s=t[a].slice();s.splice(this.axis,1);let o=!1;for(const i of r)if(De(i,s)){o=!0;break}o||r.push(s)}if(r.length>1)throw new ot("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(t))}mergeFunction(t){return ut(()=>UI(t,this.axis))}computeOutputShape(t){if(!(Array.isArray(t)&&Array.isArray(t[0])))throw new ot("A `Concatenate` layer should be called on a list of inputs.");const e=t,r=e[0].slice(),a=this.axis<0?r.length+this.axis:this.axis;for(const s of e.slice(1)){if(r[a]==null||s[a]==null){r[a]=null;break}r[a]+=s[a]}return r}computeMask(t,e){if(e==null)return null;if(!Array.isArray(e))throw new ot("`mask` should be an array for Concatenate");if(!Array.isArray(t))throw new ot("`inputs` should be an array for Concatenate");if(e.length!==t.length)throw new ot(`Mismatch in the length of mask (${e.length}) and the legnth of inputs (${t.length})`);return ut(()=>{let r=!0;if(e.forEach(o=>{if(o!=null){r=!1;return}}),r)return null;const a=[];for(let o=0;o<t.length;++o)e[o]==null?a.push(Ft(Ha(t[o]),"bool")):e[o].rank<t[o].rank?a.push(Pn(e[o],-1)):a.push(e[o]);const s=_n(a,this.axis);return Gx(s,-1,!1)})}getConfig(){const t={axis:this.axis},e=super.getConfig();return Object.assign(t,e),t}}AU.className="Concatenate";$t(AU);function Rf(n,t){for(;n<0;)n+=t;return n}function Upt(n,t,e){if(n.shape.length>3||t.shape.length>3)throw new ke("batchDot is not implemented for tensors of 4D or higher rank yet");if(P(n.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${n.shape.length}`),P(n.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${t.shape.length}`),typeof e=="number"&&(e=[e,e]),n.dtype==="complex64"||t.dtype==="complex64")throw new ke("batchDot is not implemented for complex64-type Tensors yet.");const r=n.shape.length,a=t.shape.length;e==null&&(e=[r-1,a-2]);const s=e;return ut(()=>{let o;if(r>a){o=r-a;const u=[];for(let l=0;l<o;++l)u.push(1);t=at(t,t.shape.concat(u))}else if(a>r){o=a-r;const u=[];for(let l=0;l<o;++l)u.push(1);n=at(n,n.shape.concat(u))}else o=0;let i;if(n.shape.length===2&&t.shape.length===2)s[0]===s[1]?i=jt(et(n,t),s[0]):i=jt(et(Oe(n,[1,0]),t),s[1]);else{const u=s[0]!==n.shape.length-1,l=s[1]===t.shape.length-1;i=xe(n,t,u,l)}if(o>0){let u;r>a?u=r+a-3:u=r-1;const l=[];for(let h=u;h<u+o;++h)l.push(h);i=$r(i,l)}return i.shape.length===1&&(i=Pn(i,1)),i})}class DU extends _c{constructor(t){super(t),this.axes=t.axes,this.normalize=t.normalize==null?!1:t.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(t){P(Array.isArray(t)&&t.length===2&&Array.isArray(t[0])&&Array.isArray(t[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const e=t[0],r=t[1];if(e.length>3||r.length>3)throw new ke("Dot layer does not support tensors of 4D or higher rank yet.");const a=this.interpretAxes(e,r);if(e[a[0]]!==r[a[1]])throw new ot(`Dimension incompatibility: ${e[a[0]]} !== ${r[a[1]]}`)}mergeFunction(t){if(t.length!==2)throw new ot(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${t.length} input(s).`);let e=t[0],r=t[1],a;return Array.isArray(this.axes)?a=this.axes.map((s,o)=>Rf(s,t[o].shape.length)):a=[Rf(this.axes,e.shape.length),Rf(this.axes,r.shape.length)],this.normalize&&(e=yb(e,a[0]),r=yb(r,a[1])),Upt(e,r,a)}interpretAxes(t,e){let r;return Array.isArray(this.axes)?r=this.axes:r=[Rf(this.axes,t.length),Rf(this.axes,e.length)],r}computeOutputShape(t){P(Array.isArray(t)&&t.length===2&&Array.isArray(t[0])&&Array.isArray(t[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const e=t[0].slice(),r=t[1].slice();if(e.length>3||r.length>3)throw new ke("Dot layer does not support tensors of 4D or higher rank yet.");const a=this.interpretAxes(e,r);e.splice(a[0],1),r.splice(a[1],1),r.splice(0,1);const s=e.concat(r);return s.length===1&&s.push(1),s}computeMask(t,e){return null}getConfig(){const t={axes:this.axes,normalize:this.normalize},e=super.getConfig();return Object.assign(t,e),t}}DU.className="Dot";$t(DU);class $U extends Re{constructor(t){super(t),this.supportsMasking=!0,this.stddev=t.stddev}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={stddev:this.stddev};return Object.assign(e,t),e}call(t,e){return ut(()=>{this.invokeCallHook(t,e);const r=he(t);return iv(()=>It(K1(r.shape,0,this.stddev),r),()=>r,e.training||!1)})}}$U.className="GaussianNoise";$t($U);class OU extends Re{constructor(t){super(t),this.supportsMasking=!0,this.rate=t.rate}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={rate:this.rate};return Object.assign(e,t),e}call(t,e){return ut(()=>{this.invokeCallHook(t,e);const r=he(t);return this.rate>0&&this.rate<1?iv(()=>{const s=Math.sqrt(this.rate/(1-this.rate));return et(r,K1(r.shape,1,s))},()=>r,e.training||!1):r})}}OU.className="GaussianDropout";$t(OU);class FU extends Re{constructor(t){super(t),this.supportsMasking=!0,this.rate=t.rate,this.noiseShape=t.noiseShape}_getNoiseShape(t){return this.noiseShape||he(t).shape}computeOutputShape(t){return t}getConfig(){const t=super.getConfig(),e={rate:this.rate};return Object.assign(e,t),e}call(t,e){return ut(()=>{if(this.rate<1&&this.rate>0){const r=this._getNoiseShape(t);return iv(()=>{const s=he(t),i=-1.6732632423543772*1.0507009873554805;let u=Bi(el(r),this.rate);u=zo(u,"float32");const l=((1-this.rate)*(1+this.rate*i**2))**-.5,h=-l*i*this.rate,d=It(et(s,u),et(It(u,-1),i));return It(et(d,l),h)},()=>he(t),e.training||!1)}return t})}}FU.className="AlphaDropout";$t(FU);function fm(n,t,e,r,a,s=.001){let o;if(n.rank===2)o=tT(n,t,e,r,a,s);else if(n.rank===3)o=eT(n,t,e,r,a,s);else if(n.rank===4)o=nT(n,t,e,r,a,s);else throw new ke(`batchNormalization is not implemented for array of rank ${n.rank} yet`);return o}function Wpt(n,t,e,r,a=.001){return ut(()=>{const s=Mg(n,r),o=s.mean,i=s.variance;return[fm(n,o,i,e,t,a),o,i]})}function Gpt(n,t,e,r,a=.001){return ut(()=>{const s=Mg(n,r),o=s.mean,i=s.variance,u=[];for(const v of so(0,n.rank))r.indexOf(v)!==-1?u.push(1):u.push(n.shape[v]);const l=at(o,u),h=at(i,u),d=t==null?null:at(t,u),f=e==null?null:at(e,u);return[fm(n,l,h,f,d,a),o,i]})}function Hpt(n,t,e,r,a=.001){return De(r.slice().sort(),so(0,n.rank-1))?Wpt(n,t,e,r,a):Gpt(n,t,e,r,a)}class MU extends Re{constructor(t){t==null&&(t={}),super(t),this.supportsMasking=!0,this.axis=t.axis==null?-1:t.axis,this.momentum=t.momentum==null?.99:t.momentum,this.epsilon=t.epsilon==null?.001:t.epsilon,this.center=t.center==null?!0:t.center,this.scale=t.scale==null?!0:t.scale,this.betaInitializer=Cn(t.betaInitializer||"zeros"),this.gammaInitializer=Cn(t.gammaInitializer||"ones"),this.movingMeanInitializer=Cn(t.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=Cn(t.movingVarianceInitializer||"ones"),this.betaConstraint=lr(t.betaConstraint),this.gammaConstraint=lr(t.gammaConstraint),this.betaRegularizer=Nn(t.betaRegularizer),this.gammaRegularizer=Nn(t.gammaRegularizer)}build(t){t=je(t);const e=this.axis>=0?this.axis:this.axis+t.length,r=t[e];if(r==null)throw new ot(`Axis ${e} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(t)}.`);this.inputSpec=[new ir({ndim:t.length,axes:{[e]:r}})];const a=[r];this.scale&&(this.gamma=this.addWeight("gamma",a,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",a,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",a,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",a,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(t,e){return ut(()=>{const r=e.training==null?!1:e.training,a=he(t),s=a.shape,o=s.length,i=so(0,o),u=this.axis>=0?this.axis:this.axis+o;i.splice(u,1);const l=cc(1,o);l[u]=s[u];const h=i.slice();h.sort();const d=!De(h,so(0,o).slice(0,o-1)),f=()=>{if(d){const S=at(this.movingMean.read(),l),N=at(this.movingVariance.read(),l),C=this.center?at(this.beta.read(),l):null,T=this.scale?at(this.gamma.read(),l):null;return fm(a,S,N,C,T,this.epsilon)}else return fm(a,this.movingMean.read(),this.movingVariance.read(),this.beta==null?null:this.beta.read(),this.gamma==null?null:this.gamma.read(),this.epsilon)};if(!r)return f();const[m,v,y]=Hpt(a,this.gamma.read(),this.beta.read(),i,this.epsilon),b=(S,N,C)=>{ut(()=>{const T=1-C,I=S.read(),_=et(zt(I,N),T);S.write(zt(I,_))})};return b(this.movingMean,v,this.momentum),b(this.movingVariance,y,this.momentum),m})}getConfig(){const t={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:In(this.betaInitializer),gammaInitializer:In(this.gammaInitializer),movingMeanInitializer:In(this.movingMeanInitializer),movingVarianceInitializer:In(this.movingVarianceInitializer),betaRegularizer:cn(this.betaRegularizer),gammaRegularizer:cn(this.gammaRegularizer),betaConstraint:ur(this.betaConstraint),gammaConstraint:ur(this.gammaConstraint)},e=super.getConfig();return Object.assign(t,e),t}}MU.className="BatchNormalization";$t(MU);class LU extends Re{constructor(t){if(t==null&&(t={}),super(t),this.axis=t.axis==null?-1:t.axis,typeof this.axis=="number"){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else if(Array.isArray(this.axis)){for(const e of this.axis)if(!Number.isInteger(e))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}else throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);this.epsilon=t.epsilon==null?.001:t.epsilon,this.center=t.center==null?!0:t.center,this.scale=t.scale==null?!0:t.scale,this.betaInitializer=Cn(t.betaInitializer||"zeros"),this.gammaInitializer=Cn(t.gammaInitializer||"ones"),this.betaRegularizer=Nn(t.betaRegularizer),this.gammaRegularizer=Nn(t.gammaRegularizer),this.supportsMasking=!0}build(t){t=je(t);const e=t.length;typeof this.axis=="number"&&(this.axis=[this.axis]);for(let s=0;s<this.axis.length;++s)this.axis[s]<0&&(this.axis[s]+=e);for(const s of this.axis)if(s<0||s>=e)throw new Error(`Invalid axis: ${s}`);if(this.axis.length!==Du(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const r=this.axis.map(s=>t[s]),a=!0;this.scale?this.gamma=this.addWeight("gamma",r,"float32",this.gammaInitializer,this.gammaRegularizer,a):this.gamma=null,this.center?this.beta=this.addWeight("beta",r,"float32",this.betaInitializer,this.betaRegularizer,a):this.beta=null,this.built=!0}call(t,e){const r=he(t),a=r.shape,s=a.length;return ut(()=>{let{mean:i,variance:u}=Mg(r,this.axis,!0);const l=cc(1,s);for(const y of this.axis)l[y]=a[y];const h=y=>y!=null&&y.shape.length!==s?at(y,l):y;let d=this.scale?h(this.gamma.read()):null,f=this.center?h(this.beta.read()):null;const m=[],v=[];for(let y=0;y<s;++y)this.axis.indexOf(y)!==-1?(m.push(a[y]),v.push(1)):(m.push(1),v.push(a[y]));return i=ls(i,m),u=ls(u,m),d!=null&&(d=ls(d,v)),f!=null&&(f=ls(f,v)),fm(r,i,u,f,d,this.epsilon)})}getConfig(){const t={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:In(this.betaInitializer),gammaInitializer:In(this.gammaInitializer),betaRegularizer:cn(this.betaRegularizer),gammaRegularizer:cn(this.gammaRegularizer)},e=super.getConfig();return Object.assign(t,e),t}}LU.className="LayerNormalization";$t(LU);function jpt(n,t,e){return ut(()=>{if(n.rank!==4)throw new ot(`temporalPadding expects input tensor to be 4-D, but received a ${n.rank}-D tensor.`);if(t==null&&(t=[[1,1],[1,1]]),t.length!==2||t[0].length!==2||t[1].length!==2)throw new ot("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(e==null&&(e=oo()),e!=="channelsLast"&&e!=="channelsFirst")throw new ot(`Unknown data format: ${e}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let r;return e==="channelsFirst"?r=[[0,0],[0,0],t[0],t[1]]:r=[[0,0],t[0],t[1],[0,0]],zi(n,r)})}class BU extends Re{constructor(t){if(t==null&&(t={}),super(t),this.dataFormat=t.dataFormat==null?oo():t.dataFormat,t.padding==null)this.padding=[[1,1],[1,1]];else if(typeof t.padding=="number")this.padding=[[t.padding,t.padding],[t.padding,t.padding]];else{if(t.padding=t.padding,t.padding.length!==2)throw new ot(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${t.padding.length} array.`);let e,r;if(typeof t.padding[0]=="number")e=[t.padding[0],t.padding[0]],r=[t.padding[1],t.padding[1]];else{if(t.padding=t.padding,t.padding[0].length!==2)throw new ot(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${t.padding[0].length} array.`);if(e=t.padding[0],t.padding[1].length!==2)throw new ot(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${t.padding[1].length} array.`);r=t.padding[1]}this.padding=[e,r]}this.inputSpec=[new ir({ndim:4})]}computeOutputShape(t){t=je(t);let e,r;return this.dataFormat==="channelsFirst"?(t[2]!=null&&t[2]>=0?e=t[2]+this.padding[0][0]+this.padding[0][1]:e=null,t[3]!=null&&t[3]>=0?r=t[3]+this.padding[1][0]+this.padding[1][1]:r=null,[t[0],t[1],e,r]):(t[1]!=null&&t[1]>=0?e=t[1]+this.padding[0][0]+this.padding[0][1]:e=null,t[2]!=null&&t[2]>=0?r=t[2]+this.padding[1][0]+this.padding[1][1]:r=null,[t[0],e,r,t[3]])}call(t,e){return ut(()=>jpt(he(t),this.padding,this.dataFormat))}getConfig(){const t={padding:this.padding,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}BU.className="ZeroPadding2D";$t(BU);function nw(n,t,e,r,a,s){return ut(()=>{Wn(a),tV(s),ws(r),e==null&&(e=[1,1]),r==null&&(r="valid"),a==null&&(a=oo()),s==null&&(s="max"),n=e_(n,a);let o;const i=r==="same"?"same":"valid";return s==="max"?o=Fg(n,t,e,i):o=Tg(n,t,e,i),a==="channelsFirst"&&(o=Oe(o,[0,3,1,2])),o})}function zU(n,t,e,r,a,s){return ut(()=>{Wn(a),tV(s),ws(r),e==null&&(e=[1,1,1]),r==null&&(r="valid"),a==null&&(a=oo()),s==null&&(s="max"),n=nU(n,a);let o;const i=r==="same"?"same":"valid";return s==="max"?o=NT(n,t,e,i):o=Jk(n,t,e,i),a==="channelsFirst"&&(o=Oe(o,[0,4,1,2,3])),o})}class PU extends Re{constructor(t){if(t.poolSize==null&&(t.poolSize=2),super(t),typeof t.poolSize=="number")this.poolSize=[t.poolSize];else if(Array.isArray(t.poolSize)&&t.poolSize.length===1&&typeof t.poolSize[0]=="number")this.poolSize=t.poolSize;else throw new ot(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.poolSize)}`);if(vr(this.poolSize,"poolSize"),t.strides==null)this.strides=this.poolSize;else if(typeof t.strides=="number")this.strides=[t.strides];else if(Array.isArray(t.strides)&&t.strides.length===1&&typeof t.strides[0]=="number")this.strides=t.strides;else throw new ot(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.strides)}`);vr(this.strides,"strides"),this.padding=t.padding==null?"valid":t.padding,ws(this.padding),this.inputSpec=[new ir({ndim:3})]}computeOutputShape(t){t=je(t);const e=ro(t[1],this.poolSize[0],this.padding,this.strides[0]);return[t[0],e,t[2]]}call(t,e){return ut(()=>{this.invokeCallHook(t,e),t=sv(he(t),2);const r=this.poolingFunction(he(t),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return $r(r,[2])})}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides},e=super.getConfig();return Object.assign(t,e),t}}class VU extends PU{constructor(t){super(t)}poolingFunction(t,e,r,a,s){return Wn(s),ws(a),nw(t,e,r,a,s,"max")}}VU.className="MaxPooling1D";$t(VU);class UU extends PU{constructor(t){super(t)}poolingFunction(t,e,r,a,s){return Wn(s),ws(a),nw(t,e,r,a,s,"avg")}}UU.className="AveragePooling1D";$t(UU);class WU extends Re{constructor(t){if(t.poolSize==null&&(t.poolSize=[2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize],t.strides==null)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(t.strides.length!==2)throw new ot(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${t.strides.length}.`);this.strides=t.strides}else this.strides=[t.strides,t.strides];vr(this.poolSize,"poolSize"),vr(this.strides,"strides"),this.padding=t.padding==null?"valid":t.padding,this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,Wn(this.dataFormat),ws(this.padding),this.inputSpec=[new ir({ndim:4})]}computeOutputShape(t){t=je(t);let e=this.dataFormat==="channelsFirst"?t[2]:t[1],r=this.dataFormat==="channelsFirst"?t[3]:t[2];return e=ro(e,this.poolSize[0],this.padding,this.strides[0]),r=ro(r,this.poolSize[1],this.padding,this.strides[1]),this.dataFormat==="channelsFirst"?[t[0],t[1],e,r]:[t[0],e,r,t[3]]}call(t,e){return ut(()=>(this.invokeCallHook(t,e),this.poolingFunction(he(t),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}class GU extends WU{constructor(t){super(t)}poolingFunction(t,e,r,a,s){return Wn(s),ws(a),nw(t,e,r,a,s,"max")}}GU.className="MaxPooling2D";$t(GU);class HU extends WU{constructor(t){super(t)}poolingFunction(t,e,r,a,s){return Wn(s),ws(a),nw(t,e,r,a,s,"avg")}}HU.className="AveragePooling2D";$t(HU);class jU extends Re{constructor(t){if(t.poolSize==null&&(t.poolSize=[2,2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize,t.poolSize],t.strides==null)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(t.strides.length!==3)throw new ot(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${t.strides.length}.`);this.strides=t.strides}else this.strides=[t.strides,t.strides,t.strides];vr(this.poolSize,"poolSize"),vr(this.strides,"strides"),this.padding=t.padding==null?"valid":t.padding,this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,Wn(this.dataFormat),ws(this.padding),this.inputSpec=[new ir({ndim:5})]}computeOutputShape(t){t=je(t);let e=this.dataFormat==="channelsFirst"?t[2]:t[1],r=this.dataFormat==="channelsFirst"?t[3]:t[2],a=this.dataFormat==="channelsFirst"?t[4]:t[3];return e=ro(e,this.poolSize[0],this.padding,this.strides[0]),r=ro(r,this.poolSize[1],this.padding,this.strides[1]),a=ro(a,this.poolSize[2],this.padding,this.strides[2]),this.dataFormat==="channelsFirst"?[t[0],t[1],e,r,a]:[t[0],e,r,a,t[4]]}call(t,e){return ut(()=>(this.invokeCallHook(t,e),this.poolingFunction(he(t),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}class qU extends jU{constructor(t){super(t)}poolingFunction(t,e,r,a,s){return Wn(s),ws(a),zU(t,e,r,a,s,"max")}}qU.className="MaxPooling3D";$t(qU);class KU extends jU{constructor(t){super(t)}poolingFunction(t,e,r,a,s){return Wn(s),ws(a),zU(t,e,r,a,s,"avg")}}KU.className="AveragePooling3D";$t(KU);class XU extends Re{constructor(t){super(t),this.inputSpec=[new ir({ndim:3})]}computeOutputShape(t){return[t[0],t[2]]}call(t,e){throw new ke}}class YU extends XU{constructor(t){super(t||{})}call(t,e){return ut(()=>{const r=he(t);return En(r,1)})}}YU.className="GlobalAveragePooling1D";$t(YU);class QU extends XU{constructor(t){super(t||{})}call(t,e){return ut(()=>{const r=he(t);return vs(r,1)})}}QU.className="GlobalMaxPooling1D";$t(QU);class ZU extends Re{constructor(t){super(t),this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,Wn(this.dataFormat),this.inputSpec=[new ir({ndim:4})]}computeOutputShape(t){return t=t,this.dataFormat==="channelsLast"?[t[0],t[3]]:[t[0],t[1]]}call(t,e){throw new ke}getConfig(){const t={dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}}class JU extends ZU{call(t,e){return ut(()=>{const r=he(t);return this.dataFormat==="channelsLast"?En(r,[1,2]):En(r,[2,3])})}}JU.className="GlobalAveragePooling2D";$t(JU);class tW extends ZU{call(t,e){return ut(()=>{const r=he(t);return this.dataFormat==="channelsLast"?vs(r,[1,2]):vs(r,[2,3])})}}tW.className="GlobalMaxPooling2D";$t(tW);class eW extends Re{constructor(t){super(t),this.layer=t.layer}build(t){this.built=!0}get trainable(){return this.layer!=null?this.layer.trainable:!1}set trainable(t){this.layer!=null&&(this.layer.trainable=t)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(t){this.layer.setWeights(t)}getConfig(){const t={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},e=super.getConfig();return Object.assign(t,e),t}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),this.layer!=null&&this.layer.setFastWeightInitDuringBuild(t)}static fromConfig(t,e,r={}){const a=e.layer,s=Ei(a,r);delete e.layer;const o={layer:s};return Object.assign(o,e),new t(o)}}class nW extends eW{constructor(t){super(t),this.supportsMasking=!0}build(t){if(t=je(t),t.length<3)throw new ot(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(t)}`);this.inputSpec=[{shape:t}];const e=[t[0]].concat(t.slice(2));this.layer.built||(this.layer.build(e),this.layer.built=!0),super.build(t)}computeOutputShape(t){t=je(t);const e=[t[0]].concat(t.slice(2)),r=this.layer.computeOutputShape(e),a=t[1];return[r[0],a].concat(r.slice(1))}call(t,e){return ut(()=>(t=he(t),hU((o,i)=>[he(this.layer.call(o,e)),[]],t,[],!1,null,null,!1,!0)[1]))}}nW.className="TimeDistributed";$t(nW);function qpt(n){Ic(fdt,"BidirectionalMergeMode",n)}const Kpt="concat";class rW extends eW{constructor(t){super(t);const e=t.layer.getConfig(),r={};r.className=t.layer.getClassName(),r.config=e,this.forwardLayer=Ei(r),e.goBackwards=e.goBackwards!==!0;const a={};if(a.className=t.layer.getClassName(),a.config=e,this.backwardLayer=Ei(a),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=t.mergeMode===void 0?Kpt:t.mergeMode,qpt(this.mergeMode),t.weights)throw new ke("weights support is not implemented for Bidirectional layer yet.");this._stateful=t.layer.stateful,this.returnSequences=t.layer.returnSequences,this.returnState=t.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=t.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(t){this._trainable=t,this.forwardLayer!=null&&(this.forwardLayer.trainable=t),this.backwardLayer!=null&&(this.backwardLayer.trainable=t)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(t){const e=t.length,r=Math.floor(e/2);this.forwardLayer.setWeights(t.slice(0,r)),this.backwardLayer.setWeights(t.slice(r))}computeOutputShape(t){let e=this.forwardLayer.computeOutputShape(t);Array.isArray(e)&&Array.isArray(e[0])||(e=[e]),e=e;let r,a,s;return this.returnState&&(s=e.slice(1)),r=e[0],r=r,this.mergeMode==="concat"?(r[r.length-1]*=2,a=[r]):this.mergeMode==null?a=[r,r.slice()]:a=[r],this.returnState?this.mergeMode==null?a.concat(s).concat(s.slice()):[r].concat(s).concat(s.slice()):ba(a)}apply(t,e){let r=e==null?null:e.initialState,a=e==null?null:e.constants;e==null&&(e={});const s=cU(t,r,a,this.numConstants);if(t=s.inputs,r=s.initialState,a=s.constants,Array.isArray(t)&&(r=t.slice(1),t=t[0]),(r==null||r.length===0)&&a==null)return super.apply(t,e);const o=[],i=[];if(r!=null){const l=r.length;if(l%2>0)throw new ot("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");e.initialState=r,o.push(...r);const h=r.map(d=>new ir({shape:d.shape}));this.forwardLayer.stateSpec=h.slice(0,l/2),this.backwardLayer.stateSpec=h.slice(l/2),i.push(...h)}if(a!=null)throw new ke("Support for constants in Bidirectional layers is not implemented yet.");const u=o[0]instanceof jo;for(const l of o)if(l instanceof jo!==u)throw new ot("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(u){const l=[t].concat(o),h=this.inputSpec.concat(i),d=this.inputSpec;this.inputSpec=h;const f=super.apply(l,e);return this.inputSpec=d,f}else return super.apply(t,e)}call(t,e){return ut(()=>{const r=e.initialState;let a,s;if(r==null)a=this.forwardLayer.call(t,e),s=this.backwardLayer.call(t,e);else{const u=r.slice(0,r.length/2),l=r.slice(r.length/2);a=this.forwardLayer.call(t,Object.assign(e,{initialState:u})),s=this.backwardLayer.call(t,Object.assign(e,{initialState:l}))}let o;this.returnState&&(Array.isArray(a)&&(o=a.slice(1).concat(s.slice(1))),a=a[0],s=s[0]),this.returnSequences&&(s=bs(s,1));let i;return this.mergeMode==="concat"?i=UI([a,s]):this.mergeMode==="sum"?i=It(a,s):this.mergeMode==="ave"?i=et(.5,It(a,s)):this.mergeMode==="mul"?i=et(a,s):this.mergeMode==null&&(i=[a,s]),this.returnState?this.mergeMode==null?i.concat(o):[i].concat(o):i})}resetStates(t){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(t){Yl(this.forwardLayer.name,()=>{this.forwardLayer.build(t)}),Yl(this.backwardLayer.name,()=>{this.backwardLayer.build(t)}),this.built=!0}computeMask(t,e){Array.isArray(e)&&(e=e[0]);let r;if(this.returnSequences?this.mergeMode==null?r=[e,e]:r=e:this.mergeMode==null?r=[null,null]:r=null,this.returnState){const s=this.forwardLayer.states.map(o=>null);return Array.isArray(r)?r.concat(s).concat(s):[r].concat(s).concat(s)}else return r}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),this.forwardLayer!=null&&this.forwardLayer.setFastWeightInitDuringBuild(t),this.backwardLayer!=null&&this.backwardLayer.setFastWeightInitDuringBuild(t)}getConfig(){const t={mergeMode:this.mergeMode},e=super.getConfig();return Object.assign(t,e),t}static fromConfig(t,e){const r=Ei(e.layer);if(delete e.layer,e.numConstants!=null)throw new ke("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const a=e;return a.layer=r,new t(a)}}rW.className="Bidirectional";$t(rW);class aW extends Re{constructor(t){super(t),this.scale=t.scale,t.offset?this.offset=t.offset:this.offset=0}getConfig(){const t={scale:this.scale,offset:this.offset},e=super.getConfig();return Object.assign(t,e),t}call(t,e){return ut(()=>(t=he(t),t.dtype!=="float32"&&(t=zo(t,"float32")),It(et(t,this.scale),this.offset)))}}aW.className="Rescaling";$t(aW);const{resizeBilinear:Xpt,cropAndResize:Ypt}=ha;class sW extends Re{constructor(t){super(t),this.height=t.height,this.width=t.width}centerCrop(t,e,r,a,s,o,i,u){return ut(()=>{let l,h=!1;const d=e/o,f=r/i,m=(a+e)/o,v=(s+r)/i,y=[d,f,m,v],b=[];t.rank===3?(h=!0,l=Ta([t])):l=t;for(let T=0;T<l.shape[0];T++)b.push(y);const w=gs(b,[b.length,4]),S=Ai(0,b.length,1,"int32"),C=Ypt(l,w,S,[a,s],"nearest");return zo(h?he(xs(C)):C,u)})}upsize(t,e,r,a){return ut(()=>{const s=Xpt(t,[e,r]);return zo(s,a)})}call(t,e){return ut(()=>{const r=he(t),a=r.dtype,s=r.shape,o=s[s.length-3],i=s[s.length-2];let u=0;o!==this.height&&(u=Math.floor((o-this.height)/2));let l=0;return i!==this.width&&(l=Math.floor((i-this.width)/2),l===0&&(l=1)),u>=0&&l>=0?this.centerCrop(r,u,l,this.height,this.width,o,i,a):this.upsize(t,this.height,this.width,a)})}getConfig(){const t={height:this.height,width:this.width},e=super.getConfig();return Object.assign(t,e),t}computeOutputShape(t){t=je(t);const e=t.length-3,r=t.length-2;return t[e]=this.height,t[r]=this.width,t}}sW.className="CenterCrop";$t(sW);function Qpt(n,t,e,r){let a=he(n);if(a.dtype!=="int32"&&(a=zo(a,"int32")),t==="int")return a;const s=a.shape;if(a.rank===0&&(a=Pn(a,-1)),t==="oneHot"&&a.shape[a.shape.length-1]!==1&&(a=Pn(a,-1)),a.rank>2)throw new ot(`When outputMode is not int, maximum output rank is 2 Received outputMode ${t} and input shape ${s} which would result in output rank ${a.rank}.`);const o=["multiHot","oneHot"].includes(t),i=a;let u;if(typeof r<"u"&&t==="count"?u=P0(i,r,e,o):u=P0(i,[],e,o),t!=="tfIdf")return u;if(r)return et(u,r);throw new ot("When outputMode is 'tfIdf', weights must be provided.")}class oW extends Re{constructor(t){super(t),this.numTokens=t.numTokens,t.outputMode?this.outputMode=t.outputMode:this.outputMode="multiHot"}getConfig(){const t={numTokens:this.numTokens,outputMode:this.outputMode},e=super.getConfig();return Object.assign(t,e),t}computeOutputShape(t){return t=je(t),t==null?[this.numTokens]:this.outputMode==="oneHot"&&t[t.length-1]!==1?(t.push(this.numTokens),t):(t[t.length-1]=this.numTokens,t)}call(t,e){return ut(()=>{t=he(t),t.dtype!=="int32"&&(t=zo(t,"int32"));let r;if(typeof e.countWeights<"u"){if(this.outputMode!=="count")throw new ot(`countWeights is not used when outputMode !== count.
              Received countWeights=${e.countWeights}`);r=he(e.countWeights)}const a=vs(t),s=Yh(t),o=ga(this.numTokens,a).bufferSync().get(0),i=Bi(s,0).bufferSync().get(0);if(!(o&&i))throw new ot(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return Qpt(t,this.outputMode,this.numTokens,r)})}}oW.className="CategoryEncoding";$t(oW);const Zpt=["bilinear","nearest"],UF=new Set(Zpt);class iW extends Re{constructor(t){if(super(t),this.height=t.height,this.width=t.width,t.interpolation)if(UF.has(t.interpolation))this.interpolation=t.interpolation;else throw new ot(`Invalid interpolation parameter: ${t.interpolation} is not implemented`);else this.interpolation="bilinear";this.cropToAspectRatio=!!t.cropToAspectRatio}computeOutputShape(t){t=je(t);const e=t[2];return[this.height,this.width,e]}getConfig(){const t={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},e=super.getConfig();return Object.assign(t,e),t}call(t,e){return ut(()=>{const r=[this.height,this.width];if(this.interpolation==="bilinear")return ha.resizeBilinear(t,r,!this.cropToAspectRatio);if(this.interpolation==="nearest")return ha.resizeNearestNeighbor(t,r,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...UF]} are supported`)})}}iW.className="Resizing";$t(iW);class uW{constructor(t){this.seed=t}next(){if(this.seed!==void 0)return this.seed++}}uW.className="RandomSeed";class lW extends Re{constructor(t){super(t),this.randomGenerator=new uW(t.seed)}getConfig(){const t={seed:this.randomGenerator.seed},e=super.getConfig();return Object.assign(t,e),t}}lW.className="BaseRandomLayer";const Jpt=["bilinear","nearest"],WF=new Set(Jpt);class cW extends lW{constructor(t){super(t);const{factor:e,interpolation:r="bilinear"}=t;if(this.factor=e,Array.isArray(this.factor)&&this.factor.length===2)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else if(!Array.isArray(this.factor)&&this.factor>0)this.widthLower=-this.factor,this.widthUpper=this.factor;else throw new ot(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);if(this.widthLower<-1||this.widthUpper<-1)throw new ot(`factor must have values larger than -1. Got: ${this.factor}`);if(this.widthUpper<this.widthLower)throw new ot(`factor cannot have upper bound less than lower bound.
        Got upper bound: ${this.widthUpper}.
        Got lower bound: ${this.widthLower}
      `);if(r)if(WF.has(r))this.interpolation=r;else throw new ot(`Invalid interpolation parameter: ${r} is not implemented`)}getConfig(){const t={factor:this.factor,interpolation:this.interpolation},e=super.getConfig();return Object.assign(t,e),t}computeOutputShape(t){t=je(t);const e=t[2];return[this.imgHeight,-1,e]}call(t,e){return ut(()=>{const r=he(t);this.imgHeight=r.shape[r.shape.length-3];const a=r.shape[r.shape.length-2];this.widthFactor=el([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let s=this.widthFactor.dataSync()[0]*a;s=Math.round(s);const o=[this.imgHeight,s];switch(this.interpolation){case"bilinear":return ha.resizeBilinear(t,o);case"nearest":return ha.resizeNearestNeighbor(t,o);default:throw new Error(`Interpolation is ${this.interpolation}
          but only ${[...WF]} are supported`)}})}}cW.className="RandomWidth";$t(cW);var GF;(function(n){n[n.FAIL=0]="FAIL",n[n.SHORTEST=1]="SHORTEST",n[n.LONGEST=2]="LONGEST"})(GF||(GF={}));function Kt(n,t){Array.isArray(n)||(n=[n]),n.forEach(e=>{e!=null&&P(e.dtype!=="complex64",()=>`${t} does not support complex64 tensors in the CPU backend.`)})}const tft=g1;class rw extends Db{nextDataId(){return rw.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new Tk(this,as())}write(t,e,r){this.firstUse&&(this.firstUse=!1,dt().get("IS_NODE")&&is(`
============================
Hi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. 
============================`));const a={id:this.nextDataId()};return this.data.set(a,{values:t,dtype:r,refCount:1}),a}makeTensorInfo(t,e,r){let a;if(e==="string"&&r!=null&&r.length>0&&Io(r[0])){const s=r.map(o=>$o(o));a=this.write(s,t,e)}else a=this.write(r,t,e);return{dataId:a,shape:t,dtype:e}}refCount(t){return this.data.has(t)?this.data.get(t).refCount:0}incRef(t){const e=this.data.get(t);e.refCount++}decRef(t){if(this.data.has(t)){const e=this.data.get(t);e.refCount--}}move(t,e,r,a,s){this.data.set(t,{values:e,dtype:a,refCount:s})}numDataIds(){return this.data.numDataIds()}async read(t){return this.readSync(t)}readSync(t){const{dtype:e,complexTensorInfos:r}=this.data.get(t);if(e==="complex64"){const a=this.readSync(r.real.dataId),s=this.readSync(r.imag.dataId);return Di(a,s)}return WM(this.data.get(t).values,e)}bufferSync(t){const e=this.readSync(t.dataId);if(t.dtype==="string")try{const r=e.map(a=>Ii(a));return we(t.shape,t.dtype,r)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return we(t.shape,t.dtype,e)}makeOutput(t,e,r){return as().makeTensorFromTensorInfo(this.makeTensorInfo(e,r,t),this)}disposeData(t,e=!1){if(this.data.has(t)){if(this.data.get(t).refCount--,!e&&this.data.get(t).refCount>0)return!1;const{complexTensorInfos:r}=this.data.get(t);r!=null&&(this.disposeData(r.real.dataId,!0),this.disposeData(r.imag.dataId,!0)),this.data.delete(t)}return!0}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}async time(t){const e=ra();return t(),{kernelMs:ra()-e}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(t){Kt([t],"where");const e=this.readSync(t.dataId);return tft(t.shape,e)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}rw.nextDataId=0;function hW(n){const t=new Float32Array(n.length);for(let e=0;e<n.length;++e)t[e]=Math.abs(n[e]);return t}const eft=n=>{const{x:t}=n.inputs,e=n.backend;Kt(t,"abs");let r=new Float32Array(xt(t.shape));const a=e.data.get(t.dataId).values;return r=hW(a),e.makeOutput(r,t.shape,t.dtype)},nft={kernelName:xm,backendName:"cpu",kernelFunc:eft};function Gn(n){return(t,e,r,a,s)=>{const o=me(t,e),i=o.length,u=oe(o),l=xt(o),h=xr(s,l),d=t.length,f=e.length,m=oe(t),v=oe(e),y=rc(t,o),b=rc(e,o);if(y.length+b.length===0)for(let w=0;w<h.length;++w)h[w]=n(r[w%r.length],a[w%a.length]);else for(let w=0;w<h.length;++w){const S=vc(w,i,u),N=S.slice(-d);y.forEach(_=>N[_]=0);const C=eo(N,d,m),T=S.slice(-f);b.forEach(_=>T[_]=0);const I=eo(T,f,v);h[w]=n(r[C],a[I])}return[h,o]}}function Pa(n){const{inputs:t,backend:e}=n,{real:r,imag:a}=t,s=e.data.get(r.dataId).values,o=e.data.get(a.dataId).values,i=e.makeTensorInfo(r.shape,"complex64"),u=e.data.get(i.dataId);return u.complexTensorInfos={real:e.makeTensorInfo(r.shape,"float32",s),imag:e.makeTensorInfo(a.shape,"float32",o)},i}const rft={kernelName:Vb,backendName:"cpu",kernelFunc:Pa};function Cb(n,t,e="float32"){if(e==="complex64"){const a=Cb(n,t,"float32"),s=Cb(n,t,"float32");return Pa({inputs:{real:a,imag:s},backend:n})}const r=Mr(xt(t),e);return n.makeTensorInfo(t,e,r)}function qo(n){const{inputs:t,backend:e}=n,{x:r}=t;return e.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const aft={kernelName:Ad,backendName:"cpu",kernelFunc:qo};function hc(n){const{inputs:t,backend:e}=n,{input:r}=t,a=e.data.get(r.dataId).complexTensorInfos.real,s=e.data.get(a.dataId).values;return e.makeTensorInfo(a.shape,a.dtype,s)}const sft={kernelName:xx,backendName:"cpu",kernelFunc:hc};function dW(n,t,e,r){if(r==="int32"){const a=Int32Array.from(n);return[t,"int32",a]}if(r==="bool"){const a=Yu([0],e),[s,o]=Gn((i,u)=>i!==u?1:0)(t,[],n,a,"bool");return[o,"bool",s]}throw new Error(`Error in Cast: failed to cast ${e} to ${r}`)}function Ku(n){const{inputs:t,backend:e,attrs:r}=n,{x:a}=t,{dtype:s}=r;if(s==="complex64"){if(a.dtype==="complex64")return qo({inputs:{x:a},backend:e});const h=Cb(e,a.shape,a.dtype),d=Ku({inputs:{x:a},backend:e,attrs:{dtype:"float32"}}),f=Pa({inputs:{real:d,imag:h},backend:e});return e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(d),f}if(a.dtype==="complex64"){const h=hc({inputs:{input:a},backend:e}),d=Ku({inputs:{x:h},backend:e,attrs:{dtype:s}});return e.disposeIntermediateTensorInfo(h),d}if(!_k(a.dtype,s)){const h=qo({inputs:{x:a},backend:e});return{dataId:h.dataId,shape:h.shape,dtype:s}}const o=e.data.get(a.dataId).values,[i,u,l]=dW(o,a.shape,a.dtype,s);return e.makeTensorInfo(i,u,l)}const oft={kernelName:yd,backendName:"cpu",kernelFunc:Ku};function cr(n,t,e,r){return e==null?({inputs:a,backend:s})=>{const{a:o,b:i}=a,u=s;Kt([o,i],n);const l=u.data.get(o.dataId).values,h=u.data.get(i.dataId).values,d=o.dtype==="string"?$i(l):l,f=o.dtype==="string"?$i(h):h,m=r||o.dtype,[v,y]=t(o.shape,i.shape,d,f,m);return u.makeTensorInfo(y,m,v)}:({inputs:a,backend:s})=>{const{a:o,b:i}=a,u=s;if(o.dtype==="complex64"||i.dtype==="complex64"){const l=Ku({inputs:{x:o},backend:u,attrs:{dtype:"complex64"}}),h=u.data.get(l.dataId),d=h.complexTensorInfos.real,f=h.complexTensorInfos.imag,m=u.data.get(d.dataId).values,v=u.data.get(f.dataId).values,y=Ku({inputs:{x:i},backend:u,attrs:{dtype:"complex64"}}),b=u.data.get(y.dataId),w=b.complexTensorInfos.real,S=b.complexTensorInfos.imag,N=u.data.get(w.dataId).values,C=u.data.get(S.dataId).values,[T,I,_]=e(o.shape,i.shape,m,v,N,C),$=u.makeTensorInfo(_,"float32",T),R=u.makeTensorInfo(_,"float32",I),D=Pa({inputs:{real:$,imag:R},backend:u});return u.disposeIntermediateTensorInfo(l),u.disposeIntermediateTensorInfo(y),u.disposeIntermediateTensorInfo($),u.disposeIntermediateTensorInfo(R),D}else{const l=u.data.get(o.dataId).values,h=u.data.get(i.dataId).values,d=r||o.dtype,[f,m]=t(o.shape,i.shape,l,h,d);return u.makeTensorInfo(m,d,f)}}}function i_(n){return(t,e,r,a,s,o)=>{const i=me(t,e),u=xt(i),l=i.length,h=oe(i),d=xr("float32",u),f=xr("float32",u),m=rc(t,i),v=rc(e,i),y=Di(r,a),b=Di(s,o),w=t.length,S=oe(t),N=e.length,C=oe(e);if(m.length+v.length===0)for(let T=0;T<d.length;T++){const I=T%y.length,_=T%b.length,$=n(y[I*2],y[I*2+1],b[_*2],b[_*2+1]);d[T]=$.real,f[T]=$.imag}else for(let T=0;T<d.length;T++){const I=vc(T,l,h),_=I.slice(-w);m.forEach(L=>_[L]=0);const $=eo(_,w,S),R=I.slice(-N);v.forEach(L=>R[L]=0);const D=eo(R,N,C),A=n(y[$*2],y[$*2+1],b[D*2],b[D*2+1]);d[T]=A.real,f[T]=A.imag}return[d,f,i]}}const pW=Gn(((n,t)=>n+t)),ift=i_(((n,t,e,r)=>({real:n+e,imag:t+r}))),od=cr(yc,pW,ift),uft={kernelName:yc,backendName:"cpu",kernelFunc:od};function u_(n,t,e,r,a){const s=xt(r),o=Mr(a,e);for(let i=0;i<n.length;i++){const u=n[i];if(u<0)throw new Error("Input x must be non-negative!");u>=a||(s>0?o[u]+=t[i]:o[u]+=1)}return o}function fW(n,t,e,r=!1){const a=n.shape[0],s=n.shape[1],o=we([a,e],t.dtype);for(let i=0;i<a;i++)for(let u=0;u<s;u++){const l=n.get(i,u);if(l<0)throw new Error("Input x must be non-negative!");l>=e||(r?o.set(1,i,l):t.size>0?o.set(o.get(i,l)+t.get(i,u),i,l):o.set(o.get(i,l)+1,i,l))}return o}const mW=Gn(((n,t)=>n&t)),lft=cr(Im,mW),cft={kernelName:Im,backendName:"cpu",kernelFunc:lft};function Jo(n){return(t,e,r)=>{const a=On(e,t.length);for(let s=0;s<t.length;++s)a[s]=n(t[s],r);return a}}function tn(n,t,e){const r=Jo(t);return il(n,r,e)}function il(n,t,e){return({inputs:r,attrs:a,backend:s})=>{const{x:o}=r;Kt(o,n);const i=s,u=i.data.get(o.dataId).values;let l;if(o.dtype==="string"){if(!Array.isArray(u))throw new Error("String tensor's value was not an instance of Array");l=$i(u)}else l=u;const h=e||o.dtype,d=t(l,h,a);return i.makeTensorInfo(o.shape,h,d)}}const gW=Jo(n=>Math.ceil(n)),hft=il(bd,gW),dft={kernelName:bd,backendName:"cpu",kernelFunc:hft};function vW(n,t,e,r){const a=On(e,xt(t));if(r&&e!=="string"){let s=0;n.forEach(o=>{const i=xt(o.shape);a.set(o.vals,s),s+=i})}else{let s=0;n.forEach(o=>{const i=e==="string"?$i(o.vals):o.vals;let u=0;for(let l=0;l<o.shape[0];++l){const h=l*t[1]+s;for(let d=0;d<o.shape[1];++d)a[h+d]=i[u++]}s+=o.shape[1]})}return a}const yW=Gn((n,t)=>n===t?1:0),bW=cr(Lm,yW,null,"bool"),pft={kernelName:Lm,backendName:"cpu",kernelFunc:bW};const xW=Jo(n=>Math.exp(n)),wW=il(Td,xW,"float32"),fft={kernelName:Td,backendName:"cpu",kernelFunc:wW};const SW=Jo(n=>Math.expm1(n)),mft=il(Ed,SW),gft={kernelName:Ed,backendName:"cpu",kernelFunc:mft};const CW=Jo(n=>Math.floor(n)),vft=il(Id,CW),yft={kernelName:Id,backendName:"cpu",kernelFunc:vft};const NW=Gn((n,t)=>Math.floor(n/t)),bft=cr(_d,NW,null,"int32"),xft={kernelName:_d,backendName:"cpu",kernelFunc:bft};function kW(n,t,e,r,a,s,o,i,u){const l=we([r,s],e);for(let h=0;h<r;h++){const d=[];let f=0;for(let m=0;m<a;m++){const v=n[h*a+m];f+=v*o[m],d.push(v)}if(f<0||f>=u/s)throw new Error(`Invalid indices: ${d} does not index into ${i}`);for(let m=0;m<s;m++)l.values[h*s+m]=t.get(...t.indexToLoc(f*s+m))}return l}function TW(n,t,e){const r=we(e,n.dtype);for(let a=0;a<r.size;++a){const o=r.indexToLoc(a).slice(),i=o[0],u=o[2],l=t.locToIndex([i,u]);o[2]=t.values[l];const h=n.locToIndex(o);0<=h&&h<n.values.length&&(r.values[a]=n.values[h])}return r}const EW=Gn((n,t)=>n>t?1:0),wft=cr(Vm,EW,null,"bool"),Sft={kernelName:Vm,backendName:"cpu",kernelFunc:wft};const IW=Gn((n,t)=>n>=t?1:0),Cft=cr(Rd,IW,null,"bool"),Nft={kernelName:Rd,backendName:"cpu",kernelFunc:Cft};const _W=Gn((n,t)=>n<t?1:0),kft=cr(Wm,_W,null,"bool"),Tft={kernelName:Wm,backendName:"cpu",kernelFunc:kft};const RW=Gn((n,t)=>n<=t?1:0),Eft=cr(Gm,RW,null,"bool"),Ift={kernelName:Gm,backendName:"cpu",kernelFunc:Eft};function AW(n,t,e){const r=(t-n)/(e-1),a=Mr(e,"float32");a[0]=n;for(let s=1;s<a.length;s++)a[s]=a[s-1]+r;return a}const DW=Jo(n=>Math.log(n)),_ft=il(Fd,DW),Rft={kernelName:Fd,backendName:"cpu",kernelFunc:_ft};function $W(n,t,e,r){const a=xr(r,xt(e));for(let s=0;s<a.length;++s){const o=s*t;let i=n[o];for(let u=0;u<t;++u){const l=n[o+u];(Number.isNaN(l)||l>i)&&(i=l)}a[s]=i}return a}const OW=Gn(((n,t)=>Math.max(n,t))),Aft=cr(Ld,OW),Dft={kernelName:Ld,backendName:"cpu",kernelFunc:Aft};const FW=Gn(((n,t)=>Math.min(n,t))),$ft=cr(Bd,FW),Oft={kernelName:Bd,backendName:"cpu",kernelFunc:$ft};const l_=Gn(((n,t)=>n*t)),Fft=i_(((n,t,e,r)=>({real:n*e-t*r,imag:n*r+t*e}))),aw=cr(Pd,l_,Fft),Mft={kernelName:Pd,backendName:"cpu",kernelFunc:aw};function MW(n,t,e){const r=Fi(-1,e);return l_([],t,r,n,e)}function Lft(n){const{inputs:t,backend:e}=n,{x:r}=t;Kt(r,"neg");const a=e.data.get(r.dataId).values,[s,o]=MW(a,r.shape,r.dtype);return e.makeTensorInfo(o,r.dtype,s)}const Bft={kernelName:eg,backendName:"cpu",kernelFunc:Lft};const LW=Gn(((n,t)=>n!==t?1:0)),zft=cr(ng,LW,null,"bool"),Pft={kernelName:ng,backendName:"cpu",kernelFunc:zft};function c_(n,t,e,r,a){const s=t.length,o=xt(t),i=oe(t),u=oe(a),l=xr(e,xt(a));for(let h=0;h<o;++h){const d=vc(h,s,i),f=new Array(d.length);for(let v=0;v<f.length;v++)f[v]=d[r[v]];const m=eo(f,s,u);l[m]=n[h]}return l}function Ea(n){const{inputs:t,attrs:e,backend:r}=n,{x:a}=t,{perm:s}=e;Kt(a,"transpose");const o=a.shape.length,i=new Array(o);for(let d=0;d<i.length;d++)i[d]=a.shape[s[d]];const u=r.data.get(a.dataId).values,l=c_(u,a.shape,a.dtype,s,i);return{dataId:r.write(l,i,a.dtype),shape:i,dtype:a.dtype}}const Vft={kernelName:ql,backendName:"cpu",kernelFunc:Ea};function BW(n,t,e,r){const[a,s]=kr(n,r),o=Sa(t,"int32"),i=Mr(xt(a),o),u=xt(s);for(let l=0;l<i.length;++l){const h=l*u;let d=1;for(let f=0;f<u;++f)d*=e[h+f];i[l]=d}return{outVals:i,outShape:a,outDtype:o}}function Uft(n){const{inputs:t,backend:e,attrs:r}=n,{x:a}=t,{axis:s,keepDims:o}=r;Kt(a,"prod");const i=a.shape.length,u=_e(s,a.shape),l=An(u,i);let h=u,d=a;const f=[];l!=null&&(d=Ea({inputs:{x:a},backend:e,attrs:{perm:l}}),f.push(d),h=Un(h.length,i));const m=e.data.get(d.dataId).values,{outVals:v,outShape:y,outDtype:b}=BW(d.shape,d.dtype,m,h);let w=y;return o&&(w=Vn(y,u)),f.forEach(S=>e.disposeIntermediateTensorInfo(S)),e.makeTensorInfo(w,b,v)}const Wft={kernelName:ug,backendName:"cpu",kernelFunc:Uft};function Gft(n,t,e){n.forEach((r,a)=>{if(r<0||r>=e){const s=vc(a,t.length,oe(t)).join(",");throw new Error(`indices[${s}] = ${r} is not in [0, ${e})`)}})}function Hft(n,t){for(let e=0;e<n.length;++e){const r=n[e],a=e===n.length-1?t:n[e+1].length;if(r.length===0)throw new Error("Ragged splits may not be empty");if(r[0]<0)throw new Error("Ragged splits must be non-negative");if(r[r.length-1]>a)throw new Error("Ragged splits must not point past values");for(let s=1;s<r.length;++s)if(r[s-1]>r[s])throw new Error("Ragged splits must be sorted in ascending order")}}function jft(n,t,e,r){const a=[];let s=0;const o=t.length-1+e.length,i=new Array(o).fill(null).map(()=>[0]);Hft(e,r);let u=1;for(let l=0;l<t.length-1;++l){u*=t[l];const h=t[l+1];for(let d=1;d<u+1;++d)i[l].push(d*h)}for(let l=0;l<n.length;++l){let h=n[l],d=n[l]+1;for(let f=0;f<e.length;++f){const m=e[f],v=f+t.length-1;if(v>=0){const y=i[v],b=y[y.length-1]-m[h];for(let w=h;w<d;++w)i[v].push(m[w+1]+b)}h=m[h],d=m[d]}d!==h&&(a.push([h,d]),s+=d-h)}return{outSplits:i,valueSlices:a,numValues:s}}function qft(n){const t=[];for(let e=0;e<n.length;++e){const r=n[e].length,a=On("int32",r);t.push(a),n[e].forEach((s,o)=>a[o]=s)}return t}function HF(n,t){const e=n.slice(0,t);for(;e.length<t;)e.push(1);for(let r=t;r<n.length;r++)e[t-1]*=n[r];return e}function Kft(n,t,e,r,a,s){const o=HF(t,2)[1],i=HF(s,2)[1];let u=0;for(const l of e)for(let h=l[0];h<l[1];++h){for(let d=0;d<r;++d)a[u*i+d]=n[h*o+d];++u}}function Xft(n,t,e,r,a){const s=t.slice();s[0]=a;const o=On(e,xt(s)),i=n.length,u=i===0?0:i/t[0];return Kft(n,t,r,u,o,s),[o,s]}function zW(n,t,e,r,a,s,o,i){if(n.length===0)throw new Error("paramsNestedSplits must be non empty");if(t[0].length===0)throw new Error("Split tensors must not be scalars");const u=t[0][0]-1;if(Gft(s,o,u),r.length===0)throw new Error("params.rank must be nonzero");const l=r[0],{outSplits:h,valueSlices:d,numValues:f}=jft(s,o,n,l),m=qft(h),v=Xft(e,r,a,d,f);return[m,v[0],v[1]]}const jF=2147483647;function PW(n,t,e,r,a,s,o){if(t.length>1)throw new Error("starts must be a scalar or vector");if(a.length>1)throw new Error("limits must be a scalar or vector");if(o.length>1)throw new Error("deltas must be a scalar or vector");const i=t.length===0,u=a.length===0,l=o.length===0,h=[];i||h.push(t[0]),u||h.push(a[0]),l||h.push(o[0]);for(let b=1;b<h.length;++b)if(h[b]!==h[b-1])throw new Error("starts, limits, and deltas must have the same shape");const d=h.length===0?1:h[0],f=On("int32",d+1);f[0]=0;for(let b=0;b<d;++b){const w=i?n[0]:n[b],S=u?r[0]:r[b],N=l?s[0]:s[b];if(N===0)throw new Error("Requires delta != 0");let C;if(N>0&&S<w||N<0&&S>w)C=0;else if(C=Math.ceil(Math.abs((S-w)/N)),C>jF)throw new Error(`Requires ((limit - start) / delta) <= ${jF}`);f[b+1]=f[b]+C}const m=f[d],v=On(e,m);let y=0;for(let b=0;b<d;++b){const w=f[b+1]-f[b];let S=i?n[0]:n[b];const N=l?s[0]:s[b];for(let C=0;C<w;++C)v[y++]=S,S+=N}return[f,v]}var $s=Qs;class Nb{constructor(t,e,r,a,s,o,i,u,l,h){this.shape=t,this.shapeShape=e,this.values=r,this.valuesShape=a,this.valuesDType=s,this.defaultValue=o,this.defaultValueShape=i,this.rowPartitionValues=u,this.rowPartitionValuesShapes=l,this.rowPartitionTypes=U4(h),this.raggedRank=W4(this.rowPartitionTypes)}getRowPartitionTypeByDimension(t){return this.rowPartitionTypes[0]===$s.FIRST_DIM_SIZE?this.rowPartitionTypes[t+1]:this.rowPartitionTypes[t]}getRowPartitionTensor(t){return this.rowPartitionTypes[0]===$s.FIRST_DIM_SIZE?this.rowPartitionValues[t+1]:this.rowPartitionValues[t]}getMaxWidth(t){const e=this.getRowPartitionTensor(t-1);switch(this.getRowPartitionTypeByDimension(t-1)){case $s.VALUE_ROWIDS:return Nb.getMaxWidthValueRowID(e);case $s.ROW_SPLITS:return Nb.getMaxWidthRowSplit(e);default:throw new Error(`Cannot handle partition type ${$s[this.getRowPartitionTypeByDimension(t-1)]}`)}}static getMaxWidthRowSplit(t){const e=t.length;if(e===0||e===1)return 0;let r=0;for(let a=0;a<e-1;++a){const s=t[a+1]-t[a];s>r&&(r=s)}return r}static getMaxWidthValueRowID(t){const e=t.length;if(e===0)return 0;let r=0,a=t[0],s=0;for(let o=1;o<e;++o){const i=t[o];i!==a&&(a=i,s=Math.max(o-r,s),r=o)}return Math.max(e-r,s)}tensorShapeFromTensor(t,e,r=!0){if(e.length===0){if(t[0]===-1)return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return KF(t,r)}calculateOutputSize(t){const e=this.valuesShape,r=this.defaultValueShape;G4(r,e);const a=this.tensorShapeFromTensor(this.shape,this.shapeShape),o=V4(this.raggedRank,a,e);o[0]<0&&(o[0]=t);for(let i=1;i<=this.raggedRank;++i)o[i]<0&&(o[i]=this.getMaxWidth(i));return o}calculateFirstParentOutputIndex(t,e,r){const a=Math.min(t,r),s=[];let o=0;for(let i=0;i<a;++i,o+=e)s.push(o);for(let i=a;i<t;++i)s.push(-1);return P(s.length===t,()=>"Final length of result must be equal to firstDimension."),s}calculateOutputIndexRowSplit(t,e,r,a){const s=t.length,o=[];for(let i=0;i<s-1;++i){const u=t[i+1]-t[i];let l=Math.min(a,u),h=e[i];h===-1&&(l=0);for(let d=0;d<l;++d)o.push(h),h+=r;for(let d=0;d<u-l;++d)o.push(-1)}if(s>0&&o.length!==t[s-1])throw new Error("Invalid row split size.");return o}calculateOutputIndexValueRowID(t,e,r,a){const s=t.length,o=[];if(s===0)return[];let i=0,u=t[0];if(u>=e.length)throw new Error(`Got currentValueRowId=${u}, which is not less than ${e.length}`);let l=e[u];o.push(l);for(let h=1;h<s;++h){const d=t[h];if(d===u)l>=0&&(++i,i<a?l+=r:l=-1);else{if(i=0,u=d,d>=e.length)throw new Error(`Got nextValueRowId=${d} which is not less than ${e.length}`);l=e[d]}o.push(l)}if(o.length!==t.length)throw new Error("Invalid row ids.");return o}calculateOutputIndex(t,e,r,a){const s=this.getRowPartitionTensor(t),o=this.getRowPartitionTypeByDimension(t);switch(o){case $s.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(s,e,r,a);case $s.ROW_SPLITS:if(s.length-1>e.length)throw new Error(`Row partition size is greater than output size: ${s.length-1} > ${e.length}`);return this.calculateOutputIndexRowSplit(s,e,r,a);default:throw new Error(`Unsupported partition type: ${$s[o]}`)}}getFirstDimensionSize(){const t=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error("No row_partition_types given.");const e=this.rowPartitionTypes[0];switch(e){case $s.FIRST_DIM_SIZE:return t[0];case $s.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case $s.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${$s[e]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const e=this.getFirstDimensionSize(),r=this.calculateOutputSize(e),a=new Array(this.raggedRank+1);a[a.length-1]=1;for(let u=a.length-2;u>=0;--u)a[u]=a[u+1]*r[u+1];const s=KF(r,!1),o=On(this.valuesDType,xt(s));if(a[0]*r[0]>0){let u=this.calculateFirstParentOutputIndex(e,a[0],r[0]);for(let l=1;l<=this.raggedRank;++l)u=this.calculateOutputIndex(l-1,u,a[l],r[l]);this.setOutput(this.raggedRank,u,o,s)}return[s,o]}setOutput(t,e,r,a){if(r.length===0)return;const s=this.values,o=r;let i=a.slice();i=i.slice(t+1);const u=xt(i),l=e.length;let h=this.defaultValue;if(h.length!==u&&h.length!==1){const v=this.defaultValueShape;ut(()=>{const y=at(h,v);h=Kl(y,i).dataSync()})}let d=0,f=0,m=0;for(let v=0;v<=l;++v){let y=v<l?e[v]:-1;if(y===m){++m;continue}if(f<m){const b=s.subarray(d*u),w=o.subarray(f*u),S=(m-f)*u;qF(w,b,S)}if(v>=l){const b=r.length;y=Math.floor(b/u)}if(y>m)if(this.defaultValue.length===1)o.subarray(m*u,y*u).fill(this.defaultValue[0]),m=y;else for(;y>m;){const b=o.slice(m*u);qF(b,h,u),++m}y<0?(d=v+1,f=m):(d=v,f=m,m=f+1)}}}function qF(n,t,e){for(let r=0;r<e;r++)n[r]=t[r]}function KF(n,t){const e=[];for(let r of n){if(r<0){if(!t)throw new Error(`Dimension ${r} must be >= 0`);if(r<-1)throw new Error(`Dimension ${r} must be >= -1`);r=-1}e.push(r)}return e}function VW(n,t,e,r,a,s,o,i,u,l){return new Nb(n,t,e,r,a,s,o,i,u,l).compute()}function UW(n,t,e,r){const a=n===t,s=n<t&&e<0,o=t<n&&e>1;if(a||s||o)return Mr(0,r);const i=Math.abs(Math.ceil((t-n)/e)),u=Mr(i,r);t<n&&e===1&&(e=-1),u[0]=n;for(let l=1;l<u.length;l++)u[l]=u[l-1]+e;return u}const WW=Jo(n=>1/Math.sqrt(n)),Yft=il(jd,WW),Qft={kernelName:jd,backendName:"cpu",kernelFunc:Yft};function Hl(n,t,e,r,a,s,o,i,u,l){const h=[r/a,a],d=n.values,f=t.values;if(r===0)return we(e,t.dtype);const m=u instanceof Yn?u:we(h,t.dtype);typeof u=="string"||typeof u=="number"?m.values.fill(u):typeof u=="boolean"&&m.values.fill(+u);for(let v=0;v<s;v++){const y=[];let b=0;for(let w=0;w<o;w++){const S=d[v*o+w];y.push(S),b+=S*i[w]}if(b<0||b>=r/a)throw new Error(`Invalid indices: ${y} does not index into ${e}`);for(let w=0;w<a;w++)l?m.values[b*a+w]+=f[v*a+w]:m.values[b*a+w]=t.rank===0?f[0]:f[v*a+w]}return m}const Zft=Jo(n=>1/(1+Math.exp(-n))),GW=tn(Qd,n=>1/(1+Math.exp(-n))),Jft={kernelName:Qd,backendName:"cpu",kernelFunc:GW};function HW(n,t,e,r,a){const s=oE(r,t,e),o=xt(e),i=oe(r);if(s){const d=iE(t,i);return a==="string"?n.slice(d,d+o):n.subarray(d,d+o)}const u=a==="string"?$i(n):n,l=we(r,a,u),h=we(e,a);for(let d=0;d<h.size;++d){const f=h.indexToLoc(d),m=f.map((v,y)=>v+t[y]);h.set(l.get(...m),...f)}return a==="string"?cB(h.values):h.values}function dc(n){const{inputs:t,backend:e,attrs:r}=n,{x:a}=t,{begin:s,size:o}=r;Kt(a,"slice");const[i,u]=E1(a,s,o);aE(a,i,u);const l=e.data.get(a.dataId).values,h=HW(l,i,u,a.shape,a.dtype);return e.makeTensorInfo(u,a.dtype,h)}const tmt={kernelName:fg,backendName:"cpu",kernelFunc:dc};function jW(n,t,e,r,a,s,o){const i=t[0],u=s[0],l=new Array(u),h=new Array(i),d=t[1];if(u===0){if(i!==0)throw new Error(Q4(i));const b=On(e,0),w=On(a,0);return[b,[0,d],w,l,h]}let f=!0,m=0;const v=new Array(u).fill(0);for(let b=0;b<i;++b){const w=n[b*d];if(w<0)throw new Error(Z4(b,w));if(w>=u)throw new Error(J4(b,w,u));++v[w],f=f&&w>=m,m=w}let y=!0;for(let b=0;b<u;++b){const w=v[b]===0;l[b]=w,y=y&&!w,v[b]=Math.max(v[b],1),b>0&&(v[b]+=v[b-1])}if(y&&f){const b=n,w=r;for(let S=0;S<i;++S)h[S]=S;return[b,[i,d],w,l,h]}else{const b=v[u-1],w=On(e,b*d),S=On(a,b),N=new Array(u).fill(0);for(let C=0;C<i;++C){const T=n[C*d],I=N[T],_=(T===0?0:v[T-1])+I;N[T]++;for(let $=0;$<d;++$)w[_*d+$]=n[C*d+$];S[_]=r[C],h[C]=_}for(let C=0;C<u;++C)if(N[C]===0){const I=C===0?0:v[C-1];w[I*d+0]=C;for(let _=1;_<d;++_)w[I*d+_]=0;S[I]=o}return[w,[b,d],S,l,h]}}function qW(n,t,e,r,a){const s=xt(r),o=t[0],i=a.length,u=[];let l=1,h=-1;for(let b=0;b<i;++b){const w=a[b];if(w===-1){if(h!==-1)throw new Error(tB(h,b));h=b,u.push(1)}else{if(w<0)throw new Error(eB(b,w));l*=w,u.push(w)}}if(h!==-1){if(l<=0)throw new Error(nB());const b=Math.trunc(s/l);if(l*b!==s)throw new Error(rB(r,u));u[h]=b}if(xt(u)!==s)throw new Error(aB(r,u));const f=r.length,m=[];if(f>0){m[f-1]=1;for(let b=f-2;b>=0;--b)m[b]=m[b+1]*r[b+1]}const v=[];if(i>0){v[i-1]=1;for(let b=i-2;b>=0;--b)v[b]=v[b+1]*u[b+1]}const y=On(e,o*i);for(let b=0;b<o;++b){let w=0;for(let S=0;S<f;++S)w+=n[b*f+S]*m[S];for(let S=0;S<i;++S)y[b*i+S]=Math.trunc(w/v[S]),w%=v[S]}return[y,[o,i],u]}function h_(n,t,e,r,a,s=!1,o=0){const i=r.length,u=[t[0],n.length/t[0]],l=u[1],d=i>0?a[i-1]+1:0;if(d<0)throw new Error(wN());const f=t.slice();f[0]=d;const m=f.reduce((N,C)=>N*C,1),v=On(e,m);if(i===0)return d>0&&v.fill(o),[v,f];if(d<=0)throw new Error(wN());let y=0,b=1,w=0,S=a[y];for(;;){let N=0;if(b<i){if(N=a[b],S===N){++b;continue}if(S>=N)throw new Error(sB())}if(S<0||S>=d)throw new Error(oB(S,d));S>w&&v.fill(o,w*l,S*l);for(let C=y;C<b;++C){const T=r[C];if(T<0||T>=u[0])throw new Error(iB(C,r[C],u[0]));for(let I=0;I<l;I++)v[S*l+I]+=n[T*l+I]}if(s)for(let C=0;C<l;C++)v[S*l+C]/=b-y;if(y=b,++b,w=S+1,S=N,b>i)break}return w<d&&v.fill(o,w*l,d*l),[v,f]}const emt=Jo(n=>Math.sqrt(n)),nmt=tn(Jd,n=>Math.sqrt(n)),rmt={kernelName:Jd,backendName:"cpu",kernelFunc:nmt};const KW=Gn(((n,t)=>{const e=n-t;return e*e})),amt=cr(tp,KW),smt={kernelName:tp,backendName:"cpu",kernelFunc:amt};const XW=Jo((n,t)=>{const{pattern:e,replaceGlobal:r,rewrite:a}=t;return n.replace(new RegExp(e,r?"g":""),a)}),omt=il(bg,XW),imt={kernelName:bg,backendName:"cpu",kernelFunc:omt};function YW(n,t,e,r){const a=we(n,t.dtype);for(let s=0;s<a.size;s++){const o=a.indexToLoc(s),i=new Array(o.length);for(let u=0;u<i.length;u++)i[u]=o[u]*e[u]+r[u];a.set(t.get(...i),...o)}return a}class umt{constructor(t,e,r,a,s,o){this.separator=$o(t),this.nGramWidths=e,this.leftPad=$o(r),this.rightPad=$o(a),this.padWidth=s,this.preserveShort=o}getPadWidth(t){return Math.min(this.padWidth<0?t-1:this.padWidth,t-1)}getNumNGrams(t,e){const r=this.getPadWidth(e);return Math.max(0,t+2*r-e+1)}createNGrams(t,e,r,a,s,o){for(let i=0;i<s;++i){const u=this.getPadWidth(o),l=Math.max(0,u-i),h=Math.max(0,u-(s-(i+1))),d=o-(l+h),f=e+(l>0?0:i-u);let m=0;m+=l*this.leftPad.length;for(let S=0;S<d;++S)m+=t[f+S].length;m+=h*this.rightPad.length;const v=l+h+d-1;m+=v*this.separator.length,r[a+i]=new Uint8Array(m);const y=r[a+i];let b=0;const w=S=>S.forEach(N=>y[b++]=N);for(let S=0;S<l;++S)w(this.leftPad),w(this.separator);for(let S=0;S<d-1;++S)w(t[f+S]),w(this.separator);if(d>0){w(t[f+d-1]);for(let S=0;S<h;++S)w(this.separator),w(this.rightPad)}else{for(let S=0;S<h-1;++S)w(this.rightPad),w(this.separator);w(this.rightPad)}}}compute(t,e){const r=t.length,a=e.length;if(a>0){let u=e[0];if(u!==0)throw new Error(`First split value must be 0, got ${u}`);for(let l=1;l<a;++l){let h=e[l]>=u;if(h=h&&e[l]<=r,!h)throw new Error(`Invalid split value ${e[l]}, must be in [${u}, ${r}]`);u=e[l]}if(u!==r)throw new Error(`Last split value must be data size. Expected ${r}, got ${u}`)}const s=a-1,o=On("int32",a);if(r===0||a===0){const u=new Array(r);for(let l=0;l<=s;++l)o[l]=0;return[u,o]}o[0]=0;for(let u=1;u<=s;++u){const l=e[u]-e[u-1];let h=0;this.nGramWidths.forEach(d=>{h+=this.getNumNGrams(l,d)}),this.preserveShort&&l>0&&h===0&&(h=1),o[u]=o[u-1]+h}const i=new Array(o[s]);for(let u=0;u<s;++u){const l=e[u];let h=o[u];if(this.nGramWidths.forEach(d=>{const f=e[u+1]-e[u],m=this.getNumNGrams(f,d);this.createNGrams(t,l,i,h,m,d),h+=m}),this.preserveShort&&h===o[u]){const d=e[u+1]-e[u];if(d===0)continue;const f=d+2*this.padWidth;this.createNGrams(t,l,i,h,1,f)}}return[i,o]}}function QW(n,t,e,r,a,s,o,i){return new umt(e,r,a,s,o,i).compute(n,t)}function lmt(n,t,e,r){if(!n.length)return;if(t.length===0){for(let s=0;s<n.length;++s)r.push(n.subarray(s,s+1));return}if(t.length===1){const s=t[0];let o=n.indexOf(s);for(;o!==-1;){const i=n.subarray(0,o);(!e||i.length!==0)&&r.push(i),n=n.subarray(o+1),o=n.indexOf(s)}(!e||n.length!==0)&&r.push(n);return}let a=0;for(let s=0;s<n.length+1;s++)if(s===n.length||t.indexOf(n[s])!==-1){const o=n.subarray(a,s);(!e||o.length!==0)&&r.push(o),a=s+1}}function ZW(n,t,e){const r=n.length,a=[];let s=0,o=0;const i=new Array(r);for(let f=0;f<r;++f){const m=a.length;lmt(n[f],t,e,a);const v=a.length-m;i[f]=v,s+=v,o=Math.max(o,v)}const u=On("int32",s*2),l=new Array(s),h=[r,o];let d=0;for(let f=0;f<r;++f)for(let m=0;m<i[f];++m)u[d*2]=f,u[d*2+1]=m,l[d]=a[d],++d;return[u,l,h]}function JW(n,t){const e=On("int32",n.length);for(let r=0;r<n.length;++r)e[r]=tL(n[r]).modulo(t).getLowBitsUnsigned();return e}const tG=Gn(((n,t)=>n-t)),cmt=i_(((n,t,e,r)=>({real:n-e,imag:t-r}))),d_=cr(ep,tG,cmt),hmt={kernelName:ep,backendName:"cpu",kernelFunc:d_};function eG(n,t){const e=new Array(n.rank);for(let a=0;a<e.length;a++)e[a]=n.shape[a]*t[a];const r=we(e,n.dtype);for(let a=0;a<r.values.length;++a){const s=r.indexToLoc(a),o=new Array(n.rank);for(let u=0;u<o.length;u++)o[u]=s[u]%n.shape[u];const i=n.locToIndex(o);r.values[a]=n.values[i]}return r}const Lf=(n,t)=>{const e=t.value-n.value;return e===0?n.index-t.index:e};function nG(n,t,e=0,r=n.length-1){for(;r>e;){if(r-e>600){const i=r-e+1,u=t-e+1,l=Math.log(i),h=.5*Math.exp(2*l/3),d=.5*Math.sqrt(l*h*(i-h)/i)*Math.sign(u-i/2),f=Math.max(e,Math.floor(t-u*h/i+d)),m=Math.min(r,Math.floor(t+(i-u)*h/i+d));nG(n,t,f,m)}const a=n[t];let s=e,o=r;for(Ni(n,e,t),Lf(n[r],a)>0&&Ni(n,e,r);s<o;){for(Ni(n,s,o),s++,o--;Lf(n[s],a)<0;)s=s+1;for(;Lf(n[o],a)>0;)o=o-1}Lf(n[e],a)===0?Ni(n,e,o):(o=o+1,Ni(n,o,r)),o<=t&&(e=o+1),t<=o&&(r=o-1)}}function rG(n,t,e,r,a){const s=t[t.length-1],[o,i]=[n.length/s,s],u=xr(e,o*r),l=xr("int32",o*r);for(let d=0;d<o;d++){const f=d*i,m=n.subarray(f,f+i);let v=new Array(m.length);m.forEach((S,N)=>v[N]={value:S,index:N}),r<v.length&&(nG(v,r),v=v.slice(0,r)),a&&v.sort(Lf);const y=d*r,b=u.subarray(y,y+r),w=l.subarray(y,y+r);for(let S=0;S<r;S++)b[S]=v[S].value,w[S]=v[S].index}const h=t.slice();return h[h.length-1]=r,[we(h,e,u),we(h,"int32",l)]}function aG(n,t,e,r){const a=_e(t,e)[0],s=[1,e[0],1];for(let v=0;v<a;v++)s[0]*=e[v];s[1]=e[a];for(let v=a+1;v<e.length;v++)s[2]*=e[v];const o=new Map,i=new Int32Array(e[a]),u=new Yn(s,r,n),l=[],h=s[0]===1&&s[2]===1;for(let v=0;v<e[a];v++){let y;if(h)y=n[v].toString();else{const w=[];for(let S=0;S<s[0];S++)for(let N=0;N<s[2];N++)w.push(u.get(S,v,N));y=w.join(",")}const b=o.get(y);if(b!=null)i[v]=b;else{const w=o.size;o.set(y,w),i[v]=w,l.push(v)}}const d=s.slice();d[1]=o.size;const f=new Yn(d,r);l.forEach((v,y)=>{for(let b=0;b<s[0];b++)for(let w=0;w<s[2];w++)f.set(u.get(b,v,w),b,y,w)});const m=e.slice();return m[a]=d[1],{outputValues:f.values,outputShape:m,indices:i}}const dmt=Object.freeze(Object.defineProperty({__proto__:null,addImpl:pW,bincountImpl:u_,bincountReduceImpl:fW,bitwiseAndImpl:mW,castImpl:dW,ceilImpl:gW,concatImpl:vW,equalImpl:yW,expImpl:xW,expm1Impl:SW,floorDivImpl:NW,floorImpl:CW,gatherNdImpl:kW,gatherV2Impl:TW,greaterEqualImpl:IW,greaterImpl:EW,lessEqualImpl:RW,lessImpl:_W,linSpaceImpl:AW,logImpl:DW,maxImpl:$W,maximumImpl:OW,minimumImpl:FW,multiplyImpl:l_,negImpl:MW,notEqualImpl:LW,prodImpl:BW,raggedGatherImpl:zW,raggedRangeImpl:PW,raggedTensorToTensorImpl:VW,rangeImpl:UW,rsqrtImpl:WW,scatterImpl:Hl,sigmoidImpl:Zft,simpleAbsImpl:hW,sliceImpl:HW,sparseFillEmptyRowsImpl:jW,sparseReshapeImpl:qW,sparseSegmentReductionImpl:h_,sqrtImpl:emt,squaredDifferenceImpl:KW,staticRegexReplaceImpl:XW,stridedSliceImpl:YW,stringNGramsImpl:QW,stringSplitImpl:ZW,stringToHashBucketFastImpl:JW,subImpl:tG,tileImpl:eG,topKImpl:rG,transposeImpl:c_,uniqueImpl:aG},Symbol.toStringTag,{value:"Module"}));zk("cpu",()=>new rw,1);const sG=tn(Nd,n=>n>=0?n:Math.exp(n)-1),pmt={kernelName:Nd,backendName:"cpu",kernelFunc:sG};function oG(n){const{inputs:t,backend:e,attrs:r}=n,{x:a}=t,{alpha:s}=r;Kt([a],"leakyRelu");const o=xt(a.shape),i=e.data.get(a.dataId).values,u=xr("float32",o);for(let l=0;l<i.length;l++)u[l]=i[l]<0?s*i[l]:i[l];return e.makeTensorInfo(a.shape,"float32",u)}const fmt={kernelName:Um,backendName:"cpu",kernelFunc:oG};const mmt=Gn((n,t)=>n<0?t*n:n);function iG(n){const{inputs:t,backend:e}=n,{x:r,alpha:a}=t;Kt([r,a],"prelu");const s=e.data.get(r.dataId).values,o=e.data.get(a.dataId).values,[i,u]=mmt(r.shape,a.shape,s,o,"float32");return e.makeTensorInfo(u,"float32",i)}const gmt={kernelName:ig,backendName:"cpu",kernelFunc:iG};const uG=tn(Wd,n=>Math.max(0,n)),vmt={kernelName:Wd,backendName:"cpu",kernelFunc:uG};const lG=tn(Gd,n=>Math.min(Math.max(0,n),6)),ymt={kernelName:Gd,backendName:"cpu",kernelFunc:lG};function kb(n,t,e,r,a){if(e==="linear")return qo({inputs:{x:t},backend:n});if(e==="relu")return uG({inputs:{x:t},backend:n});if(e==="elu")return sG({inputs:{x:t},backend:n});if(e==="relu6")return lG({inputs:{x:t},backend:n});if(e==="prelu")return iG({inputs:{x:t,alpha:r},backend:n});if(e==="leakyrelu")return oG({inputs:{x:t},backend:n,attrs:{alpha:a}});if(e==="sigmoid")return GW({inputs:{x:t},backend:n});throw new Error(`Activation ${e} has not been implemented for the CPU backend.`)}function gn(n){const{inputs:t,backend:e,attrs:r}=n,{x:a}=t,{shape:s}=r,o=xt(a.shape),i=Ik(s,o),u=xt(i);P(o===u,()=>`The new shape (${i}) has ${u} elements and the old shape (${a.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`),e.incRef(a.dataId);const l=e.data.get(a.dataId);if(l.complexTensorInfos!=null){const h=l.complexTensorInfos.real,d=l.complexTensorInfos.imag;h.shape=i,d.shape=i}return{dataId:a.dataId,shape:i,dtype:a.dtype}}const bmt={kernelName:lg,backendName:"cpu",kernelFunc:gn};function cG(n){const{inputs:t,backend:e,attrs:r}=n,{a,b:s}=t,{transposeA:o,transposeB:i}=r;Kt([a,s],"matMul");const u=a.shape.length,l=s.shape.length,h=o?a.shape[u-2]:a.shape[u-1],d=i?s.shape[l-1]:s.shape[l-2],f=o?a.shape[u-1]:a.shape[u-2],m=i?s.shape[l-2]:s.shape[l-1],v=a.shape.slice(0,-2),y=s.shape.slice(0,-2),b=xt(v),w=xt(y),N=me(a.shape.slice(0,-2),s.shape.slice(0,-2)).concat([f,m]);P(h===d,()=>`Error in matMul: inner shapes (${h}) and (${d}) of Tensors with shapes ${a.shape} and ${s.shape} and transposeA=${o} and transposeB=${i} must match.`);const C=o?[b,h,f]:[b,f,h],T=i?[w,m,d]:[w,d,m],I=gn({inputs:{x:a},backend:e,attrs:{shape:C}}),_=gn({inputs:{x:s},backend:e,attrs:{shape:T}}),$=o?I.shape[1]:I.shape[2],R=o?I.shape[2]:I.shape[1],D=i?_.shape[1]:_.shape[2],A=Math.max(b,w),L=e.data.get(I.dataId).values,H=e.data.get(_.dataId).values,G=oe(I.shape),q=oe(_.shape),[B,j,K]=o?[G[0],1,G[1]]:[G[0],G[1],1],[z,U,M]=i?[1,q[1],q[0]]:[q[1],1,q[0]],X=R*D,Q=we([A,R,D],I.dtype),rt=Q.values,ct=e.blockSize;for(let pt=0;pt<A;pt++){const yt=pt%b,Tt=pt%w;for(let gt=0;gt<R;gt+=ct){const Rt=Math.min(gt+ct,R);for(let At=0;At<D;At+=ct){const Lt=Math.min(At+ct,D);for(let Mt=0;Mt<$;Mt+=ct){const Wt=Math.min(Mt+ct,$);for(let se=gt;se<Rt;se++)for(let Xt=At;Xt<Lt;Xt++){let Se=0;for(let pe=Mt;pe<Wt;pe++){const Xe=L[yt*B+se*j+pe*K],We=H[pe*z+Xt*U+Tt*M];Se+=Xe*We}rt[pt*X+(se*D+Xt)]+=Se}}}}}return e.disposeIntermediateTensorInfo(I),e.disposeIntermediateTensorInfo(_),e.makeTensorInfo(N,Q.dtype,Q.values)}const xmt={kernelName:Tm,backendName:"cpu",kernelFunc:cG};function wmt(n){const{inputs:t,backend:e,attrs:r}=n,{a,b:s,bias:o,preluActivationWeights:i}=t,{transposeA:u,transposeB:l,activation:h,leakyreluAlpha:d}=r;let f,m,v;const y=[];f=cG({inputs:{a,b:s},attrs:{transposeA:u,transposeB:l},backend:e}),o&&(m=od({inputs:{a:f,b:o},backend:e}),y.push(f),f=m),h&&(v=kb(e,f,h,i,d),y.push(f),f=v);for(const w of y)e.disposeIntermediateTensorInfo(w);return f}const Smt={kernelName:jf,backendName:"cpu",kernelFunc:wmt};const Cmt=tn(hd,n=>Math.acos(n)),Nmt={kernelName:hd,backendName:"cpu",kernelFunc:Cmt};const kmt=tn(dd,n=>Math.acosh(n)),Tmt={kernelName:dd,backendName:"cpu",kernelFunc:kmt};function Emt(n){const{inputs:t,backend:e}=n,r=t;Kt(t,"addN");const a=r.map(i=>e.data.get(i.dataId).values),s=we(r[0].shape,r[0].dtype),o=s.values;for(let i=0;i<r.length;i++){const u=a[i];for(let l=0;l<o.length;l++)o[l]+=u[l]}return e.makeTensorInfo(s.shape,s.dtype,s.values)}const Imt={kernelName:wm,backendName:"cpu",kernelFunc:Emt};function _mt(n){const{inputs:t,backend:e,attrs:r}=n,{x:a}=t,{axis:s,keepDims:o}=r;Kt(a,"all");const i=_e(s,a.shape);let u=i;const l=An(u,a.shape.length);let h=a;l!=null&&(h=Ea({inputs:{x:a},backend:e,attrs:{perm:l}}),u=Un(u.length,a.shape.length)),Pr("all",u,h.shape.length);const[d,f]=kr(h.shape,u),m=xt(f),v=Mr(xt(d),h.dtype),y=e.data.get(h.dataId).values;for(let w=0;w<v.length;++w){const S=w*m;let N=y[S];for(let C=0;C<m;++C){const T=y[S+C];N=N&&T}v[w]=N}l!=null&&e.disposeIntermediateTensorInfo(h);const b=e.makeTensorInfo(d,h.dtype,v);if(o){const w=Vn(d,i),S=gn({inputs:{x:b},backend:e,attrs:{shape:w}});return e.disposeIntermediateTensorInfo(b),S}return b}const Rmt={kernelName:Fb,backendName:"cpu",kernelFunc:_mt};function Amt(n){const{inputs:t,backend:e,attrs:r}=n,{x:a}=t,{axis:s,keepDims:o}=r;Kt(a,"any");const i=_e(s,a.shape);let u=i;const l=An(u,a.shape.length);let h=a;l!=null&&(h=Ea({inputs:{x:a},backend:e,attrs:{perm:l}}),u=Un(u.length,a.shape.length)),Pr("any",u,h.shape.length);const[d,f]=kr(h.shape,u),m=xt(f),v=Mr(xt(d),h.dtype),y=e.data.get(h.dataId).values;for(let w=0;w<v.length;++w){const S=w*m;let N=y[S];for(let C=0;C<m;++C){const T=y[S+C];N=N||T}v[w]=N}l!=null&&e.disposeIntermediateTensorInfo(h);const b=e.makeTensorInfo(d,h.dtype,v);if(o){const w=Vn(d,i),S=gn({inputs:{x:b},backend:e,attrs:{shape:w}});return e.disposeIntermediateTensorInfo(b),S}return b}const Dmt={kernelName:Mb,backendName:"cpu",kernelFunc:Amt};function $mt(n){const{inputs:t,backend:e,attrs:r}=n,{x:a}=t,{axis:s}=r;Kt(a,"argMax");let o=_e(s,a.shape);const i=An(o,a.shape.length);let u=a;const l=[];i!=null&&(u=Ea({inputs:{x:a},backend:e,attrs:{perm:i}}),l.push(u),o=Un(o.length,u.shape.length)),o=[o[0]],Pr("argMax",o,u.shape.length);const[h,d]=kr(u.shape,o),f=xt(h),m=Mr(f,"int32"),v=xt(d),y=e.data.get(u.dataId).values;for(let b=0;b<m.length;++b){const w=b*v;let S=y[w],N=0;for(let C=0;C<v;++C){const T=y[w+C];T>S&&(S=T,N=C)}m[b]=N}return l.forEach(b=>e.disposeIntermediateTensorInfo(b)),e.makeTensorInfo(h,"int32",m)}const Omt={kernelName:Sm,backendName:"cpu",kernelFunc:$mt};function Fmt(n){const{inputs:t,backend:e,attrs:r}=n,{x:a}=t,{axis:s}=r;Kt(a,"argMin");let o=_e(s,a.shape);const i=An(o,a.shape.length);let u=a;const l=[];i!=null&&(u=Ea({inputs:{x:a},backend:e,attrs:{perm:i}}),l.push(u),o=Un(o.length,u.shape.length)),o=[o[0]],Pr("argMin",o,u.shape.length);const[h,d]=kr(u.shape,o),f=xt(h),m=Mr(f,"int32"),v=xt(d),y=e.data.get(u.dataId).values;for(let b=0;b<m.length;++b){const w=b*v;let S=y[w],N=0;for(let C=0;C<v;++C){const T=y[w+C];T<S&&(S=T,N=C)}m[b]=N}return l.forEach(b=>e.disposeIntermediateTensorInfo(b)),e.makeTensorInfo(h,"int32",m)}const Mmt={kernelName:Cm,backendName:"cpu",kernelFunc:Fmt};const Lmt=tn(pd,n=>Math.asin(n)),Bmt={kernelName:pd,backendName:"cpu",kernelFunc:Lmt};const zmt=tn(fd,n=>Math.asinh(n)),Pmt={kernelName:fd,backendName:"cpu",kernelFunc:zmt};const Vmt=tn(md,n=>Math.atan(n)),Umt={kernelName:md,backendName:"cpu",kernelFunc:Vmt};const Wmt=Gn((n,t)=>Math.atan2(n,t)),Gmt=cr(vd,Wmt),Hmt={kernelName:vd,backendName:"cpu",kernelFunc:Gmt};const jmt=tn(gd,n=>Math.atanh(n)),qmt={kernelName:gd,backendName:"cpu",kernelFunc:jmt};function p_(n,t,e,r,a,s){const o=a.strideHeight,i=a.strideWidth,u=a.dilationHeight,l=a.dilationWidth,h=a.effectiveFilterHeight,d=a.effectiveFilterWidth,f=a.padInfo.top,m=a.padInfo.left,v=s==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,y=we(a.outShape,e),b=y.values,w=a.outShape[1]*a.outShape[2]*a.outShape[3],S=a.outShape[2]*a.outShape[3],N=a.outShape[3];for(let C=0;C<a.batchSize;++C){const T=C*w,I=C*r[0];for(let _=0;_<a.inChannels;++_)for(let $=0;$<a.outHeight;++$){const R=$*o-f,D=Math.max(0,R),A=Math.min(a.inHeight,h+R),L=T+$*S;for(let H=0;H<a.outWidth;++H){const G=H*i-m,q=Math.max(0,G),B=Math.min(a.inWidth,d+G);let j=v,K=0,z=0;for(let M=D;M<A;M+=u){const X=I+M*r[1];for(let Q=q;Q<B;Q+=l){const rt=X+Q*r[2],ct=n[rt+_];s==="max"&&ct>j?j=ct:s==="avg"&&(K+=ct,z++)}if(isNaN(j))break}const U=L+H*N+_;b[U]=s==="avg"?K/z:j}}}return y}function hG(n,t,e,r,a=!1,s=!1){const o=we(r.outShape,"int32"),i=r.strideHeight,u=r.strideWidth,l=r.dilationHeight,h=r.dilationWidth,d=r.effectiveFilterHeight,f=r.effectiveFilterWidth,m=r.padInfo.top,v=r.padInfo.left,y=we(t,e,n);for(let b=0;b<r.batchSize;++b)for(let w=0;w<r.inChannels;++w)for(let S=0;S<r.outHeight;++S){const N=S*i-m;let C=N;for(;C<0;)C+=l;const T=Math.min(r.inHeight,d+N);for(let I=0;I<r.outWidth;++I){const _=I*u-v;let $=_;for(;$<0;)$+=h;const R=Math.min(r.inWidth,f+_);let D=Number.NEGATIVE_INFINITY,A=-1;for(let L=C;L<T;L+=l){const H=L-N;for(let G=$;G<R;G+=h){const q=G-_,B=y.get(b,L,G,w);B>D&&(D=B,a?A=s?((b*r.inHeight+L)*r.inWidth+G)*r.inChannels+w:(L*r.inWidth+G)*r.inChannels+w:A=H*f+q)}}o.set(A,b,S,I,w)}}return o}function dG(n,t,e,r,a,s){const o=a.strideDepth,i=a.strideHeight,u=a.strideWidth,l=a.dilationDepth,h=a.dilationHeight,d=a.dilationWidth,f=a.effectiveFilterDepth,m=a.effectiveFilterHeight,v=a.effectiveFilterWidth,y=a.padInfo.front,b=a.padInfo.top,w=a.padInfo.left,S=s==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,N=we(a.outShape,e),C=N.values,T=a.outShape[1]*a.outShape[2]*a.outShape[3]*a.outShape[4],I=a.outShape[2]*a.outShape[3]*a.outShape[4],_=a.outShape[3]*a.outShape[4],$=a.outShape[4];for(let R=0;R<a.batchSize;++R){const D=R*T,A=R*r[0];for(let L=0;L<a.inChannels;++L)for(let H=0;H<a.outDepth;++H){const G=H*o-y;let q=G;for(;q<0;)q+=l;const B=Math.min(a.inDepth,f+G),j=D+H*I;for(let K=0;K<a.outHeight;++K){const z=K*i-b;let U=z;for(;U<0;)U+=h;const M=Math.min(a.inHeight,m+z),X=j+K*_;for(let Q=0;Q<a.outWidth;++Q){const rt=Q*u-w;let ct=rt;for(;ct<0;)ct+=d;const pt=Math.min(a.inWidth,v+rt),yt=X+Q*$;let Tt=S,gt=0,Rt=0;for(let Lt=q;Lt<B;Lt+=l){const Mt=A+Lt*r[1];for(let Wt=U;Wt<M;Wt+=h){const se=Mt+Wt*r[2];for(let Xt=ct;Xt<pt;Xt+=d){const Se=se+Xt*r[3],pe=n[Se+L];if(s==="max"&&pe>Tt?Tt=pe:s==="avg"&&(gt+=pe,Rt++),isNaN(Tt))break}if(isNaN(Tt))break}if(isNaN(Tt))break}const At=yt+L;C[At]=s==="avg"?gt/Math.max(Rt,1):Tt}}}}return N}function Kmt(n,t){const e=we(t.outShape,"int32"),r=t.strideDepth,a=t.strideHeight,s=t.strideWidth,o=t.dilationDepth,i=t.dilationHeight,u=t.dilationWidth,l=t.effectiveFilterDepth,h=t.effectiveFilterHeight,d=t.effectiveFilterWidth,f=t.padInfo.front,m=t.padInfo.top,v=t.padInfo.left;for(let y=0;y<t.batchSize;++y)for(let b=0;b<t.inChannels;++b)for(let w=0;w<t.outDepth;++w){const S=w*r-f;let N=S;for(;N<0;)N+=o;const C=Math.min(t.inDepth,l+S);for(let T=0;T<t.outHeight;++T){const I=T*a-m;let _=I;for(;_<0;)_+=i;const $=Math.min(t.inHeight,h+I);for(let R=0;R<t.outWidth;++R){const D=R*s-v;let A=D;for(;A<0;)A+=u;const L=Math.min(t.inWidth,d+D);let H=Number.NEGATIVE_INFINITY,G=-1;for(let q=N;q<C;q+=o){const B=q-S;for(let j=_;j<$;j+=i){const K=j-I;for(let z=A;z<L;z+=u){const U=z-D,M=n.get(y,q,j,z,b);M>=H&&(H=M,G=B*h*d+K*h+U)}}}e.set(G,y,w,T,R,b)}}}return e}function Xmt(n){const{inputs:t,backend:e,attrs:r}=n,{x:a}=t;Kt(a,"avgPool");const{filterSize:s,strides:o,pad:i,dimRoundingMode:u}=r,l=1;P(zr(o,l),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${l}'`);const h=Vs(a.shape,s,o,l,i,u);let d;if(h.filterWidth===1&&h.filterHeight===1&&De(h.inShape,h.outShape))d=qo({inputs:{x:a},backend:e});else{const f=e.data.get(a.dataId).values,m=oe(a.shape),v=p_(f,a.shape,a.dtype,m,h,"avg");d=e.makeTensorInfo(h.outShape,a.dtype,v.values)}return d}const Ymt={kernelName:Nm,backendName:"cpu",kernelFunc:Xmt};function Qmt(n){const{inputs:t,backend:e,attrs:r}=n,{x:a}=t,{filterSize:s,strides:o,pad:i,dimRoundingMode:u,dataFormat:l}=r;Kt(a,"avgPool3d");const h=Mi(a.shape,s,o,1,i,u,l),d=e.data.get(a.dataId).values,f=dG(d,a.shape,a.dtype,oe(a.shape),h,"avg");return e.makeTensorInfo(f.shape,"float32",f.values)}const Zmt={kernelName:km,backendName:"cpu",kernelFunc:Qmt};function Jmt(n){const{inputs:t,backend:e,attrs:r}=n,{dy:a,input:s}=t,{filterSize:o,strides:i,pad:u,dimRoundingMode:l}=r;Kt([a,s],"avgPool3DGrad");const h=Mi(s.shape,o,i,1,u,l),d=h.strideDepth,f=h.strideHeight,m=h.strideWidth,v=h.filterDepth,y=h.filterHeight,b=h.filterWidth,w=h.dilationDepth,S=h.dilationHeight,N=h.dilationWidth,C=h.effectiveFilterDepth,T=h.effectiveFilterHeight,I=h.effectiveFilterWidth,_=C-1-h.padInfo.front,$=I-1-h.padInfo.left,R=T-1-h.padInfo.top,D=we(s.shape,"float32"),A=1/(v*y*b),L=e.bufferSync(a);for(let H=0;H<h.batchSize;++H)for(let G=0;G<h.inChannels;++G)for(let q=0;q<h.inDepth;++q)for(let B=0;B<h.inHeight;++B)for(let j=0;j<h.inWidth;++j){const K=q-_,z=B-R,U=j-$;let M=0;for(let X=0;X<C;X+=w){const Q=(K+X)/d;if(!(Q<0||Q>=h.outDepth||Math.floor(Q)!==Q))for(let rt=0;rt<T;rt+=S){const ct=(z+rt)/f;if(!(ct<0||ct>=h.outHeight||Math.floor(ct)!==ct))for(let pt=0;pt<I;pt+=N){const yt=(U+pt)/m;if(yt<0||yt>=h.outWidth||Math.floor(yt)!==yt)continue;const Tt=L.get(H,Q,ct,yt,G);M+=Tt}}}D.set(M*A,H,q,B,j,G)}return e.makeTensorInfo(D.shape,D.dtype,D.values)}const tgt={kernelName:Bb,backendName:"cpu",kernelFunc:Jmt};function egt(n){const{inputs:t,backend:e,attrs:r}=n,{dy:a,input:s}=t,o=s;Kt([a,s],"avgPoolGrad");const{filterSize:i,strides:u,pad:l}=r,h=Vs(o.shape,i,u,1,l),d=h.strideHeight,f=h.strideWidth,m=h.filterHeight,v=h.filterWidth,y=h.dilationHeight,b=h.dilationWidth,w=h.effectiveFilterHeight,S=h.effectiveFilterWidth,N=S-1-h.padInfo.left,C=w-1-h.padInfo.top,T=we(o.shape,"float32"),I=1/(m*v),_=e.data.get(a.dataId).values,$=we(a.shape,"float32",_);for(let R=0;R<h.batchSize;++R)for(let D=0;D<h.inChannels;++D)for(let A=0;A<h.inHeight;++A)for(let L=0;L<h.inWidth;++L){const H=A-C,G=L-N;let q=0;for(let B=0;B<w;B+=y){const j=(H+B)/d;if(!(j<0||j>=h.outHeight||Math.floor(j)!==j))for(let K=0;K<S;K+=b){const z=(G+K)/f;if(z<0||z>=h.outWidth||Math.floor(z)!==z)continue;const U=$.get(R,j,z,D);q+=U}}T.set(q*I,R,A,L,D)}return e.makeTensorInfo(T.shape,T.dtype,T.values)}const ngt={kernelName:Lb,backendName:"cpu",kernelFunc:egt};function rgt(n){const{inputs:t,backend:e,attrs:r}=n,{x:a,scale:s,offset:o,mean:i,variance:u}=t;P(i.shape.length===u.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),P(o==null||i.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),P(s==null||i.shape.length===s.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),Kt([a,i,u,s,o],"batchNorm");let{varianceEpsilon:l}=r;l==null&&(l=.001);const h=e.data.get(a.dataId).values,d=e.data.get(i.dataId).values,f=e.data.get(u.dataId).values,m=s?e.data.get(s.dataId).values:new Float32Array([1]),v=o?e.data.get(o.dataId).values:new Float32Array([0]),y=new Float32Array(h.length),b=v.length,w=m.length,S=f.length,N=d.length;let C=0,T=0,I=0,_=0;for(let $=0;$<h.length;++$)y[$]=v[C++]+(h[$]-d[T++])*m[I++]/Math.sqrt(f[_++]+l),C>=b&&(C=0),T>=N&&(T=0),I>=w&&(I=0),_>=S&&(_=0);return e.makeTensorInfo(a.shape,a.dtype,y)}const agt={kernelName:zm,backendName:"cpu",kernelFunc:rgt};function sgt(n){const{inputs:t,backend:e,attrs:r}=n,{x:a}=t,{blockShape:s,crops:o}=r;Kt([a],"batchToSpaceND");const i=s.reduce((w,S)=>w*S),u=Gg(a.shape,s,i),l=Hg(u.length,s.length),h=jg(a.shape,s,i),d=pE(o,s.length),f=fE(h,o,s.length),m=gn({inputs:{x:a},backend:e,attrs:{shape:u}}),v=Ea({inputs:{x:m},backend:e,attrs:{perm:l}}),y=gn({inputs:{x:v},backend:e,attrs:{shape:h}}),b=dc({inputs:{x:y},backend:e,attrs:{begin:d,size:f}});return e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(v),e.disposeIntermediateTensorInfo(y),b}const ogt={kernelName:Em,backendName:"cpu",kernelFunc:sgt};function igt(n){const{inputs:t,backend:e,attrs:r}=n,{x:a,weights:s}=t,{size:o}=r,i=e.data.get(a.dataId).values,u=e.data.get(s.dataId).values,l=u_(i,u,s.dtype,s.shape,o);return e.makeTensorInfo([o],s.dtype,l)}const ugt={kernelName:zb,backendName:"cpu",kernelFunc:igt};function lgt(n){const{inputs:t,backend:e}=n,{s0:r,s1:a}=t,s=e.data.get(r.dataId).values,o=e.data.get(a.dataId).values,i=me(Array.from(s),Array.from(o));return e.makeTensorInfo([i.length],"int32",Int32Array.from(i))}const cgt={kernelName:Pb,backendName:"cpu",kernelFunc:lgt};const hgt=tn(xd,(n,t)=>{const e=t;return n>e.clipValueMax?e.clipValueMax:n<e.clipValueMin?e.clipValueMin:n}),dgt={kernelName:xd,backendName:"cpu",kernelFunc:hgt};const pgt=n=>{const{x:t}=n.inputs,e=n.backend,r=new Float32Array(xt(t.shape)),a=e.data.get(t.dataId),s=a.complexTensorInfos.real,o=a.complexTensorInfos.imag,i=e.data.get(s.dataId).values,u=e.data.get(o.dataId).values;for(let l=0;l<i.length;l++){const h=i[l],d=u[l];r[l]=Math.hypot(h,d)}return e.makeOutput(r,t.shape,"float32")},fgt={kernelName:_m,backendName:"cpu",kernelFunc:pgt};function id(n){const{inputs:t,backend:e}=n,{input:r}=t,a=e.data.get(r.dataId).complexTensorInfos.imag,s=e.data.get(a.dataId).values;return e.makeTensorInfo(a.shape,a.dtype,s)}const mgt={kernelName:ox,backendName:"cpu",kernelFunc:id};function ud(n){const{inputs:t,backend:e,attrs:r}=n,{axis:a}=r,s=_e(a,t[0].shape)[0],o=t.map(y=>y.shape);cE(o,s);let i=Fo(t.map(y=>y.shape),s);if(xt(i)===0)return e.makeTensorInfo(i,t[0].dtype,[]);const u=t.filter(y=>xt(y.shape)>0);if(u.length===1)return qo({inputs:{x:u[0]},backend:e});if(u[0].dtype==="complex64"){const y=u.map(C=>hc({inputs:{input:C},backend:e})),b=u.map(C=>id({inputs:{input:C},backend:e})),w=ud({inputs:y,backend:e,attrs:{axis:s}}),S=ud({inputs:b,backend:e,attrs:{axis:s}}),N=Pa({inputs:{real:w,imag:S},backend:e});return y.forEach(C=>e.disposeIntermediateTensorInfo(C)),b.forEach(C=>e.disposeIntermediateTensorInfo(C)),e.disposeIntermediateTensorInfo(w),e.disposeIntermediateTensorInfo(S),N}const l=u.map(y=>{const w=[-1,xt(y.shape.slice(s))];return gn({inputs:{x:y},backend:e,attrs:{shape:w}})}),h=l.map(y=>({vals:e.data.get(y.dataId).values,shape:y.shape}));i=Fo(l.map(y=>y.shape),1);const d=l[0].shape[0]===1,f=vW(h,i,t[0].dtype,d),m=Fo(u.map(y=>y.shape),s),v=e.makeTensorInfo(m,t[0].dtype,f);return l.forEach(y=>e.disposeIntermediateTensorInfo(y)),v}const ggt={kernelName:Rm,backendName:"cpu",kernelFunc:ud};function pG(n){const{inputs:t,backend:e,attrs:r}=n,{x:a,filter:s}=t,{strides:o,pad:i,dataFormat:u,dilations:l,dimRoundingMode:h}=r;Kt([a,s],"conv2d");const d=Li(u),f=Nr(a.shape,s.shape,o,l,i,h,!1,d),m=f.filterHeight,v=f.filterWidth,y=f.dilationHeight,b=f.dilationWidth,w=f.padInfo.left,S=f.padInfo.top,N=f.dataFormat==="channelsLast",C=new Yn(f.outShape,a.dtype),T=oe(a.shape),I=oe(s.shape),_=T[0],$=N?T[1]:T[2],R=N?T[2]:1,D=N?1:T[1],A=C.strides[0],L=N?C.strides[1]:C.strides[2],H=N?C.strides[2]:1,G=N?1:C.strides[1],q=e.data.get(a.dataId).values,B=e.data.get(s.dataId).values,j=C.values;for(let K=0;K<f.batchSize;++K){const z=K*_,U=K*A;for(let M=0;M<f.outHeight;++M){const X=U+M*L,Q=M*f.strideHeight-S;for(let rt=0;rt<m;++rt){const ct=Q+rt*y;if(ct<0||ct>=f.inHeight)continue;const pt=rt*I[0],yt=z+ct*$;for(let Tt=0;Tt<f.outWidth;++Tt){const gt=X+Tt*H,Rt=Tt*f.strideWidth-w;for(let At=0;At<v;++At){const Lt=Rt+At*b;if(Lt<0||Lt>=f.inWidth)continue;const Mt=pt+At*I[1],Wt=yt+Lt*R;let se=Mt;for(let Xt=0;Xt<f.inChannels;++Xt){const Se=q[Wt+Xt*D];for(let pe=0;pe<f.outChannels;++pe)j[gt+pe*G]+=Se*B[se+pe];se+=f.outChannels}}}}}}return e.makeTensorInfo(C.shape,C.dtype,j)}const vgt={kernelName:Am,backendName:"cpu",kernelFunc:pG};function ygt(n){const{inputs:t,backend:e,attrs:r}=n,{x:a,dy:s}=t,{strides:o,pad:i,dataFormat:u,dimRoundingMode:l,filterShape:h}=r;Kt([a,s],"conv2dBackpropFilter");const d=Li(u),f=Nr(a.shape,h,o,1,i,l,!1,d),{strideHeight:m,strideWidth:v,filterHeight:y,filterWidth:b}=f,w=f.dataFormat==="channelsLast",S=new Yn(f.filterShape,"float32"),N=f.padInfo.left,C=f.padInfo.top,T=e.data.get(a.dataId).values,I=e.data.get(s.dataId).values,_=new Yn(a.shape,a.dtype,T),$=new Yn(s.shape,s.dtype,I);for(let R=0;R<y;++R){const D=Math.max(0,Math.ceil((C-R)/m)),A=Math.min(f.outHeight,(f.inHeight+C-R)/m);for(let L=0;L<b;++L){const H=Math.max(0,Math.ceil((N-L)/v)),G=Math.min(f.outWidth,(f.inWidth+N-L)/v);for(let q=0;q<f.inChannels;++q)for(let B=0;B<f.outChannels;++B){let j=0;for(let K=0;K<f.batchSize;++K)for(let z=D;z<A;++z){const U=R+z*m-C;for(let M=H;M<G;++M){const X=L+M*v-N;w?j+=_.get(K,U,X,q)*$.get(K,z,M,B):j+=_.get(K,q,U,X)*$.get(K,B,z,M)}}S.set(j,R,L,q,B)}}}return e.makeTensorInfo(S.shape,S.dtype,S.values)}const bgt={kernelName:Ub,backendName:"cpu",kernelFunc:ygt};function xgt(n){const{inputs:t,backend:e,attrs:r}=n,{dy:a,filter:s}=t,{inputShape:o,strides:i,pad:u,dataFormat:l,dimRoundingMode:h}=r;Kt([a,s],"conv2dBackpropInput");const d=oe(s.shape),f=oe(a.shape);let m=Li(l);const v=Nr(o,s.shape,i,1,u,h,!1,m),y=new Yn(v.inShape,"float32"),b=y.values,w=e.data.get(a.dataId).values,S=e.data.get(s.dataId).values,[N,C,T]=d,{batchSize:I,filterHeight:_,filterWidth:$,inChannels:R,inHeight:D,inWidth:A,outChannels:L,outHeight:H,outWidth:G,strideHeight:q,strideWidth:B}=v;m=v.dataFormat;const j=_-1-v.padInfo.top,K=$-1-v.padInfo.left,z=m==="channelsLast",U=y.strides[0],M=z?y.strides[1]:y.strides[2],X=z?y.strides[2]:1,Q=z?1:y.strides[1],rt=f[0],ct=z?f[1]:f[2],pt=z?f[2]:1,yt=z?1:f[1];for(let Tt=0;Tt<I;++Tt)for(let gt=0;gt<R;++gt)for(let Rt=0;Rt<D;++Rt){const At=Rt-j,Lt=Math.max(0,Math.ceil(At/q)),Mt=Math.min(H,(_+At)/q);for(let Wt=0;Wt<A;++Wt){const se=Wt-K,Xt=Math.max(0,Math.ceil(se/B)),Se=Math.min(G,($+se)/B);let pe=0;for(let We=Lt;We<Mt;++We){const hn=We*q-At;for(let vn=Xt;vn<Se;++vn){const Hn=vn*B-se,Ge=rt*Tt+ct*We+pt*vn,Ot=N*(_-1-hn)+C*($-1-Hn)+T*gt;for(let Ht=0;Ht<L;++Ht){const Ce=w[Ge+yt*Ht],ge=S[Ot+Ht];pe+=Ce*ge}}}const Xe=U*Tt+M*Rt+X*Wt+Q*gt;b[Xe]=pe}}return e.makeTensorInfo(y.shape,y.dtype,y.values)}const wgt={kernelName:Dm,backendName:"cpu",kernelFunc:xgt};function Sgt(n){const{inputs:t,backend:e,attrs:r}=n,{x:a,filter:s}=t,{strides:o,pad:i,dilations:u}=r;Kt([a,s],"conv3d");const l=Zu(a.shape,s.shape,o,u,i),{filterDepth:h,filterHeight:d,filterWidth:f,dilationDepth:m,dilationHeight:v,dilationWidth:y,padInfo:b}=l,w=b.front,S=b.left,N=b.top,C=new Yn(l.outShape,a.dtype),T=e.data.get(a.dataId).values,I=e.data.get(s.dataId).values,_=C.values,$=oe(a.shape),R=oe(s.shape);for(let D=0;D<l.batchSize;++D){const A=D*$[0],L=D*C.strides[0];for(let H=0;H<l.outDepth;++H){const G=L+H*C.strides[1],q=H*l.strideDepth-w;for(let B=0;B<h;++B){const j=q+B*m;if(j<0||j>=l.inDepth)continue;const K=B*R[0],z=A+j*$[1];for(let U=0;U<l.outHeight;++U){const M=G+U*C.strides[2],X=U*l.strideHeight-N;for(let Q=0;Q<d;++Q){const rt=X+Q*v;if(rt<0||rt>=l.inHeight)continue;const ct=K+Q*R[1],pt=z+rt*$[2];for(let yt=0;yt<l.outWidth;++yt){const Tt=M+yt*l.outChannels,gt=yt*l.strideWidth-S;for(let Rt=0;Rt<f;++Rt){const At=gt+Rt*y;if(At<0||At>=l.inWidth)continue;const Lt=ct+Rt*R[2],Mt=pt+At*l.inChannels;let Wt=Lt;for(let se=0;se<l.inChannels;++se){const Xt=T[Mt+se];for(let Se=0;Se<l.outChannels;++Se)_[Tt+Se]+=Xt*I[Wt+Se];Wt+=l.outChannels}}}}}}}}return e.makeTensorInfo(C.shape,C.dtype,C.values)}const Cgt={kernelName:$m,backendName:"cpu",kernelFunc:Sgt};function Ngt(n){const{inputs:t,backend:e,attrs:r}=n,{x:a,dy:s}=t,{strides:o,pad:i,filterShape:u}=r;Kt([a,s],"conv3dBackpropFilterV2");const l=oe(a.shape),h=oe(s.shape),d=Zu(a.shape,u,o,1,i),f=d.strideDepth,m=d.strideHeight,v=d.strideWidth,y=d.filterDepth,b=d.filterHeight,w=d.filterWidth,S=new Yn(d.filterShape,"float32"),N=S.values,[C,T,I,_]=S.strides,$=e.data.get(s.dataId).values,[R,D,A,L]=h,H=e.data.get(a.dataId).values,[G,q,B,j]=l,K=d.padInfo.front,z=d.padInfo.left,U=d.padInfo.top;for(let M=0;M<y;++M){const X=Math.max(0,Math.ceil((K-M)/f)),Q=Math.min(d.outDepth,(d.inDepth+K-M)/f),rt=M*C;for(let ct=0;ct<b;++ct){const pt=Math.max(0,Math.ceil((U-ct)/m)),yt=Math.min(d.outHeight,(d.inHeight+U-ct)/m),Tt=ct*T+rt;for(let gt=0;gt<w;++gt){const Rt=Math.max(0,Math.ceil((z-gt)/v)),At=Math.min(d.outWidth,(d.inWidth+z-gt)/v),Lt=gt*I+Tt;for(let Mt=0;Mt<d.inChannels;++Mt){const Wt=Mt*_+Lt;for(let se=0;se<d.outChannels;++se){let Xt=0;for(let Se=0;Se<d.batchSize;++Se){const pe=Se*G,Xe=Se*R;for(let We=X;We<Q;++We){const vn=(M+We*f-K)*q+pe,Hn=We*D+Xe;for(let Ge=pt;Ge<yt;++Ge){const Ht=(ct+Ge*m-U)*B+vn,Ce=Ge*A+Hn;for(let ge=Rt;ge<At;++ge){const hr=(gt+ge*v-z)*j+Ht,Wr=ge*L+Ce;Xt+=H[hr+Mt]*$[Wr+se]}}}}N[Wt+se]=Xt}}}}}return e.makeTensorInfo(S.shape,S.dtype,S.values)}const kgt={kernelName:Wb,backendName:"cpu",kernelFunc:Ngt};function Tgt(n){const{inputs:t,backend:e,attrs:r}=n,{dy:a,filter:s}=t,{pad:o,strides:i,inputShape:u}=r;Kt([a],"conv3dBackpropInputV2");const l=oe(a.shape),h=oe(s.shape),d=Zu(u,s.shape,i,1,o),f=new Yn(d.inShape,"float32"),m=f.values,[v,y,b,w]=f.strides,S=e.data.get(a.dataId).values,[N,C,T,I]=l,_=e.data.get(s.dataId).values,[$,R,D,A]=h,{batchSize:L,filterDepth:H,filterHeight:G,filterWidth:q,inChannels:B,inDepth:j,inHeight:K,inWidth:z,outChannels:U,outDepth:M,outHeight:X,outWidth:Q,strideDepth:rt,strideHeight:ct,strideWidth:pt}=d,yt=H-1-d.padInfo.front,Tt=G-1-d.padInfo.top,gt=q-1-d.padInfo.left;for(let Rt=0;Rt<L;++Rt)for(let At=0;At<B;++At)for(let Lt=0;Lt<j;++Lt){const Mt=Lt-yt,Wt=Math.max(0,Math.ceil(Mt/rt)),se=Math.min(M,(H+Mt)/rt);for(let Xt=0;Xt<K;++Xt){const Se=Xt-Tt,pe=Math.max(0,Math.ceil(Se/ct)),Xe=Math.min(X,(G+Se)/ct);for(let We=0;We<z;++We){const hn=We-gt,vn=Math.max(0,Math.ceil(hn/pt)),Hn=Math.min(Q,(q+hn)/pt);let Ge=0;for(let Ot=Wt;Ot<se;++Ot){const Ht=Ot*rt-Mt;for(let Ce=pe;Ce<Xe;++Ce){const ge=Ce*ct-Se;for(let en=vn;en<Hn;++en){const hr=en*pt-hn,Wr=N*Rt+C*Ot+T*Ce+I*en,ti=$*(H-1-Ht)+R*(G-1-ge)+D*(q-1-hr)+A*At;for(let Er=0;Er<U;++Er){const Dn=S[Wr+Er],dr=_[ti+Er];Ge+=Dn*dr}}}}m[v*Rt+y*Lt+b*Xt+w*We+At]=Ge}}}return e.makeTensorInfo(f.shape,f.dtype,f.values)}const Egt={kernelName:Gb,backendName:"cpu",kernelFunc:Tgt};const Igt=tn(wd,n=>Math.cos(n)),_gt={kernelName:wd,backendName:"cpu",kernelFunc:Igt};const Rgt=tn(Sd,n=>Math.cosh(n)),Agt={kernelName:Sd,backendName:"cpu",kernelFunc:Rgt};function Dgt(n){const{inputs:t,backend:e,attrs:r}=n,{image:a,boxes:s,boxInd:o}=t,{cropSize:i,method:u,extrapolationValue:l}=r,[h,d,f,m]=a.shape,v=s.shape[0],[y,b]=i,w=we([v,y,b,m],"float32"),S=e.data.get(s.dataId).values,N=e.data.get(o.dataId).values,C=e.data.get(a.dataId).values,T=oe(a.shape),I=oe(w.shape);for(let _=0;_<v;_++){const $=_*4,R=S[$],D=S[$+1],A=S[$+2],L=S[$+3],H=N[_];if(H>=h)continue;const G=y>1?(A-R)*(d-1)/(y-1):0,q=b>1?(L-D)*(f-1)/(b-1):0;for(let B=0;B<y;B++){const j=y>1?R*(d-1)+B*G:.5*(R+A)*(d-1);if(j<0||j>d-1){for(let K=0;K<b;K++)for(let z=0;z<m;z++){const U=z+K*I[2]+B*I[1]+_*I[0];w.values[U]=l}continue}if(u==="bilinear"){const K=Math.floor(j),z=Math.ceil(j),U=j-K;for(let M=0;M<b;M++){const X=b>1?D*(f-1)+M*q:.5*(D+L)*(f-1);if(X<0||X>f-1){for(let pt=0;pt<m;pt++){const yt=pt+M*I[2]+B*I[1]+_*I[0];w.values[yt]=l}continue}const Q=Math.floor(X),rt=Math.ceil(X),ct=X-Q;for(let pt=0;pt<m;pt++){let yt=pt+Q*T[2]+K*T[1]+H*T[0];const Tt=C[yt];yt=pt+rt*T[2]+K*T[1]+H*T[0];const gt=C[yt];yt=pt+Q*T[2]+z*T[1]+H*T[0];const Rt=C[yt];yt=pt+rt*T[2]+z*T[1]+H*T[0];const At=C[yt],Lt=Tt+(gt-Tt)*ct,Mt=Rt+(At-Rt)*ct;yt=pt+M*I[2]+B*I[1]+_*I[0],w.values[yt]=Lt+(Mt-Lt)*U}}}else for(let K=0;K<b;++K){const z=b>1?D*(f-1)+K*q:.5*(D+L)*(f-1);if(z<0||z>f-1){for(let X=0;X<m;X++){const Q=X+K*I[2]+B*I[1]+_*I[0];w.values[Q]=l}continue}const U=Math.round(z),M=Math.round(j);for(let X=0;X<m;X++){const Q=X+U*T[2]+M*T[1]+H*T[0],rt=X+K*I[2]+B*I[1]+_*I[0];w.values[rt]=C[Q]}}}}return e.makeTensorInfo(w.shape,w.dtype,w.values)}const $gt={kernelName:jb,backendName:"cpu",kernelFunc:Dgt};function Ogt(n){const{inputs:t,backend:e,attrs:r}=n,{x:a}=t,{axis:s,exclusive:o,reverse:i}=r;Kt(a,"cumprod");const u=An([s],a.shape.length);let l=a;u!=null&&(l=Ea({inputs:{x:a},backend:e,attrs:{perm:u}}));const h=Un(1,a.shape.length)[0];if(h!==l.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${l.shape.length-1} but got axis=${h}`);const d=Sa(l.dtype,"int32"),f=Ob(xt(l.shape),d),m=e.data.get(l.dataId).values,v=l.shape[l.shape.length-1],y=i?(w,S)=>w+v-S-1:(w,S)=>w+S;for(let w=0;w<m.length;w+=v)for(let S=0;S<v;S++){const N=y(w,S);if(S===0)f[N]=o?1:m[N];else{const C=y(w,S-1);f[N]=o?m[C]*f[C]:m[N]*f[C]}}const b=e.makeTensorInfo(l.shape,d,f);if(u!=null){const w=Ju(u),S=Ea({inputs:{x:b},backend:e,attrs:{perm:w}});return e.disposeIntermediateTensorInfo(b),e.disposeIntermediateTensorInfo(l),S}return b}const Fgt={kernelName:Hb,backendName:"cpu",kernelFunc:Ogt};function Mgt(n){const{inputs:t,backend:e,attrs:r}=n,{x:a}=t,{axis:s,exclusive:o,reverse:i}=r;Kt(a,"cumsum");const u=An([s],a.shape.length);let l=a;u!=null&&(l=Ea({inputs:{x:a},backend:e,attrs:{perm:u}}));const h=Un(1,a.shape.length)[0];if(h!==l.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${l.shape.length-1} but got axis=${h}`);const d=Sa(l.dtype,"int32"),f=Mr(xt(l.shape),d),m=e.data.get(l.dataId).values,v=l.shape[l.shape.length-1],y=i?(w,S)=>w+v-S-1:(w,S)=>w+S;for(let w=0;w<m.length;w+=v)for(let S=0;S<v;S++){const N=y(w,S);if(S===0)f[N]=o?0:m[N];else{const C=y(w,S-1);f[N]=o?m[C]+f[C]:m[N]+f[C]}}const b=e.makeTensorInfo(l.shape,d,f);if(u!=null){const w=Ju(u),S=Ea({inputs:{x:b},backend:e,attrs:{perm:w}});return e.disposeIntermediateTensorInfo(b),e.disposeIntermediateTensorInfo(l),S}return b}const Lgt={kernelName:Om,backendName:"cpu",kernelFunc:Mgt};function Bgt(n){const{inputs:t,backend:e,attrs:r}=n,{x:a,weights:s}=t,{size:o,binaryOutput:i}=r;if(a.shape.length===1){const u=e.data.get(a.dataId).values,l=e.data.get(s.dataId).values,h=u_(u,l,s.dtype,s.shape,o);return e.makeTensorInfo([o],s.dtype,h)}else if(a.shape.length===2){const u=e.bufferSync(a),l=e.bufferSync(s),h=fW(u,l,o,i);return e.makeTensorInfo(h.shape,s.dtype,h.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${a.shape.length}.`)}const zgt={kernelName:qb,backendName:"cpu",kernelFunc:Bgt};function Pgt(n){const{inputs:t,backend:e,attrs:r}=n,{x:a}=t,{blockSize:s,dataFormat:o}=r;P(o==="NHWC",()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${o}`);const i=a.shape[0],u=a.shape[1],l=a.shape[2],h=a.shape[3],d=u*s,f=l*s,m=h/(s*s),v=e.data.get(a.dataId).values,y=new Float32Array(i*d*f*m);let b=0;for(let w=0;w<i;++w)for(let S=0;S<d;++S){const N=Math.floor(S/s),C=S%s;for(let T=0;T<f;++T){const I=Math.floor(T/s),_=T%s,$=(C*s+_)*m;for(let R=0;R<m;++R){const A=R+$+h*(I+l*(N+u*w));y[b++]=v[A]}}}return e.makeTensorInfo([i,d,f,m],a.dtype,y)}const Vgt={kernelName:Kb,backendName:"cpu",kernelFunc:Pgt};function fG(n){const{inputs:t,backend:e,attrs:r}=n,{x:a,filter:s}=t,{strides:o,pad:i,dilations:u,dimRoundingMode:l}=r;Kt([a,s],"depthwiseConv2DNative");const h=oe(a.shape),d=oe(s.shape);let f=u;f==null&&(f=[1,1]),P(zr(o,f),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${f}'`);const m=Nr(a.shape,s.shape,o,f,i,l,!0),{filterHeight:v,filterWidth:y,dilationHeight:b,dilationWidth:w,padInfo:S}=m,N=S.left,C=S.top,T=m.outChannels/m.inChannels,I=new Yn(m.outShape,a.dtype),_=e.data.get(a.dataId).values,$=e.data.get(s.dataId).values,R=I.values;for(let D=0;D<m.batchSize;++D){const A=D*h[0],L=D*I.strides[0];for(let H=0;H<m.outHeight;++H){const G=L+H*I.strides[1],q=H*m.strideHeight-C;for(let B=0;B<v;++B){const j=q+B*b;if(j<0||j>=m.inHeight)continue;const K=B*d[0],z=A+j*h[1];for(let U=0;U<m.outWidth;++U){const M=G+U*I.strides[2],X=U*m.strideWidth-N;for(let Q=0;Q<y;++Q){const rt=X+Q*w;if(rt<0||rt>=m.inWidth)continue;const ct=K+Q*d[1],pt=z+rt*m.inChannels;let yt=M,Tt=ct;for(let gt=0;gt<m.inChannels;++gt){const Rt=_[pt+gt];for(let At=0;At<T;++At)R[yt+At]+=Rt*$[Tt+At];yt+=T,Tt+=T}}}}}}return e.makeTensorInfo(I.shape,I.dtype,I.values)}const Ugt={kernelName:Fm,backendName:"cpu",kernelFunc:fG};function Wgt(n){const{inputs:t,backend:e,attrs:r}=n,{x:a,dy:s}=t,{strides:o,dilations:i,pad:u,dimRoundingMode:l,filterShape:h}=r;Kt([a,s],"depthwiseConv2dNativeBackpropFilter");const d=Nr(a.shape,h,o,i,u,l,!0),{strideHeight:f,strideWidth:m,filterHeight:v,filterWidth:y}=d,b=new Yn(d.filterShape,"float32"),w=d.padInfo.left,S=d.padInfo.top,N=d.outChannels/d.inChannels,C=e.data.get(a.dataId).values,T=new Yn(a.shape,a.dtype,C),I=e.data.get(s.dataId).values,_=new Yn(s.shape,s.dtype,I);for(let $=0;$<v;++$){const R=Math.max(0,Math.ceil((S-$)/f)),D=Math.min(d.outHeight,(d.inHeight+S-$)/f);for(let A=0;A<y;++A){const L=Math.max(0,Math.ceil((w-A)/m)),H=Math.min(d.outWidth,(d.inWidth+w-A)/m);for(let G=0;G<d.outChannels;++G){const q=Math.trunc(G/N),B=G%N;let j=0;for(let K=0;K<d.batchSize;++K)for(let z=R;z<D;++z){const U=$+z*f-S;for(let M=L;M<H;++M){const X=A+M*m-w;j+=T.get(K,U,X,q)*_.get(K,z,M,G)}}b.set(j,$,A,q,B)}}}return e.makeTensorInfo(b.shape,b.dtype,b.values)}const Ggt={kernelName:Xb,backendName:"cpu",kernelFunc:Wgt};function Hgt(n){const{inputs:t,backend:e,attrs:r}=n,{dy:a,filter:s}=t,{strides:o,dilations:i,pad:u,dimRoundingMode:l,inputShape:h}=r;Kt([a,s],"depthwiseConv2DNativeBackpropInput");const d=oe(a.shape),f=oe(s.shape),m=Nr(h,s.shape,o,i,u,l,!0),v=new Yn(m.inShape,"float32"),y=v.values,[b,w,S]=v.strides,N=e.data.get(a.dataId).values,[C,T,I]=d,_=e.data.get(s.dataId).values,[$,R,D]=f,{batchSize:A,filterHeight:L,filterWidth:H,inChannels:G,inHeight:q,inWidth:B,outChannels:j,outHeight:K,outWidth:z,strideHeight:U,strideWidth:M}=m,X=L-1-m.padInfo.top,Q=H-1-m.padInfo.left,rt=j/G;for(let ct=0;ct<A;++ct)for(let pt=0;pt<G;++pt)for(let yt=0;yt<q;++yt){const Tt=yt-X,gt=Math.max(0,Math.ceil(Tt/U)),Rt=Math.min(K,(L+Tt)/U);for(let At=0;At<B;++At){const Lt=At-Q,Mt=Math.max(0,Math.ceil(Lt/M)),Wt=Math.min(z,(H+Lt)/M);let se=0;for(let Xt=gt;Xt<Rt;++Xt){const Se=Xt*U-Tt;for(let pe=Mt;pe<Wt;++pe){const Xe=pe*M-Lt,We=C*ct+T*Xt+I*pe,hn=$*(L-1-Se)+R*(H-1-Xe)+D*pt;for(let vn=0;vn<rt;++vn){const Hn=pt*rt+vn,Ge=N[We+Hn],Ot=_[hn+vn];se+=Ge*Ot}}}y[b*ct+w*yt+S*At+pt]=se}}return e.makeTensorInfo(v.shape,v.dtype,v.values)}const jgt={kernelName:Yb,backendName:"cpu",kernelFunc:Hgt};function qgt(n){const{inputs:t,backend:e}=n,{x:r}=t,a=xt(r.shape),s=e.data.get(r.dataId).values,o=we([a,a],r.dtype),i=o.values;for(let l=0;l<s.length;l++)i[l*a+l]=s[l];const u=[...r.shape,...r.shape];return e.makeTensorInfo(u,o.dtype,o.values)}const Kgt={kernelName:Qb,backendName:"cpu",kernelFunc:qgt};const Xgt={kernelName:Mm,backendName:"cpu",kernelFunc:({inputs:n,backend:t,attrs:e})=>{const{x:r,filter:a}=n,{strides:s,pad:o,dilations:i}=e,u=t,l=u.data.get(r.dataId).values,h=r.shape.length,d=u.data.get(a.dataId).values,f=a.shape.length,{batchSize:m,inHeight:v,inWidth:y,inChannels:b,outHeight:w,outWidth:S,padInfo:N,strideHeight:C,strideWidth:T,filterHeight:I,filterWidth:_,dilationHeight:$,dilationWidth:R,outShape:D}=kg(r.shape,a.shape,s,o,"NHWC",i),A=xt(D),L=D.length,H=On(r.dtype,A);for(let q=0;q<m;++q)for(let B=0;B<w;++B){const j=B*C-N.top;for(let K=0;K<S;++K){const z=K*T-N.left;for(let U=0;U<b;++U){let M=Number.MIN_SAFE_INTEGER;for(let Q=0;Q<I;++Q){const rt=j+Q*$;if(rt>=0&&rt<v)for(let ct=0;ct<_;++ct){const pt=z+ct*R;if(pt>=0&&pt<y){const yt=eo([q,rt,pt,U],h,oe(r.shape)),Tt=eo([Q,ct,U],f,oe(a.shape)),gt=l[yt]+d[Tt];gt>M&&(M=gt)}}}const X=eo([q,B,K,U],L,oe(D));H[X]=M}}}return{dataId:u.write(Yu(H,r.dtype),D,r.dtype),shape:D,dtype:r.dtype}}};const Ygt={kernelName:M0,backendName:"cpu",kernelFunc:({inputs:n,backend:t,attrs:e})=>{const{x:r,filter:a,dy:s}=n,{strides:o,pad:i,dilations:u}=e,l=t,h=ms(r.shape,l.data.get(r.dataId).values),d=ms(a.shape,l.data.get(a.dataId).values),{batchSize:f,inHeight:m,inWidth:v,inChannels:y,outHeight:b,outWidth:w,padInfo:S,strideHeight:N,strideWidth:C,filterHeight:T,filterWidth:I,dilationHeight:_,dilationWidth:$,outShape:R}=kg(r.shape,a.shape,o,i,"NHWC",u);P(s.rank===R.length,()=>`Error in ${M0}, dy must have the same rank as output ${R.length}, but got ${s.rank}`);const D=ms(R,l.data.get(s.dataId).values),A=Rk(a.shape,a.dtype);for(let H=0;H<f;++H)for(let G=0;G<b;++G){const q=G*N-S.top;for(let B=0;B<w;++B){const j=B*C-S.left;for(let K=0;K<y;++K){let z=Number.MIN_SAFE_INTEGER,U=0,M=0;for(let X=0;X<T;++X){const Q=q+X*_;if(Q>=0&&Q<m)for(let rt=0;rt<I;++rt){const ct=j+rt*$;if(ct>=0&&ct<v){const pt=h[H][Q][ct][K]+d[X][rt][K];pt>z&&(z=pt,U=X,M=rt)}}}A[U][M][K]+=D[H][G][B][K]}}}return{dataId:l.write(Yu(A,r.dtype),a.shape,a.dtype),shape:a.shape,dtype:a.dtype}}};const Qgt={kernelName:F0,backendName:"cpu",kernelFunc:({inputs:n,backend:t,attrs:e})=>{const{x:r,filter:a,dy:s}=n,{strides:o,pad:i,dilations:u}=e,l=t,h=ms(r.shape,l.data.get(r.dataId).values),d=ms(a.shape,l.data.get(a.dataId).values),{batchSize:f,inHeight:m,inWidth:v,inChannels:y,outHeight:b,outWidth:w,padInfo:S,strideHeight:N,strideWidth:C,filterHeight:T,filterWidth:I,dilationHeight:_,dilationWidth:$,outShape:R}=kg(r.shape,a.shape,o,i,"NHWC",u);P(s.rank===R.length,()=>`Error in ${F0}, dy must have the same rank as output ${R.length}, but got ${s.rank}`);const D=ms(R,l.data.get(s.dataId).values),A=Rk(r.shape,r.dtype);for(let H=0;H<f;++H)for(let G=0;G<b;++G){const q=G*N-S.top;for(let B=0;B<w;++B){const j=B*C-S.left;for(let K=0;K<y;++K){let z=Number.MIN_SAFE_INTEGER,U=q<0?0:q,M=j<0?0:j;for(let X=0;X<T;++X){const Q=q+X*_;if(Q>=0&&Q<m)for(let rt=0;rt<I;++rt){const ct=j+rt*$;if(ct>=0&&ct<v){const pt=h[H][Q][ct][K]+d[X][rt][K];pt>z&&(z=pt,U=Q,M=ct)}}}A[H][U][M][K]+=D[H][G][B][K]}}}return{dataId:l.write(Yu(A,r.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};function Zgt(n){const{inputs:t,backend:e,attrs:r}=n,{image:a}=t,{canvas:s,options:o}=r,{contextOptions:i,imageOptions:u}=o||{},l=u?.alpha||1,h=i?.contextType||"2d";if(h!=="2d")throw new Error(`Context type ${i.contextType} is not supported by the CPU backend.`);const d=s.getContext(h,i?.contextAttributes||{});if(d==null)throw new Error(`Could not get the context with ${h} type.`);const[f,m]=a.shape.slice(0,2),v=a.shape.length===2?1:a.shape[2],y=e.data.get(a.dataId).values,b=a.dtype==="float32"?255:1,w=new Uint8ClampedArray(m*f*4);for(let N=0;N<f*m;++N){const C=[0,0,0,255*l];for(let I=0;I<v;I++){const _=y[N*v+I];if(a.dtype==="float32"){if(_<0||_>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${_}.`)}else if(a.dtype==="int32"&&(_<0||_>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${_}.`);v===1?(C[0]=_*b,C[1]=_*b,C[2]=_*b):C[I]=_*b}const T=N*4;w[T+0]=Math.round(C[0]),w[T+1]=Math.round(C[1]),w[T+2]=Math.round(C[2]),w[T+3]=Math.round(C[3])}s.width=m,s.height=f;const S=new ImageData(w,m,f);return d.putImageData(S,0,0),a}const Jgt={kernelName:Zb,backendName:"cpu",kernelFunc:Zgt};function dv(n){const{inputs:t,backend:e,attrs:r}=n,{x:a}=t,{axis:s,keepDims:o}=r;Kt(a,"sum");let i;a.dtype==="bool"?i=Ku({inputs:{x:a},backend:e,attrs:{dtype:"int32"}}):i=qo({inputs:{x:a},backend:e});const u=i.shape.length,l=_e(s,i.shape),h=An(l,u);let d=l,f=i;h!=null&&(f=Ea({inputs:{x:i},backend:e,attrs:{perm:h}}),d=Un(d.length,u)),Pr("sum",d,f.shape.length);const[m,v]=kr(f.shape,d),y=Sa(f.dtype,"int32");let b=Cb(e,m,y);const w=xt(v),S=e.data.get(b.dataId).values,N=e.data.get(f.dataId).values;for(let C=0;C<S.length;++C){const T=C*w;let I=0;for(let _=0;_<w;++_)I+=N[T+_];S[C]=I}if(o){const C=Vn(b.shape,l),T=b;b=gn({inputs:{x:b},backend:e,attrs:{shape:C}}),e.disposeIntermediateTensorInfo(T)}return e.disposeIntermediateTensorInfo(i),h!=null&&e.disposeIntermediateTensorInfo(f),b}const tvt={kernelName:mg,backendName:"cpu",kernelFunc:dv};function evt(n){const{inputs:t,backend:e,attrs:r}=n,{equation:a}=r,s=t,{allDims:o,summedDims:i,idDims:u}=SE(a,s.length);NE(o.length,u,s);const{path:l,steps:h}=kE(i,u),d=h.length;let f=null,m=o.length;const v=[];for(let y=0;y<d;++y){for(const b of h[y]){const{permutationIndices:w,expandDims:S}=CE(m,u[b]);let N;TE(w)?N=s[b]:(N=Ea({inputs:{x:s[b]},backend:e,attrs:{perm:w}}),v.push(N));const C=N.shape.slice();for(let T=0;T<S.length;++T)C.splice(S[T],0,1);De(N.shape,C)||(N=gn({inputs:{x:N},backend:e,attrs:{shape:C}}),v.push(N)),f===null?f=N:(f=aw({inputs:{a:N,b:f},backend:e}),v.push(f))}y<d-1&&(l[y]>=0&&(f=dv({inputs:{x:f},backend:e,attrs:{axis:l[y]-(o.length-m),keepDims:!1}}),v.push(f)),m--)}for(const y of v)y!==f&&e.disposeIntermediateTensorInfo(y);return f}const nvt={kernelName:Jb,backendName:"cpu",kernelFunc:evt};function rvt(n){const{inputs:t,backend:e}=n,{dy:r,y:a}=t;Kt([r,a],"eluGrad");const s=new Float32Array(xt(a.shape)),o=e.data.get(a.dataId).values,i=e.data.get(r.dataId).values;for(let u=0;u<o.length;++u){const l=o[u];l>=0?s[u]=i[u]:s[u]=i[u]*(l+1)}return e.makeTensorInfo(a.shape,"float32",s)}const avt={kernelName:tx,backendName:"cpu",kernelFunc:rvt};const svt=mE,ovt=gE,ivt=vE,uvt=yE,lvt=bE,cvt=xE,hvt=tn(kd,n=>{const t=Math.sign(n),e=Math.abs(n),r=1/(1+svt*e);return t*(1-((((cvt*r+lvt)*r+uvt)*r+ivt)*r+ovt)*r*Math.exp(-e*e))}),dvt={kernelName:kd,backendName:"cpu",kernelFunc:hvt};function Tb(n){const{inputs:t,backend:e,attrs:r}=n,{input:a}=t,{dim:s}=r,o=a.shape.length,i=a.shape.slice();let u=s;return s<0&&(P(-(o+1)<=s,()=>`Axis must be in the interval [${-(o+1)}, ${o}]`),u=o+s+1),i.splice(u,0,1),gn({inputs:{x:a},backend:e,attrs:{shape:i}})}const pvt={kernelName:Bm,backendName:"cpu",kernelFunc:Tb};const fvt=Gn((n,t)=>n/t),f_=cr(Cd,fvt),fk={kernelName:Cd,backendName:"cpu",kernelFunc:f_};function mG(n,t,e){const r=n.shape,a=r[0],s=r[1],o=e.data.get(n.dataId),i=o.complexTensorInfos.real,u=o.complexTensorInfos.imag,l=[a,s],h=xt(l),d=xr("float32",h),f=xr("float32",h);for(let b=0;b<a;b++){const w=dc({inputs:{x:i},backend:e,attrs:{begin:[b,0],size:[1,s]}}),S=dc({inputs:{x:u},backend:e,attrs:{begin:[b,0],size:[1,s]}}),N=Pa({inputs:{real:w,imag:S},backend:e}),{real:C,imag:T}=mvt(N,t,e),I=Di(C,T);for(let _=0;_<s;_++){const $=wE(I,_);d[b*s+_]=$.real,f[b*s+_]=$.imag}e.disposeIntermediateTensorInfo(w),e.disposeIntermediateTensorInfo(S),e.disposeIntermediateTensorInfo(N)}const m=e.makeTensorInfo(l,"float32",d),v=e.makeTensorInfo(l,"float32",f),y=Pa({inputs:{real:m,imag:v},backend:e});return e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(v),y}function mvt(n,t,e){const r=xt(n.shape),a=e.data.get(n.dataId),s=e.data.get(a.complexTensorInfos.real.dataId).values,o=e.data.get(a.complexTensorInfos.imag.dataId).values;if(gvt(r)){const i=mk(s,o,r,t,e),u=[n.shape[0],n.shape[1]];if(t){const l=e.makeTensorInfo(u,"float32",i.real),h=e.makeTensorInfo(u,"float32",i.imag),d=e.makeTensorInfo([],"float32",Fi(r,"float32")),f=qo({inputs:{x:d},backend:e}),m=fk.kernelFunc({inputs:{a:l,b:d},backend:e}),v=fk.kernelFunc({inputs:{a:h,b:f},backend:e}),y=e.data.get(m.dataId).values,b=e.data.get(v.dataId).values;return e.disposeIntermediateTensorInfo(l),e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(v),{real:y,imag:b}}return i}else{const i=Di(s,o),u=vvt(i,r,t);return H4(u)}}function gvt(n){return(n&n-1)===0}function mk(n,t,e,r,a){if(e===1)return{real:n,imag:t};const s=Di(n,t),o=e/2,i=j4(s),u=i.real,l=i.imag,h=[u.length],d=a.makeTensorInfo(h,"float32",u),f=a.makeTensorInfo(h,"float32",l),m=Pa({inputs:{real:d,imag:f},backend:a}),v=q4(s),y=v.real,b=v.imag,w=[y.length],S=a.makeTensorInfo(w,"float32",y),N=a.makeTensorInfo(w,"float32",b),C=Pa({inputs:{real:S,imag:N},backend:a}),T=mk(u,l,o,r,a),I=T.real,_=T.imag,$=[I.length],R=a.makeTensorInfo($,"float32",I),D=a.makeTensorInfo($,"float32",_),A=Pa({inputs:{real:R,imag:D},backend:a}),L=mk(y,b,o,r,a),H=L.real,G=L.imag,q=[H.length],B=a.makeTensorInfo(q,"float32",H),j=a.makeTensorInfo(q,"float32",G),K=Pa({inputs:{real:B,imag:j},backend:a}),z=X4(e,r),U=[z.real.length],M=a.makeTensorInfo(U,"float32",z.real),X=a.makeTensorInfo(U,"float32",z.imag),Q=Pa({inputs:{real:M,imag:X},backend:a}),rt=aw({inputs:{a:Q,b:K},backend:a}),ct=od({inputs:{a:A,b:rt},backend:a}),pt=d_({inputs:{a:A,b:rt},backend:a}),yt=hc({inputs:{input:ct},backend:a}),Tt=hc({inputs:{input:pt},backend:a}),gt=id({inputs:{input:ct},backend:a}),Rt=id({inputs:{input:pt},backend:a}),At=ud({inputs:[yt,Tt],backend:a,attrs:{axis:0}}),Lt=ud({inputs:[gt,Rt],backend:a,attrs:{axis:0}}),Mt=a.data.get(At.dataId).values,Wt=a.data.get(Lt.dataId).values;return a.disposeIntermediateTensorInfo(d),a.disposeIntermediateTensorInfo(f),a.disposeIntermediateTensorInfo(m),a.disposeIntermediateTensorInfo(S),a.disposeIntermediateTensorInfo(N),a.disposeIntermediateTensorInfo(C),a.disposeIntermediateTensorInfo(R),a.disposeIntermediateTensorInfo(D),a.disposeIntermediateTensorInfo(A),a.disposeIntermediateTensorInfo(B),a.disposeIntermediateTensorInfo(j),a.disposeIntermediateTensorInfo(K),a.disposeIntermediateTensorInfo(M),a.disposeIntermediateTensorInfo(X),a.disposeIntermediateTensorInfo(Q),a.disposeIntermediateTensorInfo(rt),a.disposeIntermediateTensorInfo(ct),a.disposeIntermediateTensorInfo(pt),a.disposeIntermediateTensorInfo(yt),a.disposeIntermediateTensorInfo(gt),a.disposeIntermediateTensorInfo(Tt),a.disposeIntermediateTensorInfo(Rt),a.disposeIntermediateTensorInfo(At),a.disposeIntermediateTensorInfo(Lt),{real:Mt,imag:Wt}}function vvt(n,t,e){const r=new Float32Array(t*2);for(let a=0;a<t;a++){let s=0,o=0;for(let i=0;i<t;i++){const u=Y4(a*i,t,e),l=wE(n,i);s+=l.real*u.real-l.imag*u.imag,o+=l.real*u.imag+l.imag*u.real}e&&(s/=t,o/=t),K4(r,s,o,a)}return r}function yvt(n){const{inputs:t,backend:e}=n,{input:r}=t,a=xt(r.shape),s=r.shape[r.shape.length-1],o=a/s,i=gn({inputs:{x:r},backend:e,attrs:{shape:[o,s]}}),u=mG(i,!1,e),l=gn({inputs:{x:u},backend:e,attrs:{shape:r.shape}});return e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(u),l}const bvt={kernelName:ex,backendName:"cpu",kernelFunc:yvt};function m_(n){const{backend:t,attrs:e}=n,{shape:r,value:a,dtype:s}=e,o=s||gc(a),i=On(o,xt(r));return wvt(i,a,o),t.makeTensorInfo(r,o,i)}const xvt={kernelName:nx,backendName:"cpu",kernelFunc:m_};function wvt(n,t,e){n.fill(t)}const Svt={kernelName:rx,backendName:"cpu",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{image:r}=n,a=e,s=xr(r.dtype,xt(r.shape)),[o,i,u,l]=r.shape,h=a.data.get(r.dataId).values;for(let f=0;f<o;f++){const m=f*u*i*l;for(let v=0;v<i;v++){const y=v*(u*l);for(let b=0;b<u;b++){const w=b*l;for(let S=0;S<l;S++){const N=Math.round(u-b-1),C=m+y+w+S;let T=h[C];if(N>=0&&N<u){const I=N*l,_=m+y+I+S;T=h[_]}s[C]=T}}}}return{dataId:a.write(s,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};function Cvt(n){const{inputs:t,backend:e,attrs:r}=n,{x:a,filter:s,bias:o,preluActivationWeights:i}=t,{strides:u,pad:l,dataFormat:h,dilations:d,dimRoundingMode:f,activation:m,leakyreluAlpha:v}=r;let y=pG({inputs:{x:a,filter:s},backend:e,attrs:{strides:u,pad:l,dataFormat:h,dilations:d,dimRoundingMode:f}});if(o){const b=y;if(h==="NCHW"&&o.shape.length===1&&o.shape[0]!==1){const w=gn({inputs:{x:o},backend:e,attrs:{shape:[o.shape[0],1,1]}});y=od({inputs:{a:y,b:w},backend:e}),e.disposeIntermediateTensorInfo(w)}else y=od({inputs:{a:y,b:o},backend:e});e.disposeIntermediateTensorInfo(b)}if(m){const b=y;if(h==="NCHW"&&m==="prelu"&&i.shape.length===1&&i.shape[0]!==1){const w=gn({inputs:{x:i},backend:e,attrs:{shape:[i.shape[0],1,1]}});y=kb(e,y,m,w,v),e.disposeIntermediateTensorInfo(w)}else y=kb(e,y,m,i,v);e.disposeIntermediateTensorInfo(b)}return y}const Nvt={kernelName:qf,backendName:"cpu",kernelFunc:Cvt};function kvt(n){const{inputs:t,backend:e,attrs:r}=n,{x:a,filter:s,bias:o,preluActivationWeights:i}=t,{strides:u,pad:l,dataFormat:h,dilations:d,dimRoundingMode:f,activation:m,leakyreluAlpha:v}=r;let y=fG({inputs:{x:a,filter:s},backend:e,attrs:{strides:u,pad:l,dataFormat:h,dilations:d,dimRoundingMode:f}});if(o){const b=y;y=od({inputs:{a:y,b:o},backend:e}),e.disposeIntermediateTensorInfo(b)}if(m){const b=y;y=kb(e,y,m,i,v),e.disposeIntermediateTensorInfo(b)}return y}const Tvt={kernelName:Kf,backendName:"cpu",kernelFunc:kvt};function Evt(n){const{inputs:t,backend:e}=n,{params:r,indices:a}=t,s=xt(r.shape),o=a.shape,i=o[o.length-1],[u,l,h,d]=T1(r,a);if(l===0)return e.makeTensorInfo(u,r.dtype,[]);const f=e.data.get(a.dataId).values,m=e.bufferSync(r),v=kW(f,m,r.dtype,l,i,h,d,r.shape,s);return e.makeTensorInfo(u,r.dtype,v.values)}const Ivt={kernelName:ax,backendName:"cpu",kernelFunc:Evt};function _vt(n){const{inputs:t,backend:e,attrs:r}=n,{x:a,indices:s}=t,{axis:o,batchDims:i}=r;Kt([a,s],"gatherV2");const u=_e(o,a.shape)[0],l=e.data.get(s.dataId).values,h=a.shape[u];for(let C=0;C<l.length;++C){const T=l[C];P(T<=h-1&&T>=0,()=>`GatherV2: the index value ${T} is not in [0, ${h-1}]`)}let d=i;i==null&&(d=0);const f=xt(s.shape),m=IE(a,s,u,d),v=gn({inputs:{x:a},backend:e,attrs:{shape:[m.batchSize,m.outerSize,m.dimSize,m.sliceSize]}}),y=gn({inputs:{x:s},backend:e,attrs:{shape:[m.batchSize,f/m.batchSize]}}),b=[m.batchSize,m.outerSize,f/m.batchSize,m.sliceSize],w=e.bufferSync(y),S=e.bufferSync(v),N=TW(S,w,b);return e.disposeIntermediateTensorInfo(v),e.disposeIntermediateTensorInfo(y),e.makeTensorInfo(m.outputShape,N.dtype,N.values)}const Rvt={kernelName:Pm,backendName:"cpu",kernelFunc:_vt};function Avt(n){const{inputs:t,backend:e}=n,{input:r}=t,a=xt(r.shape),s=r.shape[r.shape.length-1],o=a/s,i=gn({inputs:{x:r},backend:e,attrs:{shape:[o,s]}}),u=mG(i,!0,e),l=gn({inputs:{x:u},backend:e,attrs:{shape:r.shape}});return e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(u),l}const Dvt={kernelName:sx,backendName:"cpu",kernelFunc:Avt};const $vt=tn(Dd,n=>Number.isFinite(n)?1:0,"bool"),Ovt={kernelName:Dd,backendName:"cpu",kernelFunc:$vt};const Fvt=tn($d,n=>Math.abs(n)===1/0?1:0,"bool"),Mvt={kernelName:$d,backendName:"cpu",kernelFunc:Fvt};const Lvt=tn(Od,n=>Number.isNaN(n)?1:0,"bool"),Bvt={kernelName:Od,backendName:"cpu",kernelFunc:Lvt};function zvt(n){const{backend:t,attrs:e}=n,{start:r,stop:a,num:s}=e,o=AW(r,a,s);return t.makeTensorInfo([o.length],"float32",o)}const Pvt={kernelName:ix,backendName:"cpu",kernelFunc:zvt};const Vvt=tn(Md,n=>Math.log1p(n)),Uvt={kernelName:Md,backendName:"cpu",kernelFunc:Vvt};const Wvt=Gn((n,t)=>n&&t),Gvt=cr(Hm,Wvt,null,"bool"),Hvt={kernelName:Hm,backendName:"cpu",kernelFunc:Gvt};const jvt=tn(jm,n=>n?0:1,"bool"),qvt={kernelName:jm,backendName:"cpu",kernelFunc:jvt};const Kvt=Gn((n,t)=>n||t),Xvt=cr(qm,Kvt,null,"bool"),Yvt={kernelName:qm,backendName:"cpu",kernelFunc:Xvt};function Qvt(n){const{inputs:t,backend:e,attrs:r}=n,{x:a}=t,{depthRadius:s,bias:o,alpha:i,beta:u}=r;Kt(a,"LRN");const l=a.shape[3],h=l-1,d=e.data.get(a.dataId).values,f=xt(a.shape),m=new Float32Array(f);function v(y){const b=y%l;let w=y-b+Math.max(0,b-s);const S=y-b+Math.min(b+s,h);let N=0;for(;w<=S;w++){const C=d[w];N+=C*C}return N}for(let y=0;y<f;y++){const b=v(y),w=d[y]*Math.pow(o+i*b,-u);m[y]=w}return e.makeTensorInfo(a.shape,a.dtype,m)}const Zvt={kernelName:Km,backendName:"cpu",kernelFunc:Qvt};function Jvt(n){const{inputs:t,backend:e,attrs:r}=n,{x:a,y:s,dy:o}=t,{depthRadius:i,bias:u,alpha:l,beta:h}=r;Kt(o,"LRNGrad");const d=xt(o.shape),f=o.shape[3],m=e.data.get(o.dataId).values,v=e.data.get(a.dataId).values,y=e.data.get(s.dataId).values,b=new Float32Array(d),w=d;for(let S=0;S<w;S++){const N=S%f,C=S-N+Math.max(0,N-i),T=S-N+Math.min(f,N+i+1);let I=0;for(let _=C;_<T;_++)I+=Math.pow(v[_],2);I=l*I+u;for(let _=C;_<T;_++){let $=-2*l*h*v[_]*y[S]/I;S===_&&($+=Math.pow(I,-h)),$*=m[S],b[_]+=$}}return e.makeTensorInfo(o.shape,a.dtype,b)}const tyt={kernelName:ux,backendName:"cpu",kernelFunc:Jvt};function gG(n){const{inputs:t,backend:e,attrs:r}=n,{x:a}=t,{reductionIndices:s,keepDims:o}=r,i=e;let u=a.shape;const l=u.length,h=_e(s,u);let d=h;const f=An(d,l);let m=i.data.get(a.dataId).values;if(f!=null){const C=new Array(l);for(let T=0;T<C.length;T++)C[T]=u[f[T]];m=c_(m,u,a.dtype,f,C),d=Un(d.length,l),u=C}Kt(a,"max"),Pr("max",d,l);const[v,y]=kr(u,d),b=xt(y),w=$W(m,b,v,a.dtype),S=i.write(w,v,a.dtype);let N=v;return o&&(N=Vn(v,h)),{dataId:S,shape:N,dtype:a.dtype}}const eyt={kernelName:Xm,backendName:"cpu",kernelFunc:gG};function nyt(n){const{inputs:t,backend:e,attrs:r}=n,{x:a}=t;Kt(a,"maxPool");const{filterSize:s,strides:o,pad:i,dimRoundingMode:u}=r,l=1;P(zr(o,l),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${l}'`);const h=Vs(a.shape,s,o,l,i,u);let d;if(h.filterWidth===1&&h.filterHeight===1&&De(h.inShape,h.outShape))d=qo({inputs:{x:a},backend:e});else{const f=e.data.get(a.dataId).values,m=oe(a.shape),v=p_(f,a.shape,a.dtype,m,h,"max");d=e.makeTensorInfo(h.outShape,a.dtype,v.values)}return d}const ryt={kernelName:Ym,backendName:"cpu",kernelFunc:nyt};function ayt(n){const{inputs:t,backend:e,attrs:r}=n,{x:a}=t,{filterSize:s,strides:o,pad:i,dimRoundingMode:u,dataFormat:l}=r;Kt(a,"maxPool3d");const h=Mi(a.shape,s,o,1,i,u,l),d=e.data.get(a.dataId).values,f=dG(d,a.shape,a.dtype,oe(a.shape),h,"max");return e.makeTensorInfo(f.shape,"float32",f.values)}const syt={kernelName:Qm,backendName:"cpu",kernelFunc:ayt};function oyt(n){const{inputs:t,backend:e,attrs:r}=n,{dy:a,input:s}=t,{filterSize:o,strides:i,pad:u,dimRoundingMode:l}=r;Kt([a,s],"maxPool3DGrad");const h=Mi(s.shape,o,i,1,u,l),d=e.bufferSync(s),f=Kmt(d,h),m=h.strideDepth,v=h.strideHeight,y=h.strideWidth,b=h.dilationDepth,w=h.dilationHeight,S=h.dilationWidth,N=h.effectiveFilterDepth,C=h.effectiveFilterHeight,T=h.effectiveFilterWidth,I=N-1-h.padInfo.front,_=T-1-h.padInfo.left,$=C-1-h.padInfo.top,R=we(s.shape,"float32"),D=e.bufferSync(a);for(let A=0;A<h.batchSize;++A)for(let L=0;L<h.inChannels;++L)for(let H=0;H<h.inDepth;++H)for(let G=0;G<h.inHeight;++G)for(let q=0;q<h.inWidth;++q){const B=H-I,j=G-$,K=q-_;let z=0;for(let U=0;U<N;U+=b){const M=(B+U)/m;if(!(M<0||M>=h.outDepth||Math.floor(M)!==M))for(let X=0;X<C;X+=w){const Q=(j+X)/v;if(!(Q<0||Q>=h.outHeight||Math.floor(Q)!==Q))for(let rt=0;rt<T;rt+=S){const ct=(K+rt)/y;if(ct<0||ct>=h.outWidth||Math.floor(ct)!==ct)continue;const pt=N*C*T-1-f.get(A,M,Q,ct,L),yt=U*C*T+X*T+rt,Tt=pt===yt?1:0;if(Tt===0)continue;const gt=D.get(A,M,Q,ct,L);z+=gt*Tt}}}R.set(z,A,H,G,q,L)}return e.makeTensorInfo(R.shape,R.dtype,R.values)}const iyt={kernelName:cx,backendName:"cpu",kernelFunc:oyt};function uyt(n){const{inputs:t,backend:e,attrs:r}=n,{dy:a,input:s,output:o}=t,i=s;Kt([s,o],"maxPoolGrad");const{filterSize:u,strides:l,pad:h,dimRoundingMode:d}=r,f=Vs(i.shape,u,l,1,h,d),m=e.data.get(i.dataId).values,v=we(f.outShape,i.dtype,hG(m,i.shape,i.dtype,f).values),y=f.strideHeight,b=f.strideWidth,w=f.dilationHeight,S=f.dilationWidth,N=f.effectiveFilterHeight,C=f.effectiveFilterWidth,T=C-1-f.padInfo.left,I=N-1-f.padInfo.top,_=we(i.shape,"float32"),$=e.data.get(a.dataId).values,R=we(a.shape,"float32",$);for(let D=0;D<f.batchSize;++D)for(let A=0;A<f.inChannels;++A)for(let L=0;L<f.inHeight;++L)for(let H=0;H<f.inWidth;++H){const G=L-I,q=H-T;let B=0;for(let j=0;j<N;j+=w){const K=(G+j)/y;if(!(K<0||K>=f.outHeight||Math.floor(K)!==K))for(let z=0;z<C;z+=S){const U=(q+z)/b;if(U<0||U>=f.outWidth||Math.floor(U)!==U)continue;const M=N*C-1-v.get(D,K,U,A),X=j*C+z,Q=M===X?1:0;if(Q===0)continue;const rt=R.get(D,K,U,A);B+=rt*Q}}_.set(B,D,L,H,A)}return e.makeTensorInfo(_.shape,_.dtype,_.values)}const lyt={kernelName:lx,backendName:"cpu",kernelFunc:uyt};function cyt(n,t,e,r,a){const s=oe(t),o=p_(n,t,e,s,a,"max"),i=hG(n,t,e,a,!0,r);return[o.values,i.values]}const hyt={kernelName:hx,backendName:"cpu",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{x:r}=n,{filterSize:a,strides:s,pad:o,includeBatchInIndex:i}=t,u=e;Kt(r,"MaxPoolWithArgmax");const l=u.data.get(r.dataId).values,h=Vs(r.shape,a,s,[1,1],o),[d,f]=cyt(l,r.shape,r.dtype,i,h),m=u.write(d,h.outShape,r.dtype),v=u.write(f,h.outShape,r.dtype);return[{dataId:m,shape:h.outShape,dtype:r.dtype},{dataId:v,shape:h.outShape,dtype:"int32"}]}};function dyt(n){const{inputs:t,backend:e,attrs:r}=n,{x:a}=t,{axis:s,keepDims:o}=r,i=_e(s,a.shape),l=kr(a.shape,i)[1],h=xt(l),d=[],f=e.makeTensorInfo([],"float32",new Float32Array([h]));d.push(f);const m=Ku({inputs:{x:a},backend:e,attrs:{dtype:"float32"}});d.push(m);const v=f_({inputs:{a:m,b:f},backend:e});d.push(v);const y=dv({inputs:{x:v},backend:e,attrs:{axis:s,keepDims:o}});return d.forEach(b=>e.disposeIntermediateTensorInfo(b)),y}const pyt={kernelName:Zm,backendName:"cpu",kernelFunc:dyt};function fyt(n){const{inputs:t,backend:e,attrs:r}=n,{x:a}=t,{axis:s,keepDims:o}=r;Kt(a,"min");const i=_e(s,a.shape);let u=i;const l=An(u,a.shape.length);let h=a;l!=null&&(h=Ea({inputs:{x:a},backend:e,attrs:{perm:l}}),u=Un(u.length,a.shape.length)),Pr("min",u,h.shape.length);const[d,f]=kr(h.shape,u),m=xt(f),v=Mr(xt(d),h.dtype),y=e.data.get(h.dataId).values;for(let w=0;w<v.length;++w){const S=w*m;let N=y[S];for(let C=0;C<m;++C){const T=y[S+C];(Number.isNaN(T)||T<N)&&(N=T)}v[w]=N}l!=null&&e.disposeIntermediateTensorInfo(h);const b=e.makeTensorInfo(d,h.dtype,v);if(o){const w=Vn(d,i),S=gn({inputs:{x:b},backend:e,attrs:{shape:w}});return e.disposeIntermediateTensorInfo(b),S}return b}const myt={kernelName:Jm,backendName:"cpu",kernelFunc:fyt};function gyt(n){const{inputs:t,backend:e,attrs:r}=n,{x:a}=t,{paddings:s,mode:o}=r;Kt(a,"mirrorPad");const i=s.map((N,C)=>N[0]+a.shape[C]+N[1]),u=s.map(N=>N[0]),l=s.map((N,C)=>N[0]+a.shape[C]),h=o==="reflect"?0:1,d=e.data.get(a.dataId).values,f=a.shape.length,m=oe(a.shape),v=xt(i),y=i.length,b=oe(i),w=xr(a.dtype,v);for(let N=0;N<v;N++){let C=vc(N,y,b);for(let I=0;I<y;I++)C[I]<u[I]?C[I]=u[I]*2-C[I]-h:C[I]>=l[I]&&(C[I]=(l[I]-1)*2-C[I]+h);C=C.map((I,_)=>I-u[_]);const T=eo(C,f,m);w[N]=d[T]}return{dataId:e.write(w,i,a.dtype),shape:i,dtype:a.dtype}}const vyt={kernelName:tg,backendName:"cpu",kernelFunc:gyt};const yyt=Gn(((n,t)=>{const e=n%t;return n<0&&t<0||n>=0&&t>=0?e:(e+t)%t})),byt=cr(zd,yyt),xyt={kernelName:zd,backendName:"cpu",kernelFunc:byt};function vG(n){const{inputs:t,backend:e,attrs:r}=n,{logits:a}=t,{dim:s}=r,o=a.shape.length;let i=s;if(i===-1&&(i=o-1),i!==o-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${o} and dim was ${i}`);const u=_e([i],a.shape),l=gG({inputs:{x:a},backend:e,attrs:{reductionIndices:u,keepDims:!1}}),h=Vn(l.shape,u),d=gn({inputs:{x:l},backend:e,attrs:{shape:h}}),f=d_({inputs:{a,b:d},backend:e}),m=wW({inputs:{x:f},backend:e}),v=dv({inputs:{x:m},backend:e,attrs:{axis:u,keepDims:!1}}),y=gn({inputs:{x:v},backend:e,attrs:{shape:h}}),b=f_({inputs:{a:m,b:y},backend:e});return e.disposeIntermediateTensorInfo(l),e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(v),e.disposeIntermediateTensorInfo(y),b}const wyt={kernelName:yg,backendName:"cpu",kernelFunc:vG};function Syt(n){const{inputs:t,backend:e,attrs:r}=n,{logits:a}=t,{numSamples:s,seed:o,normalized:i}=r;Kt(a,"multinomial");const u=i?a:vG({inputs:{logits:a},backend:e,attrs:{dim:-1}}),l=u.shape[0],h=u.shape[1],d=e.data.get(u.dataId).values,f=[l,s],m=Mr(xt(f),"int32");for(let v=0;v<l;++v){const y=v*h,b=new Float32Array(h-1);b[0]=d[y];for(let N=1;N<b.length;++N)b[N]=b[N-1]+d[y+N];const w=e1.alea(o.toString()),S=v*s;for(let N=0;N<s;++N){const C=w();m[S+N]=b.length;for(let T=0;T<b.length;T++)if(C<b[T]){m[S+N]=T;break}}}return i||e.disposeIntermediateTensorInfo(u),e.makeTensorInfo(f,"int32",m)}const Cyt={kernelName:dx,backendName:"cpu",kernelFunc:Syt};const Nyt=S1;function kyt(n){const{inputs:t,backend:e,attrs:r}=n,{boxes:a,scores:s}=t,{maxOutputSize:o,iouThreshold:i,scoreThreshold:u}=r;Kt(a,"NonMaxSuppression");const l=e.data.get(a.dataId).values,h=e.data.get(s.dataId).values,{selectedIndices:d}=Nyt(l,h,o,i,u);return e.makeTensorInfo([d.length],"int32",new Int32Array(d))}const Tyt={kernelName:px,backendName:"cpu",kernelFunc:kyt};const Eyt=C1;function Iyt(n){const{inputs:t,backend:e,attrs:r}=n,{boxes:a,scores:s}=t,{maxOutputSize:o,iouThreshold:i,scoreThreshold:u,padToMaxOutputSize:l}=r;Kt(a,"NonMaxSuppressionPadded");const h=e.data.get(a.dataId).values,d=e.data.get(s.dataId).values,{selectedIndices:f,validOutputs:m}=Eyt(h,d,o,i,u,l);return[e.makeTensorInfo([f.length],"int32",new Int32Array(f)),e.makeTensorInfo([],"int32",new Int32Array([m]))]}const _yt={kernelName:fx,backendName:"cpu",kernelFunc:Iyt};const Ryt=N1;function Ayt(n){const{inputs:t,backend:e,attrs:r}=n,{boxes:a,scores:s}=t,{maxOutputSize:o,iouThreshold:i,scoreThreshold:u,softNmsSigma:l}=r;Kt(a,"NonMaxSuppressionWithScore");const h=e.data.get(a.dataId).values,d=e.data.get(s.dataId).values,f=o,m=i,v=u,y=l,{selectedIndices:b,selectedScores:w}=Ryt(h,d,f,m,v,y);return[e.makeTensorInfo([b.length],"int32",new Int32Array(b)),e.makeTensorInfo([w.length],"float32",new Float32Array(w))]}const Dyt={kernelName:mx,backendName:"cpu",kernelFunc:Ayt};function $yt(n){const{inputs:t,backend:e,attrs:r}=n,{indices:a}=t,{dtype:s,depth:o,onValue:i,offValue:u}=r;Kt(a,"oneHot");const l=xt(a.shape),h=new Float32Array(l*o);h.fill(u);const d=e.data.get(a.dataId).values;for(let f=0;f<l;++f)d[f]>=0&&d[f]<o&&(h[f*o+d[f]]=i);return e.makeTensorInfo([...a.shape,o],s,h)}const Oyt={kernelName:ag,backendName:"cpu",kernelFunc:$yt};function Eb(n){const{inputs:t,backend:e}=n,{x:r}=t;if(r.dtype==="string")throw new Error("zerosLike is not supported for string tensors");if(r.dtype==="complex64"){const a=hc({inputs:{input:r},backend:e}),s=Eb({inputs:{x:a},backend:e}),o=id({inputs:{input:r},backend:e}),i=Eb({inputs:{x:o},backend:e}),u=Pa({inputs:{real:s,imag:i},backend:e});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(i),u}else return m_({backend:e,attrs:{shape:r.shape,value:0,dtype:r.dtype}})}const Fyt={kernelName:Sg,backendName:"cpu",kernelFunc:Eb};function yG(n){const{inputs:t,backend:e}=n,{x:r}=t;if(r.dtype==="string")throw new Error("onesLike is not supported for string tensors");if(r.dtype==="complex64"){const a=hc({inputs:{input:r},backend:e}),s=yG({inputs:{x:a},backend:e}),o=id({inputs:{input:r},backend:e}),i=Eb({inputs:{x:o},backend:e}),u=Pa({inputs:{real:s,imag:i},backend:e});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(i),u}else return m_({backend:e,attrs:{shape:r.shape,value:1,dtype:r.dtype}})}const Myt={kernelName:rg,backendName:"cpu",kernelFunc:yG};function bG(n){const{inputs:t,backend:e,attrs:r}=n,{axis:a}=r;if(t.length===1)return Tb({inputs:{input:t[0]},backend:e,attrs:{dim:a}});const s=t[0].shape,o=t[0].dtype;t.forEach(h=>{Br(s,h.shape,"All tensors passed to stack must have matching shapes"),P(o===h.dtype,()=>"All tensors passed to stack must have matching dtypes")});const i=[],u=t.map(h=>{const d=Tb({inputs:{input:h},backend:e,attrs:{dim:a}});return i.push(d),d}),l=ud({inputs:u,backend:e,attrs:{axis:a}});return i.forEach(h=>e.disposeIntermediateTensorInfo(h)),l}const Lyt={kernelName:sg,backendName:"cpu",kernelFunc:bG};function Byt(n){const{inputs:t,backend:e,attrs:r}=n,{x:a}=t,{paddings:s,constantValue:o}=r;Kt(a,"pad");const i=s.map((S,N)=>S[0]+a.shape[N]+S[1]),u=s.map(S=>S[0]),l=e.data.get(a.dataId).values,h=xt(a.shape),d=a.shape.length,f=oe(a.shape),m=xt(i),v=i.length,y=oe(i),b=xr(a.dtype,m);o!==0&&b.fill(o);for(let S=0;S<h;S++){const C=vc(S,d,f).map((I,_)=>I+u[_]),T=eo(C,v,y);b[T]=l[S]}return{dataId:e.write(b,i,a.dtype),shape:i,dtype:a.dtype}}const xG={kernelName:og,backendName:"cpu",kernelFunc:Byt};const zyt=Gn((n,t)=>Math.pow(n,t)),Pyt=cr(Vd,zyt),Vyt={kernelName:Vd,backendName:"cpu",kernelFunc:Pyt};function Uyt(n){const{inputs:t,backend:e,attrs:r}=n,{paramsNestedSplits:a,paramsDenseValues:s,indices:o}=t,{outputRaggedRank:i}=r,u=a.map(w=>e.data.get(w.dataId).values),l=a.map(w=>w.shape),h=e.data.get(s.dataId).values,d=e.data.get(o.dataId).values,[f,m,v]=zW(u,l,h,s.shape,s.dtype,d,o.shape),y=f.map(w=>e.makeTensorInfo([w.length],"int32",w)),b=e.makeTensorInfo(v,s.dtype,m);return y.concat([b])}const Wyt={kernelName:gx,backendName:"cpu",kernelFunc:Uyt};function Gyt(n){const{inputs:t,backend:e}=n,{starts:r,limits:a,deltas:s}=t,o=e.data.get(r.dataId).values,i=e.data.get(a.dataId).values,u=e.data.get(s.dataId).values,[l,h]=PW(o,r.shape,r.dtype,i,a.shape,u,s.shape),d=e.makeTensorInfo([l.length],"int32",l),f=e.makeTensorInfo([h.length],r.dtype,h);return[d,f]}const Hyt={kernelName:vx,backendName:"cpu",kernelFunc:Gyt};function jyt(n){const{inputs:t,backend:e,attrs:r}=n,{shape:a,values:s,defaultValue:o,rowPartitionTensors:i}=t,{rowPartitionTypes:u}=r,l=e.data.get(a.dataId).values,h=e.data.get(s.dataId).values,d=e.data.get(o.dataId).values,f=i.map(b=>e.data.get(b.dataId).values),m=i.map(b=>b.shape),[v,y]=VW(l,a.shape,h,s.shape,s.dtype,d,o.shape,f,m,u);return e.makeTensorInfo(v,s.dtype,y)}const qyt={kernelName:yx,backendName:"cpu",kernelFunc:jyt};function Kyt(n){const{backend:t,attrs:e}=n,{start:r,stop:a,dtype:s,step:o}=e,i=UW(r,a,o,s);return t.makeTensorInfo([i.length],s,i)}const Xyt={kernelName:bx,backendName:"cpu",kernelFunc:Kyt};const Yyt=tn(Ud,n=>1/n),Qyt={kernelName:Ud,backendName:"cpu",kernelFunc:Yyt};function Zyt(n){const{inputs:t,backend:e,attrs:r}=n,{images:a}=t,{alignCorners:s,halfPixelCenters:o,size:i}=r;Kt(a,"resizeBilinear");const u=oe(a.shape),[l,h]=i,[d,f,m,v]=a.shape,y=e.data.get(a.dataId).values,b=new Float32Array(xt([d,l,h,v])),w=[s&&l>1?f-1:f,s&&h>1?m-1:m],S=[s&&l>1?l-1:l,s&&h>1?h-1:h];let N=0;const C=w[0]/S[0],T=w[1]/S[1];for(let I=0;I<d;I++)for(let _=0;_<l;_++){let $;o?$=C*(_+.5)-.5:$=C*_;const R=Math.max(0,Math.floor($)),D=$-R,A=Math.min(f-1,Math.ceil($)),L=I*u[0]+R*u[1],H=I*u[0]+A*u[1];for(let G=0;G<h;G++){let q;o?q=T*(G+.5)-.5:q=T*G;const B=Math.max(0,Math.floor(q)),j=q-B,K=Math.min(m-1,Math.ceil(q)),z=L+B*u[2],U=H+B*u[2],M=L+K*u[2],X=H+K*u[2];for(let Q=0;Q<v;Q++){const rt=y[z+Q],ct=y[U+Q],pt=y[M+Q],yt=y[X+Q],Tt=rt+(pt-rt)*j,gt=ct+(yt-ct)*j,Rt=Tt+(gt-Tt)*D;b[N++]=Rt}}}return e.makeTensorInfo([d,l,h,v],"float32",b)}const Jyt={kernelName:hg,backendName:"cpu",kernelFunc:Zyt};function t0t(n){const{inputs:t,backend:e,attrs:r}=n,{images:a,dy:s}=t,{alignCorners:o}=r;Kt([s,a],"resizeBilinearGrad");const i=oe(a.shape),[u,l,h,d]=a.shape,[,f,m]=s.shape,v=new Float32Array(u*l*h*d),y=[o&&f>1?l-1:l,o&&m>1?h-1:h],b=[o&&f>1?f-1:f,o&&m>1?m-1:m],w=y[0]/b[0],S=y[1]/b[1],N=e.data.get(s.dataId).values;let C=0;for(let T=0;T<u;T++){const I=T*i[0];for(let _=0;_<f;_++){const $=_*w,R=Math.floor($),D=Math.min(Math.ceil($),l-1),A=I+R*i[1],L=I+D*i[1],H=$-R,G=1-H;for(let q=0;q<m;q++){const B=q*S,j=Math.floor(B),K=Math.min(Math.ceil(B),h-1),z=B-j,U=1-z,M=A+j*i[2],X=A+K*i[2],Q=L+j*i[2],rt=L+K*i[2],ct=G*U,pt=G*z,yt=H*U,Tt=H*z;for(let gt=0;gt<d;gt++){const Rt=N[C++];v[M+gt]+=Rt*ct,v[X+gt]+=Rt*pt,v[Q+gt]+=Rt*yt,v[rt+gt]+=Rt*Tt}}}}return e.makeTensorInfo([u,h,l,d],"float32",v)}const e0t={kernelName:Sx,backendName:"cpu",kernelFunc:t0t};function n0t(n){const{inputs:t,backend:e,attrs:r}=n,{images:a}=t,{alignCorners:s,halfPixelCenters:o,size:i}=r;Kt(a,"resizeNearestNeighbor");const u=oe(a.shape),[l,h]=i,[d,f,m,v]=a.shape,y=e.data.get(a.dataId).values,b=new Float32Array(d*l*h*v),w=[s&&l>1?f-1:f,s&&h>1?m-1:m],S=[s&&l>1?l-1:l,s&&h>1?h-1:h],N=w[0]/S[0],C=w[1]/S[1];let T=0;for(let I=0;I<d;I++){const _=I*u[0];for(let $=0;$<l;$++){const R=o?N*($+.5):N*$;let D=Math.min(f-1,s?Math.round(R):Math.floor(R));o&&(D=Math.max(0,D));const A=_+D*u[1];for(let L=0;L<h;L++){const H=o?C*(L+.5):C*L;let G=Math.min(m-1,s?Math.round(H):Math.floor(H));o&&(G=Math.max(0,G));const q=A+G*u[2];for(let B=0;B<v;B++){const j=y[q+B];b[T++]=j}}}}return e.makeTensorInfo([d,l,h,v],a.dtype,b)}const r0t={kernelName:cg,backendName:"cpu",kernelFunc:n0t};function a0t(n){const{inputs:t,backend:e,attrs:r}=n,{images:a,dy:s}=t,{alignCorners:o}=r;Kt([s,a],"resizeNearestNeighborGrad");const i=oe(a.shape),u=oe(s.shape),[l,h,d,f]=a.shape,[,m,v]=s.shape,y=new Float32Array(l*h*d*f),b=e.data.get(s.dataId).values,w=[o&&m>1?h-1:h,o&&v>1?d-1:d],S=[o&&m>1?m-1:m,o&&v>1?v-1:v],N=w[0]/S[0],C=w[1]/S[1],T=1/N,I=1/C,_=Math.ceil(T)*2+2,$=Math.ceil(I)*2+2;for(let R=0;R<l;R++){const D=R*i[0];for(let A=0;A<h;A++){const L=D+A*i[1],H=Math.floor(A*T),G=Math.floor(H-_/2);for(let q=0;q<d;q++){const B=L+q*i[2],j=Math.floor(q*I),K=Math.floor(j-$/2);for(let z=0;z<f;z++){let U=0;for(let M=0;M<_;M++){const X=M+G;if(X<0||X>=m)continue;const Q=D+X*u[1],rt=X*N,ct=Math.min(h-1,o?Math.round(rt):Math.floor(rt));if(A===ct)for(let pt=0;pt<$;pt++){const yt=pt+K;if(yt<0||yt>=v)continue;const Tt=Q+yt*u[2],gt=yt*C,Rt=Math.min(d-1,o?Math.round(gt):Math.floor(gt));q===Rt&&(U+=b[Tt+z])}}y[B+z]=U}}}}return e.makeTensorInfo(a.shape,a.dtype,y)}const s0t={kernelName:wx,backendName:"cpu",kernelFunc:a0t};function o0t(n){const{inputs:t,backend:e,attrs:r}=n,{x:a}=t,{dims:s}=r;Kt(a,"reverse");const o=a.shape.length,i=_e(s,a.shape);if(o===0)return qo({inputs:{x:a},backend:e});const u=new Yn(a.shape,a.dtype),l=e.bufferSync(a);for(let h=0;h<u.size;h++){const d=u.indexToLoc(h),f=d.slice();i.forEach(m=>f[m]=a.shape[m]-1-f[m]),u.set(l.get(...f),...d)}return e.makeTensorInfo(u.shape,u.dtype,u.values)}const i0t={kernelName:dg,backendName:"cpu",kernelFunc:o0t};const u0t={kernelName:zx,backendName:"cpu",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{image:r}=n,{radians:a,fillValue:s,center:o}=t,i=e,u=xr(r.dtype,xt(r.shape)),[l,h,d,f]=r.shape,[m,v]=dE(o,h,d),y=255,b=Math.sin(a),w=Math.cos(a),S=i.data.get(r.dataId).values;for(let C=0;C<l;C++){const T=C*d*h*f;for(let I=0;I<h;I++){const _=I*(d*f);for(let $=0;$<d;$++){const R=$*f;for(let D=0;D<f;D++){const A=[l,I,$,D],L=A[2],H=A[1];let G=(L-m)*w-(H-v)*b,q=(L-m)*b+(H-v)*w;G=Math.round(G+m),q=Math.round(q+v);let B=s;if(typeof s!="number"&&(D===3?B=y:B=s[D]),G>=0&&G<d&&q>=0&&q<h){const K=q*(d*f),z=G*f,U=T+K+z+D;B=S[U]}const j=T+_+R+D;u[j]=B}}}}return{dataId:i.write(u,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};const l0t=tn(Hd,n=>{const t=Math.floor(n);return n-t<.5?Math.floor(n):n-t>.5?Math.ceil(n):t%2===0?t:t+1}),c0t={kernelName:Hd,backendName:"cpu",kernelFunc:l0t};function h0t(n){const{inputs:t,backend:e,attrs:r}=n,{indices:a,updates:s}=t,{shape:o}=r,{sliceRank:i,numUpdates:u,sliceSize:l,strides:h,outputSize:d}=nl(s,a,o),f=!0,m=e.bufferSync(a),v=e.bufferSync(s),y=Hl(m,v,o,d,l,u,i,h,0,f);return e.makeTensorInfo(o,y.dtype,y.values)}const d0t={kernelName:Cx,backendName:"cpu",kernelFunc:h0t};function p0t(n,t){let e=0,r=n.length,a=0;for(;e<r;)a=Math.floor((e+r)/2),n[a]<t?e=a+1:r=a;return r}function f0t(n,t){let e=0,r=n.length,a=0;for(;e<r;)a=Math.floor((e+r)/2),n[a]<=t?e=a+1:r=a;return r}function m0t(n,t,e,r,a,s){const o=On("int32",e*a);for(let i=0;i<e;++i){const u=n.slice(i*r,(i+1)*r),l=i*a;for(let h=0;h<a;++h)o[l+h]=s==="left"?p0t(u,t[h+l]):f0t(u,t[h+l])}return o}function g0t(n){const{inputs:t,backend:e,attrs:r}=n,{sortedSequence:a,values:s}=t,{side:o}=r,i=e.data.get(a.dataId).values,u=e.data.get(s.dataId).values,l=m0t(i,u,a.shape[0],a.shape[1],s.shape[1],o);return e.makeTensorInfo(s.shape,"int32",l)}const v0t={kernelName:kx,backendName:"cpu",kernelFunc:g0t};function y0t(n){const{inputs:t,backend:e}=n,{condition:r,t:a,e:s}=t;Kt([r,a,s],"select");const o=r.shape.length,i=e.data.get(r.dataId).values,u=e.data.get(a.dataId).values,l=e.data.get(s.dataId).values,h=Sa(a.dtype,s.dtype),d=Mr(xt(a.shape),h);let f=0;const m=o===0||o>1||a.shape.length===1?1:xt(a.shape.slice(1));for(let v=0;v<i.length;v++)for(let y=0;y<m;y++)i[v]===1?d[f++]=u[v]:d[f++]=l[v];return e.makeTensorInfo(a.shape,h,d)}const b0t={kernelName:pg,backendName:"cpu",kernelFunc:y0t};const x0t=_1,w0t=R1,S0t=tn(qd,n=>n>=0?w0t*n:x0t*(Math.exp(n)-1)),C0t={kernelName:qd,backendName:"cpu",kernelFunc:S0t};const N0t=tn(Yd,n=>n<0?-1:n>0?1:0),k0t={kernelName:Yd,backendName:"cpu",kernelFunc:N0t};const T0t=tn(Kd,n=>Math.sin(n)),E0t={kernelName:Kd,backendName:"cpu",kernelFunc:T0t};const I0t=tn(Xd,n=>Math.sinh(n)),_0t={kernelName:Xd,backendName:"cpu",kernelFunc:I0t};const R0t=11920928955078125e-23,XF=Math.log(R0t)+2,A0t=tn(Zd,n=>{const t=n>-XF,e=n<XF,r=Math.exp(n);let a;return e?a=r:t?a=n:a=Math.log(1+r),a}),D0t={kernelName:Zd,backendName:"cpu",kernelFunc:A0t};function $0t(n){const{inputs:t,backend:e,attrs:r}=n,{x:a}=t,{blockShape:s,paddings:o}=r;Kt([a],"spaceToBatchND");const i=xt(s),u=[[0,0]];u.push(...o);for(let I=1+s.length;I<a.shape.length;++I)u.push([0,0]);const l=xG.kernelFunc({inputs:{x:a},backend:e,attrs:{paddings:u,constantValue:0}}),h=Gg(l.shape,s,i,!1),d=Hg(h.length,s.length,!1),f=jg(l.shape,s,i,!1),y=gn({inputs:{x:l},backend:e,attrs:{shape:h}}),S=Ea({inputs:{x:y},backend:e,attrs:{perm:d}}),T=gn({inputs:{x:S},backend:e,attrs:{shape:f}});return e.disposeIntermediateTensorInfo(l),e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(S),T}const O0t={kernelName:gg,backendName:"cpu",kernelFunc:$0t};function F0t(n){const{inputs:t,backend:e}=n,{indices:r,values:a,denseShape:s,defaultValue:o}=t;if(s.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
        ${s.shape}`);if(r.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
        ${r.shape}`);if(a.shape.length!==1)throw new Error(`Values must be a vector, saw:
        ${a.shape}`);if(o.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${o.shape}`);const i=e.data.get(r.dataId).values,u=e.data.get(a.dataId).values,l=e.data.get(s.dataId).values,h=e.data.get(o.dataId).values[0],[d,f,m,v,y]=jW(i,r.shape,r.dtype,u,a.dtype,l,h);return[e.makeTensorInfo(f,r.dtype,d),e.makeTensorInfo([f[0]],a.dtype,m),e.makeTensorInfo([v.length],"bool",new Uint8Array(v.map(b=>Number(b)))),e.makeTensorInfo([y.length],r.dtype,new Int32Array(y))]}const M0t={kernelName:Tx,backendName:"cpu",kernelFunc:F0t};function L0t(n){const{inputs:t,backend:e}=n,{inputIndices:r,inputShape:a,newShape:s}=t;if(r.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${r.shape}`);if(a.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${a.shape}`);if(s.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);const o=Array.from(e.data.get(a.dataId).values),i=e.data.get(r.dataId).values,u=Array.from(e.data.get(s.dataId).values),[l,h,d]=qW(i,r.shape,r.dtype,o,u);return[e.makeTensorInfo(h,r.dtype,l),e.makeTensorInfo([d.length],s.dtype,new Int32Array(d))]}const B0t={kernelName:Ex,backendName:"cpu",kernelFunc:L0t};function z0t(n){const{inputs:t,backend:e}=n,{data:r,indices:a,segmentIds:s}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(a.shape.length!==1)throw new Error(`Indices should be a vector but received shape
          ${a.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
          ${s.shape}`);if(a.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");const o=e.data.get(r.dataId).values,i=e.data.get(a.dataId).values,u=e.data.get(s.dataId).values,[l,h]=h_(o,r.shape,r.dtype,i,u,!0);return e.makeTensorInfo(h,r.dtype,l)}const P0t={kernelName:Ix,backendName:"cpu",kernelFunc:z0t};function V0t(n){const{inputs:t,backend:e}=n,{data:r,indices:a,segmentIds:s}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(a.shape.length!==1)throw new Error(`Indices should be a vector but received shape
         ${a.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
         ${s.shape}`);if(a.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");const o=e.data.get(r.dataId).values,i=e.data.get(a.dataId).values,u=e.data.get(s.dataId).values,[l,h]=h_(o,r.shape,r.dtype,i,u);return e.makeTensorInfo(h,r.dtype,l)}const U0t={kernelName:_x,backendName:"cpu",kernelFunc:V0t};function W0t(n){const{inputs:t,backend:e,attrs:r}=n,{sparseIndices:a,sparseValues:s,defaultValue:o}=t,{outputShape:i}=r,{sliceRank:u,numUpdates:l,sliceSize:h,strides:d,outputSize:f}=nl(s,a,i),m=!1,v=e.bufferSync(a);let y;switch(s.dtype){case"bool":{const b=e.bufferSync(s),w=!!e.data.get(o.dataId).values[0];y=Hl(v,b,i,f,h,l,u,d,w,m);break}case"float32":{const b=e.bufferSync(s),w=e.data.get(o.dataId).values[0];y=Hl(v,b,i,f,h,l,u,d,w,m);break}case"int32":{const b=e.bufferSync(s),w=e.data.get(o.dataId).values[0];y=Hl(v,b,i,f,h,l,u,d,w,m);break}case"string":{const b=e.bufferSync(s),w=Ii(e.data.get(o.dataId).values[0]);y=Hl(v,b,i,f,h,l,u,d,w,m);break}default:throw new Error(`Unsupported type ${s.dtype}`)}return e.makeTensorInfo(i,y.dtype,y.values)}const G0t={kernelName:Rx,backendName:"cpu",kernelFunc:W0t};function H0t(n){const{inputs:t,backend:e,attrs:r}=n,{x:a}=t,{numOrSizeSplits:s,axis:o}=r,i=_e(o,a.shape)[0],u=EE(a,s,i),l=new Array(a.shape.length).fill(0),h=a.shape.slice();return u.map(d=>{const f=[...h];f[i]=d;const m=dc({inputs:{x:a},backend:e,attrs:{begin:l,size:f}});return l[i]+=d,m})}const j0t={kernelName:vg,backendName:"cpu",kernelFunc:H0t};const q0t={kernelName:Ax,backendName:"cpu",kernelFunc:({inputs:n,backend:t})=>{const{x:e}=n,r=t;Kt(e,"square");const a=r.data.get(e.dataId).values,s=new Float32Array(a.length);for(let i=0;i<a.length;++i){const u=a[i];s[i]=u*u}return{dataId:r.write(s,e.shape,e.dtype),shape:e.shape,dtype:e.dtype}}};const K0t=tn(sp,(n,t)=>{const e=t;return isNaN(n)?NaN:n>0?1:e.alpha}),X0t={kernelName:sp,backendName:"cpu",kernelFunc:K0t};function Y0t(n){const{inputs:t,backend:e,attrs:r}=n,{x:a}=t,{begin:s,end:o,strides:i,beginMask:u,endMask:l,ellipsisMask:h,newAxisMask:d,shrinkAxisMask:f}=r;Kt(a,"stridedSlice");const{finalShapeSparse:m,finalShape:v,isIdentity:y,sliceDim0:b,isSimpleSlice:w,begin:S,end:N,strides:C}=uE(a.shape,s,o,i,u,l,h,d,f);let T;if(y)T=gn({inputs:{x:a},backend:e,attrs:{shape:v}});else if(b||w){P(a.shape.length>=1,()=>`Input must have rank at least 1, got: ${a.shape.length}`);const I=sE(S,N,C),_=dc({inputs:{x:a},backend:e,attrs:{begin:S,size:I}});T=gn({inputs:{x:_},backend:e,attrs:{shape:v}}),e.disposeIntermediateTensorInfo(_)}else{const I=e.bufferSync(a),_=YW(m,I,C,S);T=e.makeTensorInfo(v,_.dtype,_.values)}return T}const Q0t={kernelName:Dx,backendName:"cpu",kernelFunc:Y0t};function Z0t(n){const{inputs:t,backend:e,attrs:r}=n,{separator:a,nGramWidths:s,leftPad:o,rightPad:i,padWidth:u,preserveShortSequences:l}=r,{data:h,dataSplits:d}=t,f=e.data.get(h.dataId).values,m=e.data.get(d.dataId).values,[v,y]=QW(f,m,a,s,o,i,u,l);return[e.makeTensorInfo([v.length],"string",v),e.makeTensorInfo(d.shape,"int32",y)]}const J0t={kernelName:$x,backendName:"cpu",kernelFunc:Z0t};function tbt(n){const{inputs:t,backend:e,attrs:r}=n,{skipEmpty:a}=r,{input:s,delimiter:o}=t;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(s.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(o.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${o.shape}`);const i=e.data.get(s.dataId).values,u=e.data.get(o.dataId).values[0],[l,h,d]=ZW(i,u,a),f=h.length;return[e.makeTensorInfo([f,2],"int32",l),e.makeTensorInfo([f],"string",h),e.makeTensorInfo([2],"int32",new Int32Array(d))]}const ebt={kernelName:Ox,backendName:"cpu",kernelFunc:tbt};function nbt(n){const{inputs:t,backend:e,attrs:r}=n,{numBuckets:a}=r,{input:s}=t;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(a<=0)throw new Error("Number of buckets must be at least 1");const o=e.data.get(s.dataId).values,i=JW(o,a);return e.makeTensorInfo(s.shape,"int32",i)}const rbt={kernelName:Fx,backendName:"cpu",kernelFunc:nbt};const abt=tn(np,n=>Math.tan(n)),sbt={kernelName:np,backendName:"cpu",kernelFunc:abt};const obt=tn(rp,n=>Math.tanh(n)),ibt={kernelName:rp,backendName:"cpu",kernelFunc:obt};function ubt(n){const{inputs:t,backend:e}=n,{tensor:r,indices:a,updates:s}=t,{sliceRank:o,numUpdates:i,sliceSize:u,strides:l,outputSize:h}=nl(s,a,r.shape),d=!1,f=e.bufferSync(a),m=e.bufferSync(s),v=e.bufferSync(r),y=Hl(f,m,r.shape,h,u,i,o,l,v,d);return e.makeTensorInfo(r.shape,y.dtype,y.values)}const lbt={kernelName:Nx,backendName:"cpu",kernelFunc:ubt};function cbt(n){const{inputs:t,backend:e,attrs:r}=n,{x:a}=t,{reps:s}=r;Kt(a,"tile");const o=eG(e.bufferSync(a),s);return e.makeTensorInfo(o.shape,o.dtype,o.values)}const hbt={kernelName:ap,backendName:"cpu",kernelFunc:cbt};function dbt(n){const{inputs:t,backend:e,attrs:r}=n,{x:a}=t,{k:s,sorted:o}=r;Kt(a,"topk");const i=e.data.get(a.dataId).values,[u,l]=rG(i,a.shape,a.dtype,s,o);return[e.makeTensorInfo(u.shape,u.dtype,u.values),e.makeTensorInfo(l.shape,l.dtype,l.values)]}const pbt={kernelName:Mx,backendName:"cpu",kernelFunc:dbt};function fbt(n){const{inputs:t,attrs:e,backend:r}=n,{image:a,transforms:s}=t,{interpolation:o,fillMode:i,fillValue:u,outputShape:l}=e,[h,d,f,m]=a.shape,[v,y]=l??[d,f],b=[h,v,y,m],w=oe(a.shape),S=w[0],N=w[1],C=w[2],T=oe(b),I=T[0],_=T[1],$=T[2],R=xr(a.dtype,xt(b));R.fill(u);const D=r.data.get(a.dataId).values,A=r.data.get(s.dataId).values;for(let H=0;H<h;++H){const G=s.shape[0]===1?A:A.subarray(H*8,H*8+8);for(let q=0;q<v;++q)for(let B=0;B<y;++B)for(let j=0;j<m;++j){let K;const z=G[6]*B+G[7]*q+1;if(z===0)continue;const U=(G[0]*B+G[1]*q+G[2])/z,M=(G[3]*B+G[4]*q+G[5])/z,X=YF(U,f,i),Q=YF(M,d,i);switch(o){case"nearest":K=xbt(D,d,f,S,N,C,H,Q,X,j,u);break;case"bilinear":K=wbt(D,d,f,S,N,C,H,Q,X,j,u);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${o}`)}const rt=H*I+q*_+B*$+j;R[rt]=K}return r.makeTensorInfo(b,a.dtype,R)}return{dataId:r.write(R,b,a.dtype),shape:a.shape,dtype:a.dtype}}const mbt={kernelName:Lx,backendName:"cpu",kernelFunc:fbt};function YF(n,t,e){switch(e){case"reflect":return gbt(n,t);case"wrap":return vbt(n,t);case"nearest":return bbt(n,t);default:return ybt(n)}}function gbt(n,t){let e=n;if(e<0)if(t<=1)e=0;else{const r=2*t;e<r&&(e=r*Math.trunc(-e/r)+e),e=e<-t?e+r:-e-1}else if(e>t-1)if(t<=1)e=0;else{const r=2*t;e-=r*Math.trunc(e/r),e>=t&&(e=r-e-1)}return Ou(0,e,t-1)}function vbt(n,t){let e=n;if(e<0)if(t<=1)e=0;else{const r=t-1;e+=t*(Math.trunc(-e/r)+1)}else if(e>t-1)if(t<=1)e=0;else{const r=t-1;e-=t*Math.trunc(e/r)}return Ou(0,e,t-1)}function ybt(n,t){return n}function bbt(n,t){return Ou(0,n,t-1)}function Bf(n,t,e,r,a,s,o,i,u,l,h){const d=o*r+i*a+u*s+l;return 0<=i&&i<t&&0<=u&&u<e?n[d]:h}function xbt(n,t,e,r,a,s,o,i,u,l,h){const d=Math.round(i),f=Math.round(u);return Bf(n,t,e,r,a,s,o,d,f,l,h)}function wbt(n,t,e,r,a,s,o,i,u,l,h){const d=Math.floor(i),f=Math.floor(u),m=d+1,v=f+1,y=(v-u)*Bf(n,t,e,r,a,s,o,d,f,l,h)+(u-f)*Bf(n,t,e,r,a,s,o,d,v,l,h),b=(v-u)*Bf(n,t,e,r,a,s,o,m,f,l,h)+(u-f)*Bf(n,t,e,r,a,s,o,m,v,l,h);return(m-i)*y+(i-d)*b}function Sbt(n){const{inputs:t,attrs:e,backend:r}=n,{axis:a}=e,{x:s}=t;Kt(s,"unique");const o=r.data.get(s.dataId).values,{outputValues:i,outputShape:u,indices:l}=aG(o,a,s.shape,s.dtype);return[r.makeTensorInfo(u,s.dtype,i),r.makeTensorInfo([l.length],"int32",l)]}const Cbt={kernelName:Bx,backendName:"cpu",kernelFunc:Sbt};function Nbt(n){const{inputs:t,backend:e,attrs:r}=n,{value:a}=t;let{axis:s}=r;s<0&&(s+=a.shape.length);const o=a.shape.length,i=a.shape[s],u=new Array(o-1);let l=0;for(let m=0;m<o;m++)m!==s&&(u[l++]=a.shape[m]);const h=new Array(o).fill(0),d=a.shape.slice();d[s]=1;const f=new Array(i);for(let m=0;m<f.length;m++){h[s]=m;const v=dc({inputs:{x:a},backend:e,attrs:{begin:h,size:d}});f[m]=gn({inputs:{x:v},backend:e,attrs:{shape:u}}),e.disposeIntermediateTensorInfo(v)}return f}const kbt={kernelName:xg,backendName:"cpu",kernelFunc:Nbt};function Tbt(n){const{inputs:t,backend:e,attrs:r}=n,{x:a,segmentIds:s}=t,{numSegments:o}=r;Kt(a,"unsortedSegmentSum");const i=a.shape.length,u=s.shape.length,l=[],h=[],d=i-u;let f=s;for(let v=0;v<d;++v){const y=Tb({inputs:{input:f},backend:e,attrs:{dim:v+1}});f=y,h.push(y)}for(let v=0;v<o;++v){const y=Fi(v,"int32"),b=e.makeTensorInfo([],"int32",y),w=bW({inputs:{a:b,b:f},backend:e}),S=Ku({inputs:{x:w},backend:e,attrs:{dtype:"float32"}}),N=aw({inputs:{a:S,b:a},backend:e}),C=dv({inputs:{x:N},backend:e,attrs:{axis:0,keepDims:!1}});l.push(C),h.push(b),h.push(w),h.push(S),h.push(N),h.push(C)}const m=bG({inputs:l,backend:e,attrs:{axis:0}});return h.forEach(v=>e.disposeIntermediateTensorInfo(v)),m}const Ebt={kernelName:wg,backendName:"cpu",kernelFunc:Tbt};const Ibt=[Smt,nft,Nmt,Tmt,uft,Imt,Rmt,Dmt,Omt,Mmt,Bmt,Pmt,Umt,Hmt,qmt,Ymt,Zmt,tgt,ngt,xmt,agt,ogt,ugt,cft,cgt,oft,dft,dgt,rft,fgt,ggt,vgt,bgt,wgt,Cgt,kgt,Egt,_gt,Agt,$gt,Fgt,Lgt,zgt,Vgt,Ugt,Ggt,jgt,Kgt,Xgt,Ygt,Qgt,Jgt,nvt,pmt,avt,pft,dvt,fft,pvt,gft,bvt,xvt,Svt,yft,xft,Nvt,Tvt,Ivt,Rvt,Sft,Nft,aft,Dvt,mgt,Ovt,Mvt,Bvt,fmt,Tft,Ift,Pvt,Rft,Uvt,Hvt,qvt,Yvt,Zvt,tyt,eyt,Dft,ryt,syt,iyt,lyt,hyt,pyt,myt,Oft,vyt,xyt,Cyt,Mft,Bft,Tyt,_yt,Dyt,Pft,Oyt,Myt,Lyt,xG,Vyt,gmt,Wft,Wyt,Hyt,qyt,Xyt,sft,fk,Qyt,vmt,ymt,bmt,Jyt,e0t,r0t,s0t,i0t,u0t,c0t,Qft,d0t,v0t,b0t,C0t,Jft,k0t,E0t,_0t,tmt,wyt,D0t,O0t,M0t,B0t,P0t,U0t,G0t,j0t,rmt,q0t,smt,imt,X0t,Q0t,J0t,ebt,rbt,hmt,tvt,sbt,ibt,lbt,hbt,pbt,mbt,Vft,Cbt,kbt,Ebt,Fyt];for(const n of Ibt)Px(n);const Vl={},l0={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function _bt(n,t){Vl[n]=t}function io(n,t){if(!(n in Vl)||t!=null){const r=Abt(n,t);if(r!==null)Vl[n]=r;else return console.log("Could not get context for WebGL version",n),null}const e=Vl[n];return e==null||e.isContextLost()?(delete Vl[n],io(n)):(e.disable(e.DEPTH_TEST),e.disable(e.STENCIL_TEST),e.disable(e.BLEND),e.disable(e.DITHER),e.disable(e.POLYGON_OFFSET_FILL),e.disable(e.SAMPLE_COVERAGE),e.enable(e.SCISSOR_TEST),e.enable(e.CULL_FACE),e.cullFace(e.BACK),Vl[n])}function Rbt(n){if(!dt().getBool("IS_SAFARI")&&typeof OffscreenCanvas<"u"&&n===2)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function Abt(n,t){if(n!==1&&n!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const e=t??Rbt(n);return e.addEventListener("webglcontextlost",r=>{r.preventDefault(),delete Vl[n]},!1),dt().getBool("SOFTWARE_WEBGL_ENABLED")&&(l0.failIfMajorPerformanceCaveat=!1),n===1?e.getContext("webgl",l0)||e.getContext("experimental-webgl",l0):e.getContext("webgl2",l0)}var mm;(function(n){n[n.DENSE=0]="DENSE",n[n.SHARED_BATCH=1]="SHARED_BATCH"})(mm||(mm={}));var fs;(function(n){n[n.RENDER=0]="RENDER",n[n.UPLOAD=1]="UPLOAD",n[n.PIXELS=2]="PIXELS",n[n.DOWNLOAD=3]="DOWNLOAD"})(fs||(fs={}));var Dr;(function(n){n[n.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",n[n.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",n[n.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",n[n.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",n[n.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})(Dr||(Dr={}));function pv(n,t){return[t,n]}function Dbt(n,t){return n*t}function c0(n){const t=xt(n),e=Math.ceil(t/4);return D0(e)}function gp(n,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(n/2))]}function $bt(n,t){const[e,r]=gp(n,t);return e*r*4}function g_(n,t){const e=n;let r,a,s,o,i,u,l,h,d,f;return dt().getNumber("WEBGL_VERSION")===2?(r=e.R32F,a=e.R16F,s=e.RGBA16F,o=e.RGBA32F,i=e.RED,l=4,h=1,d=e.HALF_FLOAT,f=e.FLOAT,u=e.RGBA8):(r=n.RGBA,a=n.RGBA,s=n.RGBA,o=e.RGBA,i=n.RGBA,l=4,h=4,d=t!=null?t.HALF_FLOAT_OES:null,f=n.FLOAT,u=n.RGBA),{internalFormatFloat:r,internalFormatHalfFloat:a,internalFormatPackedHalfFloat:s,internalFormatPackedFloat:o,textureFormatFloat:i,downloadTextureFormat:u,downloadUnpackNumChannels:l,defaultNumChannels:h,textureTypeHalfFloat:d,textureTypeFloat:f}}function Vt(n,t){const e=t();return dt().getBool("DEBUG")&&Obt(n),e}function Obt(n){const t=n.getError();if(t!==n.NO_ERROR)throw new Error("WebGL Error: "+Bbt(n,t))}const Fbt=596e-10,Mbt=65504;function Lbt(n){return!!(dt().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||n===0||Fbt<Math.abs(n)&&Math.abs(n)<Mbt)}function Bbt(n,t){switch(t){case n.NO_ERROR:return"NO_ERROR";case n.INVALID_ENUM:return"INVALID_ENUM";case n.INVALID_VALUE:return"INVALID_VALUE";case n.INVALID_OPERATION:return"INVALID_OPERATION";case n.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case n.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case n.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${t}`}}function h0(n,t){return Ki(n,()=>n.getExtension(t),'Extension "'+t+'" not supported on this browser.')}function zbt(n,t){const e=Ki(n,()=>n.createShader(n.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(Vt(n,()=>n.shaderSource(e,t)),Vt(n,()=>n.compileShader(e)),n.getShaderParameter(e,n.COMPILE_STATUS)===!1)throw console.log(n.getShaderInfoLog(e)),new Error("Failed to compile vertex shader.");return e}function Pbt(n,t){const e=Ki(n,()=>n.createShader(n.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(Vt(n,()=>n.shaderSource(e,t)),Vt(n,()=>n.compileShader(e)),dt().get("ENGINE_COMPILE_ONLY"))return e;if(n.getShaderParameter(e,n.COMPILE_STATUS)===!1)throw wG(t,n.getShaderInfoLog(e)),new Error("Failed to compile fragment shader.");return e}const Vbt=/ERROR: [0-9]+:([0-9]+):/g;function wG(n,t){const e=Vbt.exec(t);if(e==null){console.log(`Couldn't parse line number in error: ${t}`),console.log(n);return}const r=+e[1],a=n.split(`
`),s=a.length.toString().length+2,o=a.map((d,f)=>jl((f+1).toString(),s)+d);let i=0;for(let d=0;d<o.length;d++)i=Math.max(o[d].length,i);const u=o.slice(0,r-1),l=o.slice(r-1,r),h=o.slice(r);console.log(u.join(`
`)),console.log(t.split(`
`)[0]),console.log(`%c ${jl(l[0],i)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(h.join(`
`))}function Ubt(n){return Ki(n,()=>n.createProgram(),"Unable to create WebGLProgram.")}function Wbt(n,t){if(Vt(n,()=>n.linkProgram(t)),!dt().get("ENGINE_COMPILE_ONLY")&&n.getProgramParameter(t,n.LINK_STATUS)===!1)throw console.log(n.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}function GC(n,t){if(Vt(n,()=>n.validateProgram(t)),n.getProgramParameter(t,n.VALIDATE_STATUS)===!1)throw console.log(n.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function Gbt(n,t){const e=Ki(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return Vt(n,()=>n.bindBuffer(n.ARRAY_BUFFER,e)),Vt(n,()=>n.bufferData(n.ARRAY_BUFFER,t,n.STATIC_DRAW)),e}function Hbt(n,t){const e=Ki(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return Vt(n,()=>n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,e)),Vt(n,()=>n.bufferData(n.ELEMENT_ARRAY_BUFFER,t,n.STATIC_DRAW)),e}function jbt(n){return Ki(n,()=>n.createTexture(),"Unable to create WebGLTexture.")}function qbt(n,t){const e=dt().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(n<=0||t<=0){const r=`[${n}x${t}]`;throw new Error("Requested texture size "+r+" is invalid.")}if(n>e||t>e){const r=`[${n}x${t}]`,a=`[${e}x${e}]`;throw new Error("Requested texture size "+r+" greater than WebGL maximum on this browser / GPU "+a+".")}}function Kbt(n){return Ki(n,()=>n.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function QF(n,t,e,r,a,s,o){const i=n.getAttribLocation(t,e);return i===-1?!1:(Vt(n,()=>n.bindBuffer(n.ARRAY_BUFFER,r)),Vt(n,()=>n.vertexAttribPointer(i,a,n.FLOAT,!1,s,o)),Vt(n,()=>n.enableVertexAttribArray(i)),!0)}function Xbt(n,t,e){txt(n,e),Vt(n,()=>n.activeTexture(n.TEXTURE0+e)),Vt(n,()=>n.bindTexture(n.TEXTURE_2D,t))}function Ybt(n,t,e){return Ki(n,()=>n.getUniformLocation(t,e),'uniform "'+e+'" not present in program.')}function Qbt(n,t,e){return n.getUniformLocation(t,e)}function Zbt(n,t,e,r){Vt(n,()=>Xbt(n,t,r)),Vt(n,()=>n.uniform1i(e,r))}function HC(n,t,e){Vt(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,e)),Vt(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,t,0))}function ZF(n,t){Vt(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,t)),Vt(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,null,0))}function d0(n){const t=n.checkFramebufferStatus(n.FRAMEBUFFER);if(t!==n.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+Jbt(n,t))}function Jbt(n,t){switch(t){case n.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case n.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${t}`}}function Ki(n,t,e){const r=Vt(n,()=>t());if(r==null)throw new Error(e);return r}function txt(n,t){const e=n.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=t+n.TEXTURE0;if(r<n.TEXTURE0||r>e){const a=`[gl.TEXTURE0, gl.TEXTURE${e}]`;throw new Error(`textureUnit must be in ${a}.`)}}function ld(n,t=2){return xt(n.slice(0,n.length-t))}function cd(n){if(n.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[n.length>1?n[n.length-2]:1,n[n.length-1]]}function p0(n){let t=[1,1,1];return n.length===0||n.length===1&&n[0]===1||(t=[ld(n),...cd(n)]),t}function ext(n,t=!1){let e=dt().getNumber("WEBGL_MAX_TEXTURE_SIZE"),r=dt().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");r===1/0&&dt().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(r=e/2),t&&(e=e*2,r=r*2,n=n.map((i,u)=>u>=n.length-2?$b(n[u]):n[u]),n.length===1&&(n=[2,n[0]])),n.length!==2&&(n=Oi(n).newShape);let a=xt(n),s=null;n.length<=1&&a<=e?s=[1,a]:n.length===2&&n[0]<=e&&n[1]<=e?s=n:n.length===3&&n[0]*n[1]<=e&&n[2]<=e?s=[n[0]*n[1],n[2]]:n.length===3&&n[0]<=e&&n[1]*n[2]<=e?s=[n[0],n[1]*n[2]]:n.length===4&&n[0]*n[1]*n[2]<=e&&n[3]<=e?s=[n[0]*n[1]*n[2],n[3]]:n.length===4&&n[0]<=e&&n[1]*n[2]*n[3]<=e&&(s=[n[0],n[1]*n[2]*n[3]]);const o=s!=null&&Math.max(...s)>r&&Math.min(...s)<=(t?2:1)&&Math.min(...s)>0;if(s==null||o)if(t){const i=ld(n);let u=2,l=2;n.length&&([u,l]=cd(n)),a=i*(u/2)*(l/2),s=D0(a).map(h=>h*2)}else s=D0(a);return s}function f0(n){return n%2===0}function Ib(n,t){if(n=n.slice(-2),t=t.slice(-2),De(n,t)||!n.length||!t.length||n[0]===0||n[1]===0||t[0]===0||t[1]===0)return!0;if(n.length!==t.length){const e=n[n.length-1],r=t[t.length-1];if(e===r||f0(e)&&f0(r)&&(n[0]===1||t[0]===1))return!0}return n[1]===t[1]&&f0(n[0])&&f0(t[0])}let jC,qC;function nxt(n){if(jC==null){const t=io(n);jC=t.getParameter(t.MAX_TEXTURE_SIZE)}return jC}function rxt(n){if(qC==null){const t=io(n);qC=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,qC)}function axt(n){if(n===0)return 0;let t;const e=io(n);return Ps(e,"EXT_disjoint_timer_query_webgl2")&&n===2?t=2:Ps(e,"EXT_disjoint_timer_query")?t=1:t=0,t}function Ps(n,t){return n.getExtension(t)!=null}function JF(n){try{if(io(n)!=null)return!0}catch(t){return console.log("Error when getting WebGL context: ",t),!1}return!1}function sxt(n){if(n===0)return!1;const t=io(n);if(n===1){if(!Ps(t,"OES_texture_float"))return!1}else if(!Ps(t,"EXT_color_buffer_float"))return!1;return gk(t)}function oxt(n){if(n===0)return!1;const t=io(n);if(n===1){if(!Ps(t,"OES_texture_float")||!Ps(t,"WEBGL_color_buffer_float"))return!1}else{if(Ps(t,"EXT_color_buffer_float"))return gk(t);const r="EXT_color_buffer_half_float";if(Ps(t,r)){const a=t.getExtension(r);return ixt(t,a)}return!1}return gk(t)}function gk(n){const t=g_(n),e=n.createTexture();n.bindTexture(n.TEXTURE_2D,e),n.texImage2D(n.TEXTURE_2D,0,t.internalFormatFloat,1,1,0,t.textureFormatFloat,t.textureTypeFloat,null);const s=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,s),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,e,0);const o=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(e),n.deleteFramebuffer(s),o}function ixt(n,t){const e=g_(n,t),r=n.createTexture();n.bindTexture(n.TEXTURE_2D,r),n.texImage2D(n.TEXTURE_2D,0,e.internalFormatHalfFloat,1,1,0,e.textureFormatFloat,e.textureTypeHalfFloat,null);const o=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,o),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,r,0);const i=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(r),n.deleteFramebuffer(o),i}function uxt(n){return n!==2?!1:io(n).fenceSync!=null}function fv(n,t){Array.isArray(n)||(n=[n]),n.forEach(e=>{e!=null&&P(e.dtype!=="complex64",()=>`${t} does not support complex64 tensors in the WebGL backend.`)})}const Zt=dt();Zt.registerFlag("HAS_WEBGL",()=>Zt.getNumber("WEBGL_VERSION")>0);Zt.registerFlag("WEBGL_VERSION",()=>JF(2)?2:JF(1)?1:0);Zt.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1);Zt.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>Zt.get("WEBGL_VERSION")===2);Zt.registerFlag("WEBGL_CPU_FORWARD",()=>!0);Zt.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1);Zt.registerFlag("WEBGL_PACK",()=>Zt.getBool("HAS_WEBGL"));Zt.registerFlag("WEBGL_PACK_NORMALIZATION",()=>Zt.getBool("WEBGL_PACK"));Zt.registerFlag("WEBGL_PACK_CLIP",()=>Zt.getBool("WEBGL_PACK"));Zt.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>Zt.getBool("WEBGL_PACK"));Zt.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>Zt.getBool("WEBGL_PACK"));Zt.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>Zt.getBool("WEBGL_PACK"));Zt.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>Zt.getBool("WEBGL_PACK"));Zt.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>Zt.getBool("WEBGL_PACK"));Zt.registerFlag("WEBGL_PACK_REDUCE",()=>Zt.getBool("WEBGL_PACK"));Zt.registerFlag("WEBGL_LAZILY_UNPACK",()=>Zt.getBool("WEBGL_PACK"));Zt.registerFlag("WEBGL_CONV_IM2COL",()=>Zt.getBool("WEBGL_PACK"));Zt.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",()=>Zt.getBool("WEBGL_PACK"));Zt.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>nxt(Zt.getNumber("WEBGL_VERSION")));Zt.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>rxt(Zt.getNumber("WEBGL_VERSION")));Zt.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const n=Zt.getNumber("WEBGL_VERSION");return n===0?0:axt(n)});Zt.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>Zt.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!Fk());Zt.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>sxt(Zt.getNumber("WEBGL_VERSION")));Zt.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>Zt.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:Zt.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));Zt.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>oxt(Zt.getNumber("WEBGL_VERSION")));Zt.registerFlag("WEBGL_FENCE_API_ENABLED",()=>uxt(Zt.getNumber("WEBGL_VERSION")));Zt.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>Zt.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);Zt.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,n=>{if(typeof n!="number")throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${n}.`);if(n<0&&n!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${n}.`)});Zt.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>Fk()?1:-1,n=>{if(typeof n!="number")throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${n}.`);if(n<0&&n!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${n}.`)});Zt.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);Zt.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1);Zt.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5);Zt.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);Zt.registerFlag("WEBGL_EXP_CONV",()=>!1);Zt.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>Zt.getBool("IS_TEST"));Zt.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0);Zt.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1);Zt.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1);Zt.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);function va(){let n,t,e,r,a,s,o,i,u,l;return dt().getNumber("WEBGL_VERSION")===2?(n="#version 300 es",t="in",e="out",r="in",a="texture",s="outputColor",o="out vec4 outputColor;",i=dt().getBool("WEBGL2_ISNAN_CUSTOM")?`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `:"",u="",l=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(n="",t="attribute",e="varying",r="varying",a="texture2D",s="gl_FragColor",o="",i=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,u=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,l=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:n,attribute:t,varyingVs:e,varyingFs:r,texture2D:a,output:s,defineOutput:o,defineSpecialNaN:i,defineSpecialInf:u,defineRound:l}}function Rc(n,t,e="index"){const r=oe(t);return r.map((a,s)=>{const o=`int ${n[s]} = ${e} / ${a}`,i=s===r.length-1?`int ${n[s+1]} = ${e} - ${n[s]} * ${a}`:`index -= ${n[s]} * ${a}`;return`${o}; ${i};`}).join("")}function sw(n,t,e="index"){const r=oe(t);return r.map((a,s)=>{const o=`int ${n[s]} = ${e} / outShapeStrides[${s}]`,i=s===r.length-1?`int ${n[s+1]} = ${e} - ${n[s]} * outShapeStrides[${s}]`:`index -= ${n[s]} * outShapeStrides[${s}]`;return`${o}; ${i};`}).join("")}function lxt(n,t){const e=n.length,r=n.map(s=>`${t}[${s}]`),a=new Array(e-1);a[e-2]=r[e-1];for(let s=e-3;s>=0;--s)a[s]=`(${a[s+1]} * ${r[s+1]})`;return a}function cxt(n,t,e="index"){const r=n.map((s,o)=>o),a=lxt(r,t);return a.map((s,o)=>{const i=`int ${n[o]} = ${e} / ${a[o]}`,u=o===a.length-1?`int ${n[o+1]} = ${e} - ${n[o]} * ${a[o]}`:`index -= ${n[o]} * ${a[o]}`;return`${i}; ${u};`}).join("")}function v_(n){const t=oe(n).map(e=>e.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;
  }
`}function y_(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}const SG=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;const{getBroadcastDims:CG}=hB;function hxt(n,t,e){const r=[];if(n.forEach(m=>{const v=xt(m.shapeInfo.logicalShape);if(m.shapeInfo.isUniform?r.push(`uniform float ${m.name}${v>1?`[${v}]`:""};`):(r.push(`uniform sampler2D ${m.name};`),r.push(`uniform int offset${m.name};`)),e.enableShapeUniforms){const{uniformShape:y}=b_(e.packedInputs,m.shapeInfo.logicalShape,m.shapeInfo.texShape);switch(y.length){case 1:r.push(`uniform int ${m.name}Shape;`);break;case 2:r.push(`uniform ivec2 ${m.name}Shape;`);break;case 3:r.push(`uniform ivec3 ${m.name}Shape;`);break;case 4:r.push(`uniform ivec4 ${m.name}Shape;`);break}r.push(`uniform ivec2 ${m.name}TexShape;`)}}),e.enableShapeUniforms){switch(t.logicalShape.length){case 1:r.push("uniform int outShape;");break;case 2:r.push("uniform ivec2 outShape;"),r.push("uniform int outShapeStrides;");break;case 3:r.push("uniform ivec3 outShape;"),r.push("uniform ivec2 outShapeStrides;");break;case 4:r.push("uniform ivec4 outShape;"),r.push("uniform ivec3 outShapeStrides;");break}r.push("uniform ivec2 outTexShape;")}e.customUniforms&&e.customUniforms.forEach(m=>{r.push(`uniform ${m.type} ${m.name}${m.arrayIndex?`[${m.arrayIndex}]`:""};`)});const a=r.join(`
`),s=n.map(m=>dxt(m,t,e.packedInputs,e.enableShapeUniforms)).join(`
`),o=t.texShape,i=va(),u=mxt(i);let l,h,d=yxt(i);return t.isPacked?(l=pxt(t.logicalShape,o,e.enableShapeUniforms),h=vxt(i)):(l=fxt(t.logicalShape,o,e.enableShapeUniforms),h=gxt(i)),e.packedInputs&&(d+=Sxt),[d,u,h,a,l,s,e.userCode].join(`
`)}function vp(n,t=!1){const e=n.shapeInfo.logicalShape;switch(e.length){case 0:return Oxt(n,t);case 1:return Mxt(n,t);case 2:return Bxt(n,t);case 3:return Pxt(n,t);case 4:return Uxt(n,t);case 5:return Wxt(n);case 6:return Gxt(n);default:throw new Error(`${e.length}-D input sampling is not yet supported`)}}function NG(n,t){switch(n.shapeInfo.logicalShape.length){case 0:return $xt(n);case 1:return Fxt(n,t);case 2:return Lxt(n,t);case 3:return zxt(n,t);default:return Vxt(n,t)}}function dxt(n,t,e=!1,r){let a="";e?a+=NG(n,r):a+=vp(n,r);const s=n.shapeInfo.logicalShape,o=t.logicalShape;return s.length<=o.length&&(e?a+=Hxt(n,t):a+=jxt(n,t)),a}function pxt(n,t,e){switch(n.length){case 0:return kG();case 1:return Cxt(n,t,e);case 2:return Axt(n,t,e);case 3:return kxt(n,t,e);default:return Ext(n,t,e)}}function fxt(n,t,e){switch(n.length){case 0:return kG();case 1:return Nxt(n,t,e);case 2:return Dxt(n,t,e);case 3:return Txt(n,t,e);case 4:return Ixt(n,t,e);case 5:return _xt(n,t);case 6:return Rxt(n,t);default:throw new Error(`${n.length}-D output sampling is not yet supported`)}}function mxt(n){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${n.texture2D}(textureSampler, uv).r;
    }
  `}function gxt(n){return`
    void setOutput(float val) {
      ${n.output} = vec4(val, 0, 0, 0);
    }
  `}function vxt(n){return`
    void setOutput(vec4 val) {
      ${n.output} = val;
    }
  `}function yxt(n){return`${n.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${n.varyingFs} vec2 resultUV;
    ${n.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${n.defineSpecialNaN}
    ${n.defineSpecialInf}
    ${n.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${bxt}
    ${xxt}
    ${wxt}
  `}const bxt=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,xxt=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,wxt=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,Sxt=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function kG(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function Cxt(n,t,e){const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];return r[0]===1?e?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${r[1]}.0);
      }
    `:r[1]===1?e?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${r[0]}.0);
      }
    `:e?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      return 2 * (resTexRC.x * ${r[1]} + resTexRC.y);
    }
  `}function Nxt(n,t,e){return t[0]===1?e?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${t[1]}.0);
      }
    `:t[1]===1?e?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${t[0]}.0);
      }
    `:e?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      return resTexRC.x * ${t[1]} + resTexRC.y;
    }
  `}function kxt(n,t,e){if(e)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],a=Math.ceil(n[2]/2),s=a*Math.ceil(n[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      int index = resTexRC.x * ${r[1]} + resTexRC.y;

      int b = index / ${s};
      index -= b * ${s};

      int r = 2 * (index / ${a});
      int c = imod(index, ${a}) * 2;

      return ivec3(b, r, c);
    }
  `}function Txt(n,t,e){if(e)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${sw(["r","c","d"],n)}
    return ivec3(r, c, d);
  }
`;const r=Rc(["r","c","d"],n);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      ${r}
      return ivec3(r, c, d);
    }
  `}function Ext(n,t,e){if(e)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],a=Math.ceil(n[n.length-1]/2),s=a*Math.ceil(n[n.length-2]/2);let o=s,i="",u="b, r, c";for(let l=2;l<n.length-1;l++)o*=n[n.length-l-1],i=`
      int b${l} = index / ${o};
      index -= b${l} * ${o};
    `+i,u=`b${l}, `+u;return`
    ivec${n.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      int index = resTexRC.x * ${r[1]} + resTexRC.y;

      ${i}

      int b = index / ${s};
      index -= b * ${s};

      int r = 2 * (index / ${a});
      int c = imod(index, ${a}) * 2;

      return ivec${n.length}(${u});
    }
  `}function Ixt(n,t,e){if(e)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${sw(["r","c","d","d2"],n)}
      return ivec4(r, c, d, d2);
    }
  `;const r=Rc(["r","c","d","d2"],n);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      ${r}
      return ivec4(r, c, d, d2);
    }
  `}function _xt(n,t){const e=Rc(["r","c","d","d2","d3"],n);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},
                             ${t[1]}));

      int index = resTexRC.x * ${t[1]} + resTexRC.y;

      ${e}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function Rxt(n,t){const e=Rc(["r","c","d","d2","d3","d4"],n);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;

      ${e}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function Axt(n,t,e){const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(De(n,t))return e?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${r[0]}, ${r[1]}));
      }
    `;const a=Math.ceil(n[1]/2);return e?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));

      int index = resTexRC.x * ${r[1]} + resTexRC.y;
      int r = 2 * (index / ${a});
      int c = imod(index, ${a}) * 2;

      return ivec2(r, c);
    }
  `}function Dxt(n,t,e){return De(n,t)?e?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));
      }
    `:n[1]===1?e?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${t[0]}, ${t[1]}));
        int index = resTexRC.x * ${t[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:n[0]===1?e?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${t[0]}, ${t[1]}));
        int index = resTexRC.x * ${t[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:e?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      int r = index / ${n[1]};
      int c = index - r * ${n[1]};
      return ivec2(r, c);
    }
  `}function Ac(n){return`offset${n}`}function $xt(n){const t=n.name,e="get"+t.charAt(0).toUpperCase()+t.slice(1),r=va();return`
    vec4 ${e}() {
      return ${r.texture2D}(${t}, halfCR);
    }
  `}function Oxt(n,t){const e=n.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1);if(n.shapeInfo.isUniform)return`float ${r}() {return ${e};}`;const[a,s]=n.shapeInfo.texShape;if(a===1&&s===1)return`
      float ${r}() {
        return sampleTexture(${e}, halfCR);
      }
    `;const o=Ac(e);if(t)return`
    float ${r}() {
      vec2 uv = uvFromFlat(${e}TexShape[0], ${e}TexShape[1], ${o});
      return sampleTexture(${e}, uv);
    }
  `;const[i,u]=n.shapeInfo.texShape;return`
    float ${r}() {
      vec2 uv = uvFromFlat(${i}, ${u}, ${o});
      return sampleTexture(${e}, uv);
    }
  `}function Fxt(n,t){const e=n.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1),a=n.shapeInfo.texShape,s=va();if(t)return`
    vec4 ${r}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${e}TexShape[0]) / 2.0), ceil(float(${e}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${s.texture2D}(${e}, uv);
    }
  `;const o=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)];return`
    vec4 ${r}(int index) {
      vec2 uv = packedUVfrom1D(
        ${o[0]}, ${o[1]}, index);
      return ${s.texture2D}(${e}, uv);
    }
  `}function Mxt(n,t){const e=n.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1);if(n.shapeInfo.isUniform)return`
      float ${r}(int index) {
        ${yp(n)}
      }
    `;const a=n.shapeInfo.texShape,s=a[0],o=a[1];if(o===1&&s===1)return`
      float ${r}(int index) {
        return sampleTexture(${e}, halfCR);
      }
    `;const i=Ac(e);return o===1?t?`
      float ${r}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${i}) + 0.5) / float(${e}TexShape[0]));
        return sampleTexture(${e}, uv);
      }
    `:`
      float ${r}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${i}) + 0.5) / ${s}.0);
        return sampleTexture(${e}, uv);
      }
    `:s===1?t?`
      float ${r}(int index) {
        vec2 uv = vec2((float(index + ${i}) + 0.5) / float(${e}TexShape[1]), 0.5);
        return sampleTexture(${e}, uv);
      }
    `:`
      float ${r}(int index) {
        vec2 uv = vec2((float(index + ${i}) + 0.5) / ${o}.0, 0.5);
        return sampleTexture(${e}, uv);
      }
    `:t?`
    float ${r}(int index) {
      vec2 uv = uvFromFlat(${e}TexShape[0], ${e}TexShape[1], index + ${i});
      return sampleTexture(${e}, uv);
    }
  `:`
    float ${r}(int index) {
      vec2 uv = uvFromFlat(${s}, ${o}, index + ${i});
      return sampleTexture(${e}, uv);
    }
  `}function Lxt(n,t){const e=n.shapeInfo.logicalShape,r=n.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=n.shapeInfo.texShape,o=s[0],i=s[1],u=va();if(s!=null&&De(e,s))return t?`
      vec4 ${a}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);

        return ${u.texture2D}(${r}, uv);
      }
    `:`
      vec4 ${a}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${i}.0, ${o}.0);

        return ${u.texture2D}(${r}, uv);
      }
    `;if(t)return`
    vec4 ${a}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${r}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${u.texture2D}(${r}, uv);
    }
  `;const l=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)],h=Math.ceil(e[1]/2);return`
    vec4 ${a}(int row, int col) {
      vec2 uv = packedUVfrom2D(${h}, ${l[0]}, ${l[1]}, row, col);
      return ${u.texture2D}(${r}, uv);
    }
  `}function Bxt(n,t){const e=n.shapeInfo.logicalShape,r=n.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=n.shapeInfo.texShape;if(s!=null&&De(e,s)){if(t)return`
      float ${a}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `;const f=s[0],m=s[1];return`
    float ${a}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${m}.0, ${f}.0);
      return sampleTexture(${r}, uv);
    }
  `}const{newShape:o,keptDims:i}=Oi(e),u=o;if(u.length<e.length){const f=bp(n,u),m=["row","col"];return`
      ${vp(f,t)}
      float ${a}(int row, int col) {
        return ${a}(${xp(m,i)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${a}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${e[1]}, 1)));
        ${yp(n)}
      }
    `;const l=s[0],h=s[1],d=Ac(r);return h===1?t?`
      float ${a}(int row, int col) {
        float index = dot(vec3(row, col, ${d}), vec3(${r}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${r}TexShape[0]));
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${a}(int row, int col) {
      float index = dot(vec3(row, col, ${d}), vec3(${e[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${l}.0);
      return sampleTexture(${r}, uv);
    }
  `:l===1?t?`
      float ${a}(int row, int col) {
        float index = dot(vec3(row, col, ${d}), vec3(${r}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${r}TexShape[1]), 0.5);
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${a}(int row, int col) {
      float index = dot(vec3(row, col, ${d}), vec3(${e[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${h}.0, 0.5);
      return sampleTexture(${r}, uv);
    }
  `:t?`
      float ${a}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${r}Shape[1] + col + ${d};
        vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);
        return sampleTexture(${r}, uv);
      }
    `:`
  float ${a}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${e[1]} + col + ${d};
    vec2 uv = uvFromFlat(${l}, ${h}, index);
    return sampleTexture(${r}, uv);
  }
`}function zxt(n,t){const e=n.shapeInfo.logicalShape,r=n.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=n.shapeInfo.texShape,o=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];if(e[0]===1){const f=e.slice(1),m=[1,2],v=bp(n,f),y=["b","row","col"];return`
        ${NG(v,t)}
        vec4 ${a}(int b, int row, int col) {
          return ${a}(${xp(y,m)});
        }
      `}const i=va();if(t)return`
    vec4 ${a}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${r}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${r}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${i.texture2D}(${r}, uv);
    }
  `;const u=o[0],l=o[1],h=Math.ceil(e[2]/2),d=h*Math.ceil(e[1]/2);return`
    vec4 ${a}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${u}, ${l}, ${d}, ${h}, b, row, col);
      return ${i.texture2D}(${r}, uv);
    }
  `}function Pxt(n,t){const e=n.shapeInfo.logicalShape,r=n.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=e[1]*e[2],o=e[2],{newShape:i,keptDims:u}=Oi(e),l=i;if(l.length<e.length){const y=bp(n,l),b=["row","col","depth"];return`
        ${vp(y,t)}
        float ${a}(int row, int col, int depth) {
          return ${a}(${xp(b,u)});
        }
      `}if(n.shapeInfo.isUniform)return`
      float ${a}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${s}, ${o}, 1)));
        ${yp(n)}
      }
    `;const h=n.shapeInfo.texShape,d=h[0],f=h[1],m=n.shapeInfo.flatOffset;if(f===s&&m==null)return t?`
      float ${a}(int row, int col, int depth) {
        int stride1 = ${r}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
        float ${a}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${o}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${f}.0, ${d}.0);
          return sampleTexture(${r}, uv);
        }
      `;if(f===o&&m==null)return t?`
      float ${a}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${r}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${a}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${e[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${f}.0, ${d}.0);
      return sampleTexture(${r}, uv);
    }
  `;const v=Ac(r);return t?`
    float ${a}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${r}Shape[1] * ${r}Shape[2];
      int stride1 = ${r}Shape[2];
      int index = row * stride0 + col * stride1 + depth + ${v};
      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);
      return sampleTexture(${r}, uv);
    }
    `:`
      float ${a}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${s} + col * ${o} + depth + ${v};
        vec2 uv = uvFromFlat(${d}, ${f}, index);
        return sampleTexture(${r}, uv);
      }
  `}function Vxt(n,t){const e=n.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1),a=va();if(t)return`
    vec4 ${r}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${e}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${e}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${e}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${e}TexShape[0]) / 2.0), ceil(float(${e}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${a.texture2D}(${e}, uv);
    }
  `;const s=n.shapeInfo.logicalShape,o=s.length,i=n.shapeInfo.texShape,u=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)],l=u[0],h=u[1],d=Math.ceil(s[o-1]/2);let f=d*Math.ceil(s[o-2]/2),m="int b, int row, int col",v=`b * ${f} + (row / 2) * ${d} + (col / 2)`;for(let y=2;y<o-1;y++)m=`int b${y}, `+m,f*=s[o-y-1],v=`b${y} * ${f} + `+v;return`
    vec4 ${r}(${m}) {
      int index = ${v};
      int texR = index / ${h};
      int texC = index - texR * ${h};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${h}, ${l});
      return ${a.texture2D}(${e}, uv);
    }
  `}function Uxt(n,t){const e=n.shapeInfo.logicalShape,r=n.name,a="get"+r.charAt(0).toUpperCase()+r.slice(1),s=e[3],o=e[2]*s,i=e[1]*o,{newShape:u,keptDims:l}=Oi(e);if(u.length<e.length){const S=bp(n,u),N=["row","col","depth","depth2"];return`
      ${vp(S,t)}
      float ${a}(int row, int col, int depth, int depth2) {
        return ${a}(${xp(N,l)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${a}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${i}, ${o}, ${s}, 1)));
        ${yp(n)}
      }
    `;const h=n.shapeInfo.flatOffset,d=n.shapeInfo.texShape,f=d[0],m=d[1],v=`int stride2 = ${r}Shape[3];`,y=`int stride1 = ${r}Shape[2] * stride2;`,b=`int stride0 = ${r}Shape[1] * stride1;`;if(m===i&&h==null)return t?`
      float ${a}(int row, int col, int depth, int depth2) {
        ${v}
        ${y}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
      float ${a}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${o}, ${s}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${m}.0, ${f}.0);
        return sampleTexture(${r}, uv);
      }
    `;if(m===s&&h==null)return t?`
      float ${a}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${r}Shape[1] * ${r}Shape[2], ${r}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
      float ${a}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${e[1]*e[2]}, ${e[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${m}.0, ${f}.0);
        return sampleTexture(${r}, uv);
      }
    `;const w=Ac(r);return t?`
    float ${a}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${v}
      ${y}
      ${b}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index + ${w});
      return sampleTexture(${r}, uv);
    }
  `:`
    float ${a}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${i} + col * ${o} +
          depth * ${s} + depth2;
      vec2 uv = uvFromFlat(${f}, ${m}, index + ${w});
      return sampleTexture(${r}, uv);
    }
  `}function Wxt(n){const t=n.shapeInfo.logicalShape,e=n.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1),a=t[4],s=t[3]*a,o=t[2]*s,i=t[1]*o,{newShape:u,keptDims:l}=Oi(t);if(u.length<t.length){const y=bp(n,u),b=["row","col","depth","depth2","depth3"];return`
      ${vp(y)}
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        return ${r}(${xp(b,l)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${i}, ${o}, ${s}, ${a})) +
          depth3;
        ${yp(n)}
      }
    `;const h=n.shapeInfo.flatOffset,d=n.shapeInfo.texShape,f=d[0],m=d[1];if(m===i&&h==null)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${o}, ${s}, ${a}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${m}.0, ${f}.0);
        return sampleTexture(${e}, uv);
      }
    `;if(m===a&&h==null)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${t[1]*t[2]*t[3]},
               ${t[2]*t[3]}, ${t[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${m}.0, ${f}.0);
        return sampleTexture(${e}, uv);
      }
    `;const v=Ac(e);return`
    float ${r}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${i} + col * ${o} + depth * ${s} +
          depth2 * ${a} + depth3 + ${v};
      vec2 uv = uvFromFlat(${f}, ${m}, index);
      return sampleTexture(${e}, uv);
    }
  `}function Gxt(n){const t=n.shapeInfo.logicalShape,e=n.name,r="get"+e.charAt(0).toUpperCase()+e.slice(1),{newShape:a,keptDims:s}=Oi(t);if(a.length<t.length){const b=bp(n,a),w=["row","col","depth","depth2","depth3","depth4"];return`
      ${vp(b)}
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${r}(${xp(w,s)});
      }
    `}const o=t[5],i=t[4]*o,u=t[3]*i,l=t[2]*u,h=t[1]*l;if(n.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${h}, ${l}, ${u}, ${i})) +
          dot(
            vec2(depth3, depth4),
            vec2(${o}, 1)));
        ${yp(n)}
      }
    `;const d=n.shapeInfo.flatOffset,f=n.shapeInfo.texShape,m=f[0],v=f[1];if(v===h&&d==null)return`
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${l}, ${u}, ${i}, ${o})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${v}.0, ${m}.0);
        return sampleTexture(${e}, uv);
      }
    `;if(v===o&&d==null)return`
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${t[1]*t[2]*t[3]*t[4]},
               ${t[2]*t[3]*t[4]},
               ${t[3]*t[4]},
               ${t[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${v}.0, ${m}.0);
        return sampleTexture(${e}, uv);
      }
    `;const y=Ac(e);return`
    float ${r}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${h} + col * ${l} + depth * ${u} +
          depth2 * ${i} + depth3 * ${o} + depth4 + ${y};
      vec2 uv = uvFromFlat(${m}, ${v}, index);
      return sampleTexture(${e}, uv);
    }
  `}function yp(n){const t=n.name,e=xt(n.shapeInfo.logicalShape);return e<2?`return ${t};`:`
    for (int i = 0; i < ${e}; i++) {
      if (i == index) {
        return ${t}[i];
      }
    }
  `}function Hxt(n,t){const e=n.name,r=e.charAt(0).toUpperCase()+e.slice(1),a="get"+r+"AtOutCoords",s=n.shapeInfo.logicalShape.length,o=t.logicalShape.length,i=CG(n.shapeInfo.logicalShape,t.logicalShape),u=sn(o),l=o-s;let h;const d=["x","y","z","w","u","v"];s===0?h="":o<2&&i.length>=1?h="coords = 0;":h=i.map(S=>`coords.${d[S+l]} = 0;`).join(`
`);let f="";o<2&&s>0?f="coords":f=n.shapeInfo.logicalShape.map((S,N)=>`coords.${d[N+l]}`).join(", ");let m="return outputValue;";const y=xt(n.shapeInfo.logicalShape)===1,w=xt(t.logicalShape)===1;if(s===1&&!y&&!w)m=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(y&&!w)o===1?m=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:m=`
        return vec4(outputValue.x);
      `;else if(i.length){const S=s-2,N=s-1;i.indexOf(S)>-1&&i.indexOf(N)>-1?m="return vec4(outputValue.x);":i.indexOf(S)>-1?m="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":i.indexOf(N)>-1&&(m="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${a}() {
      ${u} coords = getOutputCoords();
      ${h}
      vec4 outputValue = get${r}(${f});
      ${m}
    }
  `}function jxt(n,t){const e=n.name,r=e.charAt(0).toUpperCase()+e.slice(1),a="get"+r+"AtOutCoords",s=t.texShape,o=n.shapeInfo.texShape,i=n.shapeInfo.logicalShape.length,u=t.logicalShape.length;if(!n.shapeInfo.isUniform&&i===u&&n.shapeInfo.flatOffset==null&&De(o,s))return`
      float ${a}() {
        return sampleTexture(${e}, resultUV);
      }
    `;const l=sn(u),h=CG(n.shapeInfo.logicalShape,t.logicalShape),d=u-i;let f;const m=["x","y","z","w","u","v"];i===0?f="":u<2&&h.length>=1?f="coords = 0;":f=h.map(y=>`coords.${m[y+d]} = 0;`).join(`
`);let v="";return u<2&&i>0?v="coords":v=n.shapeInfo.logicalShape.map((y,b)=>`coords.${m[b+d]}`).join(", "),`
    float ${a}() {
      ${l} coords = getOutputCoords();
      ${f}
      return get${r}(${v});
    }
  `}function sn(n){if(n<=1)return"int";if(n===2)return"ivec2";if(n===3)return"ivec3";if(n===4)return"ivec4";if(n===5)return"ivec5";if(n===6)return"ivec6";throw Error(`GPU for rank ${n} is not yet supported`)}function b_(n,t,e){const{newShape:r,keptDims:a}=Oi(t),s=t.length,o=n&&s===3&&t[0]===1,i=o?t.slice(1):r,u=!n&&s>1&&!De(t,e)&&r.length<s||o;return{useSqueezeShape:u,uniformShape:u?i:t,keptDims:a}}function bp(n,t){const e=JSON.parse(JSON.stringify(n));return e.shapeInfo.logicalShape=t,e}function xp(n,t){return t.map(e=>n[e]).join(", ")}function qxt(n,t,e,r){const a=e.map((h,d)=>{const f={logicalShape:h.shape,texShape:h.isUniform?null:h.texData.texShape,isUniform:h.isUniform,isPacked:h.isUniform?!1:h.texData.isPacked,flatOffset:null};return h.texData!=null&&h.texData.slice!=null&&h.texData.slice.flatOffset>0&&(f.flatOffset=h.texData.slice.flatOffset),{name:t.variableNames[d],shapeInfo:f}}),s=a.map(h=>h.shapeInfo),o={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},i=hxt(a,o,t),u=Pbt(n.gl,i),l=n.createProgram(u);return dt().get("ENGINE_COMPILE_ONLY")?{program:t,fragmentShader:u,source:i,webGLProgram:l,inShapeInfos:s,outShapeInfo:o,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(n.buildVao(l),Object.assign({program:t,fragmentShader:u,source:i,webGLProgram:l,inShapeInfos:s,outShapeInfo:o},TG(n,t,l)))}function TG(n,t,e){const r=[],a=[];let s,o,i,u=null,l=null;l=n.getUniformLocation(e,"NAN",!1),dt().getNumber("WEBGL_VERSION")===1&&(u=n.getUniformLocation(e,"INFINITY",!1));const h=!1;for(const d of t.variableNames){const f={name:d,uniform:n.getUniformLocation(e,d,h),offset:n.getUniformLocation(e,`offset${d}`,h)};t.enableShapeUniforms&&(f.shape=n.getUniformLocation(e,`${d}Shape`,h),f.texShape=n.getUniformLocation(e,`${d}TexShape`,h)),r.push(f)}if(t.enableShapeUniforms&&(s=n.getUniformLocation(e,"outShape",h),i=n.getUniformLocation(e,"outShapeStrides",h),o=n.getUniformLocation(e,"outTexShape",h)),t.customUniforms)for(const d of t.customUniforms)a.push(n.getUniformLocation(e,d.name,h));return{variablesLocations:r,customUniformLocations:a,infLoc:u,nanLoc:l,outShapeLocation:s,outShapeStridesLocation:i,outTexShapeLocation:o}}function tM(n,t){if(n.length!==t.length)throw Error(`Binary was compiled with ${n.length} inputs, but was executed with ${t.length} inputs`);n.forEach((e,r)=>{const a=e.logicalShape,s=t[r],o=s.shape;if(!De(a,o))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${a} and ${o} must match`);if(e.isUniform&&s.isUniform)return;const i=e.texShape,u=s.isUniform?null:s.texData.texShape;if(!De(i,u))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${i} and ${u} must match`)})}function Kxt(n,t,e,r,a){t.program.enableShapeUniforms||(tM(t.inShapeInfos,e),tM([t.outShapeInfo],[r]));const s=r.texData.texture,o=r.texData.texShape;r.texData.isPacked?n.setOutputPackedMatrixTexture(s.texture,o[0],o[1]):n.setOutputMatrixTexture(s.texture,o[0],o[1]),n.setProgram(t.webGLProgram),n.bindVertexArray(t.webGLProgram.vao),dt().getNumber("WEBGL_VERSION")===1&&t.infLoc!==null&&n.gl.uniform1f(t.infLoc,1/0),t.nanLoc!==null&&n.gl.uniform1f(t.nanLoc,NaN);for(let u=0;u<e.length;++u){const l=e[u],{uniform:h,offset:d,shape:f,texShape:m}=t.variablesLocations[u];if(f){const{uniformShape:v}=b_(t.program.packedInputs,l.shape,l.texData.texShape);switch(v.length){case 1:n.gl.uniform1iv(f,new Int32Array(v));break;case 2:n.gl.uniform2iv(f,new Int32Array(v));break;case 3:n.gl.uniform3iv(f,new Int32Array(v));break;case 4:n.gl.uniform4iv(f,new Int32Array(v));break}}if(m&&n.gl.uniform2i(m,l.texData.texShape[0],l.texData.texShape[1]),h!=null){if(l.isUniform){if(xt(l.shape)<2)n.gl.uniform1f(h,l.uniformValues[0]);else{let v=l.uniformValues;v instanceof Float32Array||(v=new Float32Array(v)),n.gl.uniform1fv(h,v)}continue}l.texData.slice!=null&&d!=null&&n.gl.uniform1i(d,l.texData.slice.flatOffset),n.setInputMatrixTexture(l.texData.texture.texture,h,u)}}const i=t.outShapeLocation;if(i)switch(r.shape.length){case 1:n.gl.uniform1iv(i,new Int32Array(r.shape));break;case 2:n.gl.uniform2iv(i,new Int32Array(r.shape));break;case 3:n.gl.uniform3iv(i,new Int32Array(r.shape));break;case 4:n.gl.uniform4iv(i,new Int32Array(r.shape));break}if(t.outShapeStridesLocation){const u=oe(r.shape);switch(r.shape.length){case 2:n.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(u));break;case 3:n.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(u));break;case 4:n.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(u));break}}if(t.outTexShapeLocation&&n.gl.uniform2i(t.outTexShapeLocation,r.texData.texShape[0],r.texData.texShape[1]),t.program.customUniforms&&a)for(let u=0;u<t.program.customUniforms.length;++u){const l=t.program.customUniforms[u],h=t.customUniformLocations[u],d=a[u];if(l.type==="float")n.gl.uniform1fv(h,d);else if(l.type==="vec2")n.gl.uniform2fv(h,d);else if(l.type==="vec3")n.gl.uniform3fv(h,d);else if(l.type==="vec4")n.gl.uniform4fv(h,d);else if(l.type==="int")n.gl.uniform1iv(h,d);else if(l.type==="ivec2")n.gl.uniform2iv(h,d);else if(l.type==="ivec3")n.gl.uniform3iv(h,d);else if(l.type==="ivec4")n.gl.uniform4iv(h,d);else throw Error(`uniform type ${l.type} is not supported yet.`)}n.executeProgram()}function Xxt(n,t,e){let r="";t.concat(e).forEach(o=>{const i=o.texData!=null&&o.texData.slice!=null&&o.texData.slice.flatOffset>0;if(n.enableShapeUniforms&&!o.isUniform){const u=o.texData.texShape,{useSqueezeShape:l,uniformShape:h,keptDims:d}=b_(n.packedInputs,o.shape,u);let f="",m="",v="";if(h.length===1&&n.packedInputs){const T=[Math.ceil(u[0]/2),Math.ceil(u[1]/2)];f=`${T[0]>1}_${T[1]>1}`}else if(h.length===2&&!n.packedInputs)m=`${h[0]>1}_${h[1]>1}`;else if(h.length>2&&!n.packedInputs){const T=oe(h);v=`${T[0]===u[1]}_${T[T.length-1]===u[1]}`}const y=o.shape.length,b=h.length===2&&De(o.shape,u),w=xt(o.shape)===1,S=rc(o.shape,e.shape),N=!n.packedInputs&&y===e.shape.length&&De(u,e.texData.texShape),C=n.packedInputs||h.length>2?"":`${u[0]>1}_${u[1]>1}`;r+=`${y}_${N}_${l?d:""}_${h.length}_${w}_${S}_${b}_${f}_${m}_${v}_${C}_${i}`}else{const u=o.isUniform?"uniform":o.texData.texShape;r+=`${o.shape}_${u}_${i}`}});const a=n.userCode;let s=n.constructor.name;return s+="_"+r+"_"+a+`${dt().getNumber("WEBGL_VERSION")}`,s}function ta(n){return dt().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&n<=4}class Yxt{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=mm.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const e=va();this.outputShape=t,this.enableShapeUniforms=ta(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?sw(["r","c","d"],t):Rc(["r","c","d"],t)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${e.output} = result;
      }
    `}}class Qxt{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=mm.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const e=va();this.outputShape=t,this.enableShapeUniforms=ta(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?sw(["r","c","d"],t):Rc(["r","c","d"],t)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${e.output} = result;
      }
    `}}class Zxt{constructor(t){this.variableNames=["A"],this.outTexUsage=fs.DOWNLOAD;const e=va();this.outputShape=t,this.userCode=`
      ${SG}

      void main() {
        float x = getAAtOutCoords();
        ${e.output} = encode_float(x);
      }
    `}}class Jxt{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=fs.DOWNLOAD;const e=va();this.outputShape=t,this.userCode=`
      ${SG}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${e.output} = encode_float(x);
      }
    `}}const t1t={R:0,G:1,B:2,A:3};class eM{constructor(t,e=!1,r="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const a=va();this.outputShape=t,this.enableShapeUniforms=ta(this.outputShape.length);let s="result";e&&(s="floor(result * 255. + 0.5)");let o="";for(let i=0;i<r.length;i++){const u=r[i];o+=`
          if(offset == ${i}) {
            result = values[${t1t[u]}];
          }`}this.userCode=`
      ${this.enableShapeUniforms?y_():v_(t)}

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, ${r.length});

        flatIndex = idiv(flatIndex, ${r.length}, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = ${a.texture2D}(A, uv);
          ${o}
        }
        ${a.output} = vec4(${s}, 0., 0., 0.);
      }
    `}}class e1t{constructor(t,e=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const r=va();this.outputShape=t,this.enableShapeUniforms=ta(this.outputShape.length);let a="",s="result";e&&(s="floor(result * 255. + 0.5)");for(let o=0;o<=1;o++)for(let i=0;i<=1;i++){const u=o*2+i;a+=`
          localCoords = coords;
          if(localCoords[2] + ${i} < ${this.enableShapeUniforms?"outShape[2]":`${t[2]}`}) {
          localCoords[2] += ${i};
          if (localCoords[1] + ${o} < ${this.enableShapeUniforms?"outShape[1]":`${t[1]}`}) {
            localCoords[1] += ${o};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${r.texture2D}(A, uv);

            if (offset == 0) {
              result[${u}] = values[0];
            } else if (offset == 1) {
              result[${u}] = values[1];
            } else if (offset == 2) {
              result[${u}] = values[2];
            } else {
              result[${u}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?y_():v_(t)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${a}

          ${r.output} = ${s};
        }
    `}}function n1t(n){const t=va(),e=`${t.version}
    precision highp float;
    ${t.attribute} vec3 clipSpacePos;
    ${t.attribute} vec2 uv;
    ${t.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return zbt(n,e)}function r1t(n){const t=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return Gbt(n,t)}function a1t(n){const t=new Uint16Array([0,1,2,2,1,3]);return Hbt(n,t)}function mv(n,t,e,r,a,s){qbt(t,e);const o=jbt(n),i=n.TEXTURE_2D;return Vt(n,()=>n.bindTexture(i,o)),Vt(n,()=>n.texParameteri(i,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE)),Vt(n,()=>n.texParameteri(i,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE)),Vt(n,()=>n.texParameteri(i,n.TEXTURE_MIN_FILTER,n.NEAREST)),Vt(n,()=>n.texParameteri(i,n.TEXTURE_MAG_FILTER,n.NEAREST)),dt().getNumber("WEBGL_VERSION")===1?Vt(n,()=>n.texImage2D(i,0,r,t,e,0,a,s,null)):Vt(n,()=>n.texStorage2D(i,1,r,t,e)),Vt(n,()=>n.bindTexture(n.TEXTURE_2D,null)),{texture:o,texShape:[e,t]}}function EG(n){return n.internalFormatFloat}function s1t(n,t,e,r){const[a,s]=pv(t,e);return mv(n,a,s,EG(r),r.textureFormatFloat,n.FLOAT)}function IG(n){return n.internalFormatHalfFloat}function o1t(n,t,e,r){const[a,s]=pv(t,e);return mv(n,a,s,IG(r),r.textureFormatFloat,r.textureTypeHalfFloat)}function _G(n){return n.downloadTextureFormat}function i1t(n,t,e,r){const[a,s]=pv(t,e);return mv(n,a,s,_G(r),n.RGBA,n.UNSIGNED_BYTE)}function RG(n){return n.internalFormatPackedFloat}function u1t(n,t,e,r){const[a,s]=gp(t,e);return mv(n,a,s,RG(r),n.RGBA,n.FLOAT)}function AG(n){return n.internalFormatPackedHalfFloat}function l1t(n,t,e,r){const[a,s]=gp(t,e);return mv(n,a,s,AG(r),n.RGBA,r.textureTypeHalfFloat)}function c1t(n,t,e){return Vt(n,()=>n.bindBuffer(n.ARRAY_BUFFER,e)),QF(n,t,"clipSpacePos",e,3,20,0)&&QF(n,t,"uv",e,2,20,12)}function h1t(n,t,e,r,a,s){Vt(n,()=>n.bindTexture(n.TEXTURE_2D,t));let o,i,u;a instanceof Uint8Array?(o=new Uint8Array(e*r*4),i=n.UNSIGNED_BYTE,u=n.RGBA):(o=new Float32Array(e*r*4),i=n.FLOAT,u=s.internalFormatPackedFloat),o.set(a),dt().getNumber("WEBGL_VERSION")===2?Vt(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,e,r,n.RGBA,i,o)):Vt(n,()=>n.texImage2D(n.TEXTURE_2D,0,u,e,r,0,n.RGBA,i,o)),Vt(n,()=>n.bindTexture(n.TEXTURE_2D,null))}function d1t(n,t,e){Vt(n,()=>n.bindTexture(n.TEXTURE_2D,t)),e.data instanceof Uint8Array?dt().getNumber("WEBGL_VERSION")===2?Vt(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,e.width,e.height,n.RGBA,n.UNSIGNED_BYTE,e.data)):Vt(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,e.width,e.height,0,n.RGBA,n.UNSIGNED_BYTE,e.data)):dt().getNumber("WEBGL_VERSION")===2?Vt(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,n.RGBA,n.UNSIGNED_BYTE,e)):Vt(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,n.RGBA,n.UNSIGNED_BYTE,e)),Vt(n,()=>n.bindTexture(n.TEXTURE_2D,null))}function p1t(n,t,e,r){const a=n.createBuffer();Vt(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,a));const i=4*4*t*e;return Vt(n,()=>n.bufferData(n.PIXEL_PACK_BUFFER,i,n.STREAM_READ)),Vt(n,()=>n.readPixels(0,0,e,t,n.RGBA,n.FLOAT,0)),Vt(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,null)),a}function f1t(n,t,e){const r=n,a=new Float32Array(e);return r.bindBuffer(r.PIXEL_PACK_BUFFER,t),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,a),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),a}function m1t(n,t,e,r){const[a,s]=pv(t,e),o=4,i=new Uint8Array(Dbt(t*e,o));return Vt(n,()=>n.readPixels(0,0,a,s,r.downloadTextureFormat,n.UNSIGNED_BYTE,i)),new Float32Array(i.buffer)}function g1t(n,t,e,r,a,s,o,i){const u=n,l=new Float32Array($bt(s,o));return u.bindBuffer(u.PIXEL_PACK_BUFFER,t),u.getBufferSubData(u.PIXEL_PACK_BUFFER,0,l),u.bindBuffer(u.PIXEL_PACK_BUFFER,null),l}function v1t(n,t,e){const r=new Float32Array(t*e*4);return Vt(n,()=>n.readPixels(0,0,e,t,n.RGBA,n.FLOAT,r)),r}class KC{constructor(t){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const e=dt().getNumber("WEBGL_VERSION");if(t!=null?(this.gl=t,_bt(e,t)):this.gl=io(e),t=this.gl,dt().getNumber("WEBGL_VERSION")===2){const s=t;this.createVertexArray=()=>Vt(s,()=>s.createVertexArray()),this.bindVertexArray=o=>Vt(s,()=>s.bindVertexArray(o)),this.deleteVertexArray=o=>Vt(s,()=>s.deleteVertexArray(o)),this.getVertexArray=()=>Vt(s,()=>s.getParameter(s.VERTEX_ARRAY_BINDING))}else if(t!=null){const s=t.getExtension("OES_vertex_array_object");if(s==null)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>Vt(t,()=>s.createVertexArrayOES()),this.bindVertexArray=o=>Vt(t,()=>s.bindVertexArrayOES(o)),this.deleteVertexArray=o=>Vt(t,()=>s.deleteVertexArrayOES(o)),this.getVertexArray=()=>Vt(t,()=>t.getParameter(s.VERTEX_ARRAY_BINDING_OES))}let r="WEBGL_color_buffer_float";const a="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),dt().getNumber("WEBGL_VERSION")===1){const s="OES_texture_float",o="OES_texture_half_float";if(this.textureFloatExtension=h0(this.gl,s),Ps(this.gl,o))this.textureHalfFloatExtension=h0(this.gl,o);else if(dt().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(r),Ps(this.gl,a))this.colorBufferHalfFloatExtension=h0(this.gl,a);else if(dt().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(r="EXT_color_buffer_float",Ps(this.gl,r))this.colorBufferFloatExtension=this.gl.getExtension(r);else if(Ps(this.gl,a))this.colorBufferHalfFloatExtension=this.gl.getExtension(a);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=r1t(this.gl),this.indexBuffer=a1t(this.gl),this.framebuffer=Kbt(this.gl),this.textureConfig=g_(this.gl,this.textureHalfFloatExtension)}get debug(){return dt().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const t=this.gl;Vt(t,()=>t.finish()),Vt(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,null)),Vt(t,()=>t.deleteFramebuffer(this.framebuffer)),Vt(t,()=>t.bindBuffer(t.ARRAY_BUFFER,null)),Vt(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,null)),Vt(t,()=>t.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(t,e){return this.throwIfDisposed(),s1t(this.gl,t,e,this.textureConfig)}createFloat16MatrixTexture(t,e){return this.throwIfDisposed(),o1t(this.gl,t,e,this.textureConfig)}createUnsignedBytesMatrixTexture(t,e){return this.throwIfDisposed(),i1t(this.gl,t,e,this.textureConfig)}uploadPixelDataToTexture(t,e){this.throwIfDisposed(),d1t(this.gl,t,e)}uploadDenseMatrixToTexture(t,e,r,a){this.throwIfDisposed(),h1t(this.gl,t,e,r,a,this.textureConfig)}createFloat16PackedMatrixTexture(t,e){return this.throwIfDisposed(),l1t(this.gl,t,e,this.textureConfig)}createPackedMatrixTexture(t,e){return this.throwIfDisposed(),u1t(this.gl,t,e,this.textureConfig)}deleteMatrixTexture(t){this.throwIfDisposed(),this.outputTexture===t&&(ZF(this.gl,this.framebuffer),this.outputTexture=null),Vt(this.gl,()=>this.gl.deleteTexture(t))}downloadByteEncodedFloatMatrixFromOutputTexture(t,e,r){return this.downloadMatrixDriver(t,()=>m1t(this.gl,e,r,this.textureConfig))}downloadPackedMatrixFromBuffer(t,e,r,a,s,o){return g1t(this.gl,t,e,r,a,s,o,this.textureConfig)}downloadFloat32MatrixFromBuffer(t,e){return f1t(this.gl,t,e)}createBufferFromTexture(t,e,r){this.bindTextureToFrameBuffer(t);const a=p1t(this.gl,e,r,this.textureConfig);return this.unbindTextureToFrameBuffer(),a}createAndWaitForFence(){const t=this.createFence(this.gl);return this.pollFence(t)}createFence(t){let e,r;if(dt().getBool("WEBGL_FENCE_API_ENABLED")){const a=t,s=a.fenceSync(a.SYNC_GPU_COMMANDS_COMPLETE,0);t.flush(),r=()=>{const o=a.clientWaitSync(s,0,0);return o===a.ALREADY_SIGNALED||o===a.CONDITION_SATISFIED},e=s}else dt().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(e=this.beginQuery(),this.endQuery(),r=()=>this.isQueryAvailable(e,dt().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):r=()=>!0;return{query:e,isFencePassed:r}}downloadMatrixFromPackedTexture(t,e,r){return this.downloadMatrixDriver(t,()=>v1t(this.gl,e,r))}createProgram(t){this.throwIfDisposed();const e=this.gl;this.vertexShader==null&&(this.vertexShader=n1t(e));const r=Ubt(e);Vt(e,()=>e.attachShader(r,this.vertexShader)),Vt(e,()=>e.attachShader(r,t)),Wbt(e,r);const a=Object.assign(r,{vao:this.createVertexArray()});return this.debug&&GC(e,a),a}buildVao(t){this.setProgram(t),this.bindVertexArray(t.vao);const e=this.gl;Vt(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),c1t(e,t,this.vertexBuffer)}deleteProgram(t){this.throwIfDisposed(),t===this.program&&(this.program=null),t!=null&&(Vt(this.gl,()=>this.gl.deleteProgram(t)),this.deleteVertexArray(t.vao))}setProgram(t){this.throwIfDisposed(),this.program=t,this.program!=null&&this.debug&&GC(this.gl,this.program),Vt(this.gl,()=>this.gl.useProgram(t))}getUniformLocation(t,e,r=!0){return this.throwIfDisposed(),r?Ybt(this.gl,t,e):Qbt(this.gl,t,e)}getAttributeLocation(t,e){return this.throwIfDisposed(),Vt(this.gl,()=>this.gl.getAttribLocation(t,e))}getUniformLocationNoThrow(t,e){return this.throwIfDisposed(),this.gl.getUniformLocation(t,e)}setInputMatrixTexture(t,e,r){this.throwIfDisposed(),this.throwIfNoProgram(),Zbt(this.gl,t,e,r)}setOutputMatrixTexture(t,e,r){this.setOutputMatrixTextureDriver(t,r,e)}setOutputPackedMatrixTexture(t,e,r){this.throwIfDisposed();const[a,s]=gp(e,r);this.setOutputMatrixTextureDriver(t,a,s)}setOutputMatrixWriteRegion(t,e,r,a){this.setOutputMatrixWriteRegionDriver(r,t,a,e)}setOutputPackedMatrixWriteRegion(t,e,r,a){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&GC(this.gl,this.program),d0(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const t=this.gl;if(this.debug){const e=this.getVertexArray();console.assert(e===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}Vt(t,()=>t.drawElements(t.TRIANGLES,6,t.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),Vt(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=h0(this.gl,dt().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(dt().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const r=this.gl,a=this.getQueryTimerExtensionWebGL2(),s=r.createQuery();return r.beginQuery(a.TIME_ELAPSED_EXT,s),s}const t=this.getQueryTimerExtensionWebGL1(),e=t.createQueryEXT();return t.beginQueryEXT(t.TIME_ELAPSED_EXT,e),e}endQuery(){if(dt().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const e=this.gl,r=this.getQueryTimerExtensionWebGL2();e.endQuery(r.TIME_ELAPSED_EXT);return}const t=this.getQueryTimerExtensionWebGL1();t.endQueryEXT(t.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(t){return await eN(()=>this.disposed||this.isQueryAvailable(t,dt().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(t,dt().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(t,e){if(e===0)return null;if(e===2){const r=this.gl;return r.getQueryParameter(t,r.QUERY_RESULT)/1e6}else{const r=this.getQueryTimerExtensionWebGL1();return r.getQueryObjectEXT(t,r.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(t,e){if(e===0)return!0;if(e===2){const r=this.gl,a=this.getQueryTimerExtensionWebGL2(),s=r.getQueryParameter(t,r.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(a.GPU_DISJOINT_EXT)),s&&!this.disjoint}else{const r=this.getQueryTimerExtensionWebGL1(),a=r.getQueryObjectEXT(t,r.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),a&&!this.disjoint}}pollFence(t){return new Promise(e=>{this.addItemToPoll(()=>t.isFencePassed(),()=>e())})}pollItems(){const t=y1t(this.itemsToPoll.map(e=>e.isDoneFn));for(let e=0;e<=t;++e){const{resolveFn:r}=this.itemsToPoll[e];r()}this.itemsToPoll=this.itemsToPoll.slice(t+1)}addItemToPoll(t,e){if(this.itemsToPoll.push({isDoneFn:t,resolveFn:e}),this.itemsToPoll.length>1)return;let r;"setTimeoutCustom"in dt().platform&&(r=dt().platform.setTimeoutCustom.bind(dt().platform)),eN(()=>(this.pollItems(),this.itemsToPoll.length===0),()=>0,null,r)}bindTextureToFrameBuffer(t){this.throwIfDisposed(),HC(this.gl,t,this.framebuffer),this.debug&&d0(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(HC(this.gl,this.outputTexture,this.framebuffer),this.debug&&d0(this.gl)):ZF(this.gl,this.framebuffer)}downloadMatrixDriver(t,e){this.bindTextureToFrameBuffer(t);const r=e();return this.unbindTextureToFrameBuffer(),r}setOutputMatrixTextureDriver(t,e,r){this.throwIfDisposed();const a=this.gl;HC(a,t,this.framebuffer),this.debug&&d0(a),this.outputTexture=t,Vt(a,()=>a.viewport(0,0,e,r)),Vt(a,()=>a.scissor(0,0,e,r))}setOutputMatrixWriteRegionDriver(t,e,r,a){this.throwIfDisposed(),Vt(this.gl,()=>this.gl.scissor(t,e,r,a))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}}function y1t(n){let t=0;for(;t<n.length&&n[t]();++t);return t-1}const{addImpl:b1t,bincountImpl:DG,bincountReduceImpl:x1t,bitwiseAndImpl:w1t,castImpl:S1t,ceilImpl:C1t,concatImpl:N1t,equalImpl:k1t,expImpl:T1t,expm1Impl:E1t,floorImpl:I1t,gatherNdImpl:_1t,gatherV2Impl:R1t,greaterImpl:A1t,greaterEqualImpl:D1t,lessImpl:$1t,lessEqualImpl:O1t,linSpaceImpl:F1t,logImpl:M1t,maxImpl:L1t,maximumImpl:B1t,minimumImpl:z1t,multiplyImpl:P1t,negImpl:V1t,notEqualImpl:U1t,prodImpl:W1t,raggedGatherImpl:G1t,raggedRangeImpl:H1t,raggedTensorToTensorImpl:j1t,rangeImpl:q1t,rsqrtImpl:K1t,scatterImpl:X1t,sigmoidImpl:Y1t,simpleAbsImpl:$G,sliceImpl:Q1t,sparseFillEmptyRowsImpl:Z1t,sparseReshapeImpl:J1t,sparseSegmentReductionImpl:OG,sqrtImpl:twt,staticRegexReplaceImpl:ewt,stridedSliceImpl:nwt,stringNGramsImpl:rwt,stringSplitImpl:awt,stringToHashBucketFastImpl:swt,subImpl:owt,tileImpl:iwt,topKImpl:uwt,transposeImpl:x_,uniqueImpl:lwt}=dmt;function FG(n,t){return["x","y","z","w","u","v"].slice(0,t).map(e=>`${n}.${e}`)}function ca(n,t){return t===1?[n]:FG(n,t)}function cwt(n,t){if(n===1)return"rc";let e="";for(let r=0;r<n;r++)e+=t[r],r<n-1&&(e+=",");return e}class hwt{constructor(t){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=t,this.rank=t.length,this.enableShapeUniforms=ta(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{const e=ca("rc",this.rank),r=sn(this.rank),a=this.getOutOfBoundsCondition(e),s=this.getSetup(e),o=this.getOutput(e);this.userCode=`
        void main() {
          ${r} rc = getOutputCoords();

          if(${a}) {
            setOutput(vec4(0));
          } else {
            ${s}

            setOutput(vec4(${o}));
          }
        }
      `}}getSourceCoordsArr(t){const e=[];for(let r=0;r<=1;r++)for(let a=0;a<=1;a++){let s=`${r===0?"r":"rp1"}, ${a===0?"c":"cp1"}`;for(let o=2;o<this.rank;o++)s=`${t[t.length-1-o]},`+s;e.push(s)}return e}getOutOfBoundsCondition(t){if(this.rank===1)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let e="";for(let r=this.rank-2;r<this.rank;r++)e+=`${t[r]} >= ${this.enableShapeUniforms?`outShape[${r}]`:this.outputShape[r]}`,r<this.rank-1&&(e+="||");return e}getSetup(t){if(this.rank===1)return"";const e=t.slice(-2),r=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],a=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${e[0]};
      int c = ${e[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${r};
      bool rEdge = rp1 >= ${a};
    `}getOutput(t){const e=this.getSourceCoordsArr(t);return this.rank===1?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${e[0]}),
            cEdge ? 0. : getA(${e[1]}),
            rEdge ? 0. : getA(${e[2]}),
            rEdge || cEdge ? 0. : getA(${e[3]})`}}class MG{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=t,this.enableShapeUniforms=ta(this.outputShape.length);let r="";for(let a=0;a<4;a++){let s="thisRC = rc;";a%2===1&&(s+="thisRC.z += 1;"),a>1&&(s+="thisRC.y += 1;"),r+=`
        ${s}
        ${a>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${a}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${a>0?"}":""}
      `}this.userCode=`
      ${dwt(e,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?y_():v_(t)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":t[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":t[2]};

        ${r}

        setOutput(result);
      }
    `}}function dwt(n,t){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${t?cxt(["r","c","d"],"inputShape"):Rc(["r","c","d"],n)}
      return ivec3(r, c, d);
    }
  `}class pwt{constructor(t){this.gpgpu=t,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(t,e,r){const a=rM(e,r),s=aM(t,a,r);s in this.freeTextures||(this.freeTextures[s]=[]),s in this.usedTextures||(this.usedTextures[s]=[]);const o=nM(t,a,this.gpgpu.gl,this.gpgpu.textureConfig,r);if(this.freeTextures[s].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=o,this.log();const u=this.freeTextures[s].pop();return this.usedTextures[s].push(u),u}let i;return a===Dr.PACKED_2X2_FLOAT32?i=this.gpgpu.createPackedMatrixTexture(t[0],t[1]):a===Dr.PACKED_2X2_FLOAT16?i=this.gpgpu.createFloat16PackedMatrixTexture(t[0],t[1]):a===Dr.UNPACKED_FLOAT32?i=this.gpgpu.createFloat32MatrixTexture(t[0],t[1]):a===Dr.UNPACKED_FLOAT16?i=this.gpgpu.createFloat16MatrixTexture(t[0],t[1]):a===Dr.PACKED_4X1_UNSIGNED_BYTE&&(i=this.gpgpu.createUnsignedBytesMatrixTexture(t[0],t[1])),this.usedTextures[s].push(i),this.numUsedTextures++,this._numBytesAllocated+=o,this.log(),i}releaseTexture(t,e,r,a){if(this.freeTextures==null)return;const s=rM(r,a),o=aM(e,s,a);o in this.freeTextures||(this.freeTextures[o]=[]);const i=nM(e,s,this.gpgpu.gl,this.gpgpu.textureConfig,a),u=dt().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");u!==-1&&this._numBytesAllocated>u?(this.gpgpu.deleteMatrixTexture(t.texture),this._numBytesAllocated-=i):(this.freeTextures[o].push(t),this.numFreeTextures++,this._numBytesFree+=i),this.numUsedTextures--;const l=this.usedTextures[o],h=l&&l.indexOf(t);if(h==null||h<0)throw new Error("Cannot release a texture that was never provided by this texture manager");l[h]=l[l.length-1],l.pop(),this.log()}log(){if(!this.logEnabled)return;const t=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${t})`);const e=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*e)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(const t in this.freeTextures)this.freeTextures[t].forEach(e=>{this.gpgpu.deleteMatrixTexture(e.texture)});for(const t in this.usedTextures)this.usedTextures[t].forEach(e=>{this.gpgpu.deleteMatrixTexture(e.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function fwt(n,t){const e=n;if(t===e.R32F)return 4;if(t===e.R16F)return 2;if(t===e.RGBA32F)return 16;if(t===n.RGBA)return 16;if(t===e.RGBA16F)return 8;if(t===e.RGBA8)return 4;throw new Error(`Unknown internal format ${t}`)}function nM(n,t,e,r,a){const s=mwt(t,r);let o;if(a){const[u,l]=gp(n[0],n[1]);o=u*l}else{const[u,l]=pv(n[0],n[1]);o=u*l}const i=fwt(e,s);return o*i}function mwt(n,t){switch(n){case Dr.PACKED_2X2_FLOAT32:return RG(t);case Dr.PACKED_2X2_FLOAT16:return AG(t);case Dr.UNPACKED_FLOAT32:return EG(t);case Dr.UNPACKED_FLOAT16:return IG(t);case Dr.PACKED_4X1_UNSIGNED_BYTE:return _G(t);default:throw new Error(`Unknown physical texture type ${n}`)}}function gwt(n){return dt().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?n?Dr.PACKED_2X2_FLOAT32:Dr.UNPACKED_FLOAT32:n?Dr.PACKED_2X2_FLOAT16:Dr.UNPACKED_FLOAT16}function rM(n,t){if(n===fs.UPLOAD)return Dr.PACKED_2X2_FLOAT32;if(n===fs.RENDER||n==null)return gwt(t);if(n===fs.DOWNLOAD||n===fs.PIXELS)return Dr.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${n}`)}function aM(n,t,e){return`${n[0]}_${n[1]}_${t}_${e}`}class Do{constructor(t,e){this.variableNames=["A"],this.outputShape=t,this.enableShapeUniforms=ta(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${e}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}}const Gs="if (isnan(x)) return x;",vwt="return x;",sM="return abs(x);",ywt="return (x >= 0.0) ? x : (exp(x) - 1.0);",bwt=Gs+`
  return (x < 0.0) ? 0.0 : x;
`,xwt=Gs+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,wu="return x;",wwt="return 1.0 / (1.0 + exp(-1.0 * x));";const Swt="return x;",Cwt=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,Nwt=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,kwt=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Twt="return 1.0 / (1.0 + exp(-1.0 * x));";class Tu{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.enableShapeUniforms=ta(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${e}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}}class Ewt{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=t,this.enableShapeUniforms=ta(this.outputShape.length);const e=t.length,r=ca("rc",e),a=sn(e),s=cwt(e,r),o=r.slice(-2),i=e<=1?"rc":`vec2(${o.join(",")})`;this.userCode=`
      void main() {
        ${a} rc = getOutputCoords();
        vec4 packedInput = getA(${s});

        setOutput(getChannel(packedInput, ${i}));
      }
    `}}const Iwt=g1,_wt=1e-7,Rwt=1e-4,m0={};function Awt(n){return n in m0||(m0[n]={}),m0[n]}const Dwt=dt().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),$wt=600;function Owt(){return dt().global.screen==null?1024:dt().global.screen.height*dt().global.screen.width*window.devicePixelRatio*$wt/1024/1024}class ow extends Db{nextDataId(){return ow.nextDataId++}constructor(t){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!dt().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let e;if(t!=null){if(t instanceof KC)e=t;else{const r=io(dt().getNumber("WEBGL_VERSION"),t);e=new KC(r)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const r=io(dt().getNumber("WEBGL_VERSION"));e=new KC(r),this.binaryCache=Awt(dt().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=e,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new pwt(this.gpgpu),this.numMBBeforeWarning=Owt(),this.texData=new Tk(this,as())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(t,e,r,a,s,o){const i=this.makeTensorInfo(e,r),u=this.texData.get(i.dataId);u.isPacked=!1,u.texture={texture:t,texShape:[a,s]},u.texShape=[a,s];const l=p0(e),h=new eM(l,!1,o),d=this.runWebGLProgram(h,[i],r,[[a,s]]);return d.shape=e,u.texture=null,this.disposeIntermediateTensorInfo(i),d.dataId}write(t,e,r){if((dt().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||dt().getBool("DEBUG"))&&this.checkNumericalProblems(t),r==="complex64"&&t!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const a={id:this.nextDataId()};return this.texData.set(a,{shape:e,dtype:r,values:t,usage:fs.UPLOAD,refCount:1}),a}refCount(t){return this.texData.has(t)?this.texData.get(t).refCount:0}incRef(t){const e=this.texData.get(t);e.refCount++}decRef(t){if(this.texData.has(t)){const e=this.texData.get(t);e.refCount--}}move(t,e,r,a,s){if(dt().getBool("DEBUG")&&this.checkNumericalProblems(e),a==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(t,{shape:r,dtype:a,values:e,usage:fs.UPLOAD,refCount:s})}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}readSync(t){const e=this.texData.get(t),{values:r,dtype:a,complexTensorInfos:s,slice:o,shape:i,isPacked:u}=e;if(o!=null){let f;u?f=new Tu(i,wu):f=new Do(i,wu);const m=this.runWebGLProgram(f,[{dataId:t,shape:i,dtype:a}],a),v=this.readSync(m.dataId);return this.disposeIntermediateTensorInfo(m),v}if(r!=null)return this.convertAndCacheOnCPU(t);if(a==="string")return r;const l=this.activeTimers!=null;let h;l&&(h=ra());let d;if(a==="complex64"){const f=this.readSync(s.real.dataId),m=this.readSync(s.imag.dataId);d=Di(f,m)}else d=this.getValuesFromTexture(t);return l&&(this.downloadWaitMs+=ra()-h),this.convertAndCacheOnCPU(t,d)}async read(t){if(this.pendingRead.has(t)){const v=this.pendingRead.get(t);return new Promise(y=>v.push(y))}const e=this.texData.get(t),{values:r,shape:a,slice:s,dtype:o,complexTensorInfos:i,isPacked:u}=e;if(s!=null){let v;u?v=new Tu(a,wu):v=new Do(a,wu);const y=this.runWebGLProgram(v,[{dataId:t,shape:a,dtype:o}],o),b=this.read(y.dataId);return this.disposeIntermediateTensorInfo(y),b}if(r!=null)return this.convertAndCacheOnCPU(t);if(dt().getBool("DEBUG")&&!dt().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&dt().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let l=null,h;if(o!=="complex64"&&dt().get("WEBGL_BUFFER_SUPPORTED")){h=this.decode(t);const v=this.texData.get(h.dataId);l=this.gpgpu.createBufferFromTexture(v.texture.texture,...c0(a))}this.pendingRead.set(t,[]),o!=="complex64"&&await this.gpgpu.createAndWaitForFence();let d;if(o==="complex64"){const v=await Promise.all([this.read(i.real.dataId),this.read(i.imag.dataId)]),y=v[0],b=v[1];d=Di(y,b)}else if(l==null)d=this.getValuesFromTexture(t);else{const v=xt(a);d=this.gpgpu.downloadFloat32MatrixFromBuffer(l,v)}if(h!=null&&this.disposeIntermediateTensorInfo(h),l!=null){const v=this.gpgpu.gl;Vt(v,()=>v.deleteBuffer(l))}const f=this.convertAndCacheOnCPU(t,d),m=this.pendingRead.get(t);return this.pendingRead.delete(t),m.forEach(v=>v(f)),this.pendingDisposal.has(t)&&(this.pendingDisposal.delete(t),this.disposeData(t)&&as().removeDataId(t,this),this.pendingDeletes--),f}readToGPU(t,e={}){const r=this.texData.get(t),{values:a,shape:s,slice:o,dtype:i,isPacked:u,texture:l}=r;if(i==="complex64")throw new Error("Does not support reading texture for complex64 dtype.");if(o!=null){let m;u?m=new Tu(s,wu):m=new Do(s,wu);const v=this.runWebGLProgram(m,[{dataId:t,shape:s,dtype:i}],i),y=this.readToGPU(v,e);return this.disposeIntermediateTensorInfo(v),y}if(l==null)throw a!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const h=this.decode(t,e.customTexShape),d=as().makeTensorFromTensorInfo(h),f=this.texData.get(h.dataId);return Object.assign({tensorRef:d},f.texture)}bufferSync(t){const e=this.readSync(t.dataId);if(t.dtype==="string")try{const r=e.map(a=>Ii(a));return we(t.shape,t.dtype,r)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return we(t.shape,t.dtype,e)}checkNumericalProblems(t){if(t!=null)for(let e=0;e<t.length;e++){const r=t[e];if(!Lbt(r))throw dt().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${r} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${r} cannot be represented on this device.`)}}getValuesFromTexture(t){const{shape:e,dtype:r,isPacked:a}=this.texData.get(t),s=xt(e);if(dt().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const f=this.decode(t),m=this.texData.get(f.dataId),v=this.gpgpu.downloadMatrixFromPackedTexture(m.texture.texture,...c0(e)).subarray(0,s);return this.disposeIntermediateTensorInfo(f),v}const o=dt().getBool("WEBGL_PACK")&&a===!0,i=o?p0(e):e,u=o?new Jxt(i):new Zxt(i),l=this.runWebGLProgram(u,[{shape:i,dtype:r,dataId:t}],"float32"),h=this.texData.get(l.dataId),d=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(h.texture.texture,h.texShape[0],h.texShape[1]).subarray(0,s);return this.disposeIntermediateTensorInfo(l),d}timerAvailable(){return dt().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(t){const e=this.activeTimers,r=[];let a=!1;this.programTimersStack==null?(this.programTimersStack=r,a=!0):this.activeTimers.push(r),this.activeTimers=r,t();const s=Vo(this.activeTimers.map(u=>u.query)).filter(u=>u!=null),o=Vo(this.activeTimers.map(u=>u.name)).filter(u=>u!=null);this.activeTimers=e,a&&(this.programTimersStack=null);const i={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(dt().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const u=await Promise.all(s);i.kernelMs=MM(u),i.getExtraProfileInfo=()=>u.map((l,h)=>({name:o[h],ms:l})).map(l=>`${l.name}: ${l.ms}`).join(", ")}else i.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,i})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return dt().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:ra(),endMs:null}}endTimer(t){return dt().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),t):(t.endMs=ra(),t)}async getQueryTime(t){if(dt().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(t);const e=t;return e.endMs-e.startMs}disposeData(t,e=!1){if(this.pendingDisposal.has(t))return!1;if(!this.texData.has(t))return!0;if(e?this.texData.get(t).refCount=0:this.texData.get(t).refCount--,!e&&this.texData.get(t).refCount>0)return!1;if(this.pendingRead.has(t))return this.pendingDisposal.add(t),this.pendingDeletes++,!1;this.releaseGPUData(t);const{complexTensorInfos:r}=this.texData.get(t);return r!=null&&(this.disposeData(r.real.dataId,e),this.disposeData(r.imag.dataId,e)),this.texData.delete(t),!0}releaseGPUData(t){const{texture:e,dtype:r,texShape:a,usage:s,isPacked:o,slice:i}=this.texData.get(t),u=i&&i.origDataId||t,l=this.dataRefCount.get(u);l>1?this.dataRefCount.set(u,l-1):(this.dataRefCount.delete(u),e!=null&&(this.numBytesInGPU-=this.computeBytes(a,r),this.textureManager.releaseTexture(e,a,s,o)));const h=this.texData.get(t);h.texture=null,h.texShape=null,h.isPacked=!1,h.slice=null}getTexture(t){return this.uploadToGPU(t),this.texData.get(t).texture.texture}getDataInfo(t){return this.texData.get(t)}shouldExecuteOnCPU(t,e=Dwt){return dt().getBool("WEBGL_CPU_FORWARD")&&t.every(r=>this.texData.get(r.dataId).texture==null&&xt(r.shape)<e)}getGPGPUContext(){return this.gpgpu}where(t){is("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const e=t.dataSync();return Iwt(t.shape,e)}packedUnaryOp(t,e,r){const a=new Tu(t.shape,e),s=this.compileAndRun(a,[t],r);return as().makeTensorFromTensorInfo(s)}abs(t){if(this.shouldExecuteOnCPU([t])&&t.dtype!=="complex64"){const a=$G(this.texData.get(t.dataId).values);return this.makeOutput(t.shape,t.dtype,a)}if(dt().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,sM,t.dtype);const e=new Do(t.shape,sM),r=this.compileAndRun(e,[t]);return as().makeTensorFromTensorInfo(r)}makeTensorInfo(t,e,r){let a;if(e==="string"&&r!=null&&r.length>0&&Io(r[0])){const s=r.map(o=>$o(o));a=this.write(s,t,e)}else a=this.write(r,t,e);return this.texData.get(a).usage=null,{dataId:a,shape:t,dtype:e}}makeOutput(t,e,r){return as().makeTensorFromTensorInfo(this.makeTensorInfo(t,e,r),this)}unpackTensor(t){const e=new Ewt(t.shape);return this.runWebGLProgram(e,[t],t.dtype)}packTensor(t){const e=new hwt(t.shape);return this.runWebGLProgram(e,[t],t.dtype,null,!0)}packedReshape(t,e){const r=[ld(t.shape),...cd(t.shape)],a={dtype:t.dtype,shape:r,dataId:t.dataId},s=[ld(e),...cd(e)],o=new MG(s,r),i=!0,u=[r],l=this.runWebGLProgram(o,[a],t.dtype,u,i);return{dataId:l.dataId,shape:e,dtype:l.dtype}}decode(t,e){const r=this.texData.get(t),{isPacked:a,shape:s,dtype:o}=r;if(e!=null){const f=xt(s),m=e[0]*e[1]*4;P(f<=m,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}const i=p0(s);let u;a?u=new Qxt(i):u=new Yxt(i);const l=!0,h=[e??c0(i)],d=this.runWebGLProgram(u,[{shape:i,dtype:o,dataId:t}],o,h,l,e);return{dtype:o,shape:s,dataId:d.dataId}}runWebGLProgram(t,e,r,a,s=!1,o){const i=this.makeTensorInfo(t.outputShape,r),u=this.texData.get(i.dataId);if(t.packedOutput&&(u.isPacked=!0),t.outPackingScheme===mm.DENSE){const w=o??c0(t.outputShape);u.texShape=w.map(S=>S*2)}if(t.outTexUsage!=null&&(u.usage=t.outTexUsage),xt(i.shape)===0)return u.values=xr(i.dtype,0),i;const l=[],h=e.map(w=>{if(w.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let S=this.texData.get(w.dataId);if(S.texture==null){if(!t.packedInputs&&xt(w.shape)<=dt().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:w.shape,texData:null,isUniform:!0,uniformValues:S.values};t.packedInputs&&(S.isPacked=!0,S.shape=w.shape)}if(this.uploadToGPU(w.dataId),!!S.isPacked!=!!t.packedInputs)w=S.isPacked?this.unpackTensor(w):this.packTensor(w),l.push(w),S=this.texData.get(w.dataId);else if(S.isPacked&&!Ib(S.shape,w.shape)){const N=w,C=w.shape;w.shape=S.shape,w=this.packedReshape(w,C),l.push(w),S=this.texData.get(w.dataId),N.shape=C}return{shape:w.shape,texData:S,isUniform:!1}});this.uploadToGPU(i.dataId);const d={shape:i.shape,texData:u,isUniform:!1},f=Xxt(t,h,d),m=this.getAndSaveBinary(f,()=>qxt(this.gpgpu,t,h,d)),v=this.activeTimers!=null;let y;v&&(y=this.startTimer()),dt().get("ENGINE_COMPILE_ONLY")||Kxt(this.gpgpu,m,h,d,a),l.forEach(w=>this.disposeIntermediateTensorInfo(w)),v&&(y=this.endTimer(y),this.activeTimers.push({name:t.constructor.name,query:this.getQueryTime(y)}));const b=dt().getNumber("WEBGL_FLUSH_THRESHOLD");if(b>0){const w=ra();w-this.lastGlFlushTime>b&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=w)}if(!dt().getBool("WEBGL_LAZILY_UNPACK")&&u.isPacked&&s===!1){const w=this.unpackTensor(i);return this.disposeIntermediateTensorInfo(i),w}return i}compileAndRun(t,e,r,a,s=!1){return r=r||e[0].dtype,this.runWebGLProgram(t,e,r,a,s)}getAndSaveBinary(t,e){return t in this.binaryCache||(this.binaryCache[t]=e()),this.binaryCache[t]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(dt().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(e=>{this.gpgpu.deleteProgram(this.binaryCache[e].webGLProgram),delete this.binaryCache[e]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=ut(()=>{if(!dt().get("WEBGL_RENDER_FLOAT32_ENABLED")){const t=dt().getBool("DEBUG");dt().set("DEBUG",!1);const e=this.abs(Jt(1e-8)).dataSync()[0];if(dt().set("DEBUG",t),e>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?_wt:Rwt}uploadToGPU(t){const e=this.texData.get(t),{shape:r,dtype:a,values:s,texture:o,usage:i,isPacked:u}=e;if(o!=null)return;const l=this.activeTimers!=null;let h;l&&(h=ra());let d=e.texShape;if(d==null&&(d=ext(r,u),e.texShape=d),s!=null){const f=p0(r);let m,v=d[1],y=d[0];const b=s instanceof Uint8Array||s instanceof Uint8ClampedArray;(u||!b)&&([v,y]=gp(d[0],d[1])),u?m=new e1t(f,b):m=new eM(f,b);const w=b?[y,v]:d,S=this.makeTensorInfo(w,a),N=this.texData.get(S.dataId);b?N.usage=fs.PIXELS:N.usage=fs.UPLOAD,N.texShape=w,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(S.dataId),v,y,s);const C=[[y,v]],I=this.runWebGLProgram(m,[S],a,C,!0),_=this.texData.get(I.dataId);e.texShape=_.texShape,e.isPacked=_.isPacked,e.usage=_.usage,dt().get("ENGINE_COMPILE_ONLY")?this.disposeData(I.dataId):(e.texture=_.texture,e.values=null,this.texData.delete(I.dataId)),this.disposeIntermediateTensorInfo(S),l&&(this.uploadWaitMs+=ra()-h)}else{const f=this.acquireTexture(d,i,a,u);e.texture=f}}convertAndCacheOnCPU(t,e){const r=this.texData.get(t),{dtype:a}=r;return e!=null&&(r.values=Fwt(e,a)),r.values}acquireTexture(t,e,r,a){if(this.numBytesInGPU+=this.computeBytes(t,r),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){const s=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${s} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(t,e,a)}computeBytes(t,e){return t[0]*t[1]*Hf(e)}checkCompileCompletion(){for(const[,t]of Object.entries(this.binaryCache))this.checkCompletion_(t)}async checkCompileCompletionAsync(){const t=[];if(this.gpgpu.parallelCompilationExtension){for(const[,e]of Object.entries(this.binaryCache))t.push(this.checkCompletionAsync_(e));return Promise.all(t)}else{for(const[,e]of Object.entries(this.binaryCache)){const r=new Promise(a=>{try{this.checkCompletion_(e),a(!0)}catch(s){throw s}});t.push(r)}return Promise.all(t)}}async checkCompletionAsync_(t){return this.gpgpu.gl.getProgramParameter(t.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(t):(await lE(),this.checkCompletionAsync_(t))}checkCompletion_(t){if(this.gpgpu.gl.getProgramParameter(t.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(t.webGLProgram)),this.gpgpu.gl.getShaderParameter(t.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?(wG(t.source,this.gpgpu.gl.getShaderInfoLog(t.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(const t of Object.values(this.binaryCache)){this.gpgpu.buildVao(t.webGLProgram);const{variablesLocations:e,customUniformLocations:r,infLoc:a,nanLoc:s,outShapeLocation:o,outShapeStridesLocation:i,outTexShapeLocation:u}=TG(this.gpgpu,t.program,t.webGLProgram);t.variablesLocations=e,t.customUniformLocations=r,t.infLoc=a,t.nanLoc=s,t.outShapeLocation=o,t.outShapeStridesLocation=i,t.outTexShapeLocation=u}}createTensorFromGPUData(t,e,r){t.channels=t.channels||"RGBA";const{texture:a,height:s,width:o,channels:i}=t,u=as().backend;if(!u.gpgpu.gl.isTexture(a))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const l=u.writeTexture(a,e,r,s,o,i);return as().makeTensorFromDataId(l,e,r,u)}}ow.nextDataId=0;function Fwt(n,t){if(t==="float32"||t==="complex64")return n;if(t==="int32"||t==="bool"){const e=t==="int32"?new Int32Array(n.length):new Uint8Array(n.length);for(let r=0;r<e.length;++r)e[r]=Math.round(n[r]);return e}else throw new Error(`Unknown dtype ${t}`)}Mk()&&zk("webgl",()=>new ow,2);const w_=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;class pc{constructor(t,e,r){this.variableNames=["A","B"],this.outputShape=me(e,r),this.enableShapeUniforms=ta(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${t}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}}const Dc=`
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`;class wp{constructor(t,e,r,a=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=me(e,r);const s=this.outputShape.length;this.enableShapeUniforms=ta(s);let o="";if(a)if(s===0||xt(this.outputShape)===1)o=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(o=`
          ${sn(s)} coords = getOutputCoords();
        `,s===1)this.enableShapeUniforms?o+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:o+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{const u=ca("coords",s);this.enableShapeUniforms?o+=`
            bool nextRowOutOfBounds =
              (${u[s-2]} + 1) >= outShape[${s} - 2];
            bool nextColOutOfBounds =
              (${u[s-1]} + 1) >= outShape[${s} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:o+=`
            bool nextRowOutOfBounds =
              (${u[s-2]} + 1) >= ${this.outputShape[s-2]};
            bool nextColOutOfBounds =
              (${u[s-1]} + 1) >= ${this.outputShape[s-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${t}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${o}

        setOutput(result);
      }
    `}}function Xa(n){const{inputs:t,backend:e}=n,{x:r}=t;return e.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const Mwt={kernelName:Ad,backendName:"webgl",kernelFunc:Xa};function ul(n){const{inputs:t,backend:e}=n,{real:r,imag:a}=t,s=e.makeTensorInfo(r.shape,"complex64"),o=e.texData.get(s.dataId),i=Xa({inputs:{x:r},backend:e}),u=Xa({inputs:{x:a},backend:e});return o.complexTensorInfos={real:i,imag:u},s}const Lwt={kernelName:Vb,backendName:"webgl",kernelFunc:ul};const LG="return (a < 0.) ? b * a : a;",BG=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function Bwt(n){const{inputs:t,backend:e,attrs:r}=n,{x:a}=t,{alpha:s}=r,o=e.makeTensorInfo([],"float32",Fi(s,"float32")),i=dt().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new wp(BG,a.shape,o.shape):new pc(LG,a.shape,o.shape),u=e.runWebGLProgram(i,[a,o],"float32");return e.disposeIntermediateTensorInfo(o),u}const zwt={kernelName:Um,backendName:"webgl",kernelFunc:Bwt};const zG="return (a < 0.) ? b * a : a;",PG=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function Pwt(n){const{inputs:t,backend:e}=n,{x:r,alpha:a}=t,s=dt().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new wp(PG,r.shape,a.shape):new pc(zG,r.shape,a.shape);return e.runWebGLProgram(s,[r,a],"float32")}const Vwt={kernelName:ig,backendName:"webgl",kernelFunc:Pwt};const Sp="if (isnan(x)) return x;";function Ue({opSnippet:n,packedOpSnippet:t,cpuKernelImpl:e,dtype:r}){return({inputs:a,backend:s})=>{const{x:o}=a,i=s,u=r||o.dtype;if(i.shouldExecuteOnCPU([o])&&e!=null){const d=i.texData.get(o.dataId),f=e(d.values,u);return i.makeTensorInfo(o.shape,u,f)}const l=dt().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&t!=null;let h;return l?h=new Tu(o.shape,t):h=new Do(o.shape,n),i.runWebGLProgram(h,[o],u)}}function Ur({opSnippet:n,packedOpSnippet:t,checkOutOfBounds:e=!1,supportsComplex:r=!1,cpuKernelImpl:a,dtype:s}){return({inputs:o,backend:i})=>{const{a:u,b:l}=o,h=i;if(r&&u.dtype==="complex64"){const v=h.texData.get(u.dataId),y=h.texData.get(l.dataId),[b,w]=[[v.complexTensorInfos.real,y.complexTensorInfos.real],[v.complexTensorInfos.imag,y.complexTensorInfos.imag]].map(N=>{const[C,T]=N,I={dataId:C.dataId,dtype:C.dtype,shape:u.shape},_={dataId:T.dataId,dtype:T.dtype,shape:l.shape},$=new pc(n,u.shape,l.shape);return h.runWebGLProgram($,[I,_],Sa(C.dtype,T.dtype))}),S=ul({inputs:{real:b,imag:w},backend:h});return h.disposeIntermediateTensorInfo(b),h.disposeIntermediateTensorInfo(w),S}const d=s||Sa(u.dtype,l.dtype);if((u.dtype==="string"||l.dtype==="string"||h.shouldExecuteOnCPU([u,l]))&&a!=null){const v=h.texData.get(u.dataId).values,y=h.texData.get(l.dataId).values,b=u.dtype==="string"?$i(v):v,w=u.dtype==="string"?$i(y):y,[S,N]=a(u.shape,l.shape,b,w,d),C=h.makeTensorInfo(N,d),T=h.texData.get(C.dataId);return T.values=S,C}const f=dt().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&t!=null;let m;return f?m=new wp(t,u.shape,l.shape,e):m=new pc(n,u.shape,l.shape),h.runWebGLProgram(m,[u,l],d)}}function gm(n,t=!1){if(n==="linear")return t?Swt:vwt;if(n==="relu")return t?Nwt:bwt;if(n==="elu")return t?Cwt:ywt;if(n==="relu6")return t?kwt:xwt;if(n==="prelu")return t?PG:zG;if(n==="leakyrelu")return t?BG:LG;if(n==="sigmoid")return t?Twt:wwt;throw new Error(`Activation ${n} has not been implemented for the WebGL backend.`)}class VG{constructor(t,e,r,a=!1,s=!1,o=!1,i=null,u=!1,l=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=r,this.enableShapeUniforms=ta(this.outputShape.length);const h=a?t[1]:t[2],d=Math.ceil(h/2),f=a?"i * 2, rc.y":"rc.y, i * 2",m=s?"rc.z, i * 2":"i * 2, rc.z",v=a?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],y=s?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let b="",w="";i&&(u?b=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${i}
        }`:l?b=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${i}
        }`:b=`vec4 activation(vec4 x) {
          ${i}
        }`,w="result = activation(result);");const S=o?"result += getBiasAtOutCoords();":"";o&&this.variableNames.push("bias"),u&&this.variableNames.push("preluActivationWeights"),l&&this.variableNames.push("leakyreluAlpha");let N="rc.x",C="rc.x";t[0]<e[0]?N=`imod(rc.x, ${t[0]})`:e[0]<t[0]&&(C=`imod(rc.x, ${e[0]})`),this.userCode=`
      ${b}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${d}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        int batchA = ${N};
        int batchB = ${C};
        for (int i = 0; i < ${d}; i++) {
          vec4 a = getMatrixA(batchA, ${f});
          vec4 b = getMatrixB(batchB, ${m});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${v[0]} * ${y[0]});
          result += (${v[1]} * ${y[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${S}

        ${w}

        setOutput(result);
      }
    `}}const oM={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};class iM{constructor(t,e,r){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=me(e,r),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${t}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}}const uM="return a * b;";function S_(n){const{inputs:t,backend:e}=n,{a:r,b:a}=t,s=Sa(r.dtype,a.dtype);if(r.dtype==="complex64"){const i=e.texData.get(r.dataId),u=e.texData.get(a.dataId),l=new iM(oM.REAL,r.shape,a.shape),h=new iM(oM.IMAG,r.shape,a.shape),d=[{dataId:i.complexTensorInfos.real.dataId,dtype:i.complexTensorInfos.real.dtype,shape:r.shape},{dataId:i.complexTensorInfos.imag.dataId,dtype:i.complexTensorInfos.imag.dtype,shape:r.shape},{dataId:u.complexTensorInfos.real.dataId,dtype:u.complexTensorInfos.real.dtype,shape:a.shape},{dataId:u.complexTensorInfos.imag.dataId,dtype:u.complexTensorInfos.imag.dtype,shape:a.shape}],f=e.runWebGLProgram(l,d,"float32"),m=e.runWebGLProgram(h,d,"float32"),v=ul({inputs:{real:f,imag:m},backend:e});return e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(m),v}if(e.shouldExecuteOnCPU([r,a])){const i=e.texData.get(r.dataId),u=e.texData.get(a.dataId),[l,h]=P1t(r.shape,a.shape,i.values,u.values,s),d=e.makeTensorInfo(h,s),f=e.texData.get(d.dataId);return f.values=l,d}let o;return dt().getBool("WEBGL_PACK_BINARY_OPERATIONS")?o=new wp(uM,r.shape,a.shape):o=new pc(uM,r.shape,a.shape),e.runWebGLProgram(o,[r,a],s)}const Uwt={kernelName:Pd,backendName:"webgl",kernelFunc:S_};function Wwt(n,t,e){const r=[ld(n.shape),...cd(n.shape)],a={dtype:n.dtype,shape:r,dataId:n.dataId},s=[ld(t),...cd(t)],o=new MG(s,r),i=!0,u=[r],l=e.runWebGLProgram(o,[a],n.dtype,u,i);return{dataId:l.dataId,shape:t,dtype:l.dtype}}function Bt(n){const{inputs:t,backend:e,attrs:r}=n,{x:a}=t,{shape:s}=r,o=e,i=xt(a.shape),u=Ik(s,i),l=xt(u);P(i===l,()=>`The new shape (${u}) has ${l} elements and the old shape (${a.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`);const h=o.texData.get(a.dataId);return h.isPacked&&!Ib(a.shape,u)&&!(h.texture!==null&&Ib(h.shape,u))?Wwt(a,u,o):(o.incRef(a.dataId),{dataId:a.dataId,shape:u,dtype:a.dtype})}const Gwt={kernelName:lg,backendName:"webgl",kernelFunc:Bt};class lM{constructor(t,e){this.variableNames=["x"];const{windowSize:r,batchSize:a,inSize:s,outSize:o}=t;this.outputShape=[a,o];const i=Math.floor(r/4)*4,u=r%4;let l="sumValue += dot(values, ones);";if(e!=null){const d=1/e;l=`sumValue += dot(values * ${Zl(d)?d.toPrecision(2):d}, ones);`}let h="";s%r>0&&(h=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${h}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        float sumValue = 0.0;

        for (int i = 0; i < ${i}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${l}
        }

        int inIdx = inOffset + ${i};
        if (${u===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${l}
        } else if (${u===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${l}
        } else if (${u===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${l}
        }
        setOutput(sumValue);
      }
    `}}class Hwt{constructor(t,e){this.variableNames=["x"];const{windowSize:r,batchSize:a,inSize:s,outSize:o}=t;this.outputShape=[a,o];let i="0.0",u="";e==="prod"?i="1.0":e==="min"?(i="1.0 / 1e-20",u="min"):e==="max"&&(i="-1.0 / 1e-20",u="max");let l=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;e==="sum"?l="sumValue":e==="prod"?l="prodValue":e==="all"?l="allValue":e==="any"&&(l="anyValue");const h=Math.floor(r/4)*4,d=r%4;let f=`
      if (${e==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${e==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${u}(values, minMaxValue);
        if (${e==="min"} || ${e==="max"}) {
          minMaxValue = ${u}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,m="vec4";e==="all"?(i="1.0",f=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,m="bvec4"):e==="any"&&(i="0.0",f=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,m="bvec4");let v="";s%r>0&&(v=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${i};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${v}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        vec4 minMaxValue = vec4(${i});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${h}; i += 4) {
          int inIdx = inOffset + i;
          ${m} values = ${m}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${f}
        }

        int inIdx = inOffset + ${h};
        if (${d===1}) {
          ${m} values = ${m}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${f}
        } else if (${d===2}) {
          ${m} values = ${m}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${f}
        } else if (${d===3}) {
          ${m} values = ${m}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${f}
        }
        setOutput(${l});
      }
    `}}function jwt(n){const t=[];for(;t.length===0||t[t.length-1].outSize!==1;){const e=t.length?t[t.length-1].outSize:n[1],r=I1(e);t.push({inSize:e,windowSize:r,outSize:Math.ceil(e/r)})}return t}function $c(n,t,e,r){const a=jwt(n.shape);let s=n;for(let o=0;o<a.length;o++){const{inSize:i,windowSize:u,outSize:l}=a[o];let h,d;e==="mean"?h=o===0?new lM({windowSize:u,inSize:i,batchSize:n.shape[0],outSize:l},i):new lM({windowSize:u,inSize:i,batchSize:n.shape[0],outSize:l}):h=new Hwt({windowSize:u,inSize:i,batchSize:n.shape[0],outSize:l},e),d=s,s=r.runWebGLProgram(h,[s],t),d.dataId!==n.dataId&&r.disposeIntermediateTensorInfo(d)}return s}class qwt{constructor(t,e){this.variableNames=["A"];const r=new Array(t.length);for(let o=0;o<r.length;o++)r[o]=t[e[o]];this.outputShape=r,this.rank=r.length;const a=sn(this.rank),s=Kwt(e);this.userCode=`
    void main() {
      ${a} resRC = getOutputCoords();
      setOutput(getA(${s}));
    }
    `}}function Kwt(n){const t=n.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);const e=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(t);for(let a=0;a<n.length;a++)r[n[a]]=e[a];return r.join()}class Xwt{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const r=new Array(t.length);for(let h=0;h<r.length;h++)r[h]=t[e[h]];if(this.outputShape=r,this.rank=r.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const a=sn(this.rank),s=FG("rc",this.rank),o=new Array(this.rank);for(let h=0;h<e.length;h++)o[e[h]]=s[h];const i=`vec2(${o.slice(-2).join()})`,u=`++${s[this.rank-1]} < ${r[this.rank-1]}`,l=`getChannel(getA(${o.join()}), ${i})`;this.userCode=`
    void main() {
      ${a} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${l};
      if(${u}) {
        result[1] = ${l};
      }
      --${s[this.rank-1]};
      if(++${s[this.rank-2]} < ${r[this.rank-2]}) {
        result[2] = ${l};
        if(${u}) {
          result[3] = ${l};
        }
      }
      setOutput(result);
    }
    `}}function iw(n,t,e){const r=dt().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Xwt(n.shape,t):new qwt(n.shape,t);return e.runWebGLProgram(r,[n],n.dtype)}function Ywt(n,t,e,r){const a=t,s=n.shape.length,o=_e(a,n.shape);let i=o;const u=An(i,s),l=u!=null;let h=n;l&&(h=iw(n,u,r),i=Un(i.length,s)),Pr("sum",i,s);const[d,f]=kr(h.shape,i);let m=d;e&&(m=Vn(d,o));const v=xt(f),b=xt(n.shape)/v,w=Bt({inputs:{x:h},attrs:{shape:[b,v]},backend:r}),S=Vx(n.dtype),N=$c(w,S,"sum",r),C=Bt({inputs:{x:N},attrs:{shape:m},backend:r});return r.disposeIntermediateTensorInfo(w),r.disposeIntermediateTensorInfo(N),l&&r.disposeIntermediateTensorInfo(h),C}function uw(n){const{inputs:t,backend:e,attrs:r}=n,{x:a}=t,{axis:s,keepDims:o}=r;return Ywt(a,s,o,e)}const Qwt={kernelName:mg,backendName:"webgl",kernelFunc:uw};function fa(n){const{inputs:t,backend:e,attrs:r}=n,{x:a}=t,{perm:s}=r,o=e,i=a.shape.length,u=new Array(i);for(let h=0;h<u.length;h++)u[h]=a.shape[s[h]];let l;if(o.shouldExecuteOnCPU([a])){const d=o.texData.get(a.dataId).values,f=x_(d,a.shape,a.dtype,s,u);l=o.makeTensorInfo(u,a.dtype);const m=o.texData.get(l.dataId);m.values=f}else l=iw(a,s,o);return l}const Zwt={kernelName:ql,backendName:"webgl",kernelFunc:fa};const UG=1e3;function _b({a:n,b:t,transposeA:e,transposeB:r,backend:a,bias:s=null,preluActivationWeights:o=null,leakyreluAlpha:i=0,activation:u=null}){const l=n.shape.length,h=t.shape.length,d=e?n.shape[l-2]:n.shape[l-1],f=r?t.shape[h-1]:t.shape[h-2],m=e?n.shape[l-1]:n.shape[l-2],v=r?t.shape[h-2]:t.shape[h-1],y=n.shape.slice(0,-2),b=t.shape.slice(0,-2),w=xt(y),S=xt(b),C=me(n.shape.slice(0,-2),t.shape.slice(0,-2)).concat([m,v]);P(d===f,()=>`Error in matMul: inner shapes (${d}) and (${f}) of Tensors with shapes ${n.shape} and ${t.shape} and transposeA=${e} and transposeB=${r} must match.`);const T=e?[w,d,m]:[w,m,d],I=r?[S,v,f]:[S,f,v],_=Bt({inputs:{x:n},backend:a,attrs:{shape:T}}),$=Bt({inputs:{x:t},backend:a,attrs:{shape:I}}),R=[_,$],D=Math.max(w,S),A=e?_.shape[1]:_.shape[2],L=s!=null,H=o!=null,G=u==="leakyrelu",q=u!=null?gm(u,!0):null,B=L||H||G||q!=null;let j;if((m===1||v===1)&&A>UG&&B===!1){let z=_,U=$;e&&(z=fa({inputs:{x:_},backend:a,attrs:{perm:[0,2,1]}}),R.push(z)),r&&(U=fa({inputs:{x:$},backend:a,attrs:{perm:[0,2,1]}}),R.push(U));const M=v!==1,X=v===1;let Q=z;M&&(Q=Bt({inputs:{x:z},backend:a,attrs:{shape:[D,A,1]}}),R.push(Q));const rt=v===1?2:1;let ct=U;X&&(ct=Bt({inputs:{x:U},backend:a,attrs:{shape:[D,1,A]}}),R.push(ct));const pt=S_({inputs:{a:Q,b:ct},backend:a});j=uw({inputs:{x:pt},backend:a,attrs:{axis:rt,keepDims:!0}}),R.push(pt)}else{const z=Sa(n.dtype,t.dtype),U=new VG(T,I,[D,m,v],e,r,L,q,H,G),M=[_,$];if(s!=null&&M.push(s),H&&M.push(o),G){const X=a.makeTensorInfo([],"float32",Fi(i,"float32"));M.push(X),R.push(X)}j=a.runWebGLProgram(U,M,z)}const K=Bt({inputs:{x:j},backend:a,attrs:{shape:C}});R.push(j);for(const z of R)a.disposeIntermediateTensorInfo(z);return K}function Jwt(n){const{inputs:t,backend:e,attrs:r}=n,{a,b:s,bias:o,preluActivationWeights:i}=t,{transposeA:u,transposeB:l,activation:h,leakyreluAlpha:d}=r;return _b({a,b:s,transposeA:u,transposeB:l,backend:e,bias:o,preluActivationWeights:i,leakyreluAlpha:d,activation:h})}const t2t={kernelName:jf,backendName:"webgl",kernelFunc:Jwt};const cM="return abs(x);";function e2t(n){const{inputs:t,backend:e}=n,{x:r}=t;if(e.shouldExecuteOnCPU([r])&&r.dtype!=="complex64"){const s=e.texData.get(r.dataId),o=$G(s.values);return e.makeTensorInfo(r.shape,r.dtype,o)}let a;return dt().getBool("WEBGL_PACK_UNARY_OPERATIONS")?a=new Tu(r.shape,cM):a=new Do(r.shape,cM),e.runWebGLProgram(a,[r],r.dtype)}const n2t={kernelName:xm,backendName:"webgl",kernelFunc:e2t};const r2t=Gs+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,a2t=Ue({opSnippet:r2t}),s2t={kernelName:hd,backendName:"webgl",kernelFunc:a2t};const o2t=Gs+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,i2t=Ue({opSnippet:o2t}),u2t={kernelName:dd,backendName:"webgl",kernelFunc:i2t};const hM="return a + b;",l2t=Ur({opSnippet:hM,packedOpSnippet:hM,supportsComplex:!0,cpuKernelImpl:b1t}),c2t={kernelName:yc,backendName:"webgl",kernelFunc:l2t};class h2t{constructor(t,e){this.outputShape=[],this.outputShape=t,this.variableNames=e.map((s,o)=>`T${o}`);const r=[];this.variableNames.forEach(s=>{r.push(`float v${s} = get${s}AtOutCoords();`)});const a=this.variableNames.map(s=>`v${s}`).join(" + ");this.userCode=`
      void main() {
        ${r.join(`
        `)}

        float result = ${a};
        setOutput(result);
      }
    `}}class d2t{constructor(t,e){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.variableNames=e.map((s,o)=>`T${o}`);const r=[];this.variableNames.forEach(s=>{r.push(`vec4 v${s} = get${s}AtOutCoords();`)});const a=this.variableNames.map(s=>`v${s}`).join(" + ");this.userCode=`
      void main() {
        ${r.join(`
        `)}

        vec4 result = ${a};
        setOutput(result);
      }
    `}}function I0(n){const{inputs:t,backend:e}=n,r=t;if(r.length===1)return Xa({inputs:{x:r[0]},backend:e});if(r.length>dt().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const u=Math.floor(r.length/2),l=I0({inputs:r.slice(0,u),backend:e}),h=I0({inputs:r.slice(u),backend:e});return I0({inputs:[l,h],backend:e})}const a=r.map(u=>u.dtype).reduce((u,l)=>Sa(u,l)),s=r.map(u=>u.shape),i=dt().getBool("WEBGL_PACK")?new d2t(r[0].shape,s):new h2t(r[0].shape,s);return e.runWebGLProgram(i,r,a)}const p2t={kernelName:wm,backendName:"webgl",kernelFunc:I0};function f2t(n){const{inputs:t,backend:e,attrs:r}=n,{x:a}=t,{axis:s,keepDims:o}=r,i=a.shape.length,u=_e(s,a.shape);let l=u;const h=An(l,i);let d=a;h!=null&&(d=fa({inputs:{x:a},backend:e,attrs:{perm:h}}),l=Un(l.length,i)),Pr("all",l,i);const[f,m]=kr(d.shape,l),v=xt(m),y=Bt({inputs:{x:d},backend:e,attrs:{shape:[-1,v]}}),b=$c(y,y.dtype,"all",e);let w;if(o){const S=Vn(f,u);w=Bt({inputs:{x:b},backend:e,attrs:{shape:S}})}else w=Bt({inputs:{x:b},backend:e,attrs:{shape:f}});return e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(b),h!=null&&e.disposeIntermediateTensorInfo(d),w}const m2t={kernelName:Fb,backendName:"webgl",kernelFunc:f2t};function g2t(n){const{inputs:t,backend:e,attrs:r}=n,{x:a}=t,{axis:s,keepDims:o}=r,i=a.shape.length,u=_e(s,a.shape);let l=u;const h=An(l,i);let d=a;h!=null&&(d=fa({inputs:{x:a},backend:e,attrs:{perm:h}}),l=Un(l.length,i)),Pr("any",l,i);const[f,m]=kr(d.shape,l),v=xt(m),y=Bt({inputs:{x:d},backend:e,attrs:{shape:[-1,v]}}),b=$c(y,y.dtype,"any",e);let w;if(o){const S=Vn(f,u);w=Bt({inputs:{x:b},backend:e,attrs:{shape:S}})}else w=Bt({inputs:{x:b},backend:e,attrs:{shape:f}});return e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(b),h!=null&&e.disposeIntermediateTensorInfo(d),w}const v2t={kernelName:Mb,backendName:"webgl",kernelFunc:g2t};class y2t{constructor(t,e,r){this.variableNames=["A"];const{windowSize:a,batchSize:s,outSize:o}=t;r||this.variableNames.push("bestIndicesA"),this.outputShape=[s,o];const i=e==="max"?">":"<",u=r?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${a};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${a}; i++) {
          int inIdx = ${u};
          float candidate = getA(batch, inIdx);
          if (candidate ${i} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}}class b2t{constructor(t,e,r,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,P(t.length>2,()=>`Packed arg${r.charAt(0).toUpperCase()+r.slice(1)} supports only inputs with rank above 2.`);const s=t[t.length-1],o=Math.ceil(s/e);this.outputShape=t.slice(0,-1),o>1&&this.outputShape.push(o),a||this.variableNames.push("bestIndicesA");const i=this.outputShape,u=i.length,l=sn(u),h=ca("coords",u);let d,f;if(o===1){f=u+1;const $=sn(f);d=`
        ${$} sourceLocR = ${$}(${h.join()}, 0);
        ++${h[u-1]};
        ${$} sourceLocG = ${$}(${h.join()}, 0);
        ++${h[u-2]};
        ${$} sourceLocA = ${$}(${h.join()}, 0);
        --${h[u-1]};
        ${$} sourceLocB = ${$}(${h.join()}, 0);
        --${h[u-2]};`}else f=u,d=`
        ${l} sourceLocR = coords;
        ++${h[u-1]};
        ${l} sourceLocG = coords;
        ++${h[u-2]};
        ${l} sourceLocA = coords;
        --${h[u-1]};
        ${l} sourceLocB = coords;
        --${h[u-2]};`;const m=["x","y","z","w","u","v"].slice(0,f),v="."+m[f-1],y=m.map($=>"int "+$),b=ca("sourceLocR",f-1).concat("inIdx.r"),w=ca("sourceLocG",f-1).concat("inIdx.g"),S=ca("sourceLocB",f-1).concat("inIdx.b"),N=ca("sourceLocA",f-1).concat("inIdx.a"),C=r==="max"?"greaterThan":"lessThan",T=a?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${b.join()}),
                             getBestIndicesAChannel(${w.join()}),
                             getBestIndicesAChannel(${S.join()}),
                             getBestIndicesAChannel(${N.join()})));`,I=`vec4(
            getAChannel(${b.join()}),
            hasNextCol ? getAChannel(${w.join()}) : 0.,
            hasNextRow ? getAChannel(${S.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${N.join()}) : 0.)`,_=a?"":`
      float getBestIndicesAChannel(${y.join()}) {
        return getChannel(getBestIndicesA(${m.join()}),
                                          vec2(${m.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${y.join()}) {
        return getChannel(getA(${m.join()}),
                               vec2(${m.slice(-2).join()}));
      }
      ${_}
      void main() {
        ${l} coords = getOutputCoords();
        bool hasNextCol = ${h[u-1]} < ${i[u-1]-1};
        bool hasNextRow = ${h[u-2]} < ${i[u-2]-1};
        ${d}
        ivec4 srcIdx = ivec4(sourceLocR${v}, sourceLocG${v},
          sourceLocB${v}, sourceLocA${v}) * ${e};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${I};

        for (int i = 0; i < ${e}; i++) {
          inIdx = srcIdx;
          ${T}
          vec4 candidate = ${I};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${C}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}}function WG(n,t,e,r=null){let a=t.shape[0],s=t.shape[1];r!=null&&(a=r.shape[0],s=r.shape[1]);const o=I1(s),i={windowSize:o,inSize:s,batchSize:a,outSize:Math.ceil(s/o)},u=new y2t(i,e,r==null),l=[t];r!=null&&l.push(r);const h=n.runWebGLProgram(u,l,"int32");if(h.shape[1]===1)return h;const d=WG(n,t,e,h);return n.disposeIntermediateTensorInfo(h),d}function GG(n,t,e,r=null){const a=r!=null?r.shape:t.shape,s=a[a.length-1],o=I1(s),i=new b2t(a,o,e,r==null),u=r==null?[t]:[t,r],l=n.runWebGLProgram(i,u,"int32");if(l.shape.length===t.shape.length){const h=GG(n,t,e,l);return n.disposeIntermediateTensorInfo(l),h}return l}function HG(n,t,e,r){const a=[e];if(Pr("arg"+r.charAt(0).toUpperCase()+r.slice(1),a,t.shape.length),!dt().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){const s=[],o=n.texData.get(t.dataId),i=o!==null&&o.isPacked;let u=t;i&&(u=n.unpackTensor(t),s.push(u));const[l,h]=kr(u.shape,a),d=xt(h),f=Bt({inputs:{x:u},backend:n,attrs:{shape:[-1,d]}});s.push(f);const m=WG(n,f,r);s.push(m);const v=Bt({inputs:{x:m},backend:n,attrs:{shape:l}});return s.forEach(y=>n.disposeIntermediateTensorInfo(y)),v}return GG(n,t,r)}function x2t(n){const{inputs:t,backend:e,attrs:r}=n,{x:a}=t,{axis:s}=r;let o=_e(s,a.shape);const i=An(o,a.shape.length);let u=a;const l=[];i!=null&&(u=fa({inputs:{x:a},backend:e,attrs:{perm:i}}),l.push(u),o=Un(o.length,u.shape.length)),Pr("argMax",[o[0]],u.shape.length);const h=HG(e,u,o[0],"max");return l.forEach(d=>e.disposeIntermediateTensorInfo(d)),h}const w2t={kernelName:Sm,backendName:"webgl",kernelFunc:x2t};function S2t(n){const{inputs:t,backend:e,attrs:r}=n,{x:a}=t,{axis:s}=r;let o=_e(s,a.shape);const i=An(o,a.shape.length);let u=a;const l=[];i!=null&&(u=fa({inputs:{x:a},backend:e,attrs:{perm:i}}),l.push(u),o=Un(o.length,u.shape.length)),Pr("argMin",[o[0]],u.shape.length);const h=HG(e,u,o[0],"min");return l.forEach(d=>e.disposeIntermediateTensorInfo(d)),h}const C2t={kernelName:Cm,backendName:"webgl",kernelFunc:S2t};const N2t=Gs+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,k2t=Ue({opSnippet:N2t}),T2t={kernelName:pd,backendName:"webgl",kernelFunc:k2t};const E2t=Gs+"return log(x + sqrt(x * x + 1.0));",I2t=Ue({opSnippet:E2t}),_2t={kernelName:fd,backendName:"webgl",kernelFunc:I2t};const R2t=Gs+`
  return atan(x);
`,A2t=Ue({opSnippet:R2t}),D2t={kernelName:md,backendName:"webgl",kernelFunc:A2t};const $2t=w_+`
  return atan(a, b);
`,O2t=`
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Dc+`
  return result;
`,F2t=Ur({opSnippet:$2t,packedOpSnippet:O2t}),M2t={kernelName:vd,backendName:"webgl",kernelFunc:F2t};const L2t=Gs+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,B2t=Ue({opSnippet:L2t}),z2t={kernelName:gd,backendName:"webgl",kernelFunc:B2t};class vm{constructor(t,e,r,a=!1,s=!1){if(this.variableNames=["x"],e==="avg"&&r)throw new Error("Cannot compute positions for average pool.");const o=t.filterWidth,i=t.strideHeight,u=t.strideWidth,l=t.dilationHeight,h=t.dilationWidth,d=t.effectiveFilterHeight,f=t.effectiveFilterWidth,m=t.padInfo.top,v=t.padInfo.left;this.outputShape=t.outShape;const y=e==="avg",b=`((batch  * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + d`,w=`(xR * ${t.inWidth} + xC) * ${t.inChannels} + d`;let S="0.0";if(y||(S="-1.0 / 1e-20"),r){this.userCode=`
        const ivec2 strides = ivec2(${i}, ${u});
        const ivec2 pads = ivec2(${m}, ${v});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${d};
              wR += ${l}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${f};
                wC += ${h}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value >= currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${a?s?b:w:`wR * ${f} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const N="max";let C=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;e==="avg"&&(C="avgValue / max(count, 1.0)");const T=Math.floor(o/4)*4,I=o%4,_=`
      if (${y}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${N}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${i}, ${u});
      const ivec2 pads = ivec2(${m}, ${v});
      const float initializationValue = ${S};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${t.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${S});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${d};
            wR += ${l}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${t.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${T}; wC += 4) {
            int xC = xCCorner + wC * ${h};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${h}, d),
              getValue(batch, xR, xC + 2 * ${h}, d),
              getValue(batch, xR, xC + 3 * ${h}, d)
            );

            ${_}
          }

          int xC = xCCorner + ${T};
          if (${I===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${_}
          } else if (${I===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${h}, d),
              initializationValue,
              initializationValue
            );

            ${_}
          } else if (${I===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${h}, d),
              getValue(batch, xR, xC + 2 * ${h}, d),
              initializationValue
            );

            ${_}
          }
        }
        setOutput(${C});
      }
    `}}class C_{constructor(t,e,r,a=!1,s=!1){if(this.variableNames=["x"],e==="avg"&&r)throw new Error("Cannot compute positions for average pool.");const o=t.filterWidth,i=t.strideDepth,u=t.strideHeight,l=t.strideWidth,h=t.dilationDepth,d=t.dilationHeight,f=t.dilationWidth,m=t.effectiveFilterDepth,v=t.effectiveFilterHeight,y=t.effectiveFilterWidth,b=t.padInfo.front,w=t.padInfo.top,S=t.padInfo.left;this.outputShape=t.outShape;const N=e==="avg";let C="0.0";if(N||(C="-1.0 / 1e-20"),r){this.userCode=`
        const ivec3 strides =
            ivec3(${i}, ${u}, ${l});
        const ivec3 pads = ivec3(${b}, ${w}, ${S});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${m};
              wD += ${h}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${t.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${v};
                wR += ${d}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${t.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${y};
                  wC += ${f}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${t.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value >= currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${a?s?`(((batch * ${t.inDepth} + xD) * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`((xD * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`wD * ${v} * ${y} +
                      wR * ${y} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const T="max";let I=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;e==="avg"&&(I="avgValue / max(count, 1.0)");const _=Math.floor(o/4)*4,$=o%4,R=`
      if (${N}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${T}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${i}, ${u}, ${l});
      const ivec3 pads = ivec3(${b}, ${w}, ${S});
      const float initializationValue = ${C};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${t.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${C});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${m};
            wD += ${h}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${t.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${v};
            wR += ${d}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${_}; wC += 4) {
              int xC = xCCorner + wC * ${f};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${f}, ch),
                getValue(batch, xD, xR, xC + 2 * ${f}, ch),
                getValue(batch, xD, xR, xC + 3 * ${f}, ch)
              );

              ${R}
            }

            int xC = xCCorner + ${_};
            if (${$===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${R}
            } else if (${$===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${f}, ch),
                initializationValue,
                initializationValue
              );

              ${R}
            } else if (${$===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${f}, ch),
                getValue(batch, xD, xR, xC + 2 * ${f}, ch),
                initializationValue
              );

              ${R}
            }
          }
        }
        setOutput(${I});
      }
    `}}function P2t(n){const{inputs:t,backend:e,attrs:r}=n,{x:a}=t;fv(a,"avgPool");const{filterSize:s,strides:o,pad:i,dimRoundingMode:u}=r,l=1;P(zr(o,l),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${l}'`);const h=Vs(a.shape,s,o,l,i,u);if(h.filterWidth===1&&h.filterHeight===1&&De(h.inShape,h.outShape))return Xa({inputs:{x:a},backend:e});const d=new vm(h,"avg",!1);return e.runWebGLProgram(d,[a],"float32")}const V2t={kernelName:Nm,backendName:"webgl",kernelFunc:P2t};function U2t(n){const{inputs:t,backend:e,attrs:r}=n,{x:a}=t,{filterSize:s,strides:o,pad:i,dimRoundingMode:u,dataFormat:l}=r,h=[1,1,1],d=Mi(a.shape,s,o,h,i,u,l),f=new C_(d,"avg",!1);return e.runWebGLProgram(f,[a],"float32")}const W2t={kernelName:km,backendName:"webgl",kernelFunc:U2t};class G2t{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;const e=t.filterHeight,r=t.filterWidth,a=t.strideHeight,s=t.strideWidth,o=t.dilationHeight,i=t.dilationWidth,u=t.effectiveFilterHeight,l=t.effectiveFilterWidth,h=u-1-t.padInfo.top,d=l-1-t.padInfo.left,f=1/(e*r);this.userCode=`
      const ivec2 pads = ivec2(${h}, ${d});
      const float avgMultiplier = float(${f});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${u};
            wR += ${o}) {
          float dyR = float(dyRCorner + wR) / ${a}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${l};
            wC+= ${i}) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}}class H2t{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;const e=t.filterDepth,r=t.filterHeight,a=t.filterWidth,s=t.strideDepth,o=t.strideHeight,i=t.strideWidth,u=t.dilationDepth,l=t.dilationHeight,h=t.dilationWidth,d=t.effectiveFilterDepth,f=t.effectiveFilterHeight,m=t.effectiveFilterWidth,v=d-1-t.padInfo.front,y=f-1-t.padInfo.top,b=m-1-t.padInfo.left,w=1/(e*r*a);this.userCode=`
      const ivec3 pads = ivec3(${v}, ${y}, ${b});
      const float avgMultiplier = float(${w});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${d};
            wD += ${u}) {
          float dyD = float(dyDCorner + wD) / ${s}.0;

          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${f};
              wR += ${l}) {
            float dyR = float(dyRCorner + wR) / ${o}.0;

            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${m};
                wC += ${h}) {
              float dyC = float(dyCCorner + wC) / ${i}.0;

              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}function j2t(n){const{inputs:t,backend:e,attrs:r}=n,{dy:a,input:s}=t,o=s,{filterSize:i,strides:u,pad:l,dimRoundingMode:h}=r,d=[1,1,1],f=Mi(o.shape,i,u,d,l,h),m=new H2t(f);return e.runWebGLProgram(m,[a],o.dtype)}const q2t={kernelName:Bb,backendName:"webgl",kernelFunc:j2t};function K2t(n){const{inputs:t,backend:e,attrs:r}=n,{dy:a,input:s}=t,o=s;fv([a,s],"avgPoolGrad");const{filterSize:i,strides:u,pad:l}=r,h=Vs(o.shape,i,u,1,l),d=new G2t(h);return e.runWebGLProgram(d,[a],o.dtype)}const X2t={kernelName:Lb,backendName:"webgl",kernelFunc:K2t};function Y2t(n){const{inputs:t,backend:e,attrs:r}=n,{a,b:s}=t,{transposeA:o,transposeB:i}=r;return _b({a,b:s,transposeA:o,transposeB:i,backend:e})}const Q2t={kernelName:Tm,backendName:"webgl",kernelFunc:Y2t};class Z2t{constructor(t,e,r,a,s,o){this.outputShape=[],this.variableNames=["x","mean","variance"],me(t,e),me(t,r);let i="0.0";a!=null&&(me(t,a),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let u="1.0";s!=null&&(me(t,s),this.variableNames.push("scale"),u="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${i};
        float scale = ${u};
        float inv = scale * inversesqrt(variance + float(${o}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}}class J2t{constructor(t,e,r,a,s,o){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],me(t,e),me(t,r);let i="vec4(0.0)";a!=null&&(me(t,a),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let u="vec4(1.0)";s!=null&&(me(t,s),this.variableNames.push("scale"),u="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`
      void main() {
        vec4 offset = ${i};
        vec4 scale = ${u};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${o}));

        setOutput((x - mean) * inv + offset);
      }
    `}}const tSt=({inputs:n,backend:t,attrs:e})=>{const{x:r,mean:a,variance:s,offset:o,scale:i}=n;P(a.shape.length===s.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),P(o==null||a.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),P(i==null||a.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:u}=e;u==null&&(u=.001);const l=[r,a,s];let h=null;o!=null&&(h=o.shape,l.push(o));let d=null;i!=null&&(d=i.shape,l.push(i));const f=dt().getBool("WEBGL_PACK_NORMALIZATION")?new J2t(r.shape,a.shape,s.shape,h,d,u):new Z2t(r.shape,a.shape,s.shape,h,d,u);return t.runWebGLProgram(f,l,l[0].dtype)},eSt={kernelName:zm,backendName:"webgl",kernelFunc:tSt};class nSt{constructor(t){this.variableNames=["source"],this.outputShape=t,this.rank=t.length;const e=sn(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const r=rSt(this.rank);let a;const s=t.map((o,i)=>`sourceLoc.${vk[i]} = start[${i}] + coords.${vk[i]};`);a=`
        ${e} sourceLoc;
        ${e} coords = getOutputCoords();
        ${s.join(`
`)}
      `,this.userCode=`
      void main() {
        ${a}
        setOutput(getSource(${r}));
      }
    `}}const vk=["x","y","z","w","u","v"];function rSt(n){if(n===1)return"sourceLoc";if(n<=6)return vk.slice(0,n).map(t=>"sourceLoc."+t).join(",");throw Error(`Slicing for rank ${n} is not yet supported`)}class aSt{constructor(t){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.rank=t.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const e=sn(this.rank),r=ca("coords",this.rank),a=ca("sourceLoc",this.rank),s=this.rank===1?"sourceLoc":`vec2(${a.slice(-2).join()})`,o=`getChannel(getSource(${a.join()}), ${s})`,i=`
      result.x = ${o};
      if (++${r[this.rank-1]} < ${t[this.rank-1]}) {
        ++${a[this.rank-1]};
        result.y = ${o};
        --${a[this.rank-1]};
      }
    `,u=this.rank===1?"":`
      --${r[this.rank-1]};
      if (++${r[this.rank-2]} < ${t[this.rank-2]}) {
        ++${a[this.rank-2]};
        result.z = ${o};
        if (++${r[this.rank-1]} < ${t[this.rank-1]}) {
          ++${a[this.rank-1]};
          result.w = ${o};
        }
      }
    `,l=this.rank<=4?`sourceLoc = coords +
            ${e}(${t.map((h,d)=>`start[${d}]`).join()});`:t.map((h,d)=>`${a[d]} = ${r[d]} + start[${d}];`).join(`
`);this.userCode=`
      void main() {
        ${e} coords = getOutputCoords();
        ${e} sourceLoc;
        ${l}
        vec4 result = vec4(0.);
        ${i}
        ${u}
        setOutput(result);
      }
    `}}function sSt(n,t,e,r){const a=r.texData.get(n.dataId),s=r.makeTensorInfo(e,n.dtype),o=r.texData.get(s.dataId);Object.assign(o,a),o.refCount=1,o.shape=e,o.dtype=n.dtype;let i=iE(t,oe(n.shape));a.slice&&(i+=a.slice.flatOffset),o.slice={flatOffset:i,origDataId:a.slice&&a.slice.origDataId||n.dataId};const u=r.dataRefCount.get(o.slice.origDataId)||1;return r.dataRefCount.set(o.slice.origDataId,u+1),s}function Cp(n){const{inputs:t,backend:e,attrs:r}=n,{x:a}=t,{begin:s,size:o}=r,[i,u]=E1(a,s,o);if(aE(a,i,u),xt(u)===0)return e.makeTensorInfo(u,a.dtype,[]);if(e.shouldExecuteOnCPU([a])||a.dtype==="string"){const d=e.texData.get(a.dataId),f=Q1t(d.values,i,u,a.shape,a.dtype);return e.makeTensorInfo(u,a.dtype,f)}const{isPacked:l}=e.texData.get(a.dataId),h=oE(a.shape,i,u);if(l||!h){const d=dt().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new aSt(u):new nSt(u),f=[i];return e.runWebGLProgram(d,[a],a.dtype,f)}return e.uploadToGPU(a.dataId),sSt(a,i,u,e)}const oSt={kernelName:fg,backendName:"webgl",kernelFunc:Cp};const iSt=n=>{const{inputs:t,backend:e,attrs:r}=n,{x:a}=t,{blockShape:s,crops:o}=r;P(a.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const i=s.reduce((S,N)=>S*N),u=Gg(a.shape,s,i),l=Hg(u.length,s.length),h=jg(a.shape,s,i),d=pE(o,s.length),f=fE(h,o,s.length),m=[],v=Bt({inputs:{x:a},backend:e,attrs:{shape:u}}),y=fa({inputs:{x:v},backend:e,attrs:{perm:l}}),b=Bt({inputs:{x:y},backend:e,attrs:{shape:h}}),w=Cp({inputs:{x:b},backend:e,attrs:{begin:d,size:f}});return m.push(v),m.push(y),m.push(b),m.forEach(S=>e.disposeIntermediateTensorInfo(S)),w},uSt={kernelName:Em,backendName:"webgl",kernelFunc:iSt};function lSt(n){const{inputs:t,backend:e,attrs:r}=n,{x:a,weights:s}=t,{size:o}=r,i=e.readSync(a.dataId),u=e.readSync(s.dataId),l=DG(i,u,s.dtype,s.shape,o);return e.makeTensorInfo([o],s.dtype,l)}const cSt={kernelName:zb,backendName:"webgl",kernelFunc:lSt};const hSt=`
  int r = int(a.r) & int(b.r);
  int g = int(a.g) & int(b.g);
  int rb = int(a.b) & int(b.b);
  int ra = int(a.a) & int(b.a);
  return vec4(r, g, rb, ra);
`,dSt=`
  return float(int(a.r) & int(b.r));
`;function pSt(n){const{inputs:t,backend:e}=n,{a:r,b:a}=t,s=dt().getBool("WEBGL_PACK_BINARY_OPERATIONS"),o=dt().getNumber("WEBGL_VERSION");if(e.shouldExecuteOnCPU([r,a])||o===1){const u=e.texData.get(r.dataId).values,l=e.texData.get(a.dataId).values,[h,d]=w1t(r.shape,a.shape,u,l,r.dtype),f=e.makeTensorInfo(d,r.dtype),m=e.texData.get(f.dataId);return m.values=h,f}let i;return s?i=new wp(hSt,r.shape,a.shape,!1):i=new pc(dSt,r.shape,a.shape),e.runWebGLProgram(i,[r,a],r.dtype)}const fSt={kernelName:Im,backendName:"webgl",kernelFunc:pSt};function mSt(n){const{inputs:t,backend:e}=n,{s0:r,s1:a}=t,s=e.readSync(r.dataId),o=e.readSync(a.dataId),i=me(Array.from(s),Array.from(o));return e.makeTensorInfo([i.length],"int32",Int32Array.from(i))}const gSt={kernelName:Pb,backendName:"webgl",kernelFunc:mSt};const vSt="return float(a != b);",jG=Ur({opSnippet:vSt,cpuKernelImpl:U1t,dtype:"bool"}),ySt={kernelName:ng,backendName:"webgl",kernelFunc:jG};function gv(n){const{inputs:t,backend:e}=n,{input:r}=t,a=e.texData.get(r.dataId);return Xa({inputs:{x:a.complexTensorInfos.real},backend:e})}const bSt={kernelName:xx,backendName:"webgl",kernelFunc:gv};const xSt="return float(int(x));";function wSt(n,t){const e=new Do(n.shape,xSt),r=t.runWebGLProgram(e,[n],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}function yk(n){const{inputs:t,backend:e,attrs:r}=n,{x:a}=t,{dtype:s}=r;if(s==="complex64"){if(a.dtype==="complex64")return Xa({inputs:{x:a},backend:e});const o=Xn(a.shape),i=yk({inputs:{x:a},backend:e,attrs:{dtype:"float32"}}),u=ul({inputs:{real:i,imag:o},backend:e});return o.dispose(),e.disposeIntermediateTensorInfo(i),u}if(a.dtype==="complex64"){const o=gv({inputs:{input:a},backend:e}),i=yk({inputs:{x:o},backend:e,attrs:{dtype:s}});return e.disposeIntermediateTensorInfo(o),i}if(!_k(a.dtype,s)){const o=Xa({inputs:{x:a},backend:e});return{dataId:o.dataId,shape:o.shape,dtype:s}}if(e.shouldExecuteOnCPU([a])){const o=e.texData.get(a.dataId).values,[i,u,l]=S1t(o,a.shape,a.dtype,s);return e.makeTensorInfo(i,u,l)}if(s==="int32")return wSt(a,e);if(s==="bool"){const o=e.makeTensorInfo([],"bool",xr("bool",1)),u=jG({inputs:{a,b:o},backend:e});return e.disposeIntermediateTensorInfo(o),u}throw new Error(`Error in Cast: failed to cast ${a.dtype} to ${s}`)}const SSt={kernelName:yd,backendName:"webgl",kernelFunc:yk};const dM="return ceil(x);",CSt=Ue({opSnippet:dM,packedOpSnippet:dM,cpuKernelImpl:C1t}),NSt={kernelName:bd,backendName:"webgl",kernelFunc:CSt};class kSt{constructor(t){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=t,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}}class TSt{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=t,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}}function ESt(n){const{inputs:t,backend:e,attrs:r}=n,{x:a}=t,{clipValueMin:s,clipValueMax:o}=r;let i;dt().getBool("WEBGL_PACK_CLIP")?i=new TSt(a.shape):i=new kSt(a.shape);const u=[[s],[o]];return e.runWebGLProgram(i,[a],a.dtype,u)}const ISt={kernelName:xd,backendName:"webgl",kernelFunc:ESt};class _St{constructor(t){this.variableNames=["real","imag"],this.outputShape=t,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}}function pM(n,t){return{dataId:t.dataId,dtype:t.dtype,shape:n.shape}}function RSt(n){const{inputs:t,backend:e}=n,{x:r}=t,a=e.texData.get(r.dataId),s=new _St(r.shape),o=[pM(r,a.complexTensorInfos.real),pM(r,a.complexTensorInfos.imag)];return e.runWebGLProgram(s,o,o[0].dtype)}const ASt={kernelName:_m,backendName:"webgl",kernelFunc:RSt};class DSt{constructor(t){this.outputShape=[],this.outputShape=Fo(t,1),this.variableNames=t.map((o,i)=>`T${i}`);const e=new Array(t.length-1);e[0]=t[0][1];for(let o=1;o<e.length;o++)e[o]=e[o-1]+t[o][1];const r=[`if (yC < ${e[0]}) setOutput(getT0(yR, yC));`];for(let o=1;o<e.length;o++){const i=e[o-1];r.push(`else if (yC < ${e[o]}) setOutput(getT${o}(yR, yC-${i}));`)}const a=e.length,s=e[e.length-1];r.push(`else setOutput(getT${a}(yR, yC-${s}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${r.join(`
        `)}
      }
    `}}class $St{constructor(t,e){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=Fo(t,e);const r=this.outputShape,a=r.length,s=sn(a),o=ca("coords",a),i=["x","y","z","w","u","v"].slice(0,a);this.variableNames=t.map((y,b)=>`T${b}`);const u=new Array(t.length-1);u[0]=t[0][e];for(let y=1;y<u.length;y++)u[y]=u[y-1]+t[y][e];const l=i[e],h=i.slice(-2),d=i.join();let f=`if (${l} < ${u[0]}) {
        return getChannel(
            getT0(${d}), vec2(${h.join()}));
        }`;for(let y=1;y<u.length;y++){const b=u[y-1];f+=`
        if (${l} < ${u[y]}  && ${l} >= ${u[y-1]}) {
          return getChannel(
            getT${y}(${g0(i,l,b)}),
            vec2(${g0(h,l,b)}));
        }`}const m=u.length,v=u[u.length-1];f+=`
        return getChannel(
          getT${m}(${g0(i,l,v)}),
          vec2(${g0(h,l,v)}));`,this.userCode=`
      float getValue(${i.map(y=>"int "+y)}) {
        ${f}
      }

      void main() {
        ${s} coords = getOutputCoords();
        vec4 result = vec4(getValue(${o}), 0., 0., 0.);

        ${o[a-1]} = ${o[a-1]} + 1;
        if (${o[a-1]} < ${r[a-1]}) {
          result.g = getValue(${o});
        }

        ${o[a-2]} = ${o[a-2]} + 1;
        if (${o[a-2]} < ${r[a-2]}) {
          result.a = getValue(${o});
        }

        ${o[a-1]} = ${o[a-1]} - 1;
        if (${o[a-2]} < ${r[a-2]} &&
            ${o[a-1]} < ${r[a-1]}) {
          result.b = getValue(${o});
        }
        setOutput(result);
      }
    `}}function g0(n,t,e){const r=n.indexOf(t);return n.map((s,o)=>o===r?`${s} - ${e}`:s).join()}function lw(n){const{inputs:t,backend:e}=n,{input:r}=t,a=e.texData.get(r.dataId);return Xa({inputs:{x:a.complexTensorInfos.imag},backend:e})}const OSt={kernelName:ox,backendName:"webgl",kernelFunc:lw};function zf(n,t,e){const r=n[0].dtype;if(r==="complex64"){const m=n.map(S=>gv({inputs:{input:S},backend:e})),v=n.map(S=>lw({inputs:{input:S},backend:e})),y=zf(m,t,e),b=zf(v,t,e),w=ul({inputs:{real:y,imag:b},backend:e});return m.forEach(S=>e.disposeIntermediateTensorInfo(S)),v.forEach(S=>e.disposeIntermediateTensorInfo(S)),e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(b),w}let a=e.shouldExecuteOnCPU(n);if(r==="string"&&(a=!0),a){const m=n.map(C=>{const I=[-1,xt(C.shape.slice(t))];return Bt({inputs:{x:C},backend:e,attrs:{shape:I}})}),v=m.map(C=>({vals:e.readSync(C.dataId),shape:C.shape})),y=Fo(m.map(C=>C.shape),1),b=m[0].shape[0]===1,w=N1t(v,y,r,b),S=Fo(n.map(C=>C.shape),t),N=e.makeTensorInfo(S,r,w);return m.forEach(C=>e.disposeIntermediateTensorInfo(C)),N}const s=n.filter(m=>xt(m.shape)>0),o=dt().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&s[0].shape.length>1;if(s.length===1){const m=o?new Do(n[0].shape,wu):new Tu(n[0].shape,wu);return e.runWebGLProgram(m,n,r)}const i=dt().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(s.length>i){const m=[];for(let y=0;y<s.length;y+=i){const b=s.slice(y,y+i);m.push(zf(b,t,e))}const v=zf(m,t,e);for(const y of m)e.disposeIntermediateTensorInfo(y);return v}if(o){const m=new $St(s.map(v=>v.shape),t);return e.runWebGLProgram(m,s,r)}const{tensors2D:u,outShape:l}=FSt(s,t,e),h=new DSt(u.map(m=>m.shape)),d=e.runWebGLProgram(h,u,r);u.forEach(m=>e.disposeIntermediateTensorInfo(m));const f=Bt({inputs:{x:d},attrs:{shape:l},backend:e});return e.disposeIntermediateTensorInfo(d),f}function FSt(n,t,e){const r=Fo(n.map(s=>s.shape),t);return{tensors2D:n.map(s=>Bt({inputs:{x:s},attrs:{shape:[-1,xt(s.shape.slice(t))]},backend:e})),outShape:r}}function qG(n){const{inputs:t,backend:e,attrs:r}=n,{axis:a}=r,s=_e(a,t[0].shape)[0],o=t.map(l=>l.shape);cE(o,s);const i=Fo(t.map(l=>l.shape),s);if(xt(i)===0)return e.makeTensorInfo(i,t[0].dtype,[]);const u=t.filter(l=>xt(l.shape)>0);return u.length===1?Xa({inputs:{x:u[0]},backend:e}):zf(u,s,e)}const MSt={kernelName:Rm,backendName:"webgl",kernelFunc:qG};class KG{constructor(t,e=!1,r=null,a=!1,s=!1){this.variableNames=["x","W"],this.outputShape=t.outShape;const o=t.padInfo.top,i=t.padInfo.left,u=t.strideHeight,l=t.strideWidth,h=t.dilationHeight,d=t.dilationWidth,f=t.filterHeight,m=t.filterWidth,v=Math.floor(t.inChannels/4)*4,y=t.inChannels%4,b=t.dataFormat==="channelsLast",w=b?1:2,S=b?2:3,N=b?3:1;let C="",T="";r&&(a?C=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${r}
        }`:s?C=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${r}
        }`:C=`
          float activation(float x) {
            ${r}
          }
        `,T="result = activation(result);");const I=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${C}

      const ivec2 strides = ivec2(${u}, ${l});
      const ivec2 pads = ivec2(${o}, ${i});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${N}];

        ivec2 xRCCorner =
            ivec2(coords[${w}], coords[${S}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${f}; wR++) {
          int xR = xRCorner + wR * ${h};

          if (xR < 0 || xR >= ${t.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${m}; wC++) {
            int xC = xCCorner + wC * ${d};

            if (xC < 0 || xC >= ${t.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${v}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${b}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${y===1}) {

              if (${b}) {
                dotProd +=
                    getX(batch, xR, xC, ${v}) *
                    getW(wR, wC, ${v}, d2);
              } else {
                dotProd +=
                    getX(batch, ${v}, xR, xC) *
                    getW(wR, wC, ${v}, d2);
              }

            } else if (${y===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${v}, d2),
                getW(wR, wC, ${v} + 1, d2)
              );

              if (${b}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${v}),
                  getX(batch, xR, xC, ${v} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${v}, xR, xC),
                  getX(batch, ${v} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${y===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${v}, d2),
                getW(wR, wC, ${v} + 1, d2),
                getW(wR, wC, ${v} + 2, d2)
              );

              if (${b}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${v}),
                  getX(batch, xR, xC, ${v} + 1),
                  getX(batch, xR, xC, ${v} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${v}, xR, xC),
                  getX(batch, ${v} + 1, xR, xC),
                  getX(batch, ${v} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${I}
        ${T}
        setOutput(result);
      }
    `}}class LSt{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;const e=t.padInfo.front,r=t.padInfo.top,a=t.padInfo.left,s=t.strideDepth,o=t.strideHeight,i=t.strideWidth,u=t.dilationDepth,l=t.dilationHeight,h=t.dilationWidth,d=t.filterDepth,f=t.filterHeight,m=t.filterWidth,v=Math.floor(t.inChannels/4)*4,y=t.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${s}, ${o}, ${i});
      const ivec3 pads = ivec3(${e}, ${r}, ${a});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${d}; wF++) {
          int xF = xFCorner + wF * ${u};

          if (xF < 0 || xF >= ${t.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${f}; wR++) {
            int xR = xRCorner + wR * ${l};

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${m}; wC++) {
              int xC = xCCorner + wC * ${h};

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${v}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${y===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${v}) *
                  getW(wF, wR, wC, ${v}, d2);
              } else if (${y===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${v}),
                  getX(batch, xF, xR, xC, ${v} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${v}, d2),
                  getW(wF, wR, wC, ${v} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${y===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${v}),
                  getX(batch, xF, xR, xC, ${v} + 1),
                  getX(batch, xF, xR, xC, ${v} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${v}, d2),
                  getW(wF, wR, wC, ${v} + 1, d2),
                  getW(wF, wR, wC, ${v} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class XG{constructor(t,e=!1,r=null,a=!1,s=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=ta(this.outputShape.length);const o=t.padInfo.left,i=t.strideWidth,u=t.dilationWidth,l=t.filterHeight,h=t.filterWidth,d=h;let f=`
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;for(let b=0;b<h;b++)f+=`
           vec4 xTexelC${b*2};
           int xTexelC${b*2}Ready;
           vec4 xTexelC${b*2+1};
           int xTexelC${b*2+1}Ready;
           vec4 xC${b};`;f+=`
     for (int r = 0; r < ${l}; r++) {
      for (int d1 = 0; d1 < ${t.inChannels}; d1 += 2) {
       `;for(let b=0;b<h;b++)f+=`
           xTexelC${b*2} = vec4(0.0);
           xTexelC${b*2}Ready = 0;
           xTexelC${b*2+1} = vec4(0.0);
           xTexelC${b*2+1}Ready = 0;
           xC${b} = vec4(0.0);`;f+=`
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;for(let b=0;b<(d+1)/2;b++){const w=b*2;if(f+=`
           xC = xCCorner + ${w*u};
           `,i===1){if(w<h&&(o%2===1?(f+=`
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${w}Ready == 0) {
                   xTexelC${w} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${w}.zw = vec2(0.0);
                   }
                   xTexelC${w}Ready = 1;
                 }
               `,u===1&&w>0?f+=`
                 xC${w} = vec4(xTexelC${w-2}.zw, xTexelC${w}.xy);
                 `:f+=`
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${w} = vec4(previous.zw, xTexelC${w}.xy);
                   } else {
                     xC${w} = vec4(0.0, 0.0, xTexelC${w}.xy);
                   }
                   `):f+=`
                 if (xC >= 0 && xC < inDims[1] && xTexelC${w}Ready == 0) {
                   xTexelC${w} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${w}.zw = vec2(0.0);
                   }
                   xTexelC${w}Ready = 1;
                 }

                 xC${w} = xTexelC${w};
                 `,w+1<h)){const S=o%2===0?$b(u):u;u%2===0&&o%2===1||u%2!==0&&o%2!==1?(f+=`
                   xCOffset = xC + imod(pads[1], 2) + ${S};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${w+1}Ready == 0) {
                     xTexelC${w+1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${w+1}.zw = vec2(0.0);
                     }
                     xTexelC${w+1}Ready = 1;
                   }
                   `,u>1?f+=`
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${w+1} = vec4(previous.zw, xTexelC${w+1}.xy);
                     } else {
                      xC${w+1} = vec4(0.0, 0.0, xTexelC${w+1}.xy);
                     }
                     `:f+=`
                     xC${w+1} = vec4(xTexelC${w}.zw, xTexelC${w+1}.xy);
                     `):S===1?f+=`
                     xC${w+1} = xTexelC${w};
                     `:f+=`
                     xCOffset = xC + ${S};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${w+1}Ready == 0) {
                       xTexelC${w+1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${w+1}.zw = vec2(0.0);
                       }
                       xTexelC${w+1}Ready = 1;
                     }

                     xC${w+1} = xTexelC${w+1};
                     `}}else w<h&&(o%2===1?(f+=`
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${w}Ready == 0) {
                   xTexelC${w} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${w}.zw = vec2(0.0);
                   }
                   xTexelC${w}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${w+1}Ready == 0) {
                   xTexelC${w+1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${w+1}.zw = vec2(0.0);
                   }
                   xTexelC${w+1}Ready = 1;
                 }

                 xC${w} = vec4(xTexelC${w}.zw, xTexelC${w+1}.zw);
               `,w+1<h&&(f+=`
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${w+1} = vec4(xTexelC${w+1}.xy, final.xy);
                 `)):(f+=`
                 if(xC >= 0 && xC < inDims[1] && xTexelC${w}Ready == 0) {
                   xTexelC${w} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${w}.zw = vec2(0.0);
                   }
                   xTexelC${w}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${w+1}Ready == 0) {
                   xTexelC${w+1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${w+1}.zw = vec2(0.);
                   }
                   xTexelC${w+1}Ready = 1;
                 }

                 xC${w} = vec4(
                   xTexelC${w}.xy, xTexelC${w+1}.xy);
               `,w+1<h&&(f+=`
                   xC${w+1} = vec4(xTexelC${w}.zw, xTexelC${w+1}.zw);
                 `)));w<h&&(f+=`
             wTexel = getW(r, ${w}, d1, d2);
             dotProd += xC${w}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${t.inChannels}) {
               dotProd += xC${w}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `,w+1<h&&(f+=`
               wTexel = getW(r, ${w+1}, d1, d2);
               dotProd += xC${w+1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${t.inChannels}) {
                 dotProd += xC${w+1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `))}f+=`
     }
   `,f+=`
     }
   `,f+=`
     }
   `;let m="",v="";r&&(a?m=`vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${r}
         }`:s?m=`vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${r}
         }`:m=`vec4 activation(vec4 x) {
           ${r}
         }`,v="result = activation(result);");const y=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
       ${m}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${f}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${y}
         ${v}
         setOutput(result);
       }
     `}}class BSt{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=t,this.enableShapeUniforms=ta(this.outputShape.length);const{dataFormat:r}=e,a=va(),s=r==="channelsLast",o=s?1:2,i=s?2:3,u=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${t[2]} && pos < ${t[1]}) {`;let l="";for(let h=0;h<=1;h++)for(let d=0;d<=1;d++)l+=`
          blockIndex = rc.z + ${d};
          pos = rc.y + ${h};

          ${u}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${o}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${i}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${s}) {
                  innerDims = vec2(d1, ch);
                  result[${h*2+d}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${h*2+d}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${l}

        ${a.output} = result;
      }
    `}}function Rb(n,t){const e=n.length;return e>=3?t?[...n.slice(0,-3),n[e-3]*n[e-2],n[e-1]]:[...n.slice(0,-3),n[e-3],n[e-2]*n[e-1]]:!t&&e===1&&n[0]>1?[n[0],1]:null}function YG({x:n,filter:t,convInfo:e,backend:r,bias:a=null,preluActivationWeights:s=null,leakyreluAlpha:o=0,activation:i=null}){const u=n.shape,l=r.texData.get(n.dataId),h=e.inChannels,d=u[0]*u[1]*u[2],f=e.outChannels,m=e.dataFormat==="channelsLast",v=!1,y=!1;let b;const w=[];if(s!=null){const C=Rb(s.shape,m);C!=null&&(s=Bt({inputs:{x:s},backend:r,attrs:{shape:C}}),w.push(s))}if(a!=null){const C=Rb(a.shape,m);C!=null&&(a=Bt({inputs:{x:a},backend:r,attrs:{shape:C}}),w.push(a))}if(!((d===1||f===1)&&h>UG)&&l.isPacked&&m&&l.texture!=null&&u[2]%2!==0&&De(l.shape.slice(-3),u.slice(-3))){const C=u[0]*u[1]*(u[2]+1),T={dataId:n.dataId,shape:[1,C,e.inChannels],dtype:n.dtype},I=l.shape;l.shape=l.shape.slice(),l.shape[l.shape.length-2]++,P(Ib(l.shape,T.shape),()=>`packed reshape ${l.shape} to ${T.shape} isn't free`);const _=Bt({inputs:{x:t},backend:r,attrs:{shape:[1,e.inChannels,e.outChannels]}});w.push(_);const $=_b({a:T,b:_,backend:r,transposeA:v,transposeB:y,bias:a,activation:i,preluActivationWeights:s,leakyreluAlpha:o}),R=r.texData.get($.dataId);P(R.isPacked,()=>"batchMatMul result is expected to be packed"),l.shape=I,R.shape=e.outShape,b=Xa({inputs:{x:$},backend:r}),b.shape=e.outShape,w.push($)}else{const C=e.outHeight*e.outWidth,T=Bt({inputs:{x:n},backend:r,attrs:{shape:m?[e.batchSize,C,e.inChannels]:[e.batchSize,e.inChannels,C]}}),I=Bt({inputs:{x:t},backend:r,attrs:{shape:[1,e.inChannels,e.outChannels]}}),_=_b({a:m?T:I,b:m?I:T,transposeA:!m,transposeB:y,backend:r,bias:a,activation:i,preluActivationWeights:s,leakyreluAlpha:o});b=Bt({inputs:{x:_},backend:r,attrs:{shape:e.outShape}}),w.push(T),w.push(I),w.push(_)}for(const C of w)r.disposeIntermediateTensorInfo(C);return b}function QG({x:n,filter:t,convInfo:e,backend:r,bias:a=null,preluActivationWeights:s=null,leakyreluAlpha:o=0,activation:i=null}){const{filterWidth:u,filterHeight:l,inChannels:h,outWidth:d,outHeight:f,dataFormat:m}=e,v=m==="channelsLast",y=u*l*h,b=f*d,w=[e.batchSize,y,b],S=!0,N=!1,C=[];if(s!=null){const K=Rb(s.shape,v);K!=null&&(s=Bt({inputs:{x:s},backend:r,attrs:{shape:K}}),C.push(s))}if(a!=null){const K=Rb(a.shape,v);K!=null&&(a=Bt({inputs:{x:a},backend:r,attrs:{shape:K}}),C.push(a))}const T=Bt({inputs:{x:t},backend:r,attrs:{shape:[1,y,xt(t.shape)/y]}});C.push(T);const I=new BSt(w,e),_=[n.shape,[e.padInfo.top,e.padInfo.left],[e.strideHeight,e.strideWidth],[e.dilationHeight,e.dilationWidth],[e.inChannels],[e.filterWidth*e.inChannels],[e.outWidth]],$=r.runWebGLProgram(I,[n],"float32",_),R=Bt({inputs:{x:$},backend:r,attrs:{shape:w}});C.push($),C.push(R);const D=a!=null,A=s!=null,L=i==="leakyrelu",H=i?gm(i,!0):null,G=new VG(v?R.shape:T.shape,v?T.shape:R.shape,v?[e.batchSize,b,e.outChannels]:[e.batchSize,e.outChannels,b],S,N,D,H,A,L),q=v?[R,T]:[T,R];if(a&&q.push(a),A&&q.push(s),L){const K=r.makeTensorInfo([],"float32",Fi(o,"float32"));q.push(K),C.push(K)}const B=r.runWebGLProgram(G,q,"float32"),j=Bt({inputs:{x:B},backend:r,attrs:{shape:e.outShape}});C.push(B);for(const K of C)r.disposeIntermediateTensorInfo(K);return j}function zSt(n){const{inputs:t,backend:e,attrs:r}=n,{x:a,filter:s}=t,{strides:o,pad:i,dataFormat:u,dilations:l,dimRoundingMode:h}=r,d=Li(u),f=Nr(a.shape,s.shape,o,l,i,h,!1,d);let m;if(f.filterHeight===1&&f.filterWidth===1&&f.dilationHeight===1&&f.dilationWidth===1&&f.strideHeight===1&&f.strideWidth===1&&(f.padInfo.type==="SAME"||f.padInfo.type==="VALID"))m=YG({x:a,filter:s,convInfo:f,backend:e});else if(f.strideWidth<=2&&d==="channelsLast"&&dt().getBool("WEBGL_EXP_CONV")){const y=new XG(f),b=[[f.padInfo.top,f.padInfo.left],[f.strideHeight,f.strideWidth],[f.dilationHeight,f.dilationWidth],[f.inHeight,f.inWidth]];m=e.runWebGLProgram(y,[a,s],"float32",b)}else if(dt().getBool("WEBGL_CONV_IM2COL"))m=QG({x:a,filter:s,convInfo:f,backend:e});else{const y=new KG(f);m=e.runWebGLProgram(y,[a,s],"float32")}const v=Bt({inputs:{x:m},backend:e,attrs:{shape:f.outShape}});return e.disposeIntermediateTensorInfo(m),v}const PSt={kernelName:Am,backendName:"webgl",kernelFunc:zSt};class VSt{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;const e=t.strideHeight,r=t.strideWidth,a=t.padInfo.top,s=t.padInfo.left,o=t.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${t.batchSize}; b++) {
          for (int yR = 0; yR < ${t.outHeight}; yR++) {
            int xR = wR + yR * ${e} - ${a};

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${t.outWidth}; yC++) {
              int xC = wC + yC * ${r} - ${s};

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              ${o?`float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);`:`float dyValue = getDy(b, d2, yR, yC);
              float xValue = getX(b, d1, xR, xC);
              dotProd += (xValue * dyValue);`}
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class USt{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterHeight,r=t.filterWidth,a=t.strideHeight,s=t.strideWidth,o=t.dataFormat==="channelsLast",i=e-1-t.padInfo.top,u=r-1-t.padInfo.left,l=o?1:2,h=o?2:3,d=o?3:1;this.userCode=`
      const ivec2 pads = ivec2(${i}, ${u});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${d}];

        ivec2 dyCorner = ivec2(coords[${l}], coords[${h}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${e}; wR++) {
          float dyR = float(dyRCorner + wR) / ${a}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${e} - 1 - wR;

          for (int wC = 0; wC < ${r}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${r} - 1 - wC;

            for (int d2 = 0; d2 < ${t.outChannels}; d2++) {

              if (${o}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}}class WSt{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;const e=t.strideDepth,r=t.strideHeight,a=t.strideWidth,s=t.padInfo.front,o=t.padInfo.top,i=t.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${t.batchSize}; b++) {
          for (int yF = 0; yF < ${t.outDepth}; yF++) {
            int xF = wF + yF * ${e} - ${s};

            if (xF < 0 || xF >= ${t.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${t.outHeight}; yR++) {
              int xR = wR + yR * ${r} - ${o};

              if (xR < 0 || xR >= ${t.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${t.outWidth}; yC++) {
                int xC = wC + yC * ${a} - ${i};

                if (xC < 0 || xC >= ${t.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class GSt{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterDepth,r=t.filterHeight,a=t.filterWidth,s=t.strideDepth,o=t.strideHeight,i=t.strideWidth,u=e-1-t.padInfo.front,l=r-1-t.padInfo.top,h=a-1-t.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${u}, ${l}, ${h});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${e}; wF++) {
          float dyF = float(dyFCorner + wF) / ${s}.0;

          if (dyF < 0.0 || dyF >= ${t.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${e} - 1 - wF;

          for (int wR = 0; wR < ${r}; wR++) {
            float dyR = float(dyRCorner + wR) / ${o}.0;

            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${r} - 1 - wR;

            for (int wC = 0; wC < ${a}; wC++) {
              float dyC = float(dyCCorner + wC) / ${i}.0;

              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${a} - 1 - wC;

              for (int d2 = 0; d2 < ${t.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}function HSt(n){const{inputs:t,backend:e,attrs:r}=n,{x:a,dy:s}=t,{strides:o,pad:i,dataFormat:u,dimRoundingMode:l,filterShape:h}=r,d=Li(u),f=Nr(a.shape,h,o,1,i,l,!1,d),m=new VSt(f);return e.runWebGLProgram(m,[a,s],"float32")}const jSt={kernelName:Ub,backendName:"webgl",kernelFunc:HSt};class qSt{constructor(t){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=t.inShape,this.enableShapeUniforms=ta(this.outputShape.length);const e=t.filterHeight,r=t.filterWidth,a=e-1-t.padInfo.top,s=r-1-t.padInfo.left;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${s});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];

        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        vec4 result = vec4(0.);
        for (int wR = 0; wR < ${e}; wR++) {
          float dyR = float(dyRCorner + wR) / strides[0];
          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);
          int wRPerm = ${e} - 1 - wR;

          for (int wC = 0; wC < ${r}; wC++) {
            int wCPerm = ${r} - 1 - wC;

            float dyC = float(dyCCorner + wC) / strides[1];
            bool idyCVal = (dyC >= 0.0) && (dyC < ${t.outWidth}.0)
              && (fract(dyC) == 0.0);
            int idyC = int(dyC);

            float dyC2 = float(dyCCorner + wC + 1) / strides[1];
            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${t.outWidth}.0)
              && (fract(dyC2) == 0.0);
            int idyC2 = int(dyC2);

            if (idyCVal && idyCVal2) {
              for (int d2 = 0; d2 < ${t.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?
                  dySample : getDy(batch, idyR, idyC2, d2);

                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));

                dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample2.xy : dySample2.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal) {
              for (int d2 = 0; d2 < ${t.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal2) {
              for (int d2 = 0; d2 < ${t.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC2, d2);
                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            }
          }
        }
        setOutput(result);
      }
    `}}function KSt(n){const{inputs:t,backend:e,attrs:r}=n,{dy:a,filter:s}=t,{inputShape:o,strides:i,pad:u,dataFormat:l,dimRoundingMode:h}=r,d=Li(l),f=Nr(o,s.shape,i,1,u,h,!1,d);if(dt().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&d==="channelsLast"){const m=[[f.strideHeight,f.strideWidth]],v=new qSt(f);return e.runWebGLProgram(v,[a,s],"float32",m)}else{const m=new USt(f);return e.runWebGLProgram(m,[a,s],"float32")}}const XSt={kernelName:Dm,backendName:"webgl",kernelFunc:KSt};function YSt(n){const{inputs:t,backend:e,attrs:r}=n,{x:a,filter:s}=t,{strides:o,pad:i,dilations:u}=r,l=Zu(a.shape,s.shape,o,u,i),h=new LSt(l);return e.runWebGLProgram(h,[a,s],"float32")}const QSt={kernelName:$m,backendName:"webgl",kernelFunc:YSt};function ZSt(n){const{inputs:t,backend:e,attrs:r}=n,{x:a,dy:s}=t,{strides:o,pad:i,filterShape:u}=r,l=Zu(a.shape,u,o,1,i),h=new WSt(l);return e.runWebGLProgram(h,[a,s],"float32")}const JSt={kernelName:Wb,backendName:"webgl",kernelFunc:ZSt};function tCt(n){const{inputs:t,backend:e,attrs:r}=n,{dy:a,filter:s}=t,{pad:o,strides:i,inputShape:u}=r,l=Zu(u,s.shape,i,1,o),h=new GSt(l);return e.runWebGLProgram(h,[a,s],"float32")}const eCt={kernelName:Gb,backendName:"webgl",kernelFunc:tCt};const nCt=Sp+`
  return cos(x);
`,rCt=`
  vec4 result = cos(x);
  bvec4 isNaN = isnan(x);
  ${Dc}
  return result;
`,aCt=Ue({opSnippet:nCt,packedOpSnippet:rCt}),sCt={kernelName:wd,backendName:"webgl",kernelFunc:aCt};const oCt=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,iCt=Ue({opSnippet:oCt}),uCt={kernelName:Sd,backendName:"webgl",kernelFunc:iCt};class lCt{constructor(t,e,r,a,s){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[o,i,u,l]=t,[h]=e,[d,f]=r;this.outputShape=[h,d,f,l];const m=a==="bilinear"?1:0,[v,y]=[`${i-1}.0`,`${u-1}.0`],[b,w,S]=d>1?[`${(i-1)/(d-1)}`,"(y2-y1) * height_ratio",`y1*${v} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${v}`],[N,C,T]=f>1?[`${(u-1)/(f-1)}`,"(x2-x1) * width_ratio",`x1*${y} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${y}`];this.userCode=`
      const float height_ratio = float(${b});
      const float width_ratio = float(${N});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${o}) {
          return;
        }

        float height_scale = ${w};
        float width_scale = ${C};

        float in_y = ${S};
        if( in_y < 0.0 || in_y > ${v} ) {
          setOutput(float(${s}));
          return;
        }
        float in_x = ${T};
        if( in_x < 0.0 || in_x > ${y} ) {
          setOutput(float(${s}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${m} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}}const cCt=n=>{const{inputs:t,backend:e,attrs:r}=n,{image:a,boxes:s,boxInd:o}=t,{cropSize:i,method:u,extrapolationValue:l}=r,h=new lCt(a.shape,s.shape,i,u,l);return e.runWebGLProgram(h,[a,s,o],"float32")},hCt={kernelName:jb,backendName:"webgl",kernelFunc:cCt};var ym;(function(n){n.Prod="*",n.Sum="+"})(ym||(ym={}));class fM{constructor(t,e,r,a){this.op=t,this.outputShape=e,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const s=this.outputShape.length,o=this.op===ym.Prod?"1.0":"0.0",i=r?o:`getX(${mM(s,"coords",this.op)})`,u=this.outputShape[this.outputShape.length-1];let l="",h="";r?(l=a?`end != ${u-1}`:"end != 0",h=a?"end + 1":"end - 1"):(l=a?`end + pow2 < ${u}`:"end >= pow2",h=a?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${sn(s)} coords = getOutputCoords();
        int end = ${gM(s,"coords",this.op)};
        float val = ${i};
        int pow2 = int(pow(2.0, index));
        if (${l}) {
          int idx = ${h};
          ${gM(s,"coords",this.op)} = idx;
          val ${this.op}= getX(${mM(s,"coords",this.op)});
        }
        setOutput(val);
      }
    `}}function mM(n,t,e){if(n===1)return`${t}`;if(n===2)return`${t}.x, ${t}.y`;if(n===3)return`${t}.x, ${t}.y, ${t}.z`;if(n===4)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw new Error(`Cumulative ${e} for rank ${n} is not yet supported`)}function gM(n,t,e){if(n===1)return`${t}`;if(n===2)return`${t}.y`;if(n===3)return`${t}.z`;if(n===4)return`${t}.w`;throw new Error(`Cumulative ${e} for rank ${n} is not yet supported`)}function ZG(n,t,e,r,a,s){const o=t.shape.length,i=An([r],o);let u=t;i!=null&&(u=fa({inputs:{x:t},backend:e,attrs:{perm:i}}));const l=Un(1,o)[0];if(l!==o-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${t.shape.length-1} but got axis=${r}`);const h=u.shape[l];let d=Xa({inputs:{x:u},backend:e});for(let f=0;f<=Math.ceil(Math.log2(h))-1;f++){const m=new fM(n,u.shape,!1,s),v=[[f]],y=d;d=e.runWebGLProgram(m,[d],d.dtype,v),e.disposeIntermediateTensorInfo(y)}if(a){const f=new fM(n,u.shape,a,s),m=d;d=e.runWebGLProgram(f,[d],d.dtype),e.disposeIntermediateTensorInfo(m)}if(i!=null){const f=Ju(i),m=fa({inputs:{x:d},backend:e,attrs:{perm:f}});return e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(u),m}return d}function dCt(n){const{inputs:t,backend:e,attrs:r}=n,{x:a}=t,{axis:s,exclusive:o,reverse:i}=r;return ZG(ym.Prod,a,e,s,o,i)}const pCt={kernelName:Hb,backendName:"webgl",kernelFunc:dCt};function fCt(n){const{inputs:t,backend:e,attrs:r}=n,{x:a}=t,{axis:s,exclusive:o,reverse:i}=r;return ZG(ym.Sum,a,e,s,o,i)}const mCt={kernelName:Om,backendName:"webgl",kernelFunc:fCt};function gCt(n){const{inputs:t,backend:e,attrs:r}=n,{x:a,weights:s}=t,{size:o,binaryOutput:i}=r;if(a.shape.length===1){const u=e.readSync(a.dataId),l=e.readSync(s.dataId),h=DG(u,l,s.dtype,s.shape,o);return e.makeTensorInfo([o],s.dtype,h)}else if(a.shape.length===2){const u=e.bufferSync(a),l=e.bufferSync(s),h=x1t(u,l,o,i);return e.makeTensorInfo(h.shape,s.dtype,h.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${a.shape.length}.`)}const vCt={kernelName:qb,backendName:"webgl",kernelFunc:gCt};class yCt{constructor(t,e,r){this.variableNames=["x"],this.outputShape=[],this.outputShape=t,this.blockSize=e,this.dataFormat=r,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${e};
      int offset_h = imod(h, ${e});
      int in_w = w / ${e};
      int offset_w = imod(w, ${e});
      int offset_d = (offset_h * ${e} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}function bCt(n){const{inputs:t,backend:e,attrs:r}=n,{x:a}=t,{blockSize:s,dataFormat:o}=r,i=a.shape[0],u=o==="NHWC"?a.shape[1]:a.shape[2],l=o==="NHWC"?a.shape[2]:a.shape[3],h=o==="NHWC"?a.shape[3]:a.shape[1],d=u*s,f=l*s,m=h/(s*s),v=o==="NHWC"?[i,d,f,m]:[i,m,d,f],y=new yCt(v,s,o);return e.runWebGLProgram(y,[a],a.dtype)}const xCt={kernelName:Kb,backendName:"webgl",kernelFunc:bCt};class JG{constructor(t,e=!1,r=null,a=!1,s=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=ta(this.outputShape.length);const o=t.filterHeight,i=t.filterWidth,u=t.outChannels/t.inChannels;let l="",h="";r&&(a?l=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${r}
        }`:s?l=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${r}
        }`:l=`
          float activation(float x) {
            ${r}
          }
        `,h="result = activation(result);");const d=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${l}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${u};
        int q = d2 - d1 * ${u};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${o}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${i}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${d}
        ${h}
        setOutput(result);
      }
    `}}class tH{constructor(t,e=!1,r=null,a=!1,s=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=t.outShape,this.enableShapeUniforms=ta(this.outputShape.length);const o=t.outChannels/t.inChannels,i=t.padInfo.left,u=t.strideWidth,l=t.dilationWidth,h=t.filterHeight,d=t.filterWidth,f=d;let m=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let w=0;w<d;w++)m+=`
          vec4 xTexelC${w*2};
          int xTexelC${w*2}Ready;
          vec4 xTexelC${w*2+1};
          int xTexelC${w*2+1}Ready;
          vec4 xC${w};`;m+=`
    for (int r = 0; r < ${h}; r++) {
      `;for(let w=0;w<d;w++)m+=`
          xTexelC${w*2} = vec4(0.0);
          xTexelC${w*2}Ready = 0;
          xTexelC${w*2+1} = vec4(0.0);
          xTexelC${w*2+1}Ready = 0;
          xC${w} = vec4(0.0);`;m+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let w=0;w<(f+1)/2;w++){const S=w*2;if(m+=`
          xC = xCCorner + ${S*l};
          `,u===1){if(S<d&&(i%2===1?(m+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${S}Ready == 0) {
                  xTexelC${S} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${S}.zw = vec2(0.0);
                  }
                  xTexelC${S}Ready = 1;
                }
              `,l===1&&S>0?m+=`
                xC${S} = vec4(xTexelC${S-2}.zw, xTexelC${S}.xy);
                `:m+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${S} = vec4(previous.zw, xTexelC${S}.xy);
                  } else {
                    xC${S} = vec4(0.0, 0.0, xTexelC${S}.xy);
                  }
                  `):m+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${S}Ready == 0) {
                  xTexelC${S} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${S}.zw = vec2(0.0);
                  }
                  xTexelC${S}Ready = 1;
                }

                xC${S} = xTexelC${S};
                `,S+1<d)){const N=i%2===0?$b(l):l;l%2===0&&i%2===1||l%2!==0&&i%2!==1?(m+=`
                  xCOffset = xC + imod(pads[1], 2) + ${N};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${S+1}Ready == 0) {
                    xTexelC${S+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${S+1}.zw = vec2(0.0);
                    }
                    xTexelC${S+1}Ready = 1;
                  }
                  `,l>1?m+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${S+1} = vec4(previous.zw, xTexelC${S+1}.xy);
                    } else {
                     xC${S+1} = vec4(0.0, 0.0, xTexelC${S+1}.xy);
                    }
                    `:m+=`
                    xC${S+1} = vec4(xTexelC${S}.zw, xTexelC${S+1}.xy);
                    `):N===1?m+=`
                    xC${S+1} = xTexelC${S};
                    `:m+=`
                    xCOffset = xC + ${N};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${S+1}Ready == 0) {
                      xTexelC${S+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${S+1}.zw = vec2(0.0);
                      }
                      xTexelC${S+1}Ready = 1;
                    }

                    xC${S+1} = xTexelC${S+1};
                    `}}else S<d&&(i%2===1?(m+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${S}Ready == 0) {
                  xTexelC${S} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${S}.zw = vec2(0.0);
                  }
                  xTexelC${S}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${S+1}Ready == 0) {
                  xTexelC${S+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${S+1}.zw = vec2(0.0);
                  }
                  xTexelC${S+1}Ready = 1;
                }

                xC${S} = vec4(xTexelC${S}.zw, xTexelC${S+1}.zw);
              `,S+1<d&&(m+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${S+1} = vec4(xTexelC${S+1}.xy, final.xy);
                `)):(m+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${S}Ready == 0) {
                  xTexelC${S} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${S}.zw = vec2(0.0);
                  }
                  xTexelC${S}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${S+1}Ready == 0) {
                  xTexelC${S+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${S+1}.zw = vec2(0.);
                  }
                  xTexelC${S+1}Ready = 1;
                }

                xC${S} = vec4(
                  xTexelC${S}.xy, xTexelC${S+1}.xy);
              `,S+1<d&&(m+=`
                  xC${S+1} = vec4(xTexelC${S}.zw, xTexelC${S+1}.zw);
                `)));S<d&&(m+=`
            wTexel = getW(r, ${S}, d1, q);
            dotProd += xC${S} * vec4(wTexel.xz, wTexel.xz);
          `,S+1<d&&(m+=`
              wTexel = getW(r, ${S+1}, d1, q);
              dotProd += xC${S+1} * vec4(wTexel.xz, wTexel.xz);
            `))}m+=`
    }
  `,m+=`
      }
    `;let v="",y="";r&&(a?v=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${r}
        }`:s?v=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${r}
        }`:v=`vec4 activation(vec4 x) {
          ${r}
        }`,y="result = activation(result);");const b=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${v}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${o};
        int q = d2 - d1 * ${o};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${m}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${b}
        ${y}
        setOutput(result);
      }
    `}}function wCt(n){const{inputs:t,backend:e,attrs:r}=n,{x:a,filter:s}=t,{strides:o,pad:i,dilations:u,dimRoundingMode:l}=r;let h=u;h==null&&(h=[1,1]),P(zr(o,h),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${h}'`);const d=Nr(a.shape,s.shape,o,h,i,l,!0);let f;dt().getBool("WEBGL_PACK_DEPTHWISECONV")&&d.strideWidth<=2&&d.outChannels/d.inChannels===1?f=new tH(d):f=new JG(d);const m=[[d.padInfo.top,d.padInfo.left],[d.strideHeight,d.strideWidth],[d.dilationHeight,d.dilationWidth],[d.inHeight,d.inWidth]];return e.runWebGLProgram(f,[a,s],"float32",m)}const SCt={kernelName:Fm,backendName:"webgl",kernelFunc:wCt};class CCt{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;const e=t.strideHeight,r=t.strideWidth,a=t.padInfo.top,s=t.padInfo.left,o=t.outChannels/t.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${o} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${t.batchSize}; b++) {
          for (int yR = 0; yR < ${t.outHeight}; yR++) {
            int xR = wR + yR * ${e} - ${a};

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${t.outWidth}; yC++) {
              int xC = wC + yC * ${r} - ${s};

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class NCt{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;const e=t.filterHeight,r=t.filterWidth,a=t.strideHeight,s=t.strideWidth,o=e-1-t.padInfo.top,i=r-1-t.padInfo.left,u=t.outChannels/t.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${o}, ${i});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${e}; wR++) {
          float dyR = float(dyRCorner + wR) / ${a}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${e} - 1 - wR;

          for (int wC = 0; wC < ${r}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${r} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${u}; dm++) {
              int d2 = d1 * ${u} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}function kCt(n){const{inputs:t,backend:e,attrs:r}=n,{x:a,dy:s}=t,{strides:o,dilations:i,pad:u,dimRoundingMode:l,filterShape:h}=r,d=Nr(a.shape,h,o,i,u,l,!0),f=new CCt(d);return e.runWebGLProgram(f,[a,s],"float32")}const TCt={kernelName:Xb,backendName:"webgl",kernelFunc:kCt};function ECt(n){const{inputs:t,backend:e,attrs:r}=n,{dy:a,filter:s}=t,{strides:o,dilations:i,pad:u,dimRoundingMode:l,inputShape:h}=r,d=Nr(h,s.shape,o,i,u,l,!0),f=new NCt(d);return e.runWebGLProgram(f,[a,s],"float32")}const ICt={kernelName:Yb,backendName:"webgl",kernelFunc:ECt};class _Ct{constructor(t){this.variableNames=["X"],this.outputShape=[t,t],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}}function RCt(n){const{inputs:t,backend:e}=n,{x:r}=t,a=[...r.shape,...r.shape],s=xt(r.shape),o=Bt({inputs:{x:r},backend:e,attrs:{shape:[s]}}),i=new _Ct(s),u=e.runWebGLProgram(i,[o],o.dtype),l=Bt({inputs:{x:u},backend:e,attrs:{shape:a}});return e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(u),l}const ACt={kernelName:Qb,backendName:"webgl",kernelFunc:RCt};class DCt{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;const{inHeight:e,inWidth:r,padInfo:a,strideHeight:s,strideWidth:o,filterHeight:i,filterWidth:u,dilationHeight:l,dilationWidth:h}=t,{top:d,left:f}=a;this.userCode=`
      const ivec2 strides = ivec2(${s}, ${o});
      const ivec2 pads = ivec2(${d}, ${f});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${i}; h++) {
          int hIn = hBeg + h * ${l};

          if (hIn >= 0 && hIn < ${e}) {
            for (int w = 0; w < ${u}; w++) {
              int wIn = wBeg + w * ${h};

              if (wIn >= 0 && wIn < ${r}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}}function $Ct(n){const{inputs:t,backend:e,attrs:r}=n,{x:a,filter:s}=t,{strides:o,pad:i,dilations:u}=r,l=kg(a.shape,s.shape,o,i,"NHWC",u);let h;const d=new DCt(l);h=e.runWebGLProgram(d,[a,s],"float32");const f=Bt({inputs:{x:h},backend:e,attrs:{shape:l.outShape}});return e.disposeIntermediateTensorInfo(h),f}const OCt={kernelName:Mm,backendName:"webgl",kernelFunc:$Ct};function FCt(n){const{inputs:t,backend:e,attrs:r}=n,{equation:a}=r,s=t,{allDims:o,summedDims:i,idDims:u}=SE(a,s.length);NE(o.length,u,s);const{path:l,steps:h}=kE(i,u),d=h.length;let f=null,m=o.length;const v=[];for(let y=0;y<d;++y){for(const b of h[y]){const{permutationIndices:w,expandDims:S}=CE(m,u[b]);let N;TE(w)?N=s[b]:(N=fa({inputs:{x:s[b]},backend:e,attrs:{perm:w}}),v.push(N));const C=N.shape.slice();for(let T=0;T<S.length;++T)C.splice(S[T],0,1);De(N.shape,C)||(N=Bt({inputs:{x:N},backend:e,attrs:{shape:C}}),v.push(N)),f===null?f=N:(f=S_({inputs:{a:N,b:f},backend:e}),v.push(f))}y<d-1&&(l[y]>=0&&(f=uw({inputs:{x:f},backend:e,attrs:{axis:l[y]-(o.length-m),keepDims:!1}}),v.push(f)),m--)}for(const y of v)y!==f&&e.disposeIntermediateTensorInfo(y);return f}const MCt={kernelName:Jb,backendName:"webgl",kernelFunc:FCt};const LCt="return (x >= 0.0) ? x : (exp(x) - 1.0);",BCt=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,zCt=Ue({opSnippet:LCt,packedOpSnippet:BCt}),PCt={kernelName:Nd,backendName:"webgl",kernelFunc:zCt};const VCt="return (b >= 0.0) ? a : a * (b + 1.0);",UCt=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,WCt=n=>{const{inputs:t,backend:e}=n,{dy:r,y:a}=t,s=dt().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new wp(UCt,r.shape,a.shape):new pc(VCt,r.shape,a.shape);return e.runWebGLProgram(s,[r,a],r.dtype)},GCt={kernelName:tx,backendName:"webgl",kernelFunc:WCt};const HCt=`
  return vec4(equal(a, b));
`,jCt="return float(a == b);",qCt=Ur({opSnippet:jCt,packedOpSnippet:HCt,dtype:"bool",cpuKernelImpl:k1t}),KCt={kernelName:Lm,backendName:"webgl",kernelFunc:qCt};const XCt=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${mE};
  float a1 = ${gE};
  float a2 = ${vE};
  float a3 = ${yE};
  float a4 = ${bE};
  float a5 = ${xE};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,YCt=Ue({opSnippet:XCt}),QCt={kernelName:kd,backendName:"webgl",kernelFunc:YCt};const ZCt=Sp+`
  return exp(x);
`,JCt=`
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,eH=Ue({opSnippet:ZCt,packedOpSnippet:JCt,cpuKernelImpl:T1t,dtype:"float32"}),tNt={kernelName:Td,backendName:"webgl",kernelFunc:eH};function bk(n){const{inputs:t,attrs:e,backend:r}=n,{dim:a}=e,{input:s}=t,o=s.shape.length,i=s.shape.slice();let u=a;return a<0&&(P(-(o+1)<=a,()=>`Axis must be in the interval [${-(o+1)}, ${o}]`),u=o+a+1),i.splice(u,0,1),Bt({inputs:{x:s},backend:r,attrs:{shape:i}})}const eNt={kernelName:Bm,backendName:"webgl",kernelFunc:bk};const vM="return exp(x) - 1.0;",nNt=Ue({opSnippet:vM,packedOpSnippet:vM,cpuKernelImpl:E1t}),rNt={kernelName:Ed,backendName:"webgl",kernelFunc:nNt};class yM{constructor(t,e,r){this.variableNames=["real","imag"];const a=e[1];this.outputShape=e;const s=r?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,o=r?`${a}.0`:"1.0";let i;if(t==="real")i="return real * expR - imag * expI;";else if(t==="imag")i="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${t}.`);this.userCode=`
      const float exponentMultiplier = ${s};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${i}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${a});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${a}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${o};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}}function nH(n,t,e){const r=e.texData.get(n.dataId),a=xt(n.shape),s=n.shape[n.shape.length-1],o=a/s,i=Bt({inputs:{x:n},backend:e,attrs:{shape:[o,s]}}),u=i.shape,l=new yM("real",u,t),h=new yM("imag",u,t),d=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:u},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:u}],f=e.runWebGLProgram(l,d,"float32"),m=e.runWebGLProgram(h,d,"float32"),v=ul({inputs:{real:f,imag:m},backend:e});e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(m);const y=Bt({inputs:{x:v},backend:e,attrs:{shape:n.shape}});return e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(v),y}function aNt(n){const{inputs:t,backend:e}=n,{input:r}=t;return nH(r,!1,e)}const sNt={kernelName:ex,backendName:"webgl",kernelFunc:aNt};class oNt{constructor(t,e){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=t,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}}function vv(n){const{backend:t,attrs:e}=n,{shape:r,value:a}=e;let{dtype:s}=e;if(s=s||gc(a),s==="string"){const o=On(s,xt(r));return o.fill(a),t.makeTensorInfo(r,s,o)}else{const o=new oNt(r,a),i=[[a]];return t.runWebGLProgram(o,[],s,i)}}const iNt={kernelName:nx,backendName:"webgl",kernelFunc:vv};class uNt{constructor(t){this.variableNames=["Image"],this.outputShape=[];const e=t[2];this.outputShape=t,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${e} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${e}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}}const lNt={kernelName:rx,backendName:"webgl",kernelFunc:({inputs:n,backend:t})=>{const{image:e}=n,r=t,a=new uNt(e.shape);return r.runWebGLProgram(a,[e],e.dtype)}};const bM="return floor(x);",cNt=Ue({opSnippet:bM,packedOpSnippet:bM,cpuKernelImpl:I1t}),hNt={kernelName:Id,backendName:"webgl",kernelFunc:cNt};const dNt=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,pNt=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,fNt=Ur({opSnippet:dNt,packedOpSnippet:pNt,dtype:"int32"}),mNt={kernelName:_d,backendName:"webgl",kernelFunc:fNt};class gNt{constructor(t){this.variableNames=["A"];const e=va(),[r,a]=t;this.outputShape=t,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${a}.0, ${r}.0);

        vec4 values = ${e.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}}class vNt{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const e=va(),[r,a]=t;this.outputShape=t,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${a}.0, ${r}.0);
            vec4 values = ${e.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${e.output} = result;
      }
    `}}const yNt={kernelName:L0,backendName:"webgl",kernelFunc:bNt};let Th,XC=dt().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function bNt(n){const{inputs:t,backend:e,attrs:r}=n;let{pixels:a}=t;const{numChannels:s}=r,o=typeof HTMLVideoElement<"u"&&a instanceof HTMLVideoElement,i=typeof HTMLImageElement<"u"&&a instanceof HTMLImageElement,[u,l]=o?[a.videoWidth,a.videoHeight]:[a.width,a.height],h=[l,u],d=[l,u,s];if(i||o){const y=dt().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(Th==null||y!==XC)&&(XC=y,Th=document.createElement("canvas").getContext("2d",{willReadFrequently:XC})),Th.canvas.width=u,Th.canvas.height=l,Th.drawImage(a,0,0,u,l),a=Th.canvas}const f=e.makeTensorInfo(h,"int32");e.texData.get(f.dataId).usage=fs.PIXELS,e.gpgpu.uploadPixelDataToTexture(e.getTexture(f.dataId),a);const m=dt().getBool("WEBGL_PACK")?new vNt(d):new gNt(d),v=e.runWebGLProgram(m,[f],"int32");return e.disposeData(f.dataId),v}function xNt(n){const{inputs:t,backend:e,attrs:r}=n,{x:a,filter:s,bias:o,preluActivationWeights:i}=t,{strides:u,pad:l,dataFormat:h,dilations:d,dimRoundingMode:f,activation:m,leakyreluAlpha:v}=r,y=Li(h),b=Nr(a.shape,s.shape,u,d,l,f,!1,y);let w;const S=[],N=o!=null,C=i!=null,T=m==="leakyrelu",I=()=>{const $=[a,s],R=(D,A)=>{if(A==="NCHW"&&D.shape.length===1&&D.shape[0]!==1){const L=Bt({inputs:{x:D},backend:e,attrs:{shape:[D.shape[0],1,1]}});return S.push(L),L}return D};if(N&&$.push(R(o,h)),C&&$.push(R(i,h)),T){const D=e.makeTensorInfo([],"float32",Fi(v,"float32"));$.push(D),S.push(D)}return $};if(b.filterHeight===1&&b.filterWidth===1&&b.dilationHeight===1&&b.dilationWidth===1&&b.strideHeight===1&&b.strideWidth===1&&(b.padInfo.type==="SAME"||b.padInfo.type==="VALID"))w=YG({x:a,filter:s,convInfo:b,backend:e,bias:o,activation:m,preluActivationWeights:i,leakyreluAlpha:v});else if(b.strideWidth<=2&&y==="channelsLast"&&dt().getBool("WEBGL_EXP_CONV")){const $=m?gm(m,!0):null,R=new XG(b,N,$,C,T),D=[[b.padInfo.top,b.padInfo.left],[b.strideHeight,b.strideWidth],[b.dilationHeight,b.dilationWidth],[b.inHeight,b.inWidth]],A=I();w=e.runWebGLProgram(R,A,"float32",D)}else if(dt().getBool("WEBGL_CONV_IM2COL"))w=QG({x:a,filter:s,convInfo:b,backend:e,bias:o,activation:m,preluActivationWeights:i,leakyreluAlpha:v});else{const $=m?gm(m,!1):null,R=new KG(b,N,$,C,T),D=I();w=e.runWebGLProgram(R,D,"float32")}const _=Bt({inputs:{x:w},backend:e,attrs:{shape:b.outShape}});return S.push(w),S.forEach($=>e.disposeIntermediateTensorInfo($)),_}const wNt={kernelName:qf,backendName:"webgl",kernelFunc:xNt};function SNt(n){const{inputs:t,backend:e,attrs:r}=n,{x:a,filter:s,bias:o,preluActivationWeights:i}=t,{strides:u,pad:l,dilations:h,dimRoundingMode:d,activation:f,leakyreluAlpha:m}=r,v=[];let y=h;y==null&&(y=[1,1]),P(zr(u,y),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${u} and dilations '${y}'`);const b=Nr(a.shape,s.shape,u,y,l,d,!0),w=dt().getBool("WEBGL_PACK_DEPTHWISECONV")&&b.strideWidth<=2&&b.outChannels/b.inChannels===1,S=f?gm(f,w):null,N=[a,s],C=o!=null,T=i!=null,I=f==="leakyrelu";if(C&&N.push(o),T&&N.push(i),I){const D=e.makeTensorInfo([],"float32",Fi(m,"float32"));N.push(D),v.push(D)}let _;w?_=new tH(b,C,S,T,I):_=new JG(b,C,S,T,I);const $=[[b.padInfo.top,b.padInfo.left],[b.strideHeight,b.strideWidth],[b.dilationHeight,b.dilationWidth],[b.inHeight,b.inWidth]],R=e.runWebGLProgram(_,N,"float32",$);return v.forEach(D=>e.disposeIntermediateTensorInfo(D)),R}const CNt={kernelName:Kf,backendName:"webgl",kernelFunc:SNt};class NNt{constructor(t,e,r,a){this.sliceDim=t,this.strides=e,this.paramsShape=a,this.variableNames=["x","indices"],this.outputShape=r;const s=sn(r.length);let o=`
    int index;`;for(let i=0;i<this.sliceDim;i++)o+=`
          index = round(getIndices(coords[0], ${i}));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[i]};
          flattenIndex += index * ${this.strides[i]};`;this.userCode=`
         void main() {
          ${s} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          ${o}

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `}}function kNt(n){const{inputs:t,backend:e}=n,{params:r,indices:a}=t,s=a.shape,o=s[s.length-1],i=xt(r.shape),[u,l,h,d]=T1(r,a),f=Bt({inputs:{x:a},backend:e,attrs:{shape:[l,o]}}),m=Bt({inputs:{x:r},backend:e,attrs:{shape:[xt(r.shape)/h,h]}});if(e.shouldExecuteOnCPU([r,a])||r.dtype==="string"){const w=e.readSync(a.dataId),S=e.bufferSync(r),N=_1t(w,S,r.dtype,l,o,h,d,r.shape,i);return e.makeTensorInfo(u,r.dtype,N.values)}const v=new NNt(o,d,[l,h],r.shape),y=e.runWebGLProgram(v,[m,f],m.dtype),b=Bt({inputs:{x:y},backend:e,attrs:{shape:u}});return e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(y),b}const TNt={kernelName:ax,backendName:"webgl",kernelFunc:kNt};class ENt{constructor(t,e){this.variableNames=["A","indices"],this.outputShape=e,this.rank=e.length;const r=sn(this.rank),a=INt(t);this.userCode=`
      void main() {
        ${r} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${t[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${a}));
      }
    `}}function INt(n,t){const e=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let a=0;a<n.length;a++)a===2?r.push("index"):r.push(`${e[a]}`);return r.join()}function rH(n){const{inputs:t,backend:e,attrs:r}=n,{x:a,indices:s}=t,{axis:o,batchDims:i}=r,u=_e(o,a.shape)[0];if(dt().get("DEBUG")){const S=e.readSync(s.dataId),N=a.shape[u];for(let C=0;C<S.length;++C){const T=S[C];P(T<=N-1&&T>=0,()=>`GatherV2: the index value ${T} is not in [0, ${N-1}]`)}}const l=IE(a,s,u,i),h=xt(s.shape),d=[],f=Bt({inputs:{x:a},backend:e,attrs:{shape:[l.batchSize,l.outerSize,l.dimSize,l.sliceSize]}}),m=Bt({inputs:{x:s},backend:e,attrs:{shape:[l.batchSize,h/l.batchSize]}});d.push(f),d.push(m);const v=[l.batchSize,l.outerSize,h/l.batchSize,l.sliceSize];if(e.shouldExecuteOnCPU([a,s])||a.dtype==="string"){const S=e.bufferSync(m),N=e.bufferSync(f),C=R1t(N,S,v);return d.forEach(T=>e.disposeIntermediateTensorInfo(T)),e.makeTensorInfo(l.outputShape,C.dtype,C.values)}const y=new ENt(f.shape,v),b=e.runWebGLProgram(y,[f,m],f.dtype);d.push(b);const w=Bt({inputs:{x:b},backend:e,attrs:{shape:l.outputShape}});return d.forEach(S=>e.disposeIntermediateTensorInfo(S)),w}const _Nt={kernelName:Pm,backendName:"webgl",kernelFunc:rH};const RNt="return float(a > b);",ANt=`
  return vec4(greaterThan(a, b));
`,DNt=Ur({opSnippet:RNt,packedOpSnippet:ANt,cpuKernelImpl:A1t,dtype:"bool"}),$Nt={kernelName:Vm,backendName:"webgl",kernelFunc:DNt};const ONt="return float(a >= b);",FNt=`
  return vec4(greaterThanEqual(a, b));
`,MNt=Ur({opSnippet:ONt,packedOpSnippet:FNt,dtype:"bool",cpuKernelImpl:D1t}),LNt={kernelName:Rd,backendName:"webgl",kernelFunc:MNt};function BNt(n){const{inputs:t,backend:e}=n,{input:r}=t;return nH(r,!0,e)}const zNt={kernelName:sx,backendName:"webgl",kernelFunc:BNt};const PNt="return float(!isnan(x) && !isinf(x));",VNt=Ue({opSnippet:PNt,dtype:"bool"}),UNt={kernelName:Dd,backendName:"webgl",kernelFunc:VNt};const WNt="return float(isinf(x));",GNt=Ue({opSnippet:WNt,dtype:"bool"}),HNt={kernelName:$d,backendName:"webgl",kernelFunc:GNt};const jNt="return float(isnan(x));",qNt=Ue({opSnippet:jNt,dtype:"bool"}),KNt={kernelName:Od,backendName:"webgl",kernelFunc:qNt};const XNt="return float(a < b);",YNt=`
  return vec4(lessThan(a, b));
`,QNt=Ur({opSnippet:XNt,packedOpSnippet:YNt,cpuKernelImpl:$1t,dtype:"bool"}),ZNt={kernelName:Wm,backendName:"webgl",kernelFunc:QNt};const JNt="return float(a <= b);",tkt=`
  return vec4(lessThanEqual(a, b));
`,ekt=Ur({opSnippet:JNt,packedOpSnippet:tkt,cpuKernelImpl:O1t,dtype:"bool"}),nkt={kernelName:Gm,backendName:"webgl",kernelFunc:ekt};function rkt(n){const{backend:t,attrs:e}=n,{start:r,stop:a,num:s}=e,o=F1t(r,a,s);return t.makeTensorInfo([o.length],"float32",o)}const akt={kernelName:ix,backendName:"webgl",kernelFunc:rkt};const skt=Sp+`
  return x < 0.0 ? 0./0. : log(x);
`,okt=`
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`,ikt=Ue({opSnippet:skt,packedOpSnippet:okt,cpuKernelImpl:M1t}),ukt={kernelName:Fd,backendName:"webgl",kernelFunc:ikt};const lkt=Sp+`
  return log(1.0 + x);
`,ckt=Ue({opSnippet:lkt}),hkt={kernelName:Md,backendName:"webgl",kernelFunc:ckt};const dkt="return float(a >= 1.0 && b >= 1.0);",pkt=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,fkt=Ur({opSnippet:dkt,packedOpSnippet:pkt,dtype:"bool"}),mkt={kernelName:Hm,backendName:"webgl",kernelFunc:fkt};const gkt="return float(!(x >= 1.0));",vkt=Ue({opSnippet:gkt}),ykt={kernelName:jm,backendName:"webgl",kernelFunc:vkt};const bkt="return float(a >= 1.0 || b >= 1.0);",xkt=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,wkt=Ur({opSnippet:bkt,packedOpSnippet:xkt,dtype:"bool"}),Skt={kernelName:qm,backendName:"webgl",kernelFunc:wkt};class Ckt{constructor(t,e,r,a,s){this.variableNames=["x"],this.outputShape=[];const o=e,i=t[3]-1;this.outputShape=t;let u;const l=`float(${r}) + float(${a}) * sum`;s===.5?u=`inversesqrt(${l})`:s===1?u=`1.0/(${l})`:u=`exp(log(${l}) * float(-${s}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${o}; j <= ${o}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${i}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${u};
        setOutput(val);
      }
    `}}class Nkt{constructor(t,e,r,a,s){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const o=e,i=t[3]-1;this.outputShape=t;let u;const l=`float(${r}) + float(${a}) * sum`;s===.5?u=`inversesqrt(${l})`:s===1?u=`1.0/(${l})`:u=`exp(log(${l}) * float(-${s}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${o};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${o}; j <= ${o}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${i}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${u};
        setOutput(result);
      }
    `}}const kkt=n=>{const{inputs:t,backend:e,attrs:r}=n,{x:a}=t,{depthRadius:s,bias:o,alpha:i,beta:u}=r,l=dt().getBool("WEBGL_PACK_NORMALIZATION")?new Nkt(a.shape,s,o,i,u):new Ckt(a.shape,s,o,i,u);return e.runWebGLProgram(l,[a],a.dtype)},Tkt={kernelName:Km,backendName:"webgl",kernelFunc:kkt};class Ekt{constructor(t,e,r,a,s){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=t,this.depth=t[3],this.depthRadius=e,this.bias=r,this.alpha=a,this.beta=s,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${e})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${e} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${a}) * norm + float(${r});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${a})
                * float(${s})
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${s});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}}const Ikt=n=>{const{inputs:t,backend:e,attrs:r}=n,{x:a,y:s,dy:o}=t,{depthRadius:i,bias:u,alpha:l,beta:h}=r,d=new Ekt(a.shape,i,u,l,h);return e.runWebGLProgram(d,[a,s,o],a.dtype)},_kt={kernelName:ux,backendName:"webgl",kernelFunc:Ikt};function Rkt(n,t,e,r){const a=xt(t),o=xt(n.shape)/a,i=Bt({inputs:{x:n},attrs:{shape:[o,a]},backend:r}),u=$c(i,n.dtype,"max",r),l=Bt({inputs:{x:u},attrs:{shape:e},backend:r});return r.disposeIntermediateTensorInfo(i),r.disposeIntermediateTensorInfo(u),l}function aH(n){const{inputs:t,backend:e,attrs:r}=n,{x:a}=t,{reductionIndices:s,keepDims:o}=r,i=a.shape.length,u=_e(s,a.shape);let l=u;const h=An(l,i),d=h!=null,f=e.shouldExecuteOnCPU([a]);let m=a;if(d){if(f){const N=e.texData.get(m.dataId).values,C=new Array(i);for(let _=0;_<C.length;_++)C[_]=a.shape[h[_]];const T=x_(N,a.shape,a.dtype,h,C);m=e.makeTensorInfo(C,a.dtype);const I=e.texData.get(m.dataId);I.values=T}else m=iw(a,h,e);l=Un(l.length,i)}Pr("max",l,i);const[v,y]=kr(m.shape,l);let b=v;o&&(b=Vn(v,u));let w;if(f){const N=e.texData.get(m.dataId).values,C=L1t(N,xt(y),b,a.dtype);w=e.makeTensorInfo(b,a.dtype);const T=e.texData.get(w.dataId);T.values=C}else w=Rkt(m,y,b,e);return d&&e.disposeIntermediateTensorInfo(m),w}const Akt={kernelName:Xm,backendName:"webgl",kernelFunc:aH};const Dkt=w_+`
  return max(a, b);
`,$kt=`
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Dc+`
  return result;
`,Okt=Ur({opSnippet:Dkt,packedOpSnippet:$kt,cpuKernelImpl:B1t}),Fkt={kernelName:Ld,backendName:"webgl",kernelFunc:Okt};function Mkt(n){const{inputs:t,backend:e,attrs:r}=n,{x:a}=t;fv(a,"maxPool");const{filterSize:s,strides:o,pad:i,dimRoundingMode:u}=r,l=1;P(zr(o,l),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${l}'`);const h=Vs(a.shape,s,o,l,i,u);if(h.filterWidth===1&&h.filterHeight===1&&De(h.inShape,h.outShape))return Xa({inputs:{x:a},backend:e});const d=new vm(h,"max",!1);return e.runWebGLProgram(d,[a],a.dtype)}const Lkt={kernelName:Ym,backendName:"webgl",kernelFunc:Mkt};function Bkt(n){const{inputs:t,backend:e,attrs:r}=n,{x:a}=t,{filterSize:s,strides:o,pad:i,dataFormat:u,dimRoundingMode:l}=r,h=[1,1,1],d=Mi(a.shape,s,o,h,i,l,u),f=new C_(d,"max",!1);return e.runWebGLProgram(f,[a],a.dtype)}const zkt={kernelName:Qm,backendName:"webgl",kernelFunc:Bkt};class Pkt{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;const e=t.strideHeight,r=t.strideWidth,a=t.dilationHeight,s=t.effectiveFilterHeight,o=t.effectiveFilterWidth,i=s-1-t.padInfo.top,u=o-1-t.padInfo.left,l=s*o-1;this.userCode=`
      const ivec2 pads = ivec2(${i}, ${u});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${s};
          wR += ${a}) {
          float dyR = float(dyRCorner + wR) / ${e}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${o}; wC++) {
            float dyC = float(dyCCorner + wC) / ${r}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${l} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${o} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}}class Vkt{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;const e=t.strideDepth,r=t.strideHeight,a=t.strideWidth,s=t.dilationDepth,o=t.dilationHeight,i=t.dilationWidth,u=t.effectiveFilterDepth,l=t.effectiveFilterHeight,h=t.effectiveFilterWidth,d=u-1-t.padInfo.front,f=l-1-t.padInfo.top,m=h-1-t.padInfo.left,v=u*l*h-1;this.userCode=`
      const ivec3 pads = ivec3(${d}, ${f}, ${m});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${u};
           wD += ${s}) {
          float dyD = float(dyDCorner + wD) / ${e}.0;

          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${l};
              wR += ${o}) {
            float dyR = float(dyRCorner + wR) / ${r}.0;

            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${h};
                wC += ${i}) {
              float dyC = float(dyCCorner + wC) / ${a}.0;

              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${v} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${l} * ${h} +
                  wR * ${h} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}function Ukt(n){const{inputs:t,backend:e,attrs:r}=n,{dy:a,input:s}=t,o=s,{filterSize:i,strides:u,pad:l,dimRoundingMode:h}=r,d=[1,1,1],f=Mi(o.shape,i,u,d,l,h),m=new C_(f,"max",!0),v=e.runWebGLProgram(m,[o],o.dtype),y=new Vkt(f),b=e.runWebGLProgram(y,[a,v],o.dtype);return e.disposeIntermediateTensorInfo(v),b}const Wkt={kernelName:cx,backendName:"webgl",kernelFunc:Ukt};function Gkt(n){const{inputs:t,backend:e,attrs:r}=n,{dy:a,input:s,output:o}=t,i=s;fv([s,o],"maxPoolGrad");const{filterSize:u,strides:l,pad:h,dimRoundingMode:d}=r,f=Vs(i.shape,u,l,1,h,d),m=!0,v=new vm(f,"max",m),y=e.runWebGLProgram(v,[i],i.dtype),b=new Pkt(f),w=e.runWebGLProgram(b,[a,y],i.dtype);return e.disposeIntermediateTensorInfo(y),w}const Hkt={kernelName:lx,backendName:"webgl",kernelFunc:Gkt};function jkt(n,t,e,r){let a=new vm(e,"max",!1);const s=r.runWebGLProgram(a,[n],"float32");a=new vm(e,"max",!0,!0,t);const o=r.runWebGLProgram(a,[n],"float32");return[s,o]}const qkt={kernelName:hx,backendName:"webgl",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{x:r}=n,{filterSize:a,strides:s,pad:o,includeBatchInIndex:i}=t,u=e;P(r.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${r.shape.length}.`);const l=[1,1];P(zr(s,l),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${s} and dilations '${l}'`);const h=Vs(r.shape,a,s,l,o),[d,f]=jkt(r,i,h,u);return[d,f]}};function Kkt(n,t,e,r){const a=xt(t),o=xt(n.shape)/a,i=Bt({inputs:{x:n},attrs:{shape:[o,a]},backend:r}),u=$c(i,"float32","mean",r),l=Bt({inputs:{x:u},attrs:{shape:e},backend:r});return r.disposeIntermediateTensorInfo(i),r.disposeIntermediateTensorInfo(u),l}const Xkt={kernelName:Zm,backendName:"webgl",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{x:r}=n,{keepDims:a,axis:s}=t,o=e,i=r.shape.length,u=_e(s,r.shape);let l=u;const h=An(l,i),d=h!=null,f=o.shouldExecuteOnCPU([r]),m=[];let v=r;if(d){if(f){const C=o.texData.get(v.dataId).values,T=new Array(i);for(let $=0;$<T.length;$++)T[$]=r.shape[h[$]];const I=x_(C,r.shape,r.dtype,h,T);v=o.makeTensorInfo(T,r.dtype);const _=o.texData.get(v.dataId);_.values=I}else v=iw(r,h,o);m.push(v),l=Un(l.length,i)}Pr("sum",l,i);const[y,b]=kr(v.shape,l);let w=y;a&&(w=Vn(y,u));const S=Kkt(v,b,w,o);for(const N of m)o.disposeIntermediateTensorInfo(N);return S}};function Ykt(n){const{inputs:t,backend:e,attrs:r}=n,{x:a}=t,{axis:s,keepDims:o}=r,i=a.shape.length,u=_e(s,a.shape);let l=u;const h=An(l,i);let d=a;h!=null&&(d=fa({inputs:{x:a},backend:e,attrs:{perm:h}}),l=Un(l.length,a.shape.length)),Pr("min",l,i);const[f,m]=kr(d.shape,l),v=xt(m),y=Bt({inputs:{x:d},backend:e,attrs:{shape:[-1,v]}}),b=$c(y,y.dtype,"min",e);let w;if(o){const S=Vn(f,u);w=Bt({inputs:{x:b},backend:e,attrs:{shape:S}})}else w=Bt({inputs:{x:b},backend:e,attrs:{shape:f}});return e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(b),h!=null&&e.disposeIntermediateTensorInfo(d),w}const Qkt={kernelName:Jm,backendName:"webgl",kernelFunc:Ykt};const Zkt=w_+`
  return min(a, b);
`,Jkt=`
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Dc+`
  return result;
`,tTt=Ur({opSnippet:Zkt,packedOpSnippet:Jkt,cpuKernelImpl:z1t}),eTt={kernelName:Bd,backendName:"webgl",kernelFunc:tTt};class nTt{constructor(t,e,r){this.variableNames=["x"],this.outputShape=e.map((h,d)=>h[0]+t[d]+h[1]);const a=t.length,s=sn(a),o=e.map(h=>h[0]).join(","),i=e.map((h,d)=>h[0]+t[d]).join(","),u=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,a),l=r==="reflect"?0:1;if(a===1){this.userCode=`
        int start = ${o};
        int end = ${i};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${l};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${l};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${s} start = ${s}(${o});
      ${s} end = ${s}(${i});

      void main() {
        ${s} outC = getOutputCoords();
        for (int i = 0; i < ${a}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${l};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${l};
          }
        }
        ${s} coords = outC - start;
        setOutput(getX(${u}));
      }
    `}}class rTt{constructor(t,e,r){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e.map((v,y)=>v[0]+t[y]+v[1]);const a=t.length,s=sn(a),o=e.map(v=>v[0]).join(","),i=e.map((v,y)=>v[0]+t[y]).join(","),u=ca("rc",a),l=ca("source",a),h=`${u[a-1]} < ${this.outputShape[a-1]}`,d=a===1?"source":`vec2(${l.slice(-2).join()})`,f=r==="reflect"?0:1;let m="";if(a===1){const v=`
        ${s} source = rc;
        if (source < start) {
          source = start * 2 - source - ${f};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${f};
        }
        source -= start;
      `;m=`
        ${s} rc = outputLoc;
        ${v}
        result[0] = getChannel(getX(${l.join()}), ${d});
        ${u[a-1]} += 1;
        if(${h}) {
          ${v}
          result[1] = getChannel(getX(${l.join()}), ${d});
        }
      `}else{const v=`
        ${s} source = rc;
        ${s} lt = ${s}(lessThan(source, start));
        ${s} gte = ${s}(greaterThanEqual(source, end));
        ${s} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${f}) +
                gte * ((end - 1) * 2 - source + ${f});
        source -= start;
      `;m=`
        ${s} rc = outputLoc;
        ${v}
        result[0] = getChannel(getX(${l.join()}), ${d});
        ${u[a-1]} += 1;
        if(${h}) {
          ${v}
          result[1] = getChannel(getX(${l.join()}), ${d});
        }
        rc = outputLoc;
        ${u[a-2]} += 1;
        if(${u[a-2]} < ${this.outputShape[a-2]}) {
          ${v}
          result[2] = getChannel(getX(${l.join()}), ${d});
          ${u[a-1]} += 1;
          if(${h}) {
            ${v}
            result[3] = getChannel(getX(${l.join()}), ${d});
          }
        }
      `}this.userCode=`
      const ${s} start = ${s}(${o});
      const ${s} end = ${s}(${i});

      void main() {
        ${s} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${m}
        setOutput(result);
      }
    `}}const aTt=({inputs:n,backend:t,attrs:e})=>{const{x:r}=n,{paddings:a,mode:s}=e,o=dt().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new rTt(r.shape,a,s):new nTt(r.shape,a,s);return t.runWebGLProgram(o,[r],r.dtype)},sTt={kernelName:tg,backendName:"webgl",kernelFunc:aTt};const oTt=`if (b == 0.0) return NAN;
  return mod(a, b);`,iTt=`
  vec4 result = mod(a, b);
  bvec4 isNaN = equal(b, vec4(0.0));
  `+Dc+`
  return result;
`,uTt=Ur({opSnippet:oTt,packedOpSnippet:iTt}),lTt={kernelName:zd,backendName:"webgl",kernelFunc:uTt};class cTt{constructor(t,e,r){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[t,r],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${e-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${e-1}));
      }
    `}}const hTt=`
if (a == b) {
  return 1.0;
};
return a / b;`,dTt=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,sH=Ur({opSnippet:hTt,packedOpSnippet:dTt,checkOutOfBounds:!0}),pTt={kernelName:Cd,backendName:"webgl",kernelFunc:sH};const xM="return a - b;",oH=Ur({opSnippet:xM,packedOpSnippet:xM,supportsComplex:!0,cpuKernelImpl:owt}),fTt={kernelName:ep,backendName:"webgl",kernelFunc:oH};function iH(n){const{inputs:t,backend:e,attrs:r}=n,{logits:a}=t,{dim:s}=r,o=_e([s],a.shape),i=aH({inputs:{x:a},backend:e,attrs:{reductionIndices:o,keepDims:!1}}),u=Vn(i.shape,o),l=Bt({inputs:{x:i},backend:e,attrs:{shape:u}}),h=oH({inputs:{a,b:l},backend:e}),d=eH({inputs:{x:h},backend:e}),f=uw({inputs:{x:d},backend:e,attrs:{axis:o,keepDims:!1}}),m=Bt({inputs:{x:f},backend:e,attrs:{shape:u}}),v=sH({inputs:{a:d,b:m},backend:e});return e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(l),e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(m),v}const mTt={kernelName:yg,backendName:"webgl",kernelFunc:iH};function gTt(n){const{inputs:t,backend:e,attrs:r}=n,{logits:a}=t,{numSamples:s,seed:o,normalized:i}=r,u=i?a:iH({inputs:{logits:a},backend:e,attrs:{dim:a.shape.length-1}}),l=u.shape[0],h=u.shape[1],d=new cTt(l,h,s),f=[[o]],m=e.runWebGLProgram(d,[u],"int32",f);return i||e.disposeIntermediateTensorInfo(u),m}const vTt={kernelName:dx,backendName:"webgl",kernelFunc:gTt};const yTt=Gs+`
  return -x;
`,bTt=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;function xTt(n){const{inputs:t,backend:e}=n,{x:r}=t;if(e.shouldExecuteOnCPU([r])){const s=e.texData.get(r.dataId),[o,i]=V1t(s.values,r.shape,r.dtype);return e.makeTensorInfo(i,r.dtype,o)}let a;return dt().getBool("WEBGL_PACK_UNARY_OPERATIONS")?a=new Tu(r.shape,bTt):a=new Do(r.shape,yTt),e.runWebGLProgram(a,[r],r.dtype)}const wTt={kernelName:eg,backendName:"webgl",kernelFunc:xTt};const STt=S1;function CTt(n){is("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:e,attrs:r}=n,{boxes:a,scores:s}=t,{maxOutputSize:o,iouThreshold:i,scoreThreshold:u}=r,l=e.readSync(a.dataId),h=e.readSync(s.dataId),{selectedIndices:d}=STt(l,h,o,i,u);return e.makeTensorInfo([d.length],"int32",new Int32Array(d))}const NTt={kernelName:px,backendName:"webgl",kernelFunc:CTt};const kTt=C1;function TTt(n){is("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:e,attrs:r}=n,{boxes:a,scores:s}=t,{maxOutputSize:o,iouThreshold:i,scoreThreshold:u,padToMaxOutputSize:l}=r,h=e.readSync(a.dataId),d=e.readSync(s.dataId),{selectedIndices:f,validOutputs:m}=kTt(h,d,o,i,u,l);return[e.makeTensorInfo([f.length],"int32",new Int32Array(f)),e.makeTensorInfo([],"int32",new Int32Array([m]))]}const ETt={kernelName:fx,backendName:"webgl",kernelFunc:TTt};const ITt=N1;function _Tt(n){is("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:e,attrs:r}=n,{boxes:a,scores:s}=t,{maxOutputSize:o,iouThreshold:i,scoreThreshold:u,softNmsSigma:l}=r,h=e.readSync(a.dataId),d=e.readSync(s.dataId),f=o,m=i,v=u,y=l,{selectedIndices:b,selectedScores:w}=ITt(h,d,f,m,v,y);return[e.makeTensorInfo([b.length],"int32",new Int32Array(b)),e.makeTensorInfo([w.length],"float32",new Float32Array(w))]}const RTt={kernelName:mx,backendName:"webgl",kernelFunc:_Tt};class ATt{constructor(t,e,r,a){this.variableNames=["indices"],this.outputShape=[t,e],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${a}), float(${r}),
                      float(index == coords.y)));
      }
    `}}const DTt=n=>{const{inputs:t,backend:e,attrs:r}=n,{indices:a}=t,{dtype:s,depth:o,onValue:i,offValue:u}=r,l=xt(a.shape),h=new ATt(l,o,i,u),d=Bt({inputs:{x:a},backend:e,attrs:{shape:[l]}}),f=e.runWebGLProgram(h,[d],s);e.disposeIntermediateTensorInfo(d);const m=[...a.shape,o],v=Bt({inputs:{x:f},backend:e,attrs:{shape:m}});return e.disposeIntermediateTensorInfo(f),v},$Tt={kernelName:ag,backendName:"webgl",kernelFunc:DTt};function Ab(n){const{inputs:t,backend:e}=n,{x:r}=t;if(r.dtype==="complex64"){const a=gv({inputs:{input:r},backend:e}),s=Ab({inputs:{x:a},backend:e}),o=lw({inputs:{input:r},backend:e}),i=Ab({inputs:{x:o},backend:e}),u=ul({inputs:{real:s,imag:i},backend:e});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(i),u}else return vv({attrs:{shape:r.shape,dtype:r.dtype,value:r.dtype==="string"?"":0},backend:e})}const OTt={kernelName:Sg,backendName:"webgl",kernelFunc:Ab};function uH(n){const{inputs:t,backend:e}=n,{x:r}=t;if(r.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(r.dtype==="complex64"){const a=gv({inputs:{input:r},backend:e}),s=uH({inputs:{x:a},backend:e}),o=lw({inputs:{input:r},backend:e}),i=Ab({inputs:{x:o},backend:e}),u=ul({inputs:{real:s,imag:i},backend:e});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(i),u}else return vv({attrs:{shape:r.shape,dtype:r.dtype,value:1},backend:e})}const FTt={kernelName:rg,backendName:"webgl",kernelFunc:uH};function MTt(n){const{inputs:t,backend:e,attrs:r}=n,{axis:a}=r;if(t.length===1)return bk({inputs:{input:t[0]},backend:e,attrs:{dim:a}});const s=t[0].shape,o=t[0].dtype;t.forEach(h=>{Br(s,h.shape,"All tensors passed to stack must have matching shapes"),P(o===h.dtype,()=>"All tensors passed to stack must have matching dtypes")});const i=[],u=t.map(h=>{const d=bk({inputs:{input:h},backend:e,attrs:{dim:a}});return i.push(d),d}),l=qG({inputs:u,backend:e,attrs:{axis:a}});return i.forEach(h=>e.disposeIntermediateTensorInfo(h)),l}const LTt={kernelName:sg,backendName:"webgl",kernelFunc:MTt};class BTt{constructor(t,e,r){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=e.map((l,h)=>l[0]+t[h]+l[1]);const a=t.length,s=sn(a),o=e.map(l=>l[0]).join(","),i=e.map((l,h)=>l[0]+t[h]).join(","),u=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,a);if(a===1){this.userCode=`
        int start = ${o};
        int end = ${i};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${s} start = ${s}(${o});
      ${s} end = ${s}(${i});

      void main() {
        ${s} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${s} coords = outC - start;
          setOutput(getX(${u}));
        }
      }
    `}}class zTt{constructor(t,e,r){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=e.map((y,b)=>y[0]+t[b]+y[1]);const a=t.length,s=sn(a),o=e.map(y=>y[0]).join(","),i=e.map((y,b)=>y[0]+t[b]).join(","),u=ca("rc",a),l=ca("source",a),h=`${u[a-1]} < ${this.outputShape[a-1]}`,d=a===1?"source":`vec2(${l.slice(-2).join()})`,f=[`${s} rc = outputLoc;`,`${u[a-1]} += 1;
       if(${h}) {
      `,a===1?"":`}
       rc = outputLoc;
       ${u[a-2]} += 1;
       if(${u[a-2]} < ${this.outputShape[a-2]}) {`,a===1?"":`  ${u[a-1]} += 1;
         if(${h}) {`],m=a===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let v="";for(let y=0,b=a===1?2:4;y<b;y++)v+=`
        ${f[y]}
        if (${m}) {
          result[${y}] = float(value);
        } else {
          ${s} source = rc - start;
          result[${y}] = getChannel(getX(${l.join()}), ${d});
        }
      `;v+=a===1?"} ":"}}",this.userCode=`
      const ${s} start = ${s}(${o});
      const ${s} end = ${s}(${i});

      void main() {
        ${s} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${v}
        setOutput(result);
      }
    `}}const lH=n=>{const{inputs:t,backend:e,attrs:r}=n,{x:a}=t,{paddings:s,constantValue:o}=r;if(xt(a.shape)===0){const l=s.map((h,d)=>h[0]+a.shape[d]+h[1]);return vv({backend:e,attrs:{shape:l,value:o,dtype:a.dtype}})}const i=dt().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new zTt(a.shape,s,o):new BTt(a.shape,s,o),u=[[o]];return e.runWebGLProgram(i,[a],a.dtype,u)},PTt={kernelName:og,backendName:"webgl",kernelFunc:lH};const VTt=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,UTt=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  `+Dc+`
  return result;
`,WTt=Ur({opSnippet:VTt,packedOpSnippet:UTt}),GTt={kernelName:Vd,backendName:"webgl",kernelFunc:WTt};function HTt(n){const{inputs:t,backend:e,attrs:r}=n,{x:a}=t,{axis:s,keepDims:o}=r,i=a.shape.length,u=[],l=_e(s,a.shape);let h=l;const d=An(h,i);let f=a;d!=null&&(f=fa({inputs:{x:a},backend:e,attrs:{perm:d}}),h=Un(h.length,i),u.push(f)),Pr("prod",h,i);let m;if(e.shouldExecuteOnCPU([f])){const v=e.texData.get(f.dataId).values,{outVals:y,outShape:b,outDtype:w}=W1t(f.shape,f.dtype,v,h);m=e.makeTensorInfo(b,w,y)}else{const[v,y]=kr(f.shape,h),b=xt(y),w=Bt({inputs:{x:f},backend:e,attrs:{shape:[-1,b]}}),S=Vx(a.dtype),N=$c(w,S,"prod",e);m=Bt({inputs:{x:N},backend:e,attrs:{shape:v}}),u.push(w),u.push(N)}if(o){u.push(m);const v=Vn(m.shape,l);m=Bt({inputs:{x:m},backend:e,attrs:{shape:v}})}return u.forEach(v=>e.disposeIntermediateTensorInfo(v)),m}const jTt={kernelName:ug,backendName:"webgl",kernelFunc:HTt};function qTt(n){const{inputs:t,backend:e,attrs:r}=n,{paramsNestedSplits:a,paramsDenseValues:s,indices:o}=t,{outputRaggedRank:i}=r,u=a.map(w=>e.readSync(w.dataId)),l=a.map(w=>w.shape),h=e.readSync(s.dataId),d=e.readSync(o.dataId),[f,m,v]=G1t(u,l,h,s.shape,s.dtype,d,o.shape,i),y=f.map(w=>e.makeTensorInfo([w.length],"int32",w)),b=e.makeTensorInfo(v,s.dtype,m);return y.concat([b])}const KTt={kernelName:gx,backendName:"webgl",kernelFunc:qTt};function XTt(n){const{inputs:t,backend:e}=n,{starts:r,limits:a,deltas:s}=t,o=e.readSync(r.dataId),i=e.readSync(a.dataId),u=e.readSync(s.dataId),[l,h]=H1t(o,r.shape,r.dtype,i,a.shape,u,s.shape),d=e.makeTensorInfo([l.length],"int32",l),f=e.makeTensorInfo([h.length],r.dtype,h);return[d,f]}const YTt={kernelName:vx,backendName:"webgl",kernelFunc:XTt};function QTt(n){const{inputs:t,backend:e,attrs:r}=n,{shape:a,values:s,defaultValue:o,rowPartitionTensors:i}=t,{rowPartitionTypes:u}=r,l=e.readSync(a.dataId),h=e.readSync(s.dataId),d=e.readSync(o.dataId),f=i.map(b=>e.readSync(b.dataId)),m=i.map(b=>b.shape),[v,y]=j1t(l,a.shape,h,s.shape,s.dtype,d,o.shape,f,m,u);return e.makeTensorInfo(v,s.dtype,y)}const ZTt={kernelName:yx,backendName:"webgl",kernelFunc:QTt};const cH=n=>{const{backend:t,attrs:e}=n,{start:r,stop:a,step:s,dtype:o}=e,i=q1t(r,a,s,o);return t.makeTensorInfo([i.length],o,i)},JTt={kernelName:bx,backendName:"webgl",kernelFunc:cH};const tEt="return 1.0 / x;",eEt=Ue({opSnippet:tEt}),nEt={kernelName:Ud,backendName:"webgl",kernelFunc:eEt};const rEt=Gs+`
  return (x < 0.0) ? 0.0 : x;
`,aEt=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,sEt=Ue({opSnippet:rEt,packedOpSnippet:aEt}),oEt={kernelName:Wd,backendName:"webgl",kernelFunc:sEt};const iEt=Gs+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,uEt=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,lEt=Ue({opSnippet:iEt,packedOpSnippet:uEt}),cEt={kernelName:Gd,backendName:"webgl",kernelFunc:lEt};class hEt{constructor(t,e,r,a,s){this.variableNames=["A"],this.outputShape=[];const[o,i,u,l]=t;this.outputShape=[o,e,r,l];const h=[a&&e>1?i-1:i,a&&r>1?u-1:u],d=[a&&e>1?e-1:e,a&&r>1?r-1:r];let f;s?f="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":f="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${h[0]/d[0]},
          ${h[1]/d[1]});
      const vec2 inputShapeRC = vec2(${i}.0, ${u}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${f};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}}class dEt{constructor(t,e,r,a,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[o,i,u,l]=t;this.outputShape=[o,e,r,l];const h=[a&&e>1?i-1:i,a&&r>1?u-1:u],d=[a&&e>1?e-1:e,a&&r>1?r-1:r];let f;s?f="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":f="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${h[0]/d[0]},
          ${h[1]/d[1]},
          ${h[1]/d[1]});
      const vec3 inputShapeRC = vec3(${i}.0, ${u}.0,
                                     ${u}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${f};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${l-1};
        bool hasNextRow = coords.z < ${r-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}}function pEt(n){const{inputs:t,backend:e,attrs:r}=n,{images:a}=t,{alignCorners:s,halfPixelCenters:o,size:i}=r,[u,l]=i,h=dt().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new dEt(a.shape,u,l,s,o):new hEt(a.shape,u,l,s,o);return e.runWebGLProgram(h,[a],"float32")}const fEt={kernelName:hg,backendName:"webgl",kernelFunc:pEt};class mEt{constructor(t,e,r){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e;const[,a,s]=e,[,o,i]=t,u=[r&&o>1?a-1:a,r&&i>1?s-1:s],l=[r&&o>1?o-1:o,r&&i>1?i-1:i],h=u[0]/l[0],d=u[1]/l[1],f=1/h,m=1/d,v=Math.ceil(f)*2+2,y=Math.ceil(m)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${h});
        const float widthScale = float(${d});

        const float invHeightScale = float(${f});
        const float invWidthScale = float(${m});

        const int winHeight = int(${v});
        const int winWidth = int(${y});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${o}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${i}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${a-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${s-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}function gEt(n){const{inputs:t,backend:e,attrs:r}=n,{images:a,dy:s}=t,{alignCorners:o}=r,i=new mEt(s.shape,a.shape,o);return e.runWebGLProgram(i,[s],s.dtype)}const vEt={kernelName:Sx,backendName:"webgl",kernelFunc:gEt};class yEt{constructor(t,e,r,a,s){this.variableNames=["A"],this.outputShape=[];const[o,i,u,l]=t;this.outputShape=[o,e,r,l];const h=[a&&e>1?i-1:i,a&&r>1?u-1:u],d=[a&&e>1?e-1:e,a&&r>1?r-1:r],f=a?"0.5":"0.0";let m;s?m="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":m="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${h[0]/d[0]},
          ${h[1]/d[1]});
      const vec2 inputShapeRC = vec2(${i}.0, ${u}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${m};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${f})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}}class bEt{constructor(t,e,r,a,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[o,i,u,l]=t;this.outputShape=[o,e,r,l];const h=[a&&e>1?i-1:i,a&&r>1?u-1:u],d=[a&&e>1?e-1:e,a&&r>1?r-1:r],f=a?"0.5":"0.0";let m;s?m="max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":m="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${h[0]/d[0]},
          ${h[1]/d[1]},
          ${h[1]/d[1]});
      const vec3 inputShapeRC = vec3(${i}.0, ${u}.0,
                                     ${u}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${m};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${f})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${l-1};
        bool hasNextRow = coords.z < ${r-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}}function xEt(n){const{inputs:t,backend:e,attrs:r}=n,{images:a}=t,{alignCorners:s,halfPixelCenters:o,size:i}=r,[u,l]=i,h=dt().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new bEt(a.shape,u,l,s,o):new yEt(a.shape,u,l,s,o);return e.runWebGLProgram(h,[a],a.dtype)}const wEt={kernelName:cg,backendName:"webgl",kernelFunc:xEt};class SEt{constructor(t,e,r){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e;const[,a,s]=e,[,o,i]=t,u=[r&&o>1?a-1:a,r&&i>1?s-1:s],l=[r&&o>1?o-1:o,r&&i>1?i-1:i],h=u[0]/l[0],d=u[1]/l[1],f=1/h,m=1/d,v=Math.ceil(f)*2+2,y=Math.ceil(m)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${h});
        const float widthScale = float(${d});

        const float invHeightScale = float(${f});
        const float invWidthScale = float(${m});

        const int winHeight = int(${v});
        const int winWidth = int(${y});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${o}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${i}) {
              continue;
            }

            float sourceFracRow =
              float(${u[0]}) *
                (float(dyR) / float(${l[0]}));

            float sourceFracCol =
                float(${u[1]}) *
                  (float(dyC) / float(${l[1]}));

            int sourceNearestRow = int(min(
                float(int(${a}) - 1),
                ${r} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${s}) - 1),
                ${r} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}function CEt(n){const{inputs:t,backend:e,attrs:r}=n,{images:a,dy:s}=t,{alignCorners:o}=r,i=new SEt(s.shape,a.shape,o);return e.runWebGLProgram(i,[s],s.dtype)}const NEt={kernelName:wx,backendName:"webgl",kernelFunc:CEt};class kEt{constructor(t,e){this.variableNames=["x"];const r=t.length;if(r>4)throw new Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);if(this.outputShape=t,r===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${t[0]} - coord - 1));
        }
      `;return}const a=i=>e.indexOf(i)!==-1&&t[i]!==1?`${t[i]} - coords[${i}] - 1`:`coords[${i}]`,s=t.map((i,u)=>a(u)).join(","),o=sn(r);this.userCode=`
      void main() {
        ${o} coords = getOutputCoords();
        setOutput(getX(${s}));
      }
    `}}class TEt{constructor(t,e){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const r=t.length;if(r>4)throw new Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);this.outputShape=t;const a=ca("rc",r),s=`${a[r-1]} + 1 < ${this.outputShape[r-1]}`,o=`${a[r-2]} + 1 < ${this.outputShape[r-2]}`,i=sn(r);r===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${t[0]} - rc - 1),
            ${t[0]} - rc - 1);
          if(${s}){
              result.g = getChannel(getX(${t[0]} - (rc  + 1) - 1),
                ${t[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${i} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${u(a.slice())};
          if(${s}){
            result.g = ${l(a.slice())};
          }
          if(${o}) {
            result.b = ${h(a.slice())};
            if(${s}) {
              result.a = ${d(a.slice())};
            }
          }
          setOutput(result);
        }
    `;function u(v){return f(v)}function l(v){return v[r-1]="("+v[r-1]+" + 1)",f(v)}function h(v){return v[r-2]="("+v[r-2]+" + 1)",f(v)}function d(v){return v[r-1]="("+v[r-1]+" + 1)",v[r-2]="("+v[r-2]+" + 1)",f(v)}function f(v){const y=t.map((S,N)=>m(N,v)),b=y.join(","),w=y.slice(-2).join(",");return`getChannel(getX(${b}), vec2(${w}))`}function m(v,y){return e.indexOf(v)!==-1&&t[v]!==1?`${t[v]} - ${y[v]} - 1`:`${y[v]}`}}}function EEt(n){const{inputs:t,backend:e,attrs:r}=n,{x:a}=t,{dims:s}=r,o=a.shape.length,i=_e(s,a.shape);if(o===0)return Xa({inputs:{x:a},backend:e});const u=dt().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new TEt(a.shape,i):new kEt(a.shape,i);return e.runWebGLProgram(u,[a],a.dtype)}const IEt={kernelName:dg,backendName:"webgl",kernelFunc:EEt};class _Et{constructor(t,e){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const r=t[1],a=t[2];this.outputShape=t;let s="";typeof e=="number"?s=`float outputValue = ${e.toFixed(2)};`:s=`
        vec3 fill = vec3(${e.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${s}
          if(coordX >= 0 && coordX < ${a} && coordY >= 0 && coordY < ${r}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}}const REt={kernelName:zx,backendName:"webgl",kernelFunc:({inputs:n,attrs:t,backend:e})=>{const{image:r}=n,{radians:a,fillValue:s,center:o}=t,i=e,u=new _Et(r.shape,s),[l,h]=dE(o,r.shape[1],r.shape[2]),d=[[l,h,Math.sin(a),Math.cos(a)]];return i.runWebGLProgram(u,[r],r.dtype,d)}};const AEt=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,DEt=Ue({opSnippet:AEt}),$Et={kernelName:Hd,backendName:"webgl",kernelFunc:DEt};const OEt="return inversesqrt(x);",FEt=Ue({opSnippet:OEt,cpuKernelImpl:K1t}),MEt={kernelName:jd,backendName:"webgl",kernelFunc:FEt};class N_{constructor(t,e,r,a,s,o,i=!0,u=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=o;const l=sn(s.length),h=sn(o.length);let d="";r===1?d="i":r===2&&(d="i, j");const f=`getIndices(${d})`;let m="";a===1?m="i":a===2&&(m="i, coords[1]");const v=`getUpdates(${m})`;let y="";u&&(y="coords[0], coords[1]");const b=`getDefaultValue(${y})`,w=e>1?"strides[j]":"strides";this.userCode=`
        ${l} strides = ${l}(${s});

        void main() {
          ${h} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${t}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${e}; j++) {
              int index = round(${f});
              flattenedIndex += index * ${w};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${v};
              found = true;
            }
          }
          setOutput(mix(${b}, sum, float(found)));
        }
      `}}class LEt{constructor(t,e,r,a,s,o,i=!0,u=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=o;const l=sn(s.length),h=sn(o.length);let d="";r===1?d="i":r===2&&(d="i, j");const f=`getIndices(${d})`;let m="";a===1?m="i":a===2&&(m="i, coords[1]");const v=`getUpdates(${m})`;let y="";u&&(y="coords[0], coords[1]");const b=`getDefaultValue(${y})`,w=e>1?"strides[j]":"strides",S=e>1?"strides[j + 1]":"strides";this.userCode=`
        ${l} strides = ${l}(${s});

        void main() {
          ${h} coords = getOutputCoords();
          vec4 sum = vec4(0.);
          vec4 found = vec4(0.);
          for (int i = 0; i < ${t}; i+=2) {
            ivec2 flattenedIndex = ivec2(0);
            for (int j = 0; j < ${e}; j+=2) {
              ivec4 index = round(${f});
              flattenedIndex += index.xz * ${w};
              if (j + 1 < ${e}) {
                flattenedIndex += index.yw * ${S};
              }
            }
            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||
                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {
              vec4 updVals = ${v};
              if (flattenedIndex[0] == coords[0]) {
                sum.xy += updVals.xy;
                found.xy = vec2(1.);
              } else if (flattenedIndex[0] == coords[0] + 1) {
                sum.zw += updVals.xy;
                found.zw = vec2(1.);
              }
              if (flattenedIndex[1] == coords[0]) {
                sum.xy += updVals.zw;
                found.xy = vec2(1.);
              } else if (flattenedIndex[1] == coords[0] + 1) {
                sum.zw += updVals.zw;
                found.zw = vec2(1.);
              }
            }
          }
          setOutput(mix(${b}, sum, found));
        }
      `}}function BEt(n){const{inputs:t,backend:e,attrs:r}=n,{indices:a,updates:s}=t,{shape:o}=r,{sliceRank:i,numUpdates:u,sliceSize:l,strides:h,outputSize:d}=nl(s,a,o),f=[d/l,l];if(d===0)return e.makeTensorInfo(o,a.dtype);const m=Bt({inputs:{x:a},backend:e,attrs:{shape:[u,i]}}),v=Bt({inputs:{x:s},backend:e,attrs:{shape:[u,l]}}),y=e.makeTensorInfo([],"float32",new Float32Array([0]));let b;dt().getBool("WEBGL_PACK")?b=new LEt(u,i,m.shape.length,v.shape.length,h,f):b=new N_(u,i,m.shape.length,v.shape.length,h,f);const w=e.runWebGLProgram(b,[v,m,y],v.dtype),S=Bt({inputs:{x:w},backend:e,attrs:{shape:o}});return e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(v),e.disposeIntermediateTensorInfo(w),e.disposeIntermediateTensorInfo(y),S}const zEt={kernelName:Cx,backendName:"webgl",kernelFunc:BEt};class PEt{constructor(t,e,r,a){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[t,r];const s="while (left < right) {",o=`for (int i = 0; i < ${Math.ceil(Math.log2(e+1))}; ++i) { if (left >= right) break;`,i=dt().getNumber("WEBGL_VERSION")===2?s:o,u=a==="left"?"<":"<=";this.userCode=`
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${i}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${u} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `}}function VEt(n){const{inputs:t,backend:e,attrs:r}=n,{sortedSequence:a,values:s}=t,{side:o}=r,i=new PEt(a.shape[0],a.shape[1],s.shape[1],o),u=[[a.shape[1]]];return e.runWebGLProgram(i,[a,s],"int32",u)}const UEt={kernelName:kx,backendName:"webgl",kernelFunc:VEt};class WEt{constructor(t,e,r){this.variableNames=["c","a","b"],this.outputShape=e;let a,s;if(r>4)throw Error(`Where for rank ${r} is not yet supported`);if(r===1)s="resRC",a="resRC";else{const i=["resRC.x","resRC.y","resRC.z","resRC.w"],u=[],l=[];for(let h=0;h<e.length;h++)l.push(`${i[h]}`),h<t&&u.push(`${i[h]}`);a=u.join(),s=l.join()}const o=sn(r);this.userCode=`
      void main() {
        ${o} resRC = getOutputCoords();
        float cVal = getC(${a});
        if (cVal >= 1.0) {
          setOutput(getA(${s}));
        } else {
          setOutput(getB(${s}));
        }
      }
    `}}function GEt(n){const{inputs:t,backend:e}=n,{condition:r,t:a,e:s}=t,o=new WEt(r.shape.length,a.shape,a.shape.length);return e.runWebGLProgram(o,[r,a,s],Sa(a.dtype,s.dtype))}const HEt={kernelName:pg,backendName:"webgl",kernelFunc:GEt};const jEt=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${_1};
  float scale = ${R1};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,qEt=Ue({opSnippet:jEt}),KEt={kernelName:qd,backendName:"webgl",kernelFunc:qEt};const XEt=Sp+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,YEt=`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,QEt=Ue({opSnippet:XEt,packedOpSnippet:YEt,cpuKernelImpl:Y1t}),ZEt={kernelName:Qd,backendName:"webgl",kernelFunc:QEt};const JEt=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,tIt=Ue({opSnippet:JEt}),eIt={kernelName:Yd,backendName:"webgl",kernelFunc:tIt};const nIt=Sp+`
  return sin(x);
`,rIt=`
  vec4 result = sin(x);
  bvec4 isNaN = isnan(x);
  ${Dc}
  return result;
`,aIt=Ue({opSnippet:nIt,packedOpSnippet:rIt}),sIt={kernelName:Kd,backendName:"webgl",kernelFunc:aIt};const oIt=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,iIt=Ue({opSnippet:oIt}),uIt={kernelName:Xd,backendName:"webgl",kernelFunc:iIt};const lIt=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,cIt=Ue({opSnippet:lIt}),hIt={kernelName:Zd,backendName:"webgl",kernelFunc:cIt};const dIt=n=>{const{inputs:t,backend:e,attrs:r}=n,{x:a}=t,{blockShape:s,paddings:o}=r;P(a.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const i=s.reduce((w,S)=>w*S),u=[[0,0]];u.push(...o);for(let w=1+s.length;w<a.shape.length;++w)u.push([0,0]);const l=[],h=lH({inputs:{x:a},backend:e,attrs:{paddings:u,constantValue:0}}),d=Gg(h.shape,s,i,!1),f=Hg(d.length,s.length,!1),m=jg(h.shape,s,i,!1),v=Bt({inputs:{x:h},backend:e,attrs:{shape:d}}),y=fa({inputs:{x:v},backend:e,attrs:{perm:f}}),b=Bt({inputs:{x:y},backend:e,attrs:{shape:m}});return l.push(h),l.push(v),l.push(y),l.forEach(w=>e.disposeIntermediateTensorInfo(w)),b},pIt={kernelName:gg,backendName:"webgl",kernelFunc:dIt};function fIt(n){const{inputs:t,backend:e}=n,{indices:r,values:a,denseShape:s,defaultValue:o}=t;if(s.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${s.shape}`);if(r.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${r.shape}`);if(a.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${a.shape}`);if(o.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${o.shape}`);const i=e.readSync(r.dataId),u=e.readSync(a.dataId),l=e.readSync(s.dataId),h=e.readSync(o.dataId)[0],[d,f,m,v,y]=Z1t(i,r.shape,r.dtype,u,a.dtype,l,h);return[e.makeTensorInfo(f,r.dtype,d),e.makeTensorInfo([f[0]],a.dtype,m),e.makeTensorInfo([v.length],"bool",new Uint8Array(v.map(b=>Number(b)))),e.makeTensorInfo([y.length],r.dtype,new Int32Array(y))]}const mIt={kernelName:Tx,backendName:"webgl",kernelFunc:fIt};function gIt(n){const{inputs:t,backend:e}=n,{inputIndices:r,inputShape:a,newShape:s}=t;if(r.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${r.shape}`);if(a.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${a.shape}`);if(s.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);const o=Array.from(e.readSync(a.dataId)),i=e.readSync(r.dataId),u=Array.from(e.readSync(s.dataId)),[l,h,d]=J1t(i,r.shape,r.dtype,o,u);return[e.makeTensorInfo(h,r.dtype,l),e.makeTensorInfo([d.length],s.dtype,new Int32Array(d))]}const vIt={kernelName:Ex,backendName:"webgl",kernelFunc:gIt};function yIt(n){const{inputs:t,backend:e}=n,{data:r,indices:a,segmentIds:s}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(a.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${a.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${s.shape}`);const o=e.readSync(r.dataId),i=e.readSync(a.dataId),u=e.readSync(s.dataId),[l,h]=OG(o,r.shape,r.dtype,i,u,!0);return e.makeTensorInfo(h,r.dtype,l)}const bIt={kernelName:Ix,backendName:"webgl",kernelFunc:yIt};function xIt(n){const{inputs:t,backend:e}=n,{data:r,indices:a,segmentIds:s}=t;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(a.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${a.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${s.shape}`);const o=e.readSync(r.dataId),i=e.readSync(a.dataId),u=e.readSync(s.dataId),[l,h]=OG(o,r.shape,r.dtype,i,u);return e.makeTensorInfo(h,r.dtype,l)}const wIt={kernelName:_x,backendName:"webgl",kernelFunc:xIt};function SIt(n){const{inputs:t,backend:e,attrs:r}=n,{sparseIndices:a,sparseValues:s,defaultValue:o}=t,{outputShape:i}=r,{sliceRank:u,numUpdates:l,sliceSize:h,strides:d,outputSize:f}=nl(s,a,i),m=!1;if(s.dtype==="string"){const w=e.bufferSync(a),S=e.bufferSync(s),N=Ii(e.readSync(o.dataId)[0]),C=X1t(w,S,i,f,h,l,u,d,N,m);return e.makeTensorInfo(i,C.dtype,C.values)}const v=new N_(l,u,a.shape.length,s.shape.length,d,[f,1],m),y=e.runWebGLProgram(v,[s,a,o],s.dtype),b=Bt({inputs:{x:y},backend:e,attrs:{shape:i}});return e.disposeIntermediateTensorInfo(y),b}const CIt={kernelName:Rx,backendName:"webgl",kernelFunc:SIt};function NIt(n){const{inputs:t,backend:e,attrs:r}=n,{x:a}=t,{numOrSizeSplits:s,axis:o}=r,i=_e(o,a.shape)[0],u=EE(a,s,i),l=a.shape.length,h=new Array(l).fill(0),d=a.shape.slice();return u.map(f=>{const m=[...d];m[i]=f;const v=Cp({inputs:{x:a},backend:e,attrs:{begin:h,size:m}});return h[i]+=f,v})}const kIt={kernelName:vg,backendName:"webgl",kernelFunc:NIt};const wM="return sqrt(x);",TIt=Ue({opSnippet:wM,packedOpSnippet:wM,cpuKernelImpl:twt}),EIt={kernelName:Jd,backendName:"webgl",kernelFunc:TIt};const IIt="return x * x;",_It=Ue({opSnippet:IIt}),RIt={kernelName:Ax,backendName:"webgl",kernelFunc:_It};const SM="return (a - b) * (a - b);",AIt=Ur({opSnippet:SM,packedOpSnippet:SM}),DIt={kernelName:tp,backendName:"webgl",kernelFunc:AIt};function $It(n){const{inputs:t,backend:e,attrs:r}=n,{x:a}=t;if(a.dtype!=="string")throw new Error("Input must be of datatype string");const s=e.readSync(a.dataId),o=$i(s),i=ewt(o,"string",r);return e.makeTensorInfo(a.shape,"string",i)}const OIt={kernelName:bg,backendName:"webgl",kernelFunc:$It};function FIt({inputs:n,attrs:t,backend:e}){const{x:r}=n,a=Gs+`
    return x > 0.0 ? 1.0 : float(${t.alpha});
  `,s=new Do(r.shape,a);return e.runWebGLProgram(s,[r],r.dtype)}const MIt={kernelName:sp,backendName:"webgl",kernelFunc:FIt};class LIt{constructor(t,e,r){this.variableNames=["x"],this.outputShape=r;const a=r.length,s=sn(r.length),o=sn(r.length);let i="";if(a===1)i="coords * strides + begin";else{let u=0;i=r.map((l,h)=>(u++,r.length===1?`coords * strides[${h}] + begin[${h}]`:`coords[${u-1}] * strides[${h}] + begin[${h}]`)).join(",")}this.userCode=`
      ${s} begin = ${s}(${t});
      ${s} strides = ${s}(${e});

      void main() {
        ${o} coords = getOutputCoords();
        setOutput(getX(${i}));
      }
    `}}function BIt(n){const{inputs:t,backend:e,attrs:r}=n,{x:a}=t,{begin:s,end:o,strides:i,beginMask:u,endMask:l,ellipsisMask:h,newAxisMask:d,shrinkAxisMask:f}=r,{finalShapeSparse:m,finalShape:v,isIdentity:y,sliceDim0:b,isSimpleSlice:w,begin:S,end:N,strides:C}=uE(a.shape,s,o,i,u,l,h,d,f);let T;if(y)T=Bt({inputs:{x:a},backend:e,attrs:{shape:v}});else if(b||w){P(a.shape.length>=1,()=>`Input must have rank at least 1, got: ${a.shape.length}`);const _=sE(S,N,C),$=Cp({inputs:{x:a},backend:e,attrs:{begin:S,size:_}});T=Bt({inputs:{x:$},backend:e,attrs:{shape:v}}),e.disposeIntermediateTensorInfo($)}else if(e.shouldExecuteOnCPU([a])){const $=e.readSync(a.dataId),R=we(a.shape,a.dtype,$),D=nwt(m,R,C,S);T=e.makeTensorInfo(v,a.dtype,D.values)}else{const $=new LIt(S,C,m);T=e.runWebGLProgram($,[a],a.dtype)}const I=Bt({inputs:{x:T},backend:e,attrs:{shape:v}});return e.disposeIntermediateTensorInfo(T),I}const zIt={kernelName:Dx,backendName:"webgl",kernelFunc:BIt};function PIt(n){const{inputs:t,backend:e,attrs:r}=n,{separator:a,nGramWidths:s,leftPad:o,rightPad:i,padWidth:u,preserveShortSequences:l}=r,{data:h,dataSplits:d}=t,f=e.readSync(h.dataId),m=e.readSync(d.dataId),[v,y]=rwt(f,m,a,s,o,i,u,l);return[e.makeTensorInfo([v.length],"string",v),e.makeTensorInfo(d.shape,"int32",y)]}const VIt={kernelName:$x,backendName:"webgl",kernelFunc:PIt};function UIt(n){const{inputs:t,backend:e,attrs:r}=n,{skipEmpty:a}=r,{input:s,delimiter:o}=t;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(s.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(o.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${o.shape}`);const i=e.readSync(s.dataId),u=e.readSync(o.dataId)[0],[l,h,d]=awt(i,u,a),f=h.length;return[e.makeTensorInfo([f,2],"int32",l),e.makeTensorInfo([f],"string",h),e.makeTensorInfo([2],"int32",new Int32Array(d))]}const WIt={kernelName:Ox,backendName:"webgl",kernelFunc:UIt};function GIt(n){const{inputs:t,backend:e,attrs:r}=n,{numBuckets:a}=r,{input:s}=t;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(a<=0)throw new Error("Number of buckets must be at least 1");const o=e.readSync(s.dataId),i=swt(o,a);return e.makeTensorInfo(s.shape,"int32",i)}const HIt={kernelName:Fx,backendName:"webgl",kernelFunc:GIt};const jIt="return tan(x);",qIt=Ue({opSnippet:jIt}),KIt={kernelName:np,backendName:"webgl",kernelFunc:qIt};const XIt=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,YIt=Ue({opSnippet:XIt}),QIt={kernelName:rp,backendName:"webgl",kernelFunc:YIt};function ZIt(n){const{inputs:t,backend:e,attrs:r}=n,{tensor:a,indices:s,updates:o}=t,{sliceRank:i,numUpdates:u,sliceSize:l,strides:h,outputSize:d}=nl(o,s,a.shape),f=[d/l,l];if(d===0)return e.makeTensorInfo(a.shape,s.dtype);const m=Bt({inputs:{x:s},backend:e,attrs:{shape:[u,i]}}),v=Bt({inputs:{x:o},backend:e,attrs:{shape:[u,l]}}),y=Bt({inputs:{x:a},backend:e,attrs:{shape:f}}),b=new N_(u,i,m.shape.length,v.shape.length,h,f,!1,!0),w=e.runWebGLProgram(b,[v,m,y],y.dtype),S=Bt({inputs:{x:w},backend:e,attrs:{shape:a.shape}});return e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(v),e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(w),S}const JIt={kernelName:Nx,backendName:"webgl",kernelFunc:ZIt};class t_t{constructor(t,e){this.variableNames=["A"];const r=new Array(t.length);for(let o=0;o<r.length;o++)r[o]=t[o]*e[o];this.outputShape=r,this.rank=r.length;const a=sn(this.rank),s=e_t(t);this.userCode=`
      void main() {
        ${a} resRC = getOutputCoords();
        setOutput(getA(${s}));
      }
    `}}function e_t(n){const t=n.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(t===1)return`imod(resRC, ${n[0]})`;const e=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let a=0;a<n.length;a++)r.push(`imod(${e[a]}, ${n[a]})`);return r.join()}function hH(n){const{inputs:t,backend:e,attrs:r}=n,{x:a}=t,{reps:s}=r;if(a.dtype==="string"||a.shape.length>5){const u=e.readSync(a.dataId),l=a.dtype==="string"?u.map(f=>Ii(f)):u,h=we(a.shape,a.dtype,l),d=iwt(h,s);return e.makeTensorInfo(d.shape,d.dtype,d.values)}const o=new t_t(a.shape,s);return e.runWebGLProgram(o,[a],a.dtype)}const n_t={kernelName:ap,backendName:"webgl",kernelFunc:hH};class r_t{constructor(t){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=t,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}}class a_t{constructor(t){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=t,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}}function Rl(n,t){t!==null&&n.disposeIntermediateTensorInfo(t)}function CM(n){let t=1;for(;t<n;)t*=2;return t}function s_t(n){const{inputs:t,backend:e,attrs:r}=n,{x:a}=t,{k:s,sorted:o}=r,i=dt().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),u=dt().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),l=a.shape,h=l[l.length-1];if(e.shouldExecuteOnCPU([a])||h<i||s>u){const D=e.readSync(a.dataId),[A,L]=uwt(D,l,a.dtype,s,o);return[e.makeTensorInfo(A.shape,A.dtype,A.values),e.makeTensorInfo(L.shape,L.dtype,L.values)]}if(s===0)return l[l.length-1]=0,[e.makeTensorInfo(l,a.dtype,[]),e.makeTensorInfo(l,"int32",[])];if(h===1)return[a,vv({attrs:{shape:l,dtype:"int32",value:0},backend:e})];const d=e.texData.get(a.dataId),f=d!==null&&d.isPacked,m=f?e.unpackTensor(a):a,y=xt(l)/h,b=Bt({inputs:{x:m},attrs:{shape:[y,h]},backend:e});f&&Rl(e,m);const w=CM(s),S=CM(h);let N=null;const C=()=>N===null?[b,b]:[b,N],T=(D,A,L)=>{const H=C(),G=new r_t(L),B=[[h],[N===null?1:0],[Number.NEGATIVE_INFINITY],[D],[A]],j=N;N=e.runWebGLProgram(G,H,"int32",B),Rl(e,j)};for(let D=1;D<w;D*=2){const A=D*2;for(let L=D;L>=1;L/=2)T(A,L,[y,S])}for(let D=S;D>w;D/=2){const A=C(),L=new a_t([y,D/2]),G=[[h],[N===null?1:0],[w]],q=N;N=e.runWebGLProgram(L,A,"int32",G),Rl(e,q);const B=w/2,j=B*2;for(let K=B;K>=1;K/=2)T(j,K,N.shape)}let I=N;N=Cp({inputs:{x:N},backend:e,attrs:{begin:0,size:[y,s]}}),Rl(e,I);let _=rH({inputs:{x:b,indices:N},backend:e,attrs:{axis:1,batchDims:1}});Rl(e,b);const $=l.slice(0,-1);$.push(s),I=N,N=Bt({inputs:{x:N},attrs:{shape:$},backend:e}),Rl(e,I);const R=_;return _=Bt({inputs:{x:_},attrs:{shape:$},backend:e}),Rl(e,R),[_,N]}const o_t={kernelName:Mx,backendName:"webgl",kernelFunc:s_t};class i_t{constructor(t,e,r,a,s,o){this.variableNames=["Image","Transforms"],this.outputShape=o;const i=r==="nearest"?1:2;let u;switch(a){case"constant":u=1;break;case"reflect":u=2;break;case"wrap":u=3;break;case"nearest":u=4;break;default:u=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${u} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${u} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${u} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${t} && 0 <= coordX && coordX < ${e}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${s});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${s});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${e}));
                float mapY = mapCoord(inY, float(${t}));

                if (${i} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}}function u_t(n){const{inputs:t,backend:e,attrs:r}=n,{image:a,transforms:s}=t,{interpolation:o,fillMode:i,fillValue:u,outputShape:l}=r,[h,d,f,m]=a.shape,[v,y]=l??[d,f],b=[h,v,y,m],w=new i_t(d,f,o,i,u,b);return e.runWebGLProgram(w,[a,s],"float32")}const l_t={kernelName:Lx,backendName:"webgl",kernelFunc:u_t};function c_t(n){const{inputs:t,attrs:e,backend:r}=n,{axis:a}=e,{x:s}=t;fv(s,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const o=r.readSync(s.dataId),{outputValues:i,outputShape:u,indices:l}=lwt(o,a,s.shape,s.dtype);return[r.makeTensorInfo(u,s.dtype,i),r.makeTensorInfo([l.length],"int32",l)]}const h_t={kernelName:Bx,backendName:"webgl",kernelFunc:c_t};function d_t(n){const{inputs:t,backend:e,attrs:r}=n,{value:a}=t;let{axis:s}=r;s<0&&(s+=a.shape.length);const o=a,i=o.shape.length,u=a.shape[s],l=new Array(i-1);let h=0;for(let y=0;y<i;y++)y!==s&&(l[h++]=o.shape[y]);const d=[],f=new Array(i).fill(0),m=o.shape.slice();m[s]=1;const v=new Array(u);for(let y=0;y<v.length;y++){f[s]=y;const b=Cp({inputs:{x:o},backend:e,attrs:{begin:f,size:m}}),w=Bt({inputs:{x:b},backend:e,attrs:{shape:l}});v[y]=w,d.push(b)}return d.forEach(y=>e.disposeIntermediateTensorInfo(y)),v}const p_t={kernelName:xg,backendName:"webgl",kernelFunc:d_t};class f_t{constructor(t,e){this.variableNames=["x","segmentIds"];const r=t.windowSize,a=t.batchSize,s=t.inSize,o=t.numSegments,i=o*Math.ceil(s/r);this.outputShape=[a,i];const u="0.0",l="sumValue",h=Math.floor(r/4)*4,d=r%4,f=`
        sumValue += dot(values, segFilter);
    `;let m="";s%r>0&&(m=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return initializationValue;
        }
      `);let v="";s%r>0&&(v=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${u};

      float getValue(int batch, int inIdx) {
        ${m}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${v}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${o})) * float(${r}));
        int currentSeg = int(mod(float(outIdx), float(${o})));

        float sumValue = 0.0;

        for (int i = 0; i < ${h}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${f}
        }

        int inIdx = inOffset + ${h};
        if (${d===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${f}
        } else if (${d===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${f}
        } else if (${d===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${f}
        }
        setOutput(${l});
      }
    `}}function m_t(n){const{inputs:t,backend:e,attrs:r}=n,{x:a,segmentIds:s}=t,{numSegments:o}=r,i=a.shape.length,u=[];let l=0;const h=An([l],i);let d=a;h!=null&&(d=fa({inputs:{x:a},backend:e,attrs:{perm:h}}),u.push(d),l=Un(1,i)[0]);const f=lB(d.shape,l,o),m=xt([d.shape[l]]),v=Bt({inputs:{x:d},backend:e,attrs:{shape:[-1,m]}});u.push(v);const y=Vx(a.dtype),b=(C,T,I,_,$)=>{const R=C.shape[0],D=C.shape[1],A=uB(D,$),L={windowSize:A,inSize:D,batchSize:R,numSegments:$},H=new f_t(L,T),G=e.compileAndRun(H,[C,I],_);if(u.push(G),G.shape[1]===$)return G;const q=cH({backend:e,attrs:{start:0,stop:$,step:1,dtype:"float32"}}),B=hH({inputs:{x:q},backend:e,attrs:{reps:[D/A]}});return u.push(q),u.push(B),b(G,T,B,_,$)},w=b(v,"unsortedSegmentSum",s,y,o),S=Bt({inputs:{x:w},backend:e,attrs:{shape:f}});let N=S;if(h!=null){u.push(S);const C=Ju(h);N=fa({inputs:{x:N},backend:e,attrs:{perm:C}})}return u.forEach(C=>e.disposeIntermediateTensorInfo(C)),N}const g_t={kernelName:wg,backendName:"webgl",kernelFunc:m_t};const v_t=[t2t,n2t,s2t,u2t,c2t,p2t,m2t,v2t,w2t,C2t,T2t,_2t,D2t,M2t,z2t,V2t,W2t,q2t,X2t,Q2t,eSt,uSt,cSt,fSt,gSt,SSt,NSt,ISt,Lwt,ASt,MSt,PSt,jSt,XSt,QSt,JSt,eCt,sCt,uCt,hCt,pCt,mCt,vCt,xCt,SCt,TCt,ICt,ACt,OCt,MCt,PCt,GCt,KCt,QCt,tNt,eNt,rNt,sNt,iNt,lNt,hNt,mNt,yNt,wNt,CNt,TNt,_Nt,$Nt,LNt,Mwt,zNt,OSt,UNt,HNt,KNt,zwt,ZNt,nkt,akt,ukt,hkt,mkt,ykt,Skt,Tkt,_kt,Akt,Fkt,Lkt,zkt,Wkt,Hkt,qkt,Xkt,Qkt,eTt,sTt,lTt,vTt,Uwt,wTt,NTt,ETt,RTt,ySt,$Tt,FTt,LTt,PTt,GTt,Vwt,jTt,KTt,YTt,ZTt,JTt,bSt,pTt,nEt,oEt,cEt,Gwt,fEt,vEt,wEt,NEt,IEt,REt,$Et,MEt,zEt,UEt,HEt,KEt,ZEt,eIt,sIt,uIt,oSt,mTt,hIt,pIt,mIt,vIt,bIt,wIt,CIt,kIt,EIt,RIt,DIt,OIt,MIt,zIt,VIt,WIt,HIt,fTt,Qwt,KIt,QIt,JIt,n_t,o_t,l_t,Zwt,h_t,p_t,g_t,OTt];for(const n of v_t)Px(n);let xk=null,wk=null,Sk=null,dH=!1;const y_t="https://cdn.jsdelivr.net/gh/justadudewhohacks/face-api.js@master/weights",b_t=async n=>{try{return n("Loading Face Detection Model (SSD MobileNet)..."),await ps.ssdMobilenetv1.loadFromUri(y_t),dH=!0,n("Loading Body Segmentation Model..."),xk=await Ytt(),n("Loading Object Detection Model..."),wk=await eet.load(),n("Loading BlazeFace Model..."),Sk=await het(),n("All Models Loaded "),!0}catch(t){return console.error("Error loading models:",t),n("Error loading models. Check console."),!1}},x_t=(n,t)=>{const e=Math.max(n.x,t.x),r=Math.max(n.y,t.y),a=Math.min(n.x+n.width,t.x+t.width),s=Math.min(n.y+n.height,t.y+t.height),o=Math.max(0,a-e)*Math.max(0,s-r);if(o===0)return 0;const i=n.width*n.height,u=t.width*t.height;return o/(i+u-o)},w_t=(n,t=.3)=>{if(n.length===0)return[];const e=[...n].sort((a,s)=>s.width*s.height-a.width*a.height),r=[];for(const a of e){let s=!1;for(const o of r)if(x_t(a,o)>t){s=!0;const i=Math.min(o.x,a.x),u=Math.min(o.y,a.y),l=Math.max(o.x+o.width,a.x+a.width),h=Math.max(o.y+o.height,a.y+a.height);o.x=i,o.y=u,o.width=l-i,o.height=h-u;break}s||r.push({...a})}return r},S_t=async n=>{if(!dH)return[];try{return(await $lt(n,new nv({minConfidence:.3}))).map(e=>({x:e.box.x,y:e.box.y,width:e.box.width,height:e.box.height,source:"face-api"}))}catch(t){return console.error("face-api.js detection error:",t),[]}},C_t=async n=>{if(!Sk)return[];try{return(await Sk.estimateFaces(n,!1)).map(e=>{const r=e.topLeft,a=e.bottomRight;return{x:r[0],y:r[1],width:a[0]-r[0],height:a[1]-r[1],source:"blazeface"}})}catch(t){return console.error("BlazeFace detection error:",t),[]}},N_t=async n=>{if(!wk)return[];try{return(await wk.detect(n)).filter(e=>e.class==="person"&&e.score>.4).map(e=>{const[r,a,s,o]=e.bbox,i=o*.25,u=s*.5;return{x:r+(s-u)/2,y:a,width:u,height:i,source:"coco-head"}})}catch(t){return console.error("COCO-SSD person detection error:",t),[]}},k_t=async(n,t,e)=>{const r=t.getContext("2d",{willReadFrequently:!0});if(!r)return;t.width=n.width,t.height=n.height,r.drawImage(n,0,0);const a=e.strength||20,s=(o,i,u,l)=>{u<=0||l<=0||(r.save(),r.beginPath(),r.rect(o,i,u,l),r.clip(),r.filter=`blur(${a}px)`,r.drawImage(t,0,0),r.restore())};if(e.body&&xk)try{const o=await xk.segmentPerson(n,{internalResolution:"medium",segmentationThreshold:.7}),i=document.createElement("canvas");i.width=t.width,i.height=t.height;const u=i.getContext("2d");if(u){const l=u.createImageData(t.width,t.height),h=o.data;for(let m=0;m<h.length;m++)h[m]===1?(l.data[m*4]=255,l.data[m*4+1]=255,l.data[m*4+2]=255,l.data[m*4+3]=255):l.data[m*4+3]=0;u.putImageData(l,0,0);const d=document.createElement("canvas");d.width=t.width,d.height=t.height;const f=d.getContext("2d");f&&(f.filter=`blur(${a}px)`,f.drawImage(n,0,0),f.globalCompositeOperation="destination-in",f.drawImage(i,0,0),r.drawImage(d,0,0))}}catch(o){console.error("Body segmentation error:",o)}if(e.faces){const[o,i,u]=await Promise.all([S_t(n),C_t(n),N_t(n)]),l=[...o,...i,...u];console.log(`Face detection: face-api=${o.length}, blazeface=${i.length}, coco-head=${u.length}, total=${l.length}`);const h=w_t(l,.3);console.log(`After de-duplication: ${h.length} unique face regions`),h.forEach(d=>{const f=d.width*.2,m=d.height*.2;s(d.x-f,d.y-m,d.width+f*2,d.height+m*2)})}if(e.licensePlate||e.sensitiveText)try{const{data:o}=await ect.recognize(n,"eng");(o.words||[]).forEach(u=>{const l=u.text,h=u.bbox,d=h.x1-h.x0,f=h.y1-h.y0;let m=!1;e.sensitiveText&&(/\S+@\S+\.\S+/.test(l)&&(m=!0),/\d{3}[-.\s]?\d{4}/.test(l)&&(m=!0)),e.licensePlate&&/^[A-Z0-9]{4,9}$/.test(l.toUpperCase())&&(m=!0),m&&s(h.x0,h.y0,d,f)})}catch(o){console.error("OCR Error:",o)}};function T_t(){const[n,t]=fe.useState(!1),[e,r]=fe.useState("Initializing AI Core..."),[a,s]=fe.useState(!1),[o,i]=fe.useState(null),[u,l]=fe.useState({faces:!0,body:!1,licensePlate:!1,sensitiveText:!1,strength:20}),h=fe.useRef(null);fe.useEffect(()=>{(async()=>await b_t(T=>r(T))?(t(!0),r("")):r("Error loading AI models. Please refresh."))()},[]);const d=fe.useCallback(N=>{const C=N[0];if(C){const T=URL.createObjectURL(C),I=new Image;I.src=T,I.onload=()=>{if(i(I),h.current){const _=h.current.getContext("2d");h.current.width=I.width,h.current.height=I.height,_?.drawImage(I,0,0)}}}},[]),{getRootProps:f,getInputProps:m,isDragActive:v}=OM({onDrop:d,accept:{"image/*":[]},multiple:!1}),y=async()=>{!o||!h.current||(s(!0),setTimeout(async()=>{h.current&&o&&await k_t(o,h.current,u),s(!1)},100))},b=()=>{o&&h.current&&h.current.getContext("2d")?.drawImage(o,0,0)},w=()=>{if(h.current){const N=document.createElement("a");N.download="erased-image.png",N.href=h.current.toDataURL(),N.click()}},S=N=>{l(C=>({...C,[N]:!C[N]}))};return ce.jsxs("div",{className:"app-container",children:[(!n||a)&&ce.jsxs("div",{className:"loading-overlay",children:[ce.jsx("div",{className:"spinner"}),ce.jsx("p",{children:n?"AI Processing Image...":e})]}),ce.jsxs("header",{className:"header",children:[ce.jsxs("h1",{className:"title",children:["AI Eraser ",ce.jsx(H5,{size:40,style:{marginLeft:10,verticalAlign:"middle"}})]}),ce.jsx("p",{className:"subtitle",children:"Securely blur sensitive information locally in your browser."})]}),ce.jsxs("main",{style:{display:"grid",gridTemplateColumns:o?"3fr 1fr":"1fr",gap:"2rem"},children:[ce.jsx("div",{className:"canvas-wrapper",children:o?ce.jsx("canvas",{ref:h,style:{maxWidth:"100%",maxHeight:"600px",objectFit:"contain"}}):ce.jsxs("div",{...f(),className:`dropzone-container ${v?"dragging":""}`,children:[ce.jsx("input",{...m()}),ce.jsx(rq,{className:"dropzone-icon"}),ce.jsx("p",{className:"dropzone-text",children:"Drag & Drop Image Here"}),ce.jsx("p",{className:"dropzone-subtext",children:"Supports JPG, PNG based formats"})]})}),o&&ce.jsxs("div",{className:"controls-panel",children:[ce.jsx("h3",{className:"control-label",children:"Detection Settings"}),ce.jsxs("div",{className:"control-group",children:[ce.jsxs("div",{onClick:()=>S("faces"),className:"checkbox-wrapper",children:[ce.jsx("input",{type:"checkbox",checked:u.faces,readOnly:!0,style:{display:"none"}}),ce.jsx("div",{className:"checkbox-custom",children:ce.jsx(K$,{size:12,className:"checkbox-icon"})}),ce.jsx("span",{children:"Blur Faces"})]}),ce.jsxs("div",{onClick:()=>S("body"),className:"checkbox-wrapper",children:[ce.jsx("input",{type:"checkbox",checked:u.body,readOnly:!0,style:{display:"none"}}),ce.jsx("div",{className:"checkbox-custom",children:ce.jsx(K$,{size:12,className:"checkbox-icon"})}),ce.jsx("span",{children:"Blur Body / Parts"})]}),ce.jsxs("div",{onClick:()=>S("licensePlate"),className:"checkbox-wrapper",children:[ce.jsx("input",{type:"checkbox",checked:u.licensePlate,readOnly:!0,style:{display:"none"}}),ce.jsx("div",{className:"checkbox-custom",children:ce.jsx(q5,{size:12,className:"checkbox-icon"})}),ce.jsx("span",{children:"License Plates"})]}),ce.jsxs("div",{onClick:()=>S("sensitiveText"),className:"checkbox-wrapper",children:[ce.jsx("input",{type:"checkbox",checked:u.sensitiveText,readOnly:!0,style:{display:"none"}}),ce.jsx("div",{className:"checkbox-custom",children:ce.jsx(Q5,{size:12,className:"checkbox-icon"})}),ce.jsx("span",{children:"Private Text"})]})]}),ce.jsx("h3",{className:"control-label",style:{marginTop:"1rem"},children:"Blur Strength"}),ce.jsx("input",{type:"range",min:"5",max:"50",value:u.strength,onChange:N=>l({...u,strength:parseInt(N.target.value)}),className:"w-full",style:{accentColor:"var(--primary)"}}),ce.jsx("div",{className:"actions-row",style:{marginTop:"auto"},children:ce.jsxs("button",{className:"btn btn-primary",onClick:y,style:{flex:1},children:[ce.jsx(J5,{size:18})," Apply Blur"]})}),ce.jsxs("div",{className:"actions-row",children:[ce.jsxs("button",{className:"btn btn-secondary",onClick:b,style:{flex:1},children:[ce.jsx(eq,{size:18})," Reset"]}),ce.jsxs("button",{className:"btn btn-secondary",onClick:w,style:{flex:1},children:[ce.jsx(X5,{size:18})," Save"]})]})]})]})]})}zj.createRoot(document.getElementById("root")).render(ce.jsx(fe.StrictMode,{children:ce.jsx(T_t,{})}))});export default E_t();
